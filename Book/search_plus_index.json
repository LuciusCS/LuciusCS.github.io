{"./":{"url":"./","title":"introduction","keywords":"","body":"My Awesome Book Introduction This file file serves as your book's preface, a great place to describe your book's content and ideas. Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 19:59:54 "},"Android/":{"url":"Android/","title":"Android","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 09:29:47 "},"Android/Android基础/":{"url":"Android/Android基础/","title":"Android基础","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/Android基础/Android 6.0动态权限获取.html":{"url":"Android/Android基础/Android 6.0动态权限获取.html","title":"Android 6.0动态权限获取","keywords":"","body":"在Android 6.0及以上需要对手机权限进行动态获取 如果手机版本为Android 6.0(API 23)或更高版本，以及app的targetSdkVersion为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。 同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。 同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如Manifest.permission.BLUETOOTH在动态申请时同样不会出现权限申请对话框，但会回调 Android动态权限的申请仅对下图中的9大权限组进行申请 一、对于可选硬件功能权限的获取 使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加 当声明为android:required=\"false\"时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要PackageManager.hasSystemFeature()来确定该设备是否存在；当声明为android:required=\"true\"时，需要手机上具有该设备，否则不能进行安装操作。 二、代码实现 String[] permissions = {Manifest.permission.BLUETOOTH}; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); //只有系统API大于23时，才需要判断权限是否需要获取 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { //用于判断权限是否已经获取 int i = ContextCompat.checkSelfPermission(this, permissions[0]); //权限是否已经获取 GRANTED--授权 DINED--拒绝 if (i != PackageManager.PERMISSION_GRANTED) { //如果没有被授予该权限，提示用户请求该权限 ActivityCompat.requestPermissions(this, permissions, 1); }else { Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show(); } } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode==1){ //未获取到权限 if (grantResults[0] != PackageManager.PERMISSION_GRANTED) { //判断用户是否点击了不再提醒；检测该权限是否还可以再申请 boolean result = this.shouldShowRequestPermissionRationale(permissions[0]); //如果不可以再申请 if (!result) { //用户需要继续使用App //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示 LogUtils.printInfo(\"请到设置界面开启相应权限\"); }else { //如果可以再申请 Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show(); } } } } 三、连续多次申请权限出现问题 在进行连续多次申请时，在回调函数onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)的permissions数组会返回长度为零的数组，因为在Activity的requestPermissions()方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行onRequestPermissionsResult方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断； //Activity源码 public final void requestPermissions(@NonNull String[] permissions, int requestCode) { //省略部分代码 if (mHasCurrentPermissionsRequest) { Log.w(TAG, \"Can request only one set of permissions at a time\"); // Dispatch the callback with empty arrays which means a cancellation. onRequestPermissionsResult(requestCode, new String[0], new int[0]); return; } Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions); startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null); mHasCurrentPermissionsRequest = true; } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/Android基础/Android后台进程.html":{"url":"Android/Android基础/Android后台进程.html","title":"Andorid后台进程","keywords":"","body":"Android后台处理介绍 Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。 推荐在后台进行处理的三种情况 App处理操作是否可以滞后进行，或者需要实时处理 例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行 App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理 例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。 App操作处理是否是由系统进行触发 系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。 加一个选择策略图片 线程池 对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁 Foreground Service操作 对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。 Workmanager 对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。 后台进程操作的限制 为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。 Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。 Android 7.0(Api 24)限制隐式广播。 Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/Android基础/Android文件操作.html":{"url":"Android/Android基础/Android文件操作.html","title":"Android文件操作","keywords":"","body":"Android文件的读和写 1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M； 2、SD卡中的文件； 3、数据区(/data/data/..)的文件； 资源文件的读写 raw使用InputStream in = getResources().openRawResource(R.raw.test); asset使用InputStream in = getResources().getAssets().open(fileName); Android应用数据私有目录存储（位于应用功能安装目录下） 该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。 文件类型： /data/data/包名/cache ：存放的是APP的缓存信息 /data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码 /data/data/包名/files ： 存放APP的文件信息 还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。 私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录 context.getCacheDir()用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间 文件读操作 文件写操作 Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录） 该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。 首先需要获取权限 需要确定写入文件目录是否存在，如果不存在，则需要新建目录 Android存储公有目录 Andorid开发公有目录与Context无关，使用Environment进行获取 Environment.DIRECTORY_PICTURES 图片目录 Environment.DIRECTORY_DCIM 相册目录 Environment.DIRECTORY_DOCUMENTS 文档目录 Environment.DIRECTORY_DOWNLOADS 下载目录 Environment.DIRECTORY_MOVIES 视频 //有参 Environment.getExternalStoragePublicDirectory(String type) ; //无参 Environment.getExternalStoragePublicDirectory(); Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/Ble/":{"url":"Android/Ble/","title":"Android BLE","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/Ble/Android ble 4.0.html":{"url":"Android/Ble/Android ble 4.0.html","title":"Android BLE 4.0","keywords":"","body":"Android 蓝牙4.0开发 这是一条优雅的分割线 写在前面： 本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0 尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。 首先对蓝牙进行非专业的介绍， 蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！ 对GATT的介绍 按照惯例先上代码 优雅的代码 3 权限的获取 蓝牙4.0有一个坑爹的权限是位置信息的获取 蓝牙搜索 蓝牙的搜索有三种方式 方法一：BluetoothAdapter.startDiscovery()是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知； 蓝牙扫描广播接收器 //注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果 private class DeviceReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if(BluetoothDevice.ACTION_FOUND.equals(action)){ BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); } } } 方法二：BluetoothAdapter.startScan(ScanCallback callback)在ScanCallback的onScanResult(int callbackType, ScanResult result)方法中，通过result.getDevice()可获取扫描到的Ble设备 方法三：BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback) 该方法已经被舍弃 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/View/":{"url":"Android/View/","title":"View","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Android/View/CountDownView.html":{"url":"Android/View/CountDownView.html","title":"CountDownView","keywords":"","body":"使用自定义View实现倒计时功能 当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。 倒计时控件实现的功能 显示时间进度 计时结束后将会自动跳转到下一个Activity中 实现效果如图所示 在本篇博客中的代码会有部分缺省，源码链接 对自定义View的尺寸进行测量并绘制中间的大圆 View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。 public class CountDownView extends android.support.v7.widget.AppCompatTextView { private int circleRadius; private int circleColor=0xff33b5e5; private Paint circlePaint; private Rect bounds; private int centerX; private int centerY; public CountDownView(Context context) { super(context); init(); } public void init(){ circlePaint=new Paint(); bounds=new Rect(); } public CountDownView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec,heightMeasureSpec); circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2; setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight()); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); getDrawingRect(bounds); //获取控件的边界 centerX=bounds.centerX(); centerY=bounds.centerY(); //绘制中间的大圆的背景 circlePaint.setAntiAlias(true); circlePaint.setStyle(Paint.Style.FILL); circlePaint.setColor(circleColor); canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint); } } 在activity_main.xml中添加自定义控件 运行结果 绘制进度边框 private int cirlceBoundColor=0xff00ddff; @Override protected void onDraw(Canvas canvas) { circlePaint.setStyle(Paint.Style.STROKE); circlePaint.setStrokeWidth(5); circlePaint.setColor(cirlceBoundColor); canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint); } 绘制进度条的一条弧线 进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线 private RectF arcRectF; private int processColor=0xff99cc00; public void init(){ arcRectF=new RectF(); } @Override protected void onDraw(Canvas canvas) { circlePaint.setColor(processColor); //设置线冒样式 circlePaint.setStrokeCap(Paint.Cap.ROUND); arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8); canvas.drawArc(arcRectF,-90,40,false,circlePaint); } 进度条按照通过Timer不断控制绘制角度的增加 private int currentDrawTime; //已经绘制的次数 private Timer timer; public void init(){ timer=new Timer(); arcRectF=new RectF(); } @Override protected void onDraw(Canvas canvas) { arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8); canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint); } public void drawProcess(){ currentDrawTime=0; timer.schedule(new TimerTask() { @Override public void run() { postInvalidate(); currentDrawTime++; if (currentDrawTime==8) timer.cancel(); } },500,500); } 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时 @Override protected void onDraw(Canvas canvas) { Paint paint = getPaint(); float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2; paint.setAntiAlias(true); //防锯齿 paint.setColor(Color.WHITE); paint.setTextAlign(Paint.Align.CENTER); canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint); } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Directory/Java Directory.html":{"url":"Directory/Java Directory.html","title":"Java","keywords":"","body":"Java文章目录 Java基础 Java线程间通信 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 15:58:10 "},"Java/Java基础/":{"url":"Java/Java基础/","title":"Java基础","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Java/Java基础/String、StringBuffer、StringBuilder区别.html":{"url":"Java/Java基础/String、StringBuffer、StringBuilder区别.html","title":"String、StringBuffer、StringBuilder的区别","keywords":"","body":"String、StringBuffer、StringBuilder String类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的String对象； StringBuffer和StringBuilder对象是可以改变的，变化时基于原来的对象基础上机型改变。 StringBuffer VS. String Builder StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。 '+' VS. StringBuilder Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Java/Java多线程/":{"url":"Java/Java多线程/","title":"Java多线程","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Java/Java多线程/Java多线程基础.html":{"url":"Java/Java多线程/Java多线程基础.html","title":"Java多线程基础","keywords":"","body":"Runnable接口 仅调用Runnable的run()方法不能产生一个新的线程，新线程的执行必须通过Thread.start()方法来执行。 通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。 Thread类 Thread类的构造函数需要Runnable实例，调用Thread类的start()方法，可以对线程进行必要额初始化，然后执行Runnable实例的run()方法。 静态方法Thread.yield()用于通知CPU从一个线程切换至另外一个线程； `` 多线程框架Executor的使用 Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。 ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。 Executors中的shutdown()方法用于停止向Executor中提交新的任务，在shutdown()方法调用之前提交的同步线程任务则会继续执行。 注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理 不同线程池的使用 CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。 ExecutorService exec = Executors.newCachedThreadPool(); FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。 ExecutorService exec = Executors.newFixedThreadPool(5); SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。 Executors.newSingleThreadExecutor(); 任务的回调 使用Callable和Future,一个产生结果，一个拿到结果 每一个Runnable都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用Callable接口，而非Runnable接口。 Callable接口带有type类型参数，该参数表示call()方法（非run()）方法执行完成后的返回值，必须通过调用ExecutorService submit()调用来执行。 submit()方法返回一个一个Future对象，可以通过调用Future的isDone()方法来判断当前任务是否执行结束。调用Future的get()方法，如果当前任务没有结束，则会被阻塞，直至任务结束 class CallableResult implements Callable { private int id; public TaskWithResult(int id) { this.id = id; } public String call() { return \"result\" + id; } } public class CallableDemo { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); ArrayList> results = new ArrayList>(); for(int i = 0; i fs : results) try { System.out.println(fs.get()); } catch(InterruptedException e) { System.out.println(e); return; } catch(ExecutionException e) { System.out.println(e); } finally{ exec.shutdown(); } } } 任务的暂停 通过调用TimeUnit.MILLISECONDS.sleep(100);来阻塞当前线程指定的时间。 线程优先级 JDK有十中不同的优先级。 线程优先级Thread.MIN_PRIORIT、Thread.MAX_PRIORITY，通过setPriority()方法进行设置，以及getPriority()方法进行获取。 public void run() {Thread.currentThread().setPriority(priority); 守护线程Daemon threads 守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在thread.start();之前调用daemon.setDaemon(true); 如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用isDaemon()方法进行查看是否为守护线程。 数据共享 synchronized关键字 使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。 synchronized void f() { /* ... */ } 当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。 在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。 Lock对象的使用 在调用lock()方法后，一定需要添加在try-finally的代码块，并在finally中调用unlock()方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在try代码块中实现，这样可以保证锁释放之前返回需要的值。如果lock.lock()方法调用失败会出现什么情况 private Lock lock = new ReentrantLock(); int num=0; public int f(){ lock.lock(); try { Thread.yield(); return num++; }finally { lock.unlock(); } 当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。 boolean captured = false; try { captured = lock.tryLock(2, TimeUnit.SECONDS); //限制请求次数 //captured = lock.tryLock(); //不限制请求次数 } catch(InterruptedException e) { throw new RuntimeException(e); } try { System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured); } finally { if(captured) lock.unlock(); } 原子性和波动性（Atomicity and Volality（易变的）） 原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是synchronized而非volatile。 原子操作被应用于除long和double的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（long和double类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在long和double数据类型使用volatile关键字可以保证其操作的原子性。 在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。 当一个变量volatile关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。volatile关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。volatile关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。 atomicity和volatility是两个不同的概念，原子性操作如果是非volatile类型的，那么其不会被立即刷到内存中；如果一个变量在一个synchronized的方法或者代码块中，那么变量也会被刷到内存中。 Atomic classes （原子类） 在Java SE 5中介绍了特殊的原子类：Atomiclnteger, AtomicLong, AtomicReference；对其操作时提供了原子类型的状态。 临界区 在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。 使用synchronized创建临界区 synchronized(syncObject) { // This code can be accessed } class PairManager2 extends PairManager { public void increment() { Pair temp; synchronized(this) { p.incrementX(); p.incrementY(); emp = getPair(); } store(temp); } } 使用功Lock锁创建临界区 class ExplicitPairManager2 extends PairManager { private Lock lock = new ReentrantLock(); public void increment() { Pair temp; lock.lock(); try { p.incrementX(); p.incrementY(); temp = getPair(); } finally { lock.unlock(); } store(temp); } } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Java/Java多线程/Java多线程与单例模式.html":{"url":"Java/Java多线程/Java多线程与单例模式.html","title":"Java多线程与单例模式","keywords":"","body":"不同单例模式在多线程下的特点 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例； public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 public static Singleton getSingleton() { if (instance == null) { //Single Checked synchronized (Singleton.class) { if (instance == null) { //Double Checked instance = new Singleton(); } } } return instance ; } 于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。 1、给 instance 分配内存 2、调用 Singleton 的构造函数来初始化成员变量 3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。 public class Singleton { private volatile static Singleton instance; //声明成 volatile private Singleton (){} public static Singleton getSingleton() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } volatile具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序） 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 public class Singleton{ //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } 单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 单例模式方法同步调用 在多线程中调用单例的方法会同时调用， Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Java/Java多线程/Java多线程之间的协作.html":{"url":"Java/Java多线程/Java多线程之间的协作.html","title":"Java多线程之间的协作与通信","keywords":"","body":"Java多线程协作 Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在Object对象中有wait()和notifyAll()方法，在Java SE 5多任务库中添加Condition类，其中有await()和singal()方法。 join 当一个在线程m中调用t.join()，m线程会被挂起，直至t执行结束(t.isAlive为false)；如果t线程调用t.interrupt()(在m线程之外)，则线程m中会继续执行任务。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Directory/Other Directory.html":{"url":"Directory/Other Directory.html","title":"Other","keywords":"","body":"其他文章目录 Git使用 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "},"Other/Git/Git.html":{"url":"Other/Git/Git.html","title":"Git基础","keywords":"","body":"常用Git操作 一、将本地已有仓库推送到远程仓库 1、将本地仓库与远程仓库建立关联 git remote add github git@github.com:Lucius/GitTest.git 查看本地仓库与远程仓库关联情况 git remote -v 删除与远程仓库关联 git remote rm origin 2、设置用户名和密码 git config -global user.name \"\" git config -global user.email \"\" 3、设置SSH Key, 生成SSH Keyssh-keygen -t rsa -C \"your_email@example.com\" -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去git branch --set-upstream-to=origin 当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现fatal: refusing to merge unrelated histories错误，需要使用下面命令：git pull origin master --allow-unrelated-histories 5、将本地仓库推送至远端git push -u origin master 如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误 推送正常 二、将本地分支提交到远程 1、建立本地到上游（远端）仓的链接 git branch --set-upstream-to=origin 2、拉取远程分支内容 git pull --allow-unrelated-histories 3、将本地分支推送至远程git push origin EditBranch 三、合并多次提交 git rebase -i HEAD~3 如果在合并的过程中出现冲突需要先解决冲突，再进行合并 git rebase --continue 如果放弃本次合并，使用 git rebase --abort 四、Git多用户进行管理 需要为每一个仓库设置user、email 第一步：取消git的global用户以及邮箱 git config --global --unset user.name git config --global --unset user.email 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。 git config user.email \"xxxx@xx.com\" git config user.name \"xxxx\" 五、git reset --hard --soft与git revert git reset --hard HEAD~1修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。 git reset --soft HEAD~1修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。 git revert与git reset区别 git reset指向原地或者向前移动指针,直接删除commit，git revert创建一个逆向commit来覆盖之前commit,指针向后移动。 在后续合并旧版本时，git revert的部分不再出现；而git reset在合并旧版本时，这些被回滚的提交还会再次被引入。 撤销 git reset git reflog 查看操作历史，找到之前 HEAD 的 hash 值，然后 git reset --hard 到那个 hash 即可 六、git cherry-pick使用方法 将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。 git cherry-pick :单独合并一个提交 git cherry-pick -x ：同上，不同点：保留原提交者信息。 git cherry-pick ..：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:34:08 "}}