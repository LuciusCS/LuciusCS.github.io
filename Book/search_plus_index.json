{"./":{"url":"./","title":"introduction","keywords":"","body":"My Awesome Book Introduction This file file serves as your book's preface, a great place to describe your book's content and ideas. Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 19:59:54 "},"Android/":{"url":"Android/","title":"Android","keywords":"","body":"Andorid目录 Android基础 Android JNI Android 反编译 Android BLE View Other 框架 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 13:32:27 "},"Android/Android基础/":{"url":"Android/Android基础/","title":"Android基础","keywords":"","body":"Android Advanced 目录 Android 6.0动态权限获取 Android 后台任务 Android 文件操作 getSystemService的使用 Handler Looper介绍 异步操作Asynctask Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Android/Android JNI/":{"url":"Android/Android JNI/","title":"Android JNI","keywords":"","body":"Android Advanced 目录 Android Studio JNI引入 Android JNI敏感信息保护 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Android/Android反编译/":{"url":"Android/Android反编译/","title":"Android 反编译","keywords":"","body":"Android反编译目录 Android应用防止二次打包 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Android/Ble/":{"url":"Android/Ble/","title":"Android BLE","keywords":"","body":"Android BLE目录 Android ble 4.0 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Android/View/":{"url":"Android/View/","title":"View","keywords":"","body":"View目录 ActionBar和ToolBar的使用 CountDownView LayoutInflater的使用 Materials Design Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Android/Other/":{"url":"Android/Other/","title":"Other","keywords":"","body":"其他 Groovy介绍 Module的.gradle配置 常用操作 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Android/框架/":{"url":"Android/框架/","title":"框架","keywords":"","body":"框架目录 AAC Android Architecture Components DataBinding的使用 LifeCycle和Room的使用 Dagger2 FastJson的使用 Retrofit 2.5 框架使用与源码分析 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Java/":{"url":"Java/","title":"Java","keywords":"","body":"Java目录 Java基础 Java多线程 Java虚拟机 Java设计模式 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Java/Java基础/":{"url":"Java/Java基础/","title":"Java基础","keywords":"","body":"Java基础目录 Java输入输出操作 Java关键字 Java泛型 Java集合 Java Lambda表达式 String、StringBuffer、StringBuilder的区别 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Java/Java多线程/":{"url":"Java/Java多线程/","title":"Java多线程","keywords":"","body":"Java多线程目录 Java多线程与单例模式 Java多线程基础 Java多线程间通信 Java锁机制 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Java/设计模式/":{"url":"Java/设计模式/","title":"Java设计模式","keywords":"","body":"Java设计模式目录 观察者模式 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-10-08 14:19:41 "},"Other/Git/Git.html":{"url":"Other/Git/Git.html","title":"Git","keywords":"","body":"常用Git操作 一、将本地已有仓库推送到远程仓库 1、将本地仓库与远程仓库建立关联 git remote add github git@github.com:Lucius/GitTest.git 查看本地仓库与远程仓库关联情况 git remote -v 删除与远程仓库关联 git remote rm origin 2、设置用户名和密码 git config -global user.name \"\" git config -global user.email \"\" 3、设置SSH Key, 生成SSH Keyssh-keygen -t rsa -C \"your_email@example.com\" -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去git branch --set-upstream-to=origin 当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现fatal: refusing to merge unrelated histories错误，需要使用下面命令：git pull origin master --allow-unrelated-histories 5、将本地仓库推送至远端git push -u origin master 如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误 推送正常 二、将本地分支提交到远程 1、建立本地到上游（远端）仓的链接 git branch --set-upstream-to=origin 2、拉取远程分支内容 git pull --allow-unrelated-histories 3、将本地分支推送至远程git push origin EditBranch 三、合并多次提交 git rebase -i HEAD~3 如果在合并的过程中出现冲突需要先解决冲突，再进行合并 git rebase --continue 如果放弃本次合并，使用 git rebase --abort 四、Git多用户进行管理 需要为每一个仓库设置user、email 第一步：取消git的global用户以及邮箱 git config --global --unset user.name git config --global --unset user.email 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。 git config user.email \"xxxx@xx.com\" git config user.name \"xxxx\" 五、git reset --hard --soft与git revert git reset --hard HEAD~1修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。 git reset --soft HEAD~1修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。 git revert与git reset区别 git reset指向原地或者向前移动指针,直接删除commit，git revert创建一个逆向commit来覆盖之前commit,指针向后移动。 在后续合并旧版本时，git revert的部分不再出现；而git reset在合并旧版本时，这些被回滚的提交还会再次被引入。 撤销 git reset git reflog 查看操作历史，找到之前 HEAD 的 hash 值，然后 git reset --hard 到那个 hash 即可 六、git cherry-pick使用方法 将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。 git cherry-pick :单独合并一个提交 git cherry-pick -x ：同上，不同点：保留原提交者信息。 git cherry-pick ..：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支 七、修改git urls的路径方式 将urls由SSH模式修改为Https模式 将usrls由Https模式修改为SSH模式 八、建立本地分支，并推送至远程 九、更新fork的代码 在被下载到本地仓库中，添加源分支地址到项目远程分支列表中， Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/Android JNI/Android Studio JNI引入.html":{"url":"Android/Android JNI/Android Studio JNI引入.html","title":"Android Studio JNI引入","keywords":"","body":"Android 在已有的项目中引入JNI 最简方式 JNI与NDK JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互； NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发； 下载NDK和编译工具 NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。 CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。 LLDB：Android Studio 用于调试原生代码的调试程序。 安装方式： Android Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载 在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置 添加CMakeLists.txt和native-lib-cpp文件 现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码 # 设置cmake的最低版本 cmake_minimum_required(VERSION 3.4.1) # 设置生成的so库的信息 add_library( #生成的so库的名字 native-lib # 生成的so库的类型，类型分为两种： # STATIC：静态库，为目标文件的归档文件 # SHARED：动态库，会被动态链接，在运行时被加载 SHARED # 设置源文件的位置，可以是很多个源文件，都需要添加进去 native-lib.cpp) # 从系统里查找依赖库，可添加多个 find_library( log-lib # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest log) # 配置目标库的链接，即相互依赖关系 target_link_libraries( # 目标库（最终生成的库） native-lib # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用 # 如果是第三方库，可以直接引用 # 每行引用一个库 ${log-lib}) 在Andorid的Module下，右键选择 Link C++ Project with Gradle，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码 android { … externalNativeBuild { cmake { path file('src/main/cpp/CMakeLists.txt') } } 在native-lib.cpp添加如下代码，方法名命名规则Java_demo_lucius_baselib_MainActivity_stringFromJNI，以Java作为开头,demo_lucius_baselib_MainActivity是“包名+调用类名”，stringFromJNI方法名。即Java_{package_and_classname}_{function_name}(JNI_arguments)，包名的.被下划线替代。 #include #include extern \"C\" JNIEXPORT jstring JNICALL Java_demo_lucius_baselib_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string text = \"String from C++\"; return env->NewStringUTF(hello.c_str()); } 在上述函数JNI_arguments有JNIEnv*和jobject JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。 jobject，指向Java对象的object。 extern \"C\"只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。 在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\" public class MainActivity extends AppCompatActivity { static { //用于在运行时加载本地库 System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); System.out.println(stringFromJNI()); } public native String stringFromJNI(); 在JNI中使用C语言，新建helloJIN.c文件 #include // JNI header provided by JDK #include // C Standard IO Header // Implementation of the native method sayHello() JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) { printf(\"Hello World!\\n\"); return; } JNI基础类型介绍 在jni.h文件中定义了预编译类型，区分Java、C++以及C /* Primitive types that match up with Java equivalents. */ typedef uint8_t jboolean; /* unsigned 8 bits */ typedef int8_t jbyte; /* signed 8 bits */ typedef uint16_t jchar; /* unsigned 16 bits */ typedef int16_t jshort; /* signed 16 bits */ typedef int32_t jint; /* signed 32 bits */ typedef int64_t jlong; /* signed 64 bits */ typedef float jfloat; /* 32-bit IEEE 754 */ typedef double jdouble; /* 64-bit IEEE 754 */ /* \"cardinal indices and sizes\" */ typedef jint jsize; #ifdef __cplusplus /* * Reference types, in C++ */ class _jobject {}; class _jclass : public _jobject {}; class _jstring : public _jobject {}; class _jarray : public _jobject {}; class _jobjectArray : public _jarray {}; class _jbooleanArray : public _jarray {}; class _jbyteArray : public _jarray {}; class _jcharArray : public _jarray {}; class _jshortArray : public _jarray {}; class _jintArray : public _jarray {}; class _jlongArray : public _jarray {}; class _jfloatArray : public _jarray {}; class _jdoubleArray : public _jarray {}; class _jthrowable : public _jobject {}; typedef _jobject* jobject; typedef _jclass* jclass; typedef _jstring* jstring; typedef _jarray* jarray; typedef _jobjectArray* jobjectArray; typedef _jbooleanArray* jbooleanArray; typedef _jbyteArray* jbyteArray; typedef _jcharArray* jcharArray; typedef _jshortArray* jshortArray; typedef _jintArray* jintArray; typedef _jlongArray* jlongArray; typedef _jfloatArray* jfloatArray; typedef _jdoubleArray* jdoubleArray; typedef _jthrowable* jthrowable; typedef _jobject* jweak; #else /* not __cplusplus */ /* * Reference types, in C. */ typedef void* jobject; typedef jobject jclass; typedef jobject jstring; typedef jobject jarray; typedef jarray jobjectArray; typedef jarray jbooleanArray; typedef jarray jbyteArray; typedef jarray jcharArray; typedef jarray jshortArray; typedef jarray jintArray; typedef jarray jlongArray; typedef jarray jfloatArray; typedef jarray jdoubleArray; typedef jobject jthrowable; typedef jobject jweak; #endif /* not __cplusplus */ Java基本数据类型与Native层中的数据对应关系 这些基本数据类型可以在Native层直接使用。 Java引用数据类型与Native层中的数据对应关系 Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为jobjectArray类型进行使用。 在JNI中二维数组的使用 //获取一维数组的引用，即jintArray类型 jclass intArrayClass=env->FindClass(\"[I\"); //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null); jfieldID 和jmethodID 当Native层需要调用Java的某个方法时，需用jmethodID表示，变量则用jfieldID表示。jni.h中对jfieldID和jmethodID的定义 struct _jfieldID; /* opaque structure */ typedef struct _jfieldID* jfieldID; /* field IDs */ struct _jmethodID; /* opaque structure */ typedef struct _jmethodID* jmethodID; /* method IDs */ 在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。 //获取jfieldID jfieldID GetFieldID(jclass clazz, const char* name, const char* sig) { return functions->GetFieldID(this, clazz, name, sig); } //获取jmethodID jmethodID GetMethodID(jclass clazz, const char* name, const char* sig) { return functions->GetMethodID(this, clazz, name, sig); } 以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用 JavaVM介绍 JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。jni.h的定义中，在C++模式下，JavaVM是一个结构体；在C语言模式下JavaVM是是一个指向方法接口指针的指针。 JNIEnv介绍 JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。jni.h的定义中，在C++模式下，JNIEnv是一个结构体；在C语言模式下JNIEnv是是一个指向方法接口指针的指针。 作用： 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码; 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象; #if defined(__cplusplus) typedef _JNIEnv JNIEnv; typedef _JavaVM JavaVM; #else typedef const struct JNINativeInterface* JNIEnv; typedef const struct JNIInvokeInterface* JavaVM; #endif JNIEnv和JavaVM调用方法 对于C语言 (*env)->方法名(env,参数列表) (*vm)->方法名(vm,参数列表) 对于C++ env->方法名(参数列表) vm->方法名(参数列表) 在 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-27 16:23:54 "},"Android/Android JNI/Android JNI敏感信息保护.html":{"url":"Android/Android JNI/Android JNI敏感信息保护.html","title":"Android JNI敏感信息保护","keywords":"","body":"Android JNI对敏感信息进行保护 Android反编译 在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。 将敏感信息保存使用native代码实现 相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-21 08:52:10 "},"Android/Android反编译/Android应用防止二次打包.html":{"url":"Android/Android反编译/Android应用防止二次打包.html","title":"Android应用防止二次打包","keywords":"","body":"Android防止二次打包主要通过对签名文件的验证来进行 应用签名文件介绍 在Android Studio2.2之后多了对签名版本的选择V1(Jar Signature)和V2(Full APK Signature)V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。 签名文件在gradle中配置 signingConfigs { debug { storeFile file(\"./hyydev.jks\") storePassword \"******\" keyAlias \"**\" keyPassword \"******\" v1SigningEnabled true v2SigningEnabled true } release { storeFile file(\"./hyydev.jks\") storePassword \"******\" keyAlias \"**\" keyPassword \"******\" v1SigningEnabled true v2SigningEnabled true } } 应用签名文件查看 已有.jks文件 在cmd中输入 keytool -list -v -keystore path/android.jks -storepass password 只有.apk文件 使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入 keytool -printcert -file path/android.jks 两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码 在Java代码中进行验证，通过PackageManager获取签名信息。 使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解 在native层进行签名验证 使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。 因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。 在服务端对签名文件进行验证 服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同） Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/Android基础/Android 6.0动态权限获取.html":{"url":"Android/Android基础/Android 6.0动态权限获取.html","title":"Android 6.0动态权限获取","keywords":"","body":"在Android 6.0及以上需要对手机权限进行动态获取 如果手机版本为Android 6.0(API 23)或更高版本，以及app的targetSdkVersion为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。 同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。 同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如Manifest.permission.BLUETOOTH在动态申请时同样不会出现权限申请对话框，但会回调 Android动态权限的申请仅对下图中的9大权限组进行申请 一、对于可选硬件功能权限的获取 使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加 当声明为android:required=\"false\"时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要PackageManager.hasSystemFeature()来确定该设备是否存在；当声明为android:required=\"true\"时，需要手机上具有该设备，否则不能进行安装操作。 二、代码实现 String[] permissions = {Manifest.permission.BLUETOOTH}; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); //只有系统API大于23时，才需要判断权限是否需要获取 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { //用于判断权限是否已经获取 int i = ContextCompat.checkSelfPermission(this, permissions[0]); //权限是否已经获取 GRANTED--授权 DINED--拒绝 if (i != PackageManager.PERMISSION_GRANTED) { //如果没有被授予该权限，提示用户请求该权限 ActivityCompat.requestPermissions(this, permissions, 1); }else { Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show(); } } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode==1){ //未获取到权限 if (grantResults[0] != PackageManager.PERMISSION_GRANTED) { //判断用户是否点击了不再提醒；检测该权限是否还可以再申请 boolean result = this.shouldShowRequestPermissionRationale(permissions[0]); //如果不可以再申请 if (!result) { //用户需要继续使用App //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示 LogUtils.printInfo(\"请到设置界面开启相应权限\"); }else { //如果可以再申请 Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show(); } } } } 三、连续多次申请权限出现问题 在进行连续多次申请时，在回调函数onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)的permissions数组会返回长度为零的数组，因为在Activity的requestPermissions()方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行onRequestPermissionsResult方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断； //Activity源码 public final void requestPermissions(@NonNull String[] permissions, int requestCode) { //省略部分代码 if (mHasCurrentPermissionsRequest) { Log.w(TAG, \"Can request only one set of permissions at a time\"); // Dispatch the callback with empty arrays which means a cancellation. onRequestPermissionsResult(requestCode, new String[0], new int[0]); return; } Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions); startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null); mHasCurrentPermissionsRequest = true; } 四、其他 有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/Android基础/Android后台任务.html":{"url":"Android/Android基础/Android后台任务.html","title":"Android后台任务","keywords":"","body":"Android后台处理介绍 Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。 推荐在后台进行处理的三种情况 App处理操作是否可以滞后进行，或者需要实时处理 例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行 App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理 例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。 App操作处理是否是由系统进行触发 系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。 加一个选择策略图片 线程池 对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁 Foreground Service操作 对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。 Workmanager 对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。 后台进程操作的限制 为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。 Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。 Android 7.0(Api 24)限制隐式广播。 Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Android基础/Android文件操作.html":{"url":"Android/Android基础/Android文件操作.html","title":"Android文件操作","keywords":"","body":"Android文件的读和写 1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M； 2、SD卡中的文件； 3、数据区(/data/data/..)的文件； 资源文件的读写 raw使用InputStream in = getResources().openRawResource(R.raw.test); asset使用InputStream in = getResources().getAssets().open(fileName); Android应用数据私有目录存储（位于应用功能安装目录下） 该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。 文件类型： /data/data/包名/cache ：存放的是APP的缓存信息 /data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码 /data/data/包名/files ： 存放APP的文件信息 还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。 私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录 context.getCacheDir()用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间 文件读操作 文件写操作 Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录） 该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。 首先需要获取权限 需要确定写入文件目录是否存在，如果不存在，则需要新建目录 Android存储公有目录 Andorid开发公有目录与Context无关，使用Environment进行获取 Environment.DIRECTORY_PICTURES 图片目录 Environment.DIRECTORY_DCIM 相册目录 Environment.DIRECTORY_DOCUMENTS 文档目录 Environment.DIRECTORY_DOWNLOADS 下载目录 Environment.DIRECTORY_MOVIES 视频 //有参 Environment.getExternalStoragePublicDirectory(String type) ; //无参 Environment.getExternalStoragePublicDirectory(); Android本地文件选择 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Android基础/getSystemService的使用.html":{"url":"Android/Android基础/getSystemService的使用.html","title":"getSystemService的使用","keywords":"","body":"getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象； 传入的Name 返回的对象 说明 WINDOW_SERVICE WindowManager 管理打开的窗口程序 LAYOUT_INFLATER_SERVICE LayoutInflater 取得xml里定义的view ACTIVITY_SERVICE ActivityManager 管理应用程序的系统状态 POWER_SERVICE PowerManger 电源的服务 ALARM_SERVICE AlarmManager 闹钟的服务 NOTIFICATION_SERVICE NotificationManager 状态栏的服务 KEYGUARD_SERVICE KeyguardManager 键盘锁的服务 LOCATION_SERVICE LocationManager 位置的服务，如GPS SEARCH_SERVICE SearchManager 搜索的服务 VEBRATOR_SERVICE Vebrator 手机震动的服务 CONNECTIVITY_SERVICE Connectivity 网络连接的服务 WIFI_SERVICE WifiManager Wi-Fi服务 TELEPHONY_SERVICE TeleponyManager 电话服务 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Android基础/Handler Looper介绍.html":{"url":"Android/Android基础/Handler Looper介绍.html","title":"Handler Looper介绍","keywords":"","body":"Handler介绍 Handler直接继承于Object类 Handler与一个线程的MessageQueue进行绑定，可以用于Message的发送与处理以及Runnable对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的Message Queue相绑定，它可以将messages以及runnables对象传递到Message Queue，并对Message Queue中的messages以及runnables对象进行处理。 Handler使用的两个主要方面： 1、对messages以及runnables在将来某一个节点执行进行调度； 2、在非当前线程执行其他操作 Handler对Message的调度通过post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), 以及·、sendMessageDelayed(Message, long)等方法进行，post方法可以将Runnable对象插入到队列中，当消息队列收到Runnable对象时，可以执行。sendMessage方法可以将Message对象（其中包含大量数据）插入到队列中，通过HandlerMessage方法进行处理。 当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。 当应用程序创建一个进程之后，它的主线程用于持有的Message Queue用于管理“顶级”的应用对象(Activity Broadcast Receiver等)和他们创建的窗口。当创建自己的线程时，可以通过Handler与应用的主线程进行信息交换。 Looper介绍 Looper直接继承于Object Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的prepare()方法来运行一个loop，loop()方法用来处理message。 与message loop进行大部分交互都是通过Handler类来进行。 下列代码是实现一个Looper线程的方式，通过分离开的prepare()以及loop()方法初始化一个Handler与Looper进行交互。 class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); } } MessageQueue介绍 MessageQueue直接继承于Object Message不能直接添加至Message Queue中，需要通过与Looper相关联的Handler对象来实现。通过Looper.myQueue方法可以从当前线程中获取MessageQueue 从源码角度分析Handler、Looper、MessageQueue三者之间的关系 Handler默认构造函数Handler()，将自己与当前线程的Looper进行绑定，如果当前线程中没有Looper对象，会报出异常。 //Handler源码117行 public Handler() { this(null, false); } //Handler源码131行 public Handler(Callback callback) { this(callback, false); } 通过Looper.prepare();为当前线程设置一个Looper 具体流程： 其中prepare()方法是Looper类中的静态方法；在prepare(boolean quitAllowed)方法中调用sThreadLocal.set(new Looper(quitAllowed));当前线程设置一个新的Looper在构造函数Looper(boolean quitAllowed)中，该Looper创建了一个新的MessageQueue(mQueue = new MessageQueue(quitAllowed);); //Looper源码97行 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } //Looper源码267行 private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 在Handler源码的192行中，通过mLooper = Looper.myLooper();来获取当前线程中的Looper //Handler源码192行 public Handler(Callback callback, boolean async) { mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } //Looper71行 static final ThreadLocal sThreadLocal = new ThreadLocal(); //Looper97行 //Looper源码254行 public static @Nullable Looper myLooper() { return sThreadLocal.get(); } Handler发送消息机制 Handler调用sendMessage(Message msg)方法最终会一步一步调用sendMessageAtTime(Message msg, long uptimeMillis)在该方法中通过MessageQueue queue = mQueue;获取到MessageQueue，调用 用enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)方法将Message加入到消息队列中 //Handler源码中的689行 public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } Handler消息处理机制 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Android基础/异步操作Asynctask.html":{"url":"Android/Android基础/异步操作Asynctask.html","title":"异步操作Asynctask","keywords":"","body":"知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor 一个AsyncTask对象被创建出来后,就只能执行一个异步任务。 AsyncTask是一个抽象类，继承AsyncTask需要指定三个泛型参数 Params：启动任务时输入的参数类型 Progress：后台任务执行中返回进度值的类型 Result：后台任务执行完成后返回结果类型 AsyncTask中三个重要函数 doInBackground：异步执行后台线程要完成的任务在此方法中进行 onPreExecute：执行后台耗时操作前调用，通常用于初始化操作 onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Ble/Android ble 4.0.html":{"url":"Android/Ble/Android ble 4.0.html","title":"Android ble 4.0","keywords":"","body":"Android 蓝牙4.0开发 这是一条优雅的分割线 写在前面： 本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0 尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。 首先对蓝牙进行非专业的介绍， 蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！ 对GATT的介绍 按照惯例先上代码 优雅的代码 3 权限的获取 蓝牙4.0有一个坑爹的权限是位置信息的获取 蓝牙搜索 蓝牙的搜索有三种方式 方法一：BluetoothAdapter.startDiscovery()是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知； 蓝牙扫描广播接收器 //注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果 private class DeviceReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if(BluetoothDevice.ACTION_FOUND.equals(action)){ BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); } } } 方法二：BluetoothAdapter.startScan(ScanCallback callback)在ScanCallback的onScanResult(int callbackType, ScanResult result)方法中，通过result.getDevice()可获取扫描到的Ble设备 方法三：BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback) 该方法已经被舍弃 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:41:14 "},"Android/Other/Groovy介绍.html":{"url":"Android/Other/Groovy介绍.html","title":"Groovy介绍","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Other/Module的.gradle配置.html":{"url":"Android/Other/Module的.gradle配置.html","title":"Module的.gradle配置","keywords":"","body":"gradle介绍 gradle和make以及ant不同，它基于Groovy语言，而非一种配置； Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache， 在Moudle的build.gradle中添加依赖包 android { ... } dependencies { // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary` implementation project(\":mylibrary\") // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 implementation fileTree(dir: 'libs', include: ['*.jar']) // 依赖于远程库 implementation 'com.example.android:app-magic:12.3' } 依赖包的配置有以下类型：implementation、api、compileOnly、runtimeOnly、annotationProcessor、lintChecks、lintPublish 在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。 dependencies { freeImplementation 'com.google.firebase:firebase-ads:9.8.0' } 如果需要将依赖作为变量，与flavor和build type进行结合，要在configurations代码块中进行初始化。 configurations { //初始化只与freeDebugRuntimeOnly相关的依赖 freeDebugRuntimeOnly {} } dependencies { freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar']) } 在Debug模式下使用正式签名 在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer. android{ ... signingConfigs { release { //.jks文件放在项目目录（app目录） storeFile file(\"app.jks\")//签名文件名 storePassword \"password\"//密码 keyAlias\"key0\"//别名 keyPassword\"password\"//密码 } debug { storeFile file(\"app.jks\") storePassword\"password\" keyAlias\"key0\"//别名 keyPassword\"password\" } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release } debug { signingConfig signingConfigs.release } } .... } 加速项目的构建速度 优化项目配置 有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个devflavor和prodflavor(发布版本)。 android { ... defaultConfig {...} buildTypes {...} productFlavors { //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块； dev { minSdkVersion 21 versionNameSuffix \"-dev\" applicationIdSuffix '.dev' } prod { // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。 } } } 可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出devDemo和prodFull android { ... defaultConfig {...} buildTypes {...} // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度 flavorDimensions \"stage\", \"mode\" productFlavors { dev { dimension \"stage\" minSdkVersion 21 versionNameSuffix \"-dev\" applicationIdSuffix '.dev' //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片 resConfigs \"en\", \"xxhdpi\" ... } prod { dimension \"stage\" ... } demo { dimension \"mode\" ... } full { dimension \"mode\" ... } } } 编译类型配置 android { ... buildTypes { debug { //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度` ext.enableCrashlytics = false //防止Crashlytics 每次更新编译的id ext.alwaysUpdateBuildId = false } } 在Debug版本构建的过程中使用静态常量 在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。 int MILLIS_IN_MINUTE = 1000 * 60 int minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE android { ... defaultConfig { //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk versionCode 1 versionName \"1.0\" ... } //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。 //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理 applicationVariants.all { variant -> if (variant.buildType.name == \"release\") { variant.mergedFlavor.versionCode = minutesSinceEpoch; variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName; } } } 使用增量注解处理（incremental annotation processors） Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。 android.enableSeparateAnnotationProcessing = true 其他方式 使用确定的依赖，避免使用+，如：'com.android.tools.build:gradle:2.+' 使用离线模式进行编译 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。 创建自定义编译任务 将图片转换为WebP WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。 禁用PNG压缩 android { buildTypes { release { //禁用PNG压缩 crunchPngs false } } // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩 // aaptOptions { // cruncherEnabled false // } } 使用编译缓存 在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，clean build会变得更快，因为其会调用缓存中的文件，而非重新生成。 在gradle.gradle.properties 中指定编译缓存的路径，默认路径为/.android/build-cache/ // 执行绝对路径或者相对路径 android.buildCacheDir= android.enableBuildCache=true 打包编译多个版本的apk，待续 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/Other/常用操作.html":{"url":"Android/Other/常用操作.html","title":"常用操作","keywords":"","body":"查看签名文件信息 密码是password keytool -list -v -keystore application.jks -storepass password Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/View/ActionBar和ToolBar的使用.html":{"url":"Android/View/ActionBar和ToolBar的使用.html","title":"ActionBar和ToolBar的使用","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/View/CountDownView.html":{"url":"Android/View/CountDownView.html","title":"CountDownView","keywords":"","body":"使用自定义View实现倒计时功能 当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。 倒计时控件实现的功能 显示时间进度 计时结束后将会自动跳转到下一个Activity中 实现效果如图所示 在本篇博客中的代码会有部分缺省，源码链接 对自定义View的尺寸进行测量并绘制中间的大圆 View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。 public class CountDownView extends android.support.v7.widget.AppCompatTextView { private int circleRadius; private int circleColor=0xff33b5e5; private Paint circlePaint; private Rect bounds; private int centerX; private int centerY; public CountDownView(Context context) { super(context); init(); } public void init(){ circlePaint=new Paint(); bounds=new Rect(); } public CountDownView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec,heightMeasureSpec); circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2; setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight()); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); getDrawingRect(bounds); //获取控件的边界 centerX=bounds.centerX(); centerY=bounds.centerY(); //绘制中间的大圆的背景 circlePaint.setAntiAlias(true); circlePaint.setStyle(Paint.Style.FILL); circlePaint.setColor(circleColor); canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint); } } 在activity_main.xml中添加自定义控件 运行结果 绘制进度边框 private int cirlceBoundColor=0xff00ddff; @Override protected void onDraw(Canvas canvas) { circlePaint.setStyle(Paint.Style.STROKE); circlePaint.setStrokeWidth(5); circlePaint.setColor(cirlceBoundColor); canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint); } 绘制进度条的一条弧线 进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线 private RectF arcRectF; private int processColor=0xff99cc00; public void init(){ arcRectF=new RectF(); } @Override protected void onDraw(Canvas canvas) { circlePaint.setColor(processColor); //设置线冒样式 circlePaint.setStrokeCap(Paint.Cap.ROUND); arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8); canvas.drawArc(arcRectF,-90,40,false,circlePaint); } 进度条按照通过Timer不断控制绘制角度的增加 private int currentDrawTime; //已经绘制的次数 private Timer timer; public void init(){ timer=new Timer(); arcRectF=new RectF(); } @Override protected void onDraw(Canvas canvas) { arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8); canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint); } public void drawProcess(){ currentDrawTime=0; timer.schedule(new TimerTask() { @Override public void run() { postInvalidate(); currentDrawTime++; if (currentDrawTime==8) timer.cancel(); } },500,500); } 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时 @Override protected void onDraw(Canvas canvas) { Paint paint = getPaint(); float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2; paint.setAntiAlias(true); //防锯齿 paint.setColor(Color.WHITE); paint.setTextAlign(Paint.Align.CENTER); canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint); } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:41:14 "},"Android/View/Materials Design.html":{"url":"Android/View/Materials Design.html","title":"Materials Design","keywords":"","body":"CoordinatorLayout CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。 CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用 AppBarLayout AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。 AppBarLayout有五种滚动标识： scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部 enterAlways：让任意向下的滚动都会导致该view变为可见 enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。 exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠 snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开 CollapsingToolbarLayout CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout， Behavior Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。 SnackBar SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。 如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button； SnackBar的使用方式 Toast Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置， SnackBar和Toast之间的对比 不同 Toast SnackBar 1 Toast从API1就存在 SnackBar在API23添加 2 不需要Activity，可以显示在Android Home或者其他应用才 只能显示在某一个Activity中 3 不能根据用户的操作执行Action 可以根据用户的操作执行Action 4 在用户滑动时不能消失 在用户滑动时可以消失 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Android/框架/AAC/Android Architecture Components.html":{"url":"Android/框架/AAC/Android Architecture Components.html","title":"Android Architecture Components","keywords":"","body":"结构化组件介绍 结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。 ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁 Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。 结构化组件推荐 结构化组件的工作原理介绍如图所示， Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。 SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。 Dao：用于获取数据的Object，将Sql语句映射为Funcation，通常需要在SQLite OpenHelper中进行定义，但使用Room持久化层，只需调用方法即可，不需要再SQLite OpenHelper中进行定义。 Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在SQLite Openhelper中进行处理），Room数据库使用Dao来操作SQLite Database。 Repository：使用Repository来操作多种数据源。 ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源， LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。LiveData可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，LiveData可以自动感知与它相关的组件的生命周期的改变。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:41:14 "},"Android/框架/AAC/DataBinding的使用.html":{"url":"Android/框架/AAC/DataBinding的使用.html","title":"DataBinding的使用","keywords":"","body":"Databinding点击事件的几种实现方式 代码片段 //BaseActivity中 public void click(View view){ } public void click1(){ } public void click2(int id){ } //xml文件中 1、@{activity.click} click函数带有参数 2、@{()->activity.click()} click函数无参数 activity.click1()}\" /> 3、@{activity::click} click带参数 4、@{()->activity.click(user.id)} activity.click2(user.id)}\" /> 5、@{()->activity.click(3)} activity.click2(3)}\" /> 6、自定义View中DataBinding的点击事件 7、在RecyclerView中的item添加点击事件 // 按钮点击 holder.getBinding.getRoot().findViewById(R.id.btn_edit) .setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // todo } }); DataBinding赋值操作 方法一： Databinding特殊用法 注意事项 在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/框架/AAC/Lifecycle和Room的使用.html":{"url":"Android/框架/AAC/Lifecycle和Room的使用.html","title":"LifeCycle和Room的使用","keywords":"","body":"使用框架组件Room和Lifecycle来创建应用 在build.gradle(Module:app)中添加依赖 //Room组件 implementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\" annotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\" androidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\" //lifestyle组件 implementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\" annotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\" 创建一个Entity实体 在应用中数据是words，每一个word都是一个实体，创建一个Word类，同时需要创建构造函数以及getter方法，只要这样Room才会实例化Object 假装右图！！！！ 代码如下： public class Word { private String mWord; public Word(@NonNull String word) {this.mWord = word;} public String getWord(){return this.mWord;} } 要使得Word类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。 @Entity(tableName = \"word_table\") 每一个@Entity类代表数据表中的一个实体。 @PrimaryKey 每一个实体都需要一个主键，为了表示方便，在这里将每一个word自身作为其主键。 @NonNull 声明参数、域或者方法的返回值不为空。 @ColumnInfo(name = \"word\") 当需要指定与类中的成员变量不同的列名时使用。 @Entity(tableName = \"word_table\") public class Word { @PrimaryKey @NonNull @ColumnInfo(name = \"word\") private String mWord; public Word(String word) {this.mWord = word;} public String getWord(){return this.mWord;} } 创建Dao 在Dao(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，在默认状态下，所有的查询语句都需要在单独的线程中运行。Room使用Dao可以使得代码更加简洁。 创建一个新的接口声明为WordDao 使用功注解@Dao来定义该类为Room的一个Dao类 声明插入一个word的方法void insert(Word word) 为该方法添加@Insert注解，在方法中不需要提供任何sql语句（还有@Delete以及@Update等注解）。 声明一个删除所有words的方法void deleteAll(); 使用@Query注解，用于查询以及其他操作，@Query(\"DELETE FROM word_table\")。 创建一个获取所有单词的方法，getAllWords();返回值为List,通过注解的方式为此方法添加SQL查询语句@Query(\"SELECT * from word_table ORDER BY word ASC\") @Dao public interface WordDao { @Insert void insert(Word word); @Query(\"DELETE FROM word_table\") void deleteAll(); @Query(\"SELECT * from word_table ORDER BY word ASC\") List getAllWords(); } LiveData类的使用 当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。 LiveData是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用LiveData类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新LiveData 当你需要离开Room独立使用LiveData时，你需要更新数据，因为LiveData方法没有公有的方法来更新已经存储的数据。 在WordDao中，将getAllWords的返回值包裹在LiveData中 @Query(\"SELECT * from word_table ORDER BY word ASC\") LiveData> getAllWords(); 添加Room数据库 Room数据库层介绍 Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在SQLiteOpenHelper中处理的单调的工作。 Room使用Dao来查询数据库。 在默认状态下，Room不可以在主线程中操作数据库，LiveData通过自动的方式在后台进程中实现异步查询。 Room在编译的时候检查数据库的Sql语句 Room类需要时抽象类并继承自RoomDatabase Room数据库在整个App中需要以单例模式初始化。 实现Room数据库 创建一个public abstract类继承自RoomDatabase，public abstract class WordRoomDatabase extends RoomDatabase {} 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。@Database(entities = {Word.class}, version = 1) 定义与数据库操作相关的Dao，并使用抽象方法，代码如下： @Database(entities = {Word.class}, version = 1) public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao wordDao(); } 4.将WordRoomDatabase设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。 代码如下： private static WordRoomDatabase INSTANCE; public static WordRoomDatabase getDatabase(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { // Create database here } } } return INSTANCE; } 5.添加获取到数据库的代码 代码如下： INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, \"word_database\") .build(); 完整代码如下： @Database(entities = {Word.class}, version = 1) public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao wordDao(); private static WordRoomDatabase INSTANCE; static WordRoomDatabase getDatabase(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, \"word_database\") .build(); } } } return INSTANCE; } } 创建一个Repository Repository介绍 Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，Repository类用于操作数据。 假装有图~~~ Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。 实现Repository 1.创建一个名为WordRepository的公有类 2.创建Dao类型的成员变量以及word列表 private WordDao mWordDao; private LiveData> mAllWords; 3.添加构造函数，获得数据库的控制并初始化成员变量 WordRepository(Application application) { WordRoomDatabase db = WordRoomDatabase.getDatabase(application); mWordDao = db.wordDao(); mAllWords = mWordDao.getAllWords(); } 4.添加getAllWords()方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的LiveData将会通知订阅者。 LiveData> getAllWords() { return mAllWords; } 5.封装insert()方法，insert()方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。 public void insert (Word word) { new insertAsyncTask(mWordDao).execute(word); } 6.insertAsyncTask方法 private static class insertAsyncTask extends AsyncTask { private WordDao mAsyncTaskDao; insertAsyncTask(WordDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final Word... params) { mAsyncTaskDao.insert(params[0]); return null; } } 完整代码： public class WordRepository { private WordDao mWordDao; private LiveData> mAllWords; WordRepository(Application application) { WordRoomDatabase db = WordRoomDatabase.getDatabase(application); mWordDao = db.wordDao(); mAllWords = mWordDao.getAllWords(); } LiveData> getAllWords() { return mAllWords; } public void insert (Word word) { new insertAsyncTask(mWordDao).execute(word); } private static class insertAsyncTask extends AsyncTask { private WordDao mAsyncTaskDao; insertAsyncTask(WordDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final Word... params) { mAsyncTaskDao.insert(params[0]); return null; } } } 创建一个ViewModel ViewModel是用于向UI提供数据以及服务信息配置改变，ViewModel起着Repository与UI之间的交流中心的作用。可以使用ViewModel在fragment之间共享数据。ViewModel也是lifecycle library的一部分。 ViewModel使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：Activity以及Fragment的主要作用是在屏幕中绘制UI，而ViewModel的作用是控制操作UI需要的所有的数据。 在ViewModel中使用LiveData来表示那些UI显示过程中会发生改变的数据，使用LiveData主要有以下的优点： 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。 Repository以及UI通过ViewModel彻底分离开来，在ViewModel中不会调用数据库中的内容。 实现ViewModel 创建WordViewModel类，继承自AndroidViewModel public class WordViewModel extends AndroidViewModel {} 创建Repository的成员变量 ```java private WordRepository mRepository; * 创建LiveData成员变量用于缓存word列表 ```java private LiveData> mAllWords; 创建构造函数 public WordViewModel (Application application) { super(application); mRepository = new WordRepository(application); mAllWords = mRepository.getAllWords(); } 创建getter方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。 LiveData> getAllWords() { return mAllWords; } 创建insert()方法，用于调用Repostory中的insert()方法，这样随UI可以完全隐藏insert()方法的实现。 WordViewModel类的完整实现方法如下： public class WordViewModel extends AndroidViewModel { private WordRepository mRepository; private LiveData> mAllWords; public WordViewModel (Application application) { super(application); mRepository = new WordRepository(application); mAllWords = mRepository.getAllWords(); } LiveData> getAllWords() { return mAllWords; } public void insert(Word word) { mRepository.insert(word); } } 注：不可以向ViewModel实例中传递Context参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。 Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在ViewModel中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/框架/Dagger2.html":{"url":"Android/框架/Dagger2.html","title":"Dagger2","keywords":"","body":"在Android中使用Dagger2 Dagger2介绍 为什么我们需要注解依赖注入？ Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。 如果一个类使用new操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。 注入模式 构造函数注入：以传递参数的方式 字段注入：以变量的方式 方法注入： “依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象” Dependency provider:使用注解@Module表示的类，用于提供可以进行注入的对象。类中的方法使用注解@Providers表示该方法的返回对象可以被依赖注入。@Moudle可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用@Inject即可 Dependency consumer：注解@Inject用于定义一个依赖。 Connection consumer and producer：使用注解@Component的接口定义module对象中provider与依赖对象之间的连接，接口的实现类由Dagger自动生成。 Dagger2的局限性 Dagger2不能自动注入域 Dagger2不能注入private类型 Dagger2 工程结构图 假装有图 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/框架/fastjson的使用.html":{"url":"Android/框架/fastjson的使用.html","title":"fastjson的使用","keywords":"","body":"JSONString与HashMap之间的转换 HashMap转换为JsonString Map hashMap = new HashMap<>(); String JSONString=JSON.toJSONString(hashMap); JsonString转换为HashMap Map hashMap = new HashMap<>(); hashMap= JSON.parseObject(JSONString, Map.class); //错误方式 hashMap= (Map) JSON.parse(JSONString); 注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据 知识点 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Android/框架/Retrofit 2.5 框架使用与源码分析.html":{"url":"Android/框架/Retrofit 2.5 框架使用与源码分析.html","title":"Retrofit 2.5 框架使用与源码分析","keywords":"","body":"Retrofit 2.5 框架使用与源码分析 Retrofit 框架使用 请求内容与返回值 使用PostMan进行请求测试 请求：https://api.github.com/search/repositories?q=android 返回值： Header: Body: { \"total_count\": 943593, \"incomplete_results\": false, \"items\": [ { \"id\": 82128465, \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\", \"name\": \"Android\", \"full_name\": \"open-android/Android\", \"private\": false, \"owner\": { \"login\": \"open-android\", \"id\": 23095877, \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\", \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\", //…… }, \"html_url\": \"https://github.com/open-android/Android\", \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\", \"fork\": false, \"url\": \"https://api.github.com/repos/open-android/Android\", //…… }, { \"id\": 12544093, \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\", \"name\": \"Android\", \"full_name\": \"hmkcode/Android\", \"private\": false, \"owner\": { \"login\": \"hmkcode\", \"id\": 3790597, //…… }, //…… } ] } 引入Retrofit依赖 implementation 'com.squareup.retrofit2:retrofit:2.5.0' implementation 'com.squareup.retrofit2:converter-gson:2.5.0' 根据返回的请求结果定义Repository Bean类 返回的报文采用google.gson进行处理，金处理必要的值 public class RepoBean { //用于表示Repo id private int id; //用于表示RepoName private String name; //用于表示完整名称 //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注 @SerializedName(\"full_name\") private String fullName; //省略getter和setter //…… } 根据返回的请求结果定义一次查询结果 public class SearchRepoBean { //用于表示仓库数量 @SerializedName(\"total_count\") private int totalCount; //用于表示是否为完整结果 private boolean incompleteResults; //用于表示持有的所有的仓库类 private Listitems; //省略getter和setter //…… } 定义网络请求API接口 public interface GithubService { //@Get注解，表示以Get方法发送网络请求 //返回类型为Call，SearchRepoBean是接收数据的类，可以自定义 @GET(\"search/repositories\") Call getRepoInfo(@Query(\"q\") String query); } 初始化Retrofit实例，生成接口实现类 Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") //设置网络请求的URL地址 .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器 .build(); githubService = retrofit.create(GithubService.class); 进行网络请求 Call call = githubService.getRepoInfo(\"Android\"); //同步请求方式 //call.request(); //异步请求方式 call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { //输出请求结果 // LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size()); // ListrepoBeans=new ArrayList<>(); // repoBeans.addAll(response.body().getItems()); // for (int i=repoBeans.size()-1;i>=0;i--){ // LogUtils.printInfo(repoBeans.get(i).getFullName()); // } } @Override public void onFailure(Call call, Throwable t) { } }); 将请求值的返回设为LiveData 将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现 public interface GithubService { @GET(\"search/repositories\") LiveData getRepoInfo(@Query(\"q\") String query); } 自定义LiveDataCallAdapterFactory public class LiveDataCallAdapterFactory extends CallAdapter.Factory { @Override public CallAdapter get(Type returnType, Annotation[] annotations, Retrofit retrofit) { //用于获取泛型的参数 Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType); Class rawObserverType = getRawType(observerType); LiveDataCallAdapter liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType); return liveDataCallAdapter; } } 自定义 LiveDataCallAdapter public class LiveDataCallAdapter implements CallAdapter> { private Type responseType; public LiveDataCallAdapter(Type responseType){ this.responseType=responseType; } @Override public Type responseType() { return responseType; } @Override public LiveData adapt(final Call call) { LiveDatasearchRepoBeanLiveData=new LiveData() { @Override protected void onActive() { super.onActive(); call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { postValue((SearchRepoBean) response.body()); } @Override public void onFailure(Call call, Throwable t) { LogUtils.printInfo(\"error\"); } }); } }; //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值 return searchRepoBeanLiveData; } } 为Retrofit实例添加CallAdapterFactory Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(new LiveDataCallAdapterFactory()) .build(); 调用方法 repoBeanLiveData = githubService.getRepoInfo(\"Android\"); repoBeanLiveData.observe(GithubApiActivity.this, new Observer() { @Override public void onChanged(SearchRepoBean searchRepoBean) { //输出结果 } }); 添加通用的响应实体 通过LiveDataCallAdapter 和LiveDataCallAdapterFactory 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为SearchRepoBean类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。 定义一个通用的响应实体 public class ApiResponse { public ApiResponseSuccess create(Response response) { if (response.isSuccessful()) { return new ApiResponseSuccess(response.body()); } else { return null; } } //用于表示返回成功的值 public static class ApiResponseSuccess extends ApiResponse { /用于表示请求返回成功的内容，在本代码中是SearchRepoBean private T body; public ApiResponseSuccess(T body) { this.body = body; } public T getBody() { return body; } } } 修改LiveDataCallAdapterFactory public class LiveDataCallAdapterFactory extends CallAdapter.Factory { @Override public CallAdapter get(Type returnType, Annotation[] annotations, Retrofit retrofit) { //用于获取泛型的参数 //return type为LiveData> //observerType为ApiResponse Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType); //bodyType为SearchRepoBean Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType); LiveDataCallAdapter liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType); return liveDataCallAdapter; } } 修改LiveDataCallAdapter public class LiveDataCallAdapter implements CallAdapter>> { private Type responseType; public LiveDataCallAdapter(Type responseType){ this.responseType=responseType; } @Override public Type responseType() { return responseType; } @Override public LiveData> adapt(final Call call) { LiveData> result=new LiveData>() { @Override protected void onActive() { super.onActive(); call.enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { postValue(new ApiResponse().create(response)); } @Override public void onFailure(Call call, Throwable t) { // LogUtils.printInfo(\"+++++!2312qwqweww31\"); } }); } }; return result; } } 修改调用方法 repoBeanLiveData = githubService.getRepoInfo(\"Android\"); repoBeanLiveData.observe(GithubApiActivity.this, new Observer>() { @Override public void onChanged(ApiResponse searchRepoBeanApiResponse) { SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody(); //输出结果 } }); 源码详解 Retrofit构建中的.baseUrl(\"https://api.github.com/\")介绍 Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型 public final class Retrofit { public static final class Builder { public Builder baseUrl(String baseUrl) { checkNotNull(baseUrl, \"baseUrl == null\"); return baseUrl(HttpUrl.get(baseUrl)); } public Builder baseUrl(HttpUrl baseUrl) { checkNotNull(baseUrl, \"baseUrl == null\"); List pathSegments = baseUrl.pathSegments(); if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) { throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl); } this.baseUrl = baseUrl; return this; } } } Retrofit构建中的.addConverterFactory(GsonConverterFactory.create()) 通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(checkNotNull(factory, \"factory == null\")); return this; } Converter接口源码，核心是T convert(F value),将F类型的数据转换为T类型 public interface Converter { //将F类型的数据转换为T类型 @Nullable T convert(F value) throws IOException; //根据数据类型创建Converter创建 Converter abstract class Factory { //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。 public @Nullable Converter responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { return null; } //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody public @Nullable Converter requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { return null; } //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String public @Nullable Converter stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) { return null; } protected static Type getParameterUpperBound(int index, ParameterizedType type) { return Utils.getParameterUpperBound(index, type); } protected static Class getRawType(Type type) { return Utils.getRawType(type); } } } Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory()) 用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用 public final class Retrofit { final List callAdapterFactories; //………… public Builder addCallAdapterFactory(CallAdapter.Factory factory) { callAdapterFactories.add(checkNotNull(factory, \"factory == null\")); return this; } //………… } 最终用来创建Service的代码retrofit.create(GithubService.class) create()采用代理的方式进行创建， public final class Retrofit { //…… public T create(final Class service) { //判断定义的接口服务是否可用 Utils.validateServiceInterface(service); if (validateEagerly) { eagerlyValidateMethods(service); } return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // 如果是Object本身的方法，正常调用后返回 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } //如果是platform默认的方法，正常调用后返回 if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } //解析我们定义的网络请求的方法 return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } }); } //…… } loadServiceMethod(Method method)源码解析,其实际上是HttpServiceMethod对象 ServiceMethod loadServiceMethod(Method method) { //从解析的缓存中获取 ServiceMethod result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); } } return result; } static ServiceMethod parseAnnotations(Retrofit retrofit, Method method)源码 abstract class ServiceMethod { static ServiceMethod parseAnnotations(Retrofit retrofit, Method method) { //RequestFactory负责解析接口并且生成Request RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); //………… return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); } abstract T invoke(Object[] args); } HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)源码 //将一个接口方法转变为一个Http请求 final class HttpServiceMethod extends ServiceMethod { static HttpServiceMethod parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码 CallAdapter callAdapter = createCallAdapter(retrofit, method); //…… Converter responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter); } private static CallAdapter createCallAdapter( Retrofit retrofit, Method method) { Type returnType = method.getGenericReturnType(); Annotation[] annotations = method.getAnnotations(); try { //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter return (CallAdapter) retrofit.callAdapter(returnType, annotations); } catch (RuntimeException e) { // Wide exception range because factories are user code. throw methodError(method, e, \"Unable to create call adapter for %s\", returnType); } } //………… private final RequestFactory requestFactory; private final okhttp3.Call.Factory callFactory; private final CallAdapter callAdapter; private final Converter responseConverter; private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, CallAdapter callAdapter, Converter responseConverter) { this.requestFactory = requestFactory; this.callFactory = callFactory; this.callAdapter = callAdapter; this.responseConverter = responseConverter; } //代理调用的invoke最终会调用下面invoke方法 @Override ReturnT invoke(Object[] args) { return callAdapter.adapt( new OkHttpCall<>(requestFactory, args, callFactory, responseConverter)); } } `call.enqueue(new Callback() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})` ```java final class OkHttpCall implements Call { //…… @Override public void enqueue(final Callback callback) { //…… call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { Response response; //…… try { callback.onResponse(OkHttpCall.this, response); } catch (Throwable t) { t.printStackTrace(); } } }); } //…… } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Java/Java基础/Java关键字.html":{"url":"Java/Java基础/Java关键字.html","title":"Java关键字","keywords":"","body":"Java关键字介绍 static volatile final final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”； 在数据中使用final 一个数据不可改变有两种原因： 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。 在运行时赋初值后不可改变； 当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。 在方法中使用final final作为方法参数使用时，表示该引用不能被修改； final直接修饰方法时，有两个原因 防止子类修改该方法，避免该方法被重写(overridden) 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑） 在类中使用final 禁止该类被继承 transient long关键字 在Java开发过程中，如果需要long类型的变量，需要在变量后加l long a=1000000000000l; //long b=1000000000000; //会报出Integer number too large //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large //long b1=100*1000*1000*1000; //b1会输出一个奇怪的值 1215752192 //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围 //long b1=(long)(100*1000*1000*1000);; //使用功强制类型转换，b1会输出一个奇怪的值 1215752192 long b1=100l*1000l*1000l*1000l; //正确写法 //long b1=100*1000*1000l*1000l; //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Java/Java基础/Java泛型.html":{"url":"Java/Java基础/Java泛型.html","title":"Java泛型","keywords":"","body":"Generics(泛型) 一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。 Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。 如果没有泛型，参数的类型会被忽略， 装箱和拆箱 在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。 将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，会返回之前缓存的对象， int a=100; int b=100; int c=200; int d=200; System.out.println(a==b); System.out.println(c==d); 输出结果为 true; false; Java通过泛型可以自动进行装箱与拆箱。 Integer i=new Integer(xx); 会触发自动装箱 Integer i=xx; 不会触发自动装箱 注意：操作符== 在基础类型中以及引用类型中采用不同的定义方式，在int类型中，==用于通过值的大小定义的，而在Integer中是通过对象定义的。在比较两个类对象时应使用euqal 遍历循环 for循环可以被用于实现Iterable接口的任何类中， Listints=Arrays.asList(1,2,3); int s=0; for(int n:ints){ s+=n; } 等价于 for(Iteratorsit=ints.iterator();it.hasNext();){ int n=it.next(); s+=n; } Iterable接口 所有的Collection都实现了Iterable接口 泛型方法和可变参数(Generic Methods and Varargs) 将任意类型的array转换成List class List{ public static List toList(T[] arr){ Listlist=new ArrayList(); for(T elt:arr)list.add(elt); return list; } } 将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将T[]使用T...来替代。 class Lists{ public staticListtoList(T...arr){ Listlist=new ArrayList(); for(T elt:arr)list.add(elt); return list; } } 调用方式 List ints = Lists.toList(1, 2, 3); List words = Lists.toList(\"hello\", \"world\"); 子类型和通配符(SubTyping and Wildcards) 子类型和替换原则 子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。 Listnums=new ArrayList(); nums.add(2); nums.add(3.14); 根据替换规则可以在Number的List中添加Integer和Double类型的对象。 Listints=new ArrayList(); ints.add(2); ints.add(3); Listnums=ints; //在编译时报错 nums.add(3.14); 报错的原因是List不是List的子类型，反过来写也不要可以。但可以使用Listnums=ints，因为List是List的子类型。 带有extends的通配符 以Collection接口中的addAll方法为例 interface Collection{ ... public boolean addAll(Collectionc); ... } ? extends E表示可以使用E的子类型作为参数添加到Collection中 Listnums=new ArrayList(); Listints=Array.asList(1,2); Listdbls=Array.asList(2.23,3.55); nums.addAll(ints); nums.addAll(dbls); 在此情况下是被允许的，因为List是Collection的一个子类型，同时ints的数据类型List是Collection的子类型。如果addAll(Collectionc)中没有通配符，那么上面的语句在编译时会报错。 带有super的通配符 将一个List拷贝到另外一个List public static void copy(Listdst,Listsrc) { for(int i=0;i ? super T的表达方式表示目的List中的元素是T的supertype,源List是T的subtype; 典型例子 Listobjs=Array.asList(2,3,\"four\"); Listints=Array.asList(5,6); Collection.copy(objs,ints); Collection.copy(objs,ints); Collection.copy(objs,ints); Collection.copy(objs,ints); 通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。 Get和Put原则 ？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance） 不变（invariant）的 数组 在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。 Integer[] ints=new Integer[]{1,2,3}; Number[] nums=ints; num[2]=3.14; //运行时错误 Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。 与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List不会被认为是List的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List会被认为是List的子类型。 Listints=Array.asList(1,2,3); List=ints; //在编译时会报错 Listnums1=ints; //编译通过 nums1.set(2,3.14) //编译错误 第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。 在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List被认为是List的子类型，数组不支持子类型的逆变。 Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters） 使用通配符判断Collection中是否有指定的对象 interface Collection{ ... public boolean contains(Object o); public boolean containsAll(Collectionc); ... } ... Object obj=\"one\"; Listobjs=Arrays.asList(\"one\",2,3.14,4); Listints=Arrays.asList(2,4); objs.contains(obj); objs.containsAll(ints); ints.contains(obj); ints.containsAll(objs); ... 在containsAll(Collectionc)方法中 Collectionc是Collectionc的缩写(abbreviation)，继承Object是通配符常用的方式。 类型参数 可以通过类型参数来替换通配符的编码方式 interface Collection{ ... public boolean contains(E o); public boolean containsAll(Collectionc); ... } 但实际在编译的过程中使用 ... Object obj=\"one\"; Listobjs=Arrays.asList(\"one\",2,3.14,4); Listints=Arrays.asList(2,4); objs.contains(obj); objs.containsAll(ints); ints.contains(obj); //编译时报错 ints.containsAll(objs); //编译时报错 ... 两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Java/Java基础/Java集合.html":{"url":"Java/Java基础/Java集合.html","title":"Java集合","keywords":"","body":"Queue 接口 Collection的使用方法 接口Collection继承自Iterable接口 用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。 BlockingQueue接口 实现类 ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小 DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口 LinkedBlockingQueue 内部以链表的形式实现 PriorityBlockingQueue 无界并发队列 SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素； 方法 add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true，如果队列已满，则返回false poll 移除并返问队列头部的元素，，如果队列为空，则返回null peek 返回队列头部的元素，如果队列为空，则返回null put 添加一个元素，如果队列满，则阻塞 take 移除并返回队列头部的元素，如果队列为空，则阻塞 List接口：实现类 ArrayList LinkedList Vector ArrayList ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢； ArrayList在循环中删除元素可能会出现问题： 1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏 2、使用for-each进行删除，实际是调用它的迭代器来实现， LinkedList LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） Vector Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替； Java Doc里建议用Deque替代Stack接口完成栈的功能 Set接口：实现类 Hashset、TreeSet Hashset：按照哈希算法存取集合中的对象，存取速度快 TreeSet：实现Sorted接口，能够对集合中的对象进行排序 Map接口 HashMap遍历 Iterable和Iterator(迭代器) Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Java/Java基础/Lambda表达式.html":{"url":"Java/Java基础/Lambda表达式.html","title":"Lambda表达式","keywords":"","body":"Lambda介绍 Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的； Java Lambda表达式的写法 Java中的Lambda表达式通常用(argument)->(body)的语法表示 (arg1, arg2...) -> { body } (type1 arg1, type2 arg2...) -> { body } 一个Lambda表达式可以有零个或多个参数； Lambda表达式的主体可以包括零条或多条语句； 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。 函数式接口 把只有一个抽象方法的接口叫做函数式接口（functional interface），java.lang.Runnable接口是只有一个run()方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建Runnable接口引用如下： Runnable r=()->Log.i(\"测试\",\"Hello Word\"); //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口 new Thread(()->Log.i(\"测试\",\"Hello Word\")).start(); Lambda表达式与匿名类的区别 对于关键字的使用：对于匿名类，关键字this解读为匿名类，而对于Lambda表达式，关键字this解读为Lambda的外部类 Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。 使用Lambda表达式将List中的元素按照长度进行排序 //采用匿名内部类写法 List list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\"); Collections.sort(list, new Comparator(){ @Override public int compare(String s1, String s2){ return s1.length()-s2.length(); } }); //采用Lambda写法 List list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\"); Collections.sort(list, (s1, s2) ->{ return s1.length()-s2.length(); }); 使用Lambda将List中的每个值平方，并计算和 java.util.stream.Stream接口，在Java8引入，必须使用Lambda表达式作为参数，map()将input stream的元素，映射成out stream；reduce()方法用于将stream元素组合起来。 //常用写法 List list = Arrays.asList(1,2,3,4,5,6,7); int sum = 0; for(Integer tmp : list) { int x = tmp +tmp; sum = sum + x; } System.out.println(sum); // 使用Lambda写法， List list = Arrays.asList(1,2,3,4,5,6,7); int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get(); System.out.println(sum); 函数式接口 把只有一个抽象方法的接口叫做函数式接口（functional interface） Lambda表达式使用注意事项 在Lambda表达式中不能有指向其自己的引用，关键字this指向的是闭包，而在匿名内部类中this关键字指向的是匿名函数自己， Lambda表达式的常用方法 使用lambda表达式替换匿名类 使用lambda表达式替换匿名类，需要用到函数式接口,如Runnable接口；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。 //使用匿名内部类表达式方法 new Thread(new Runnable(){ @Override public void run() { System.out.println(\"Test Runnable 1\"); } ).start(); //使用匿名内部类的方式 new Thread( () -> System.out.println(\"Test Runnable 2\") ).start(); 在使用lambda表达式进行排序时，Comparator中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型 //使用匿名内部类方式对list进行排序 Collections.sort(words, new Comparator() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } }); //使用lambda表达式方式对list进行排序 Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length())); 使用Lambda表达式进行点击事件处理 //非lambda表达式方法 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.i(\"info\",\"点击\"); } }); //使用lambda表达式方式 button.setOnClickListener((e)->{ Log.i(\"info\",\"点击\"); }); 但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，setOnClickListener()方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式 hello.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates. } }) //或者 hello.setOnClickListener{ Log.i(\"info\",\"点击\"); } 在Java中使用lambda表达式和函数式接口Predicate 在java.util.function包中，包含多个类用于支持Java的函数式编程，使用java.util.function.Predicate函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为 EditBranch Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Java/Java基础/String、StringBuffer、StringBuilder区别.html":{"url":"Java/Java基础/String、StringBuffer、StringBuilder区别.html","title":"String、StringBuffer、StringBuilder区别","keywords":"","body":"String、StringBuffer、StringBuilder String类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的String对象； StringBuffer和StringBuilder对象是可以改变的，变化时基于原来的对象基础上机型改变。 StringBuffer VS. String Builder StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。 '+' VS. StringBuilder byte[]和String类型相互转化 byte[]转换为String,如果是非法值，可能转换不成功 //用于测试String和byte之间的相互转化 String testString=\"1234566789\"; byte[] testByte=testString.getBytes(); try { String string=new String(testByte, \"UTF-8\"); System.out.println(string); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-11-30 19:14:32 "},"Java/Java多线程/Java多线程与单例模式.html":{"url":"Java/Java多线程/Java多线程与单例模式.html","title":"Java多线程与单例模式","keywords":"","body":"不同单例模式在多线程下的特点 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例； public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 public static Singleton getSingleton() { if (instance == null) { //Single Checked synchronized (Singleton.class) { if (instance == null) { //Double Checked instance = new Singleton(); } } } return instance ; } 在使用synchronized关键字之后，每次只有一个线程可以进入到该方法中，但是使用synchronized关键字会造成开销过大 于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。 1、给 instance 分配内存 2、调用 Singleton 的构造函数来初始化成员变量 3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。 public class Singleton { private volatile static Singleton instance; //声明成 volatile private Singleton (){} public static Singleton getSingleton() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } volatile具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序） 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 public class Singleton{ //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } 单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Java/Java多线程/Java多线程基础.html":{"url":"Java/Java多线程/Java多线程基础.html","title":"Java多线程基础","keywords":"","body":"Runnable接口 仅调用Runnable的run()方法不能产生一个新的线程，新线程的执行必须通过Thread.start()方法来执行。 通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。 实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。 Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。 Thread类 Thread类的构造函数需要Runnable实例，调用Thread类的start()方法，可以对线程进行必要额初始化，然后执行Runnable实例的run()方法。 静态方法Thread.yield()用于通知CPU从一个线程切换至另外一个线程； 注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。 多线程框架Executor的使用 Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。 ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。 Executors中的shutdown()方法用于停止向Executor中提交新的任务，在shutdown()方法调用之前提交的同步线程任务则会继续执行。 注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理 Executor、Executors、ExecutorService区别 Executor是一个接口，用于并发提交的任务，只有execute()一个方法，没有返回值，不能对任务进行任何操作。 public interface Executor { void execute(Runnable var1); } Executors类提供不同的工厂方法来创建不同类型的线程池，包括：newSingleThreadExecutor()、newFixedThreadPool(int numOfThreads)、newCachedThreadPool() public class Executors { //... public static ExecutorService newFixedThreadPool(int var0) { return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } //... } ExecutorService 是继承自Exxecutor的接口，其中有异步执行和关闭线程池的方法。可以通过submit()方法来提交任务，同时可以对任务进行取消等操作。 public interface ExecutorService extends Executor { //... void shutdown(); List shutdownNow(); boolean isShutdown(); boolean isTerminated(); //... } 不同线程池的使用 CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。 ExecutorService exec = Executors.newCachedThreadPool(); FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。 ExecutorService exec = Executors.newFixedThreadPool(5); SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。 Executors.newSingleThreadExecutor(); 任务的回调 使用Callable和Future,一个产生结果，一个拿到结果 每一个Runnable都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用Callable接口，而非Runnable接口。 Callable接口带有type类型参数，该参数表示call()方法（非run()）方法执行完成后的返回值，必须通过调用ExecutorService submit()调用来执行。 submit()方法返回一个一个Future对象，可以通过调用Future的isDone()方法来判断当前任务是否执行结束。调用Future的get()方法，如果当前任务没有结束，则会被阻塞，直至任务结束 class CallableResult implements Callable { private int id; public TaskWithResult(int id) { this.id = id; } public String call() { return \"result\" + id; } } public class CallableDemo { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); ArrayList> results = new ArrayList>(); for(int i = 0; i fs : results) try { System.out.println(fs.get()); } catch(InterruptedException e) { System.out.println(e); return; } catch(ExecutionException e) { System.out.println(e); } finally{ exec.shutdown(); } } } 任务的暂停 通过调用TimeUnit.MILLISECONDS.sleep(100);来阻塞当前线程指定的时间。 线程优先级 JDK有十中不同的优先级。 线程优先级Thread.MIN_PRIORIT、Thread.MAX_PRIORITY，通过setPriority()方法进行设置，以及getPriority()方法进行获取。 public void run() {Thread.currentThread().setPriority(priority); 守护线程Daemon threads 守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在thread.start();之前调用daemon.setDaemon(true); 如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用isDaemon()方法进行查看是否为守护线程。 数据共享 synchronized关键字 使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。 synchronized void f() { /* ... */ } 当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。 在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。 Lock对象的使用 在调用lock()方法后，一定需要添加在try-finally的代码块，并在finally中调用unlock()方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在try代码块中实现，这样可以保证锁释放之前返回需要的值。如果lock.lock()方法调用失败会出现什么情况 private Lock lock = new ReentrantLock(); int num=0; public int f(){ lock.lock(); try { Thread.yield(); return num++; }finally { lock.unlock(); } 当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。 boolean captured = false; try { captured = lock.tryLock(2, TimeUnit.SECONDS); //限制请求次数 //captured = lock.tryLock(); //不限制请求次数 } catch(InterruptedException e) { throw new RuntimeException(e); } try { System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured); } finally { if(captured) lock.unlock(); } 原子性和波动性（Atomicity and Volality（易变的）） 原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是synchronized而非volatile。 原子操作被应用于除long和double的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（long和double类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在long和double数据类型使用volatile关键字可以保证其操作的原子性。 在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。 当一个变量volatile关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。volatile关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。volatile关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。 atomicity和volatility是两个不同的概念，原子性操作如果是非volatile类型的，那么其不会被立即刷到内存中；如果一个变量在一个synchronized的方法或者代码块中，那么变量也会被刷到内存中。 Atomic classes （原子类） 在Java SE 5中介绍了特殊的原子类：Atomiclnteger, AtomicLong, AtomicReference；对其操作时提供了原子类型的状态。 临界区 在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。 使用synchronized创建临界区 synchronized(syncObject) { // This code can be accessed } class PairManager2 extends PairManager { public void increment() { Pair temp; synchronized(this) { p.incrementX(); p.incrementY(); emp = getPair(); } store(temp); } } 使用功Lock锁创建临界区 class ExplicitPairManager2 extends PairManager { private Lock lock = new ReentrantLock(); public void increment() { Pair temp; lock.lock(); try { p.incrementX(); p.incrementY(); temp = getPair(); } finally { lock.unlock(); } store(temp); } } Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Java/Java多线程/Java线程间通信.html":{"url":"Java/Java多线程/Java线程间通信.html","title":"Java线程间通信","keywords":"","body":"线程间通信 使用单向管道（Pipe）传递数据 共享内存（Shared Memory）通信 使用阻塞队列（Blocking Queue）实现生产者-消费者模式 处理消息队列（Message Queue） wait/notify机制 等待/通知机制主要由Object类中的三个方法进行保证 1、wait()；notify();notifyAll() 上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；wait();notify();notifyAll()只有在被synchronized修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出IllegalMonitorStateException异常。 1)wait() 让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用notify()或者notifyAll()时唤醒当前线程。wait()也可以作为任务同步的一种方式。 注：调用sleep()和yield()方法不能释放当前的对象锁 wait()方法有两种用法： wait(long timeout)等待一定的时间，但与sleep()方法不同，其会释放对象锁 使用wait()等待notify()或者notifyAll()唤醒。 2)notify() 唤醒一个正在等待相应对象锁的线程，使其进入就绪队列； 3)notifyAll() 唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过synchronized(x)来获取对象锁。 synchronized(x) { x.notifyAll(); } 2、方法调用与线程状态关系 每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列 Condition Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用； 对应关系 Condition中的await()对应Object的wait() Condition中的signal()对应Object的notify() Condition中的signalAll()对应Object中的notifyAll(); Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同 生产者消费者模型 线程锁控制代码 public class Service { //线程锁 private ReentrantLock lock=new ReentrantLock(); //生产者线程控制 private Condition conditionCustomer=lock.newCondition(); //消费者线程控制 private Condition conditionProducer=lock.newCondition(); //用于表示需要生产 private boolean hasValue=false; //用于随机消费时间； private static Random rand = new Random(2000); //用于生产者 public void produce(){ try { lock.lock(); while (hasValue){ System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\"); conditionCustomer.await(); } System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\"); Thread.sleep(rand.nextInt(500)); hasValue=true; System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\"); System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\"); System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"); //唤起所有的消费者线程 conditionProducer.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } //用于消费者 public void custome(){ try{ lock.lock(); while (!hasValue){ System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\"); conditionProducer.await(); } System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\"); Thread.sleep(rand.nextInt(4000)); hasValue=false; System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\"); System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \"); System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"); //唤起所有的生产者线程 conditionCustomer.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } } } 消费者线程 public class CustomerThread extends Thread { private Service service; public CustomerThread(Service service) { this.service = service; } @Override public void run() { while (true){ service.custome(); } } } 测试代码 public class Customer_ServiceMain { public static void main(String[] args) throws InterruptedException { Service service=new Service(); CustomerThread[] customerThread=new CustomerThread[10]; ProducerThread[] producerThreads=new ProducerThread[10]; for (int i=0;i 运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 消费线程：生产者Thread：1await 消费线程：生产者Thread：0await 线程：消费者Thread：2生产中 线程：消费者Thread：2生产完毕 消费者Thread：2唤醒所有消费者线程 .... +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 生产线程：消费者Thread：2await 生产线程：消费者Thread：1await 生产线程：消费者Thread：0await 线程：生产者Thread：2消费中 线程：生产者Thread：2消费完毕 生产者Thread：2唤醒所有生产者线程 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 生产线程：消费者Thread：1await 生产线程：消费者Thread：0await 线程：生产者Thread：2消费中 线程：生产者Thread：2消费完毕 生产者Thread：2唤醒所有生产者线程 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 消费线程：生产者Thread：2await 消费线程：生产者Thread：1await 消费线程：生产者Thread：0await 线程：消费者Thread：2生产中 线程：消费者Thread：2生产完毕 消费者Thread：2唤醒所有消费者线程 .... +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 线程间通信管道模式 CountDownLatch的使用 用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。 任务执行线程 public class Task extends Thread { private static Random random = new Random(100); private final CountDownLatch latch; //使用CountDownLatch会被自动要求加上此构造函数 public Task(CountDownLatch latch, String name) { this.latch = latch; this.setName(name); } @Override public void run() { try { doWork(); //用于倒数技术 latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } public void doWork() throws InterruptedException { //random.nextInt(2000)在Java中是线程安全的来自TIJ TimeUnit.MILLISECONDS.sleep(random.nextInt(1000)); System.out.println(this.getName() + \"completed\"); } } 等待任务执行完毕，需要唤醒的线程 public class WaitingTask implements Runnable { private final CountDownLatch latch; public WaitingTask(CountDownLatch latch) { this.latch = latch; } @Override public void run() { try { latch.await(); System.out.println(\"Latch阻塞运行至waiting class\"); } catch (InterruptedException e) { e.printStackTrace(); } } } 测试代码 public class TestCountDown { static final int SIZE = 10; public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newFixedThreadPool(5); //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数 CountDownLatch latch = new CountDownLatch(SIZE); // for (int i=0;i 任务执行结果 启动所有任务 线程0completed 线程4completed 线程1completed 线程2completed 线程3completed Latch阻塞运行至waiting class Process finished with exit code 0 CyclicBarrier的使用 CyclicBarrier类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于join)，与CountDownLatch类的使用类似，CountDownLatch类只能执行一次，而CyclicBarrier可以进行多次使用。 以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮； 运动员代码 public class Athlete extends Thread { //用于表示耗时 private double time =90; private static Random rand = new Random(1); private static CyclicBarrier cyclicBarrier; public Athlete(CyclicBarrier cyclicBarrier){ this.cyclicBarrier=cyclicBarrier; } public synchronized double getTime(){ return time; } @Override public void run() { try { while (!Thread.interrupted()){ synchronized (this){ time =(double)(rand.nextInt(20)+90)/10; System.out.println(getName()+\"跑步耗时：\"+ getTime()); } Thread.sleep(1000); cyclicBarrier.await(); } } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } } 所有运动员跑完标志输出代码 public class RunningCtrl extends Thread{ public RunningCtrl(){ } @Override public void run() { super.run(); System.out.println(\"++++++++++++++++++++++++++++++++\"); } } 测试代码 public class CyclicBarrierMain { public static void main(String[] args) { RunningCtrl runningCtrl=new RunningCtrl(); CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl); ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i 运行结果 选手：0跑步耗时：9.5 选手：1跑步耗时：9.8 选手：4跑步耗时：10.4 选手：2跑步耗时：9.7 选手：3跑步耗时：10.3 ++++++++++++++++++++++++++++++++ 选手：0跑步耗时：10.4 选手：2跑步耗时：9.8 选手：1跑步耗时：9.6 选手：4跑步耗时：9.4 选手：3跑步耗时：10.8 ++++++++++++++++++++++++++++++++ 选手：4跑步耗时：9.9 选手：1跑步耗时：10.7 选手：3跑步耗时：9.2 选手：2跑步耗时：9.3 选手：0跑步耗时：10.3 ++++++++++++++++++++++++++++++++ 选手：1跑步耗时：10.4 选手：2跑步耗时：9.2 选手：0跑步耗时：9.9 选手：3跑步耗时：10.2 选手：4跑步耗时：10.6 ++++++++++++++++++++++++++++++++ 选手：4跑步耗时：10.2 选手：2跑步耗时：10.9 选手：0跑步耗时：10.6 选手：3跑步耗时：10.0 选手：1跑步耗时：10.4 ++++++++++++++++++++++++++++++++ 选手：2跑步耗时：10.8 选手：4跑步耗时：10.9 选手：1跑步耗时：10.7 选手：3跑步耗时：10.3 选手：0跑步耗时：9.2 ++++++++++++++++++++++++++++++++ DelayQueue的使用 DelayQueue是一个无界的阻塞队列，实现Delayed接口。只有当delay被激发时，该对象才能从队列中获取数据 线程间通信管道模式 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "},"Java/Java多线程/Java锁机制.html":{"url":"Java/Java多线程/Java锁机制.html","title":"Java锁机制","keywords":"","body":"Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-19 17:41:14 "},"Java/设计模式/观察者模式.html":{"url":"Java/设计模式/观察者模式.html","title":"观察者模式","keywords":"","body":"观察者模式、订阅者模式、回调函数对比 在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应； 在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心 在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者” 本篇观察者模式主要在Android中实现 在Java提供了Observer接口和Observable类方便快速实现观察者模式 Copyright © LuciusCS 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-30 16:28:42 "}}