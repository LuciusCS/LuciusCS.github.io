---
title: "C++ 基础"
description: "C++开发基础"
type: [Android]
toc: true
cover:  /cover/img107.jpg
categories: Android
date: 2017/9/25
---

## 指针

```c++
    // arr 表示一个数组，同时代表一个指针
    int arr[] ={1,2,3};

    int *p=arr;
    //修改数组的第一个值
    *p=4;
    //修改数组第二个值
    *(p+1)=5;

```

## 数组指针(也称为行指针)

`int (*p)[n]` 首先p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n；执行p+1时，p要跨过n个整型数据的长度。

```c++

    int a[3][4];
    int (*p)[4]; //该语句是定义一个数组指针，指向含四个元素的一维数组
    p=a;         //将该二维数组的首地址赋值给p，也就是a[0]或&a[0][0];
    p++:       //该语句执行过后，也就是 p=p+1; p跨过行 a[0][]指向了 a[1][];

```



## 指针数组

```c++
    int arr[] ={1,2,3};
    int *p[3];
    for(int i=0;i<3;i++){
        p[i]=&arr[i];
    }

    printf("数组%d",*p[0]);

```

## 指针函数

带指针的函数，本质是一个函数。函数的返回值是某一类型的指针；

```c++

    //    void* wParam 表示传入的参数可以是任一类型，只需要是指针即可
    int* int add_func(void* wParams){
        printf("指针函数");
        int b=10;
        int *c=&b;
        return *c;
    }

```

## 函数指针

函数指针是指向函数的指针变量，即本质是一个指针变量

```c++
    //int(*f)表示返回值， int x表示方法的参数类型
    int(*func)(int x); //声明一个函数指针

    void point_func(int x){
           printf("函数指针");
    }

    int main(){
        func=point_func;
        //调用函数指针，会直接调用函数
        func(10);
        return 0;
    }

```


## 结构体

```c++

    struct Student{
        char name[50];
        int age;
    }student,a;  //结构变量student和a可以不定义，其为Student类型
    student.age=10;

    //使用typedf定义
    typedef struct{
        char name[50];
        int age;
    }Student;

    //施工
    struct Student student1;
    student.age=10;

```

### 结构体大小

当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。

### 结构体存储原则

1、结构体变量中成员的偏移量必须是成员大小的整数倍。
2、结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。


### 内存对齐

对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，它就被称为自然对齐。

## 共用体

共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，凡是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方法。

共用体占用的内存应足够存储共用体中最大的成员，其大小取决于最大的成员变量

```c++
    union Data{
        int i;
        float f;
        char str[20];
    }data;

```

## 动态库和静态库

在Linux下，动态库后缀为 .so 静态库为 .a

在Windows下，动态库后缀为 .dll 静态库为 .lib

区别：

1、静态库比较大，动态库比较小；
2、静态库需要在编译时，被链接在目标代码中，动态库在运行时才会被加载到目标代码；静态库在运行时的速度快；
3、静态库类似于Android中的Module,一旦打包APK需要重新进行编译；
4、动态库类似于jar包，打包不需要重新进行编译；


## C++类的构造

C++的类用 .cpp表示




