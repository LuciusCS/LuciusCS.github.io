1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。
2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。
3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。
4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。
5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。
6、AMS通知淘宝绑定Application并启动MainActivity。
7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。


## Android应用启动从Zygote到Activity.onCreate

本文从点击Android应用图标开始介绍Android应用的启动过程

### Android应用有两个方面的特点

**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。

**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;


任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。

在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 


### Zygote：创建新的进程

Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。

**init进程会启动Zygote进程**

**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。

**在Zygote之后，init启动运行时的进程？**

紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**

### 用户点击图标通过Launcher启动应用的过程

点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。

* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。
* 2、目标信心会被存储至intent对象中，避免重复第一步工作；
* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；
* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；
* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。


### 在该应用启动流程中有三个不同的阶段
* 1、进程创建
* 2、绑定应用
* 3、启动Activity/Service/调用intent receiver

#### 进程创建

ActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id

在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。

#### 应用绑定

下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。


#### 启动Activity