{"pages":[],"posts":[{"title":"二叉树的前序、中序、后序遍历","text":"二叉树的结构体modified: 2017-07-27 123456typedef struct binaryTree { char item; struct binaryTree *lChild; struct binaryTree *rChild;}binaryTree, *pBinaryTree; 二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；’#’作为递归的结束； 1234567891011121314151617181920212223pBinaryTree createBinaryTree() { char tmp = '0'; pBinaryTree treeNode = NULL; scanf(\"%c\", &amp;tmp); if (tmp == '#') { treeNode = NULL; } else { //为加入的节点分配新的内存空间 treeNode = (binaryTree*)malloc(sizeof(binaryTree)); treeNode-&gt;item = tmp; //递归调用产生二叉树 treeNode-&gt;lChild = createBinaryTree(); treeNode-&gt;rChild = createBinaryTree(); } return treeNode;} 先序遍历二叉树 123456789101112void preVisitBiTree(pBinaryTree root) { if (root) { //先遍历根节点 printf(\"%c\", root-&gt;item); //遍历左子树 preVisitBiTree(root-&gt;lChild); //遍历右子树 preVisitBiTree(root-&gt;rChild); }} 中序遍历二叉树 12345678910111213void inVisitBiTree(pBinaryTree inRoot) { if (inRoot) { //先遍历左子树 inVisitBiTree(inRoot -&gt; lChild ); //遍历根节点 printf(\"%c\", inRoot-&gt;item); //遍历右子树 inVisitBiTree(inRoot-&gt;rChild); }} 后序遍历二叉树 123456789101112void lastVisitBiTree(pBinaryTree lastRoot) { if (lastRoot) { //遍历左子树 inVisitBiTree(lastRoot-&gt;lChild); //遍历右子树 inVisitBiTree(lastRoot-&gt;rChild); //遍历根节点 printf(\"%c\", lastRoot-&gt;item); }} 三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别测试：测试用例：ABC##D##E#F## 123456789101112131415int main() { //构建一颗二叉树 pBinaryTree binaryTree = createBinaryTree(); //采用先序遍历的方式遍历输出二叉树 preVisitBiTree(binaryTree); printf(\"\\n\"); //采用中序遍历的方式输出二叉树 inVisitBiTree(binaryTree); printf(\"\\n\"); lastVisitBiTree(binaryTree); printf(\"测试二叉树\"); return 0;}","link":"/public/2017/07/27/Data_Structure/2017-07-27-data-structure-binary-tree-visit/"},{"title":"排序算法","text":"排序算法modified: 2017-08-02 插入排序有直接插入排序、折半插入排序、希尔排序等 直接插入排序直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。 C语言代码实现 12345678910111213141516171819void StrightInsertSort(int array[], int length) { int tmp; //用于保存将要插入的array[i] for (int i = 1; i &lt; length; i++) { tmp = array[i]; for (int j = i; j &gt;= 0; j--) { if (tmp &gt;= array[j - 1] || j == 0) { array[j] = tmp; break; } else { array[j] = array[j - 1]; } } }} 折半插入排序折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移； C语言代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void BInsertSort(int array[], int length) { int tmp; int start, end, mid; for (int i = 1; i &lt; length; i++) { tmp = array[i]; start = 0; end = i - 1; mid = (end + start) / 2; //判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值 if (tmp &gt;= array[i - 1]) { array[i] = tmp; } else if (tmp &lt;= array[0]) { for (int j = i; j &gt; 0; j--) { array[j] = array[j - 1]; } array[0] = tmp; } //进行折半查找排序 else { while (start &lt; end) { if (tmp &gt; array[mid]) { start = mid + 1; mid = (start + end) / 2; } else if (tmp &lt; array[mid]) { end = mid - 1; mid = (start + end) / 2; } } for (int j = i; j &gt; start; j--) { array[j] = array[j - 1]; } array[start] = tmp; } }} 希尔排序希尔排序（Shell’s Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）； 颜色相同的为一个分组 C语言代码实现 12345678910111213141516171819void shell_sort(int arr[], int length) { int gap, i, j; int tmp; for (gap = length / 2; gap &gt; 0; gap /= 2) { //下面两个for循环是对每一个分组进行插入排序 for (i = gap; i &lt; length; i++) { tmp = arr[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j-=gap) { arr[j + gap] = arr[j]; } arr[j + gap] = tmp; } }}","link":"/public/2017/07/31/Data_Structure/2017-07-31-data-structure-insert-sort/"},{"title":"顺序栈的表示与实现","text":"modified: 2017-7-28本文采用C语言，利用结构体来实现顺序栈 用于定义栈的大小，以及再栈满的时候，扩充栈 12#define STACK_SIZE 50#define STACK_INCREMENT 10 采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈 12345typedef struct { int stackSize; //栈容量 int *base; //栈底指针 int *top; //栈顶指针}SqStack, *pStack; 初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针 123456789101112void initStack(pStack p) { p-&gt;base = (int *)malloc(STACK_SIZE * sizeof(int)); if (p-&gt;base != NULL) { p-&gt;top = p-&gt;base; p-&gt;stackSize = STACK_SIZE; } else { printf(\"分配内存失败\"); }} 栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false 123bool isEmpty(pStack p) { return p-&gt;top == p-&gt;base ? true : false;} 栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较 123bool isFull(pStack p) { return (p-&gt;top - p-&gt;base) &gt;= STACK_SIZE ? true : false;} 入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）； 1234567891011void push(pStack p, int topElement) { int *q = NULL; if (isFull(p)) { q = (int *)realloc(p-&gt;base, STACK_INCREMENT * sizeof(int)); // 重新调整内存块的大小 p-&gt;base = q; p-&gt;stackSize = p-&gt;stackSize + STACK_INCREMENT; } *(p-&gt;top)++ = topElement;} 出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址； 12345678910void pop(pStack p, int *topElement) { if (isEmpty(p)) { printf(\"空栈\"); } p-&gt;top--; *topElement = *p-&gt;top;} 求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一 12345678910int getStackTop(SqStack s) { int topElement; if (isEmpty(&amp;s)) { return 0; } topElement = *(s.top - 1); return topElement;} 清空栈，不断将让栈中元素出栈，直至栈空 12345678void clearStack(SqStack s) { while (!isEmpty(&amp;s)) { int tmp; pop(&amp;s, &amp;tmp); }} 求栈当前大小 1234567891011int getStackLength(SqStack s) { int i = 0; int *q = s.top; while (q != s.base) { q--; i++; } return i;}","link":"/public/2017/07/27/Data_Structure/2017-07-27-data-structure-stack/"},{"title":"查找算法","text":"折半查找modified: 2017-07-31折半查找即二分查找的实现 1234567891011121314151617181920212223242526int BinarySearch(int data[], int search,int length) { int end = length-1 ; int start = 0; int mid = (start + end) / 2; while (start&lt;=end) { if (data[mid] == search) { return mid; } else if (data[mid] &gt; search) { end = mid-1; mid = (start + end) / 2; } else { start = mid+1; mid = (start + end) / 2; } } return -1;}","link":"/public/2017/07/31/Data_Structure/2017-07-31-data-structure-search/"},{"title":"队列的表示与实现","text":"modified: 2017-08-02队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头； 链队列——队列的链式表示和实现链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。 注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点 C语言实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include \"stdlib.h\"#include \"stdio.h\"//单链队列，队列的链式存储结构，队列是由队头指向队尾typedef struct QNode { char data; struct QNode *next;}QNode,*QueuePtr;typedef struct { QueuePtr front; //队头指针 QueuePtr rare; //队尾指针}LinkQueue;//用于初始化队列void initQueue(LinkQueue &amp;lq) { lq.front = lq.rare = (QueuePtr)malloc(sizeof(QNode)); lq.rare-&gt;next = NULL;}//用于插入队列void enQueue(LinkQueue &amp;lq,char data) { //插入元素为Q的新的队尾元素 data QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); p-&gt;data = data; p-&gt;next = NULL; lq.rare-&gt;next = p; lq.rare = lq.rare-&gt;next;}//用于取出头元素，在操作之前首先需要判断是不是空队列void reQueue(LinkQueue &amp;lq) { if (lq.front==lq.rare) { printf(\"队列为空\"); } else { QueuePtr q; //因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值 printf(\"%c\",lq.front-&gt;next-&gt;data); q = lq.front; lq.front = lq.front-&gt;next; free(q); }}int main() { LinkQueue lq; initQueue(lq); enQueue(lq,'a'); enQueue(lq,'b'); reQueue(lq); reQueue(lq); return 0;} 循环队列——队列的顺序表示和实现队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度； 初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素； 当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。 C语言代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include \"stdio.h\"#include \"stdlib.h\"#define maxsize 100typedef struct { int *base; //用于为队列分配空间 int front; int rear;}sqqueue;//初始化队列void initqueue(sqqueue &amp;sq) { //构造一个空队列 sq.base = (int *)malloc(maxsize*sizeof(int)); if (!sq.base) { printf(\"构造队列失败\"); } sq.front = sq.rear = 0;}//入队void enqueue(sqqueue &amp;sq,int e) { //用于判断队列是否为满，通过查看队尾的下一个元素是不是队头 if ((sq.rear+1)%maxsize==sq.front) { printf(\"队列为满\"); } sq.base[sq.rear] = e; sq.rear = (sq.rear + 1) % maxsize; //转了一圈后sq.rare会超过maxsize}//出队void requeue(sqqueue &amp;sq) { //用于判断队是否为空 if (sq.rear==sq.front) { printf(\"队列为空\"); } printf(\"%d\\n\",sq.base[sq.front]); sq.front = (sq.front + 1) % maxsize;}int main() { sqqueue sq; initqueue(sq); enqueue(sq,10); enqueue(sq,15); requeue(sq); requeue(sq); return 0;}","link":"/public/2017/08/02/Data_Structure/2017-08-02-data-structure-queue/"},{"title":"基数排序（Radix Sort）","text":"modified: 2017-08-03 桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序； 基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 基数排序可以看做是多次桶排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include \"stdio.h\"#include \"stdlib.h\"//从个位开始，最低位优先（Least Significant Digital first）void radixSort(int num[], int length) { int *radix[10]; for (int i = 0; i &lt; 10; i++) { radix[i] = (int *)malloc(length * sizeof(int)); radix[i][0] = 0; } int index = 1; for (int i = 1; i &lt; 5; i++) { //将num数组中的数据放入数组radix中 //第一次分配 for (int i = 0; i &lt; length; i++) { radix[(num[i]/index)% 10][0]++; radix[(num[i]/index) % 10][radix[(num[i]/index )% 10][0]] = num[i]; } //第一次回收 int length = 0; for (int i = 0; i &lt; 10; i++) { for (int j = 1; j &lt; radix[i][0] + 1; j++) { num[length++] = radix[i][j]; } } for (int i = 0; i &lt; 10; i++) { radix[i][0] = 0; } index = index * 10; } for (int i = 0; i &lt; length; i++) { printf(\"%d\\n\",num[i]); }}//从最高位开始，最高位优先（Most Significant Digit first）void radixSortMSD(int num[], int length) { int *radix[10]; for (int i = 0; i &lt; 10; i++) { radix[i] = (int *)malloc(length * sizeof(int)); radix[i][0] = 0; } int index = 10000 for (int i = 1; i &lt; 5; i++) { //将num数组中的数据放入数组radix中 //分配 for (int i = 0; i &lt; length; i++) { radix[(num[i] / index) % 10][0]++; radix[(num[i] / index) % 10][radix[(num[i] / index) % 10][0]] = num[i]; } //回收 int length = 0; for (int i = 0; i &lt; 10; i++) { for (int j = 1; j &lt; radix[i][0] + 1; j++) { num[length++] = radix[i][j]; } } for (int i = 0; i &lt; 10; i++) { radix[i][0] = 0; } index = index /10; } for (int i = 0; i &lt; length; i++) { printf(\"%d\\n\", num[i]); }}int main() { int num[10] = {0,10,12,5665,285,125,554,26,7895,12}; radixSortMSD(num, 10); system(\"pause\"); return 0;}","link":"/public/2017/08/02/Data_Structure/2017-08-02-data-structure-radix-sort/"},{"title":"排序算法总结","text":"modified: 2017-08-02 各种排序算法的总结 插入排序非比较型排序桶排序基数排序计数排序","link":"/public/2017/08/02/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary/"},{"title":"栈的应用——需要再次进行编辑","text":"modified: 2017-08-02## 使用栈实现进制转换、括号匹配的检验、行编辑程序 使用栈实现进制的转换 将十进制转换为二进制 C语言实现代码 123456789101112131415161718void conversion(int num) { SqStack stack; initStack(&amp;stack); while (num / 2) { push(&amp;stack, num % 2); num /= 2; } push(&amp;stack, num); int tmp = 0; while (!isEmpty(&amp;stack)) { pop(&amp;stack, &amp;tmp); printf(\"%d\", tmp); }} 使用栈实现括号匹配的检验1234567891011121314151617181920212223242526272829303132333435363738void check_symbol() { char s[50] = { 0 }; printf(\"请输入一串括号\"); scanf(\"%s\", s); SqStack stack; initStack(&amp;stack); push(&amp;stack, s[0]); for (int i = 1; s[i] != 0; i++) { if (!isEmpty(&amp;stack)) { if (getStackTop(stack) == (int) '{'&amp;&amp;s[i] == (int)'}' || getStackTop(stack) == (int) '('&amp;&amp;s[i] == (int)')') { int tmp; pop(&amp;stack, &amp;tmp); } else { push(&amp;stack, s[i]); } } else { int tmp; push(&amp;stack, s[i]); } } if (isEmpty(&amp;stack)) { printf(\"括号匹配\"); } else { printf(\"括号不匹配\"); }} 使用栈实现行编辑器123456789101112131415161718192021222324252627282930313233343536373839void lineEdit() { //首先初始化栈 SqStack stack; initStack(&amp;stack); char ch = getchar(); while (ch != EOF) { while (ch != EOF&amp;&amp;ch!='\\n') { switch (ch) { case '@':clearStack(stack); break; case '#':if (isEmpty(&amp;stack)) break; else { int tmp; pop(&amp;stack, &amp;tmp); break; } default: push(&amp;stack, ch); break; } ch = getchar(); } ch = getchar(); } //用于将存储在栈中的内容输出 if (ch == EOF) { while (!isEmpty(&amp;stack)) { int tmp; pop(&amp;stack, &amp;tmp); printf(\"%c\", tmp); } }}","link":"/public/2017/08/02/Data_Structure/2017-08-02-data-structure-stack-use/"},{"title":"归并排序","text":"modified: 2017-08-04 归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。 归并排序的基本思路是 将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素； 将上述序列再次归并，形成n/4个序列，每个序列包含四个元素； 重复步骤2，直到所有元素排序完毕； 要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。 使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列 123456789101112131415161718192021//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，//左右有序两部分的分界点，右侧有序部分的终点，//tmp[]是大小为last-first的数组，用于临时存放排序的数列void mergeArray(int a[],int first,int mid,int last,int tmp[]) { int i = first; int j = mid+1; int k = 0; //K用作tmp[]的索引 //将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中 while (i&lt;=mid&amp;&amp;j&lt;=last) a[i] &lt; a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++]; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= last) tmp[k++] = a[j++]; while (k &gt; 0) a[--j] = tmp[--k];} 1234567891011void mergeSort(int a[],int first,int last,int tmp[]) { if (first&lt;last) { int mid = (first + last) / 2; mergeSort(a,first,mid,tmp); //左边有序 mergeSort(a, mid+1, last, tmp);//右边有序 mergeArray(a,first,mid,last,tmp); //将两个数组合并 }}` 有序数组的归并以及归并排序的测试 123456789101112131415161718192021222324int main() { int a[7] = {7,8,9,10,1,2,3}; int tmp[7]; printf(\"测试数组归并\\n\"); mergeArray(a, 1, 3, 5, tmp); for (int i = 0; i &lt; 7; i++) { printf(\"%d\\n\", a[i]); } printf(\"测试数组归并排序\\n\"); mergeSort(a,0,6,tmp); for (int i = 0; i &lt; 7; i++) { printf(\"%d\\n\", a[i]); } system(\"pause\"); return 0;}","link":"/public/2017/08/04/Data_Structure/2017-08-04-data-structure-merge-sort/"},{"title":"快速排序","text":"modified: 2017-08-02快速排序可以理解为：快速排序=挖坑填数+分治算法； 快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序； 步骤为： 从数列中选出一个元素，作为基准（pivot） 将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。 递归地把小于基准元素的子序列和大于基准的子序列进行排序 递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 进行一次排序的过程(挖坑填数) 快速排序的全过程 使用C语言实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"stdio.h\"#include \"stdlib.h\"//分治算法是基于递归的void quickSort(int arr[],int left,int right) { if (left&lt;right) { int i = left, j = right, tmp = arr[left]; //将最左边的数选为基准数字 //先从右向左搜索比tmp小的数 while (i&lt;j) { while (i&lt;j&amp;&amp;tmp &lt;= arr[j]) j--; if (i&lt;j) arr[i++] = arr[j]; //将右边的数挖出放到左边的位置 //从左至右搜索比tmp大的数 while (i&lt;j&amp;&amp;tmp &gt;arr[i]) i++; if (i&lt;j) arr[j--] = arr[i]; //将左边的数挖出放入右边的空位 } arr[i] = tmp; quickSort(arr, left, i - 1); //递归调用 quickSort(arr, i + 1, right); //递归调用 }}int main() { int a[5] = { 5,4,3,2,1 }; quickSort(a, 0, 4); for (int i = 0; i &lt; 5; i++) { printf(\"%d\",a[i]); } system(\"pause\"); return 0;}","link":"/public/2017/08/04/Data_Structure/2017-08-04-data-structure-quick-sort/"},{"title":"图的邻接矩阵表示","text":"modified: 2017-08-04 邻接矩阵 邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。 有向图的邻接矩阵表示: 无向图的邻接矩阵的表示(图中边的权重为1)： 带权无向图邻接矩阵的代码实现 图的结构定义 12345typedef struct MGraph { int numVertices, numEdges; //图中实际顶点的个数和边的条数 char VerticesList[maxVertices]; //顶点数组 int Edge[maxVertices][maxVertices]; //邻接矩阵，使用二维数组表示}; 图的初始化 12345678910void InitGraph(MGraph &amp;G) { G.numVertices = 0; G.numEdges = 0; for (int i = 0; i &lt; maxVertices; i++) //邻接矩阵初始化 { G.VerticesList[i] = '0'; for (int j = 0; j &lt; maxVertices; j++) //若为非带权图，全部赋值为0 G.Edge[i][j] = ((i == j) ? 0 : maxWeight); //maxWeight代表无穷大 }} 从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1 12345678910int GetVertexPos(MGraph G, char x) { for (int i = 0; i &lt; G.numVertices; i++) { if (G.VerticesList[i] == x) { return i; } } return -1;} 输入创建使用邻接矩阵表示的带权无向图 123456789101112131415161718192021222324252627282930void CreateGraph(MGraph &amp;G, int numVertex, int numEdge) { //从键盘输入n个顶点和m条边的信息，建立一个带权的无向图 char e; G.numVertices = numVertex; G.numEdges = numEdge; printf(\"请输入顶点\\n\"); for (int i = 0; i &lt; numVertex; i++) { scanf(\"%c\", &amp;e); G.VerticesList[i] = e; } printf(\"请输入顶点和权重\\n\"); for (int i = 0; i &lt; numEdge;) { char e1, e2; int weight; getchar(); //如果不使用getchar(),则缓冲区内还会有回车键 scanf(\"%c %c %d\", &amp;e1, &amp;e2, &amp;weight); if (GetVertexPos(G, e1) !=-1&amp;&amp; GetVertexPos(G, e2) !=-1) { G.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight; G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight; i++; } else { printf(\"输入顶点错误，请重新输入\\n\"); } }} 注：若需要带权的有向图只需将G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;注释即可 以下图为例测试 1234567891011121314151617int main() { MGraph G; InitGraph(G); CreateGraph(G, 5, 7); printf(\"\\n结果输出\\n\"); for (int i = 0; i &lt; 7; i++) { for (int j = 0; j &lt; 7; j++) { printf(\"%d \",G.Edge[i][j]); } printf(\"\\n\"); } system(\"pause\"); return 0;} 测试结果 源码下载","link":"/public/2017/08/26/Data_Structure/2017-08-26-data-structure-adjaceny-matrix/"},{"title":"创建大根堆与小根堆","text":"modified: 2017-08-26 堆的概念 n个元素序列{k0,k1,k2…ki…kn-1},当且仅当满足下列关系时称之为堆：(ki &lt;= k2i+1,ki &lt;= k2i+2)或者(ki &gt;= k2i+1,ki &gt;= k2i+2), (i = 0,1,2,3,4…(n-2)/2) 注：i从0开始与从1开始，需要改变末尾元素的下标值 堆的性质 堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性） 大根堆与小根堆 小根堆的建立源码:小根堆的建立过程如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示： 小根堆的结构定义 1234typedef struct minHeap{ int heap[HeapSize]; //存放小根堆中元素的数组 int n; //小根堆当前元素的个数，初始值为0}minHeap; 自顶向下调整 自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆 12345678910111213141516void shifDown(minHeap &amp;H, int m) { //m是开始调整的结点,n是调整结束的点 int tmp = H.heap[m]; //j是i的左子女 for (int j = 2 * m + 1; j &lt;= H.n-1; j=2*j+1) { if (j&lt;H.n-1&amp;&amp;H.heap[j]&gt;H.heap[j + 1]) j++; if (tmp &lt;= H.heap[j]) break; else { tmp = H.heap[m]; H.heap[m] = H.heap[j]; H.heap[j] = tmp; m = j; } }} 构建小根堆 构建的是从下到上，调整的时候是从上至下 12345678void createMinHeap(minHeap &amp;H, int arr[], int n) { for ( int i = 0; i &lt; n; i++) H.heap[i] = arr[i]; H.n = n; for (int i = (H.n - 2) / 2; i &gt;=0;i--) { //自底向上逐步扩大小根堆 shifDown(H,i); //局部自上向下筛选 }} 自底向上调整小根堆 1234567891011121314151617void shifUp(minHeap &amp;H,int start) { int j= start; int i = (j - 1) / 2; int tmp = H.heap[start]; while (j&gt;0) { if (H.heap[i] &lt;= tmp) break; else { H.heap[j] = H.heap[i]; j = i; i = (i - 1) / 2; } } H.heap[j] = tmp;} 小根堆的插入，采用局部自下向上调整 小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用shifUp自下向上，一层一层向上调整； 123456789void Insert(minHeap &amp;H,int x) { if (H.n==HeapSize) { printf(\"堆满\"); } H.heap[H.n] = x; shifUp(H, H.n); H.n++;} 小根堆的删除 小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用shiftDown从堆顶向下进行调整 1234567891011int Remove(minHeap &amp;H,int &amp;x) { if (!H.n) return 0; //堆空返回0 x = H.heap[0]; H.heap[0] = H.heap[H.n - 1]; H.n--; for (int i = (H.n - 2) / 2; i &gt;= 0; i--) { //自底向上逐步扩大小根堆 shifDown(H, i); //局部自上向下筛选 } return 1;} 运行测试 12345678910111213141516171819202122232425262728293031int main() { int arr[8] = { 53,17,78,9,45,65,87,23}; minHeap H; createMinHeap(H,arr,8); printf(\"小根堆的建立\\n\"); for (int i = 0; i &lt; 8; i++) { printf(\" %d \",H.heap[i]); } printf(\"\\n小根堆的插入元素10\\n\"); Insert(H,10); for (int i = 0; i &lt; 9; i++) { printf(\" %d \", H.heap[i]); } int x; x=Remove(H); printf(\"\\n小根堆的删除\\n\"); printf(\"删除的元素为\\n%d\\n\",x); printf(\"删除堆顶元素，进行调整后的元素为\\n\"); for (int i = 0; i &lt; 8; i++) { printf(\" %d \", H.heap[i]); } system(\"pause\"); return 0;} 运行结果 大根堆的建立源码大根堆的建立过程与小根堆的建立过程是相似的； 大根堆的结构定义 1234typedef struct MaxHeap { int heap[HeapSize]; int n;}MaxHeap; 采用自上而下的调整方法 1234567891011121314151617181920void shiftHeap(MaxHeap &amp;H,int m) { int tmp = H.heap[m]; for (int i = 2*m+1; i &lt;=H.n-1 ; i=i*2+1) { if (i&lt;H.n-1&amp;&amp;H.heap[i]&lt;H.heap[i+1]) { i++; } if (tmp&gt;H.heap[i]) { break; } else { H.heap[m] = H.heap[i]; H.heap[i] = tmp; m = i; } }} 大根堆的建立 12345678910111213void createHeap(MaxHeap &amp;H, int arr[],int n) { //将数组的内容赋值给堆中的元素 for (int i = 0; i &lt; n; i++) { H.heap[i] = arr[i]; } H.n = n; for (int i = (n-2)/2; i &gt;=0; i--) { shiftHeap(H, i); }} 代码测试 123456789101112int main() { int arr[8] = {1,2,3,4,5,6,7,8}; MaxHeap H; createHeap(H, arr,8); printf(\"大根堆的创建结果\\n\"); for (int i = 0; i &lt; 8; i++) { printf(\" %d \",H.heap[i]); } system(\"pause\"); return 0;} 测试结果 结果以树的形式表示","link":"/public/2017/08/26/Data_Structure/2017-08-26-data-structure-build-heap/"},{"title":"图的邻接表存储","text":"modified: 2017-08-27 邻接表邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表; 使用邻接表表示图的数据结构 1234567891011121314typedef struct EdgeNode { //边结点的定义 int dest; //边的另一个定点的位置 int cost; //边上的权重 struct EdgeNode *link; //下一条边链指针};typedef struct VertexNode { //顶点的定义 char data; struct EdgeNode *first; //边链表的头指针};typedef struct ALGraph { //图的定义 VertexNode VerticesList[maxVertices]; //顶点表（各边链表的头结点） int numVertices, numEdge; //图中实际顶点的个数和边的条数}; 初始化邻接表 12345678void initGraph(ALGraph &amp;G) { G.numEdge = 0; G.numVertices = 0; for (int i = 0; i &lt; maxVertices; i++) { G.VerticesList[i].first = NULL; }} 获取顶点在图的数组中的位置，如果不存在则返回-1 12345678910int getVertices(ALGraph G,char x) { for (int i = 0; i &lt; G.numVertices; i++) { if (G.VerticesList[i].data==x) { return i; } } return -1;} 创建一个带权的有向图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void createGraph(ALGraph &amp;G, int numVertices, int numEdge) { //从键盘输入n个顶点和m条边的信息 G.numVertices = numVertices; G.numEdge = numEdge; printf(\"请输入顶点\\n\"); for ( int i = 0; i &lt; numVertices; i++) { scanf(\"%c\",&amp;G.VerticesList[i].data); } printf(\"请输入顶点和权重\\n\"); for (int i = 0; i &lt; G.numEdge;) { char e1, e2; int weight; getchar(); scanf(\"%c %c %d\",&amp;e1,&amp;e2,&amp;weight); if (getVertices(G,e1)!=-1&amp;&amp; getVertices(G, e2) != -1) { EdgeNode *p, *q; p = G.VerticesList[getVertices(G, e1)].first; q = (EdgeNode *)malloc(sizeof(EdgeNode)); if (p==NULL) { G.VerticesList[getVertices(G, e1)].first = q; q-&gt;dest = getVertices(G, e2); q-&gt;cost = weight; q-&gt;link = NULL; i++; } else { while (p-&gt;link != NULL) { p = p-&gt;link; } p-&gt;link= q; q-&gt;dest = getVertices(G, e2); q-&gt;cost = weight; q-&gt;link = NULL; i++; } } else printf(\"顶点输入错误，请重新输入\\n\"); }} 测试代码（以上面的无向图为例，因为createGraph为构建有向图，只需将无向图看作双向有向图即可） 1234567891011121314151617181920int main() { ALGraph G; initGraph(G); createGraph(G, 4, 3); for (int i = 0; i &lt; 4; i++) { printf(\"%c \",G.VerticesList[i]); EdgeNode *p = G.VerticesList[i].first; while (p!= NULL) { printf(\"%d \", p-&gt;dest); printf(\"%d \",p-&gt;cost); p = p-&gt;link; } printf(\"\\n\"); } system(\"pause\"); return 0;} 运行结果 源码下载","link":"/public/2017/08/27/Data_Structure/2017-08-27-data-structure-adjacency-list/"},{"title":"堆排序","text":"modified: 2017-08-27 堆排序原理 在建堆完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。 使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似） 采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素 1234567891011121314151617181920void shiftHeapSort(MaxHeapSort &amp;H, int m,int n) { int tmp = H.heap[m]; for (int i = 2 * m + 1; i &lt;= n - 1; i = i * 2 + 1) { if (i&lt;n - 1 &amp;&amp; H.heap[i]&lt;H.heap[i + 1]) { i++; } if (tmp&gt;H.heap[i]) { break; } else { H.heap[m] = H.heap[i]; H.heap[i] = tmp; m = i; } }} 创建最大堆 123456789101112void createHeapSort(MaxHeapSort &amp;H, int arr[], int n) { //将数组的内容赋值给堆中的元素 for (int i = 0; i &lt; n; i++) { H.heap[i] = arr[i]; } H.n = n; for (int i = (n - 2) / 2; i &gt;= 0; i--) { shiftHeapSort(H, i,H.n); }} 对最大堆进行排序 123456789101112131415161718192021222324252627int main(){ int a[7] = {7,6,5,4,3,2,1}; //首先构建最大堆 MaxHeapSort H; createHeapSort(H, a, 7); //最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆 int tmp; for (int i = H.n-1; i &gt;=0; i--) { tmp = H.heap[0]; H.heap[0] = H.heap[i]; H.heap[i] = tmp; //将其再次调整为最大堆 for (int j = i/2; j &gt;=0; j--) { shiftHeapSort(H,j,i); } } for (int i = 0; i &lt; 7; i++) { printf(\"%d\\n\",H.heap[i]); } system(\"pause\"); return 0;} 运行结果","link":"/public/2017/08/27/Data_Structure/2017-08-27-data-structure-heap-sort/"},{"title":"Huffman树的算法实现","text":"modified 2017-08-27 Huffman树Huffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树； Huffman算法设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树/source/img/DataStructure/huffman_tree2.jpg 构造Huffman树的算法实现 Huffman树的结点结构定义 12345typedef struct HuffmanNode { char data; //数据 int weight; //权重 int lChild, rChild, parent; //指针}; Huffman树的结构定义 1234typedef struct HuffmanTree { HuffmanNode elem[totalNumber]; //树的存储数组 int n; //当前外结点的个数}; 构造Huffman树 1234567891011121314151617181920212223242526272829303132333435void createHuffmanTree(HuffmanTree &amp;HT,int weight[],int n) { //给出n个权重的数组，构造Huffman树HT int p1,p2, min1, min2; //p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值 for (int i = 0; i &lt; n; i++) HT.elem[i].weight = weight[i]; //权重传到树中 for (int i = 0; i &lt; 2*n-1; i++) //元素初始化 HT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = -1; p1 = p2 = 0; for ( int i = n; i &lt;2*n-1; i++) //逐个非叶节点构造 { min1 = min2 = 100; for ( int j = 0; j &lt; i; j++) //寻找具有最小、次小值的根建树 { if (HT.elem[j].parent== -1) { //父指针为-1，则此时该节点没有父亲 if (HT.elem[j].weight&lt;min1) //比原来最小的还要小 { p2 = p1; min2 = min1; //原来最小的变为最小 p1 = j; min1 = HT.elem[j].weight; //记下新的最小值 } else if (HT.elem[j].weight&lt;min2) //比原来的次小还要小 { p2 = j; min2 = HT.elem[j].weight; //记下新的次小值 } } } HT.elem[i].lChild = p1; HT.elem[i].rChild = p2; //左最小，右次小链接 HT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight; HT.elem[p1].parent = HT.elem[p2].parent =i ; //链接父节点 } HT.n = 2 * n - 1;} 上图构建Huffman树之后的结果 上述代码运行 123456789101112int main() { int weight[5] = {7,5,2,4,6}; HuffmanTree ht; createHuffmanTree(ht,weight,5); for (int i = 0; i &lt; 9; i++) { printf(\"%d %d %d\\n\",ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild); } system(\"pause\"); return 0;} 运行结果 源码地址","link":"/public/2017/08/28/Data_Structure/2017-08-28-data-structure-huffman-tree/"},{"title":"Other/函数式编程","text":"函数式编程（FP）“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","link":"/public/2019/09/19/Other/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"title":"PAT甲级1001. A+B Format","text":"modified: 2017-07-27 A+B Format (20) Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input-1000000 9 Sample Output-999,991 题目要求：计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出； 输入：输入两个在[-1000000,1000000]的a,b两个数 输出：应该在一行格式化输出 解题思路：a,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include \"stdio.h\"#include \"stdlib.h\"int main() { int a = 0; int b = 0; int c = 0; int num = 0; int tmp[3]; scanf(\"%d%d\", &amp;a, &amp;b); c = a + b; if (c &lt; 0) { printf(\"%c\", '-'); c = -c; } while (c/1000&gt;=1) { tmp[num] = c % 1000; num++; c = c / 1000; } tmp[num] = c; for (int i = num; i &gt;=0; i--) { if (i==num) { printf(\"%d\", tmp[i]); } else { if (tmp[i]&lt;10) { printf(\"%s%d\", \",00\", tmp[i]); } else if (tmp[i]&lt;100) { printf(\"%s%d\", \",0\", tmp[i]); } else { printf(\"%s%d\", \",\", tmp[i]); } } } return 0;}","link":"/public/2017/07/27/PAT/2017-07-27-pat-advanced-1001/"},{"title":"PAT甲级1002. A+B for Polynomials","text":"modified: 2017-07-27 This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 题目要求：两个多项式相加，多项式的输入为 K N1 aN1 N2 aN2 … 其中K代表项数，N1…代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格； 解题思路：定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中； 本题目采用C语言进行编写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int main() { int k1, k2, k3, count1 = 0, count2 = 0, count3 = 0; float NA1[20] = { 0 }; float NA2[20] = { 0 }; float NA3[40] = { 0 }; char ch; scanf(\"%d\", &amp;k1); while (ch = getchar() != '\\n') { scanf(\"%f\", &amp;NA1[count1++]); } scanf(\"%d\", &amp;k2); while (ch = getchar() != '\\n') { scanf(\"%f\", &amp;NA2[count2++]); } count1 = count2 = 0; while (count1 &lt; 2 * k1 &amp;&amp; count2 &lt; 2 * k2) { if (NA1[count1] == NA2[count2]) { NA3[count3++] = NA1[count1++]; count2 += 1; NA3[count3++] = NA1[count1++] + NA2[count2++]; } else if (NA1[count1] &gt; NA2[count2]) { NA3[count3++] = NA1[count1++]; NA3[count3++] = NA1[count1++]; } else { NA3[count3++] = NA2[count2++]; NA3[count3++] = NA2[count2++]; } } while (count1 &lt; 2 * k1) { NA3[count3++] = NA1[count1++]; NA3[count3++] = NA1[count1++]; } while (count2 &lt; 2 * k2) { NA3[count3++] = NA2[count2++]; NA3[count3++] = NA2[count2++]; } k3 = (count3 + 1) / 2; for (int i = 0; i &lt; count3; i++) { if (i % 2 == 0) { if (NA3[i + 1] == 0) { i++; k3--; } } } printf(\"%d\", k3); for (int i = 0; i &lt; count3; i++) { if (i % 2 == 0) { if (NA3[i + 1] == 0) { i++; } else { printf(\" \"); printf(\"%d\", (int)NA3[i]); } } else { printf(\" \"); printf(\"%.1f\", NA3[i]); } } system(\"pause\"); return 0;} 总结：在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；","link":"/public/2017/07/27/PAT/2017-07-27-pat-advanced-1002/"},{"title":"PAT甲级1005. Spell It Right","text":"modified: 2017-07-27Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification: Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100). Output Specification: For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input:12345 Sample Output:one five 题目要求：任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文； 输入：输入的N&lt;=10100 输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格 解题思路：首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"stdlib.h\"#include \"stdio.h\"int main() { char ch; int count = 0; int words[4]; int sum = 0; ch = getchar(); while (ch != '\\n') { sum += ch - '0'; ch = getchar(); } while (sum / 10 &gt; 0) { words[count++] = sum % 10; sum = sum / 10; } words[count++] = sum % 10; for (int i = count - 1; i &gt;= 0; i--) { switch (words[i]) { case 0: printf(\"zero\"); break; case 1: printf(\"one\"); break; case 2: printf(\"two\"); break; case 3: printf(\"three\"); break; case 4: printf(\"four\"); break; case 5: printf(\"five\"); break; case 6: printf(\"six\"); break; case 7: printf(\"seven\"); break; case 8: printf(\"eight\"); break; case 9: printf(\"nine\"); break; default: break; } if (i!=0) { printf(\" \"); } } return 0;}","link":"/public/2017/07/27/PAT/2017-07-27-pat-advanced-1005/"},{"title":"PAT甲级1007. Maximum Subsequence Sum","text":"modified: 2017-07-27Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification: Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space. Output Specification: For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input: 10 -10 1 2 3 4 -5 -23 3 7 -21 Sample Output: 10 1 4 题目要求：给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素； 解题思路：sum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp&lt;0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp&lt;0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include \"stdio.h\"#include \"stdlib.h\"#include &lt;stdbool.h&gt;int main() { int count, sum = -1, sumTmp = 0, left = 0, leftTmp = 0, right = 0, input, first, last; int num[10000]; bool positive = false, half_positive = false; scanf(\"%d\", &amp;count); for (int i = 0; i &lt; count; i++) { scanf(\"%d\", &amp;input); num[i] = input; if (input &gt;= 0) { positive = true; } sumTmp = sumTmp + input; if (sum &lt; sumTmp) { left = leftTmp; right = i; sum = sumTmp; } else if (sumTmp &lt; 0) { leftTmp=i+1; sumTmp = 0; } } if (positive) { printf(\"%d %d %d\", sum, num[left], num[right]); } else { printf(\"%d %d %d\", 0, num[0], num[count-1]); } system(\"pause\"); return 0;} 总结：又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试； 本题中容易被忽略的数列类型有如下： 连续0 5 0 0 -1 -1 0 前面都为负、最后一位为0 5 -1 -1 -1 -1 0","link":"/public/2017/07/28/PAT/2017-07-27-pat-advanced-1007/"},{"title":"PAT甲级1008. Elevator","text":"modified: 2017-07-27The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input Specification: Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100. Output Specification: For each test case, print the total time on a single line. Sample Input:3 2 3 1 Sample Output:41 题目要求：一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S； 给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层； 每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个； 解题思路：首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间； 123456789101112131415161718192021222324252627282930313233#include \"stdlib.h\"#include \"stdio.h\"int main() { char ch; int floor[101]; //用于对输入的楼层数进行计数 int count = 0; int time =0 ; scanf(\"%d\", &amp;floor[count++]); while (ch=getchar()!='\\n') { scanf(\"%d\", &amp;floor[count++]); } time += 6 * floor[1]+5; for (int i = 2; i &lt; count; i++) { if (floor[i]&gt;floor[i-1]) { time += 6 * (floor[i] - floor[i - 1])+5; } else { time += 4 * (floor[i-1] - floor[i])+5; } } printf(\"%d\",time); return 0;}","link":"/public/2017/07/27/PAT/2017-07-27-pat-advanced-1008/"},{"title":"PAT甲级1006. Sign In and Sign Out","text":"modified: 2017-07-31At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification: Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification: For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input: 3 CS301111 15:30:28 17:00:10 SC3021234 08:00:00 11:25:25 CS301133 21:45:00 21:58:40 Sample Output: SC3021234 CS301133 题目要求：每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人； 输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS； 输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开； 题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的； 解题思路方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include \"stdio.h\"#include \"stdlib.h\"#include \"string.h\"#include \"stdbool.h\"typedef struct user { char name[20]; char inTime[20]; char outTime[20];}user;int main() { user user[100]; int num; int unLockedIndex; int lockedIndex; char inTimeTmp[20]; strcpy(inTimeTmp,\"23:59:59\"); char outTimeTmp[20]; strcpy(outTimeTmp, \"00:00:00\"); unLockedIndex = 0; lockedIndex = 0; scanf(\"%d\",&amp;num); for (int i = 0; i &lt; num; i++) { scanf(\"%s\",&amp;user[i].name); scanf(\"%s\", &amp;user[i].inTime); //大于零表示第二个字符串小于第一个 if (strcmp(inTimeTmp, user[i].inTime)&gt;0) { strcpy(inTimeTmp, user[i].inTime); unLockedIndex = i; } scanf(\"%s\", &amp;user[i].outTime); //表示第二个字符串大于第一个 if (strcmp(outTimeTmp, user[i].outTime)&lt;0) { strcpy(outTimeTmp, user[i].outTime); lockedIndex = i; } } printf(\"%s %s\",user[unLockedIndex].name,user[lockedIndex].name); system(\"pause\"); return 0;} 方法二：将输入的时间转换为秒，然后再比较大小","link":"/public/2017/07/31/PAT/2017-07-31-pat-advanced-1006/"},{"title":"PAT甲级1011. World Cup Betting ","text":"modified: 2017-08-01With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%. For example, 3 games’ odds are given as the following: W T L 1.1 2.5 1.7 1.2 3.0 1.6 4.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.13.02.565%-1)2 = 37.98 yuans (accurate up to 2 decimal places). Input Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L. Output For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input 1.1 2.5 1.7 1.2 3.0 1.6 4.1 1.2 1.1 Sample Output T T W 37.98 题目要求题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果； 解题思路设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3]; 123456789101112131415161718192021222324252627282930313233343536373839404142#include \"stdio.h\"#include \"stdlib.h\"int main(){ char line[3] = {'W','T','L'}; char outChar[3]; int index; float in,tmp; float result=1; for (int i = 0; i &lt; 3; i++) { index = 0; tmp = 0; for (int j = 0; j &lt;3; j++) { scanf(\"%f\",&amp;in); if (tmp&lt;in) { tmp = in; index = j; } } result *= tmp; outChar[i]=line[index]; } for (int i = 0; i &lt; 3; i++) { printf(\"%c \",outChar[i]); } printf(\"%.2f\", (result*0.65 - 1) * 2); system(\"pause\"); return 0;}","link":"/public/2017/08/01/PAT/2017-08-01-pat-advanced-1011/"},{"title":"PAT甲级1060. Are They Equal","text":"modified: 2017-08-01If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification: Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100. Output Specification: For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1: 3 12300 12358.9 Sample Output 1: YES 0.123*10^5 Sample Input 2: 3 120 128 Sample Output 2: NO 0.12010^3 0.12810^3 题目要求将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出； 解题思路题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同; void getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中； void formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index&gt;=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index&lt;=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1； 对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出； 数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的； 需要注意的要点：结尾需要使用0进行补足 C语言代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中void getRidZero(char num[10000], int *index, int *decimalPoint, char pNum[10000]){ //做一个循环除去开头的零和小数点 for (int i = 0; i &lt; 10000; i++) { if (num[i] != '0'&amp;&amp;num[i] != '.'&amp;&amp;num[i] != '\\0') { *index = i; break; } } //用于获取小数点的位置 for (int i = 0; i &lt; 10000; i++) { if (num[i] == '\\0' || num[i] == '.') { *decimalPoint = i; break; } } int j = 0; for (int i = *index; i &lt; 10000; i++) { if (num[i] == '\\0' || num[i] &lt; 0) { pNum[j] = '0'; j++; } else if (num[i] == '.') { continue; } else { pNum[j] = num[i]; j++; } }}//用于将pNum[]中保存的数按照科学计数法输出void formatPrint(int accuracy, char pNum[10000], int decimalPoint, int index){ printf(\"0.\"); for (int i = 0; i &lt; accuracy; i++) { printf(\"%C\", pNum[i]); } if (decimalPoint - index &gt;= 0) { printf(\"*10^%d\", decimalPoint - index); } else { printf(\"*10^%d\", decimalPoint - index + 1); }}int main() { int accuracy; char num1[10000]; char num2[10000]; char pNum1[10000]; char pNum2[10000]; //用于记录小数点的位置 int decimalPoint1 = 0; int decimalPoint2 = 0; //用于记录数字开始的位置 int index1 = 0; int index2 = 0; bool equal = true; scanf(\"%d %s %s\", &amp;accuracy, num1, num2); getRidZero(num1, &amp;index1, &amp;decimalPoint1, pNum1); getRidZero(num2, &amp;index2, &amp;decimalPoint2, pNum2); for (int i = 0; i &lt; accuracy; i++) { if (pNum1[i] != pNum2[i]) { equal = false; } } if ((index1 - decimalPoint1) != (index2 - decimalPoint2)) { equal = false; } bool notZero = false; //判断00000000 和000000.000000000 for (int i = 0; i &lt; 5000; i++) { if (pNum1[i] != '0' || pNum2[i] != '0') { //证明不是0 notZero = true; break; } } if (!notZero) //证明都是0 然后输出 0.0000*10^0 ，是第六个测试点 { printf(\"YES 0.\"); for (int i = 0; i &lt; accuracy; i++) { printf(\"%C\", '0'); } printf(\"*10^%d\", 0); } else if (equal) //如果两个数相等 { printf(\"YES \"); formatPrint(accuracy, pNum1, decimalPoint1, index1); } else //如果两个数不想等 { printf(\"NO \"); formatPrint(accuracy, pNum1, decimalPoint1, index1); //输出第二个数 printf(\" \"); formatPrint(accuracy, pNum2, decimalPoint2, index2); } system(\"pause\"); return 0;} 测试用例 5 0000.0000123 0.0000123 4 000123 00123.005 4 00000 000.000001 4 00.000 00000 4 0.01 0.01000005","link":"/public/2017/08/01/PAT/2017-08-01-pat-advanced-1060/"},{"title":"线索化二叉树","text":"modified: 2017-08-04使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息； 在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。 /source/img/DataStructure/threaded_binary_tree.jpg 以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree） 根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。 为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：二叉线索树源码 如果二叉树的构造、以及遍历不熟悉的可以先看二叉树； 线索二叉树的结构体1234567891011//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继typedef enum { Link = 0, Thread = 1 //Link==0:指针，Thread==1,线索}PointerTag;typedef struct BinaryTree { char item; BinaryTree *lChild; BinaryTree *rChild; PointerTag lTag, rTag;}BinaryTree, *pBinaryTree; 二叉树的先序构造要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为’#’，第一个被遍历的结点不需要加上’#’ 如图：先序遍历的结果为：cba###d#e#f##/source/img/DataStructure/binary_tree.jpg 12345678910111213141516171819202122pBinaryTree createBinaryTree() { pBinaryTree treeNode=NULL; char tmp = '0'; scanf(\"%c\", &amp;tmp); if (tmp == '#') { treeNode = NULL; } else { treeNode = (BinaryTree *)malloc(sizeof(BinaryTree)); treeNode-&gt;item = tmp; treeNode-&gt;lChild=createBinaryTree(); if (treeNode-&gt;lChild) treeNode-&gt;lTag = Link; treeNode-&gt;rChild=createBinaryTree(); if (treeNode-&gt;rChild) treeNode-&gt;rTag = Link; } return treeNode;} 二叉树的线索化，代码过程说明：将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程； 注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。 二叉树的中序遍历 12345678void inVisitBiTree(pBinaryTree biTree) { if (biTree) { inVisitBiTree(biTree-&gt;lChild); printf(\"%c\",biTree-&gt;item); inVisitBiTree(biTree-&gt;rChild); }} 二叉树线索化函数的整体框架 二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）； 1234567891011void InThreading(pBinaryTree biTree) { if (biTree) { InThreading(biTree-&gt;lChild); //printf(\"%c\",biTree-&gt;item); { //进行指针修改的代码块； } InThreading(biTree-&gt;rChild); }} 对访问结点记录，即对前驱的记录 在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点； 123456789101112void InThreading(pBinaryTree biTree) { if (biTree) { InThreading(biTree-&gt;lChild); //printf(\"%c\",biTree-&gt;item); { //进行指针修改的代码块，两个大括号是为了方便说明； } pre = binaryTree; //保持pre指向前驱； InThreading(binaryTree-&gt;rChild); }} 全局变量会被赋初值head，在下文中有介绍： 如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread; 1234567891011121314151617void InThreading(pBinaryTree biTree) { if (biTree) { InThreading(biTree-&gt;lChild); //printf(\"%c\",biTree-&gt;item); { //进行指针修改的代码块，两个大括号是为了方便说明； if (!binaryTree-&gt;lChild) { binaryTree-&gt;lTag = Thread; binaryTree-&gt;lChild = pre; } } pre-&gt;biTree; InThreading(biTree-&gt;rChild); }} 对后继的记录 如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可； 1234567891011121314151617181920void InThreading(pBinaryTree biTree) { if (binaryTree) { InThreading(binaryTree-&gt;lChild); //如果没有左孩子时前驱线索 if (!binaryTree-&gt;lChild) { binaryTree-&gt;lTag = Thread; binaryTree-&gt;lChild = pre; } //当没有右孩子，后继线索 if (!pre-&gt;rChild) { pre-&gt;rTag = Thread; pre-&gt;rChild = binaryTree; } pre = binaryTree; //保持pre指向前驱； InThreading(binaryTree-&gt;rChild); }} 在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre-&gt;biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码） 为已经线索化的二叉树添加头结点 123456789101112131415161718192021void InOrderThreading(pBinaryTree &amp;binarytree,pBinaryTree &amp;head) { head = (pBinaryTree )malloc(sizeof(BinaryTree)); //初始化头结点 head-&gt;lTag = Link; head-&gt;rTag = Thread; head-&gt;rChild = head; //头指针回指 if (!binarytree) { head-&gt;lChild =head; } else { head-&gt;lChild = binarytree; //当binaryTree非空时，指向二叉树的根结点 pre = head; //定义的全局变量第一次赋值使用 InThreading(binarytree); //对最后一个结点线索化 pre-&gt;rTag = Thread; pre-&gt;rChild = head; head-&gt;rChild = pre; //头结点指向中序遍历的最后一个结点 }} 对于中序线索树的中序遍历先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继 一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。 123456789101112131415161718192021222324void InVisitThreadTree(pBinaryTree binarytree) { pBinaryTree pBTree; pBTree = binarytree-&gt;lChild; //当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree while (pBTree != binarytree) { //找到最左元素 while (pBTree-&gt;lTag == Link) { pBTree = pBTree-&gt;lChild; } printf(\"%c\", pBTree-&gt;item); //如果右孩子是线索，则其指向的是下一个访问的结点 while ((pBTree-&gt;rChild != binarytree) &amp;&amp; (pBTree-&gt;rTag == Thread)) { pBTree = pBTree-&gt;rChild; printf(\"%c\", pBTree-&gt;item); } pBTree = pBTree-&gt;rChild; }} 测试:cba###d#e#f##需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!! 12//定义全局变量pBinaryTree pre; 12345678910111213int main() { pBinaryTree TbinaryTree, Head; TbinaryTree = createBinaryTree(); printf(\"二叉树的先序遍历\\n\"); preVisitBiTree(TbinaryTree); printf(\"\\n二叉树的中序遍历\\n\"); inVisitBiTree(TbinaryTree); InOrderThreading(TbinaryTree, Head); printf(\"\\n中序线索二叉树的中序遍历\\n\"); InVisitThreadTree(Head); system(\"pause\"); return 0;} 测试结果：","link":"/public/2017/08/08/Data_Structure/2017-08-08-data-structure-threaded-binary-tree/"},{"title":"Hello World","text":"","link":"/public/2019/08/05/Android/Other/Groovy%E4%BB%8B%E7%BB%8D/"},{"title":"Android/框架/RxJava2.0","text":"","link":"/public/2019/09/19/Android/%E6%A1%86%E6%9E%B6/RxJava2.0/"},{"title":"ActionBar和ToolBar的使用","text":"","link":"/public/2019/09/30/Android/View/ActionBar%E5%92%8CToolBar%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Java/Java多线程/Java锁机制","text":"","link":"/public/2019/09/19/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E9%94%81%E6%9C%BA%E5%88%B6/"},{"title":"Java/Java基础/Java 输入输出操作","text":"","link":"/public/2019/09/19/Java/Java%E5%9F%BA%E7%A1%80/Java%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C/"},{"title":"Android应用启动流程","text":"1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。6、AMS通知淘宝绑定Application并启动MainActivity。7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。 Android应用启动从Zygote到Activity.onCreate本文从点击Android应用图标开始介绍Android应用的启动过程 Android应用有两个方面的特点特点一：具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。 特点二：自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId; 任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。 在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 Zygote：创建新的进程Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。 init进程会启动Zygote进程 Zygote进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。 在Zygote之后，init启动运行时的进程？ 紧接着Zygote fork并启动一个称为system server的进程，system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。 用户点击图标通过Launcher启动应用的过程点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。 1、收集intent的目标的信息，通过调用PackageManager对象中的resolveIntent()方法，默认使用PackageManager.MATCH_DEFAULT_ONLY 和 PackageManager.GET_SHARED_LIBRARY_FILES标志。 2、目标信心会被存储至intent对象中，避免重复第一步工作； 3、判断用户是否有权限调用intent中的组件，通过grantUriPermissionLocked()方法执行； 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：FLAG_ACTIVITY_NEW_TASK 或者其他flagsFLAG_ACTIVITY_CLEAR_TOP； 5、检查进程的ProcessRecord是否已经存在，如果ProcessRecord为空，ActivityManager需要创建一个新的进程来实例化目标组件。 在该应用启动流程中有三个不同的阶段 1、进程创建 2、绑定应用 3、启动Activity/Service/调用intent receiver 进程创建ActivityManagerService通过调用startProcessLocked()方法来创建一个新的进程，startProcessLocked方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用ZygoteInit.main()方法，该方法会创建一个ActivityThread对象，并返回新建进程的id 在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用Looper.loop()方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用Looper.prepareLoop()再掉用Looper.loop()方法启动message loop。 应用绑定下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的bindApplication()方法来实现。该方法将BIND_APPLICATION信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——handleBindApplication()，该方法调用makeApplication()方法，makeApplication()方法将应用中特定的类加载到内存中执行。 启动Activity","link":"/public/2019/09/30/Android/Advanced/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"Android JNI敏感信息保护","text":"Android JNI对敏感信息进行保护Android反编译在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。 将敏感信息保存使用native代码实现相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。","link":"/public/2019/09/21/Android/Android%20JNI/Android%20JNI%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4/"},{"title":"Android防止二次打包","text":"Android防止二次打包主要通过对签名文件的验证来进行 应用签名文件介绍在Android Studio2.2之后多了对签名版本的选择V1(Jar Signature)和V2(Full APK Signature)V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。 签名文件在gradle中配置signingConfigs { debug { storeFile file(&quot;./hyydev.jks&quot;) storePassword &quot;******&quot; keyAlias &quot;**&quot; keyPassword &quot;******&quot; v1SigningEnabled true v2SigningEnabled true } release { storeFile file(&quot;./hyydev.jks&quot;) storePassword &quot;******&quot; keyAlias &quot;**&quot; keyPassword &quot;******&quot; v1SigningEnabled true v2SigningEnabled true } }应用签名文件查看 已有.jks文件 在cmd中输入 12keytool -list -v -keystore path/android.jks -storepass password ![](/public/img/Android/Android safe.png) 只有.apk文件 使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入 1keytool -printcert -file path/android.jks ![](/public/img/Android/Android safe1.png) 两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码 在Java代码中进行验证，通过PackageManager获取签名信息。使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解 在native层进行签名验证使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。 因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。 在服务端对签名文件进行验证服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）","link":"/public/2019/09/30/Android/Android%E5%8F%8D%E7%BC%96%E8%AF%91/Android%E5%BA%94%E7%94%A8%E9%98%B2%E6%AD%A2%E4%BA%8C%E6%AC%A1%E6%89%93%E5%8C%85/"},{"title":"Android 6.0及以上手机权限进行动态获取","text":"在Android 6.0及以上需要对手机权限进行动态获取如果手机版本为Android 6.0(API 23)或更高版本，以及app的targetSdkVersion为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。 同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。 同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如Manifest.permission.BLUETOOTH在动态申请时同样不会出现权限申请对话框，但会回调&lt; !–more–&gt;Android动态权限的申请仅对下图中的9大权限组进行申请 一、对于可选硬件功能权限的获取使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加&lt;uses-feature&gt; 1&lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" /&gt; 当声明为android:required=&quot;false&quot;时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要PackageManager.hasSystemFeature()来确定该设备是否存在；当声明为android:required=&quot;true&quot;时，需要手机上具有该设备，否则不能进行安装操作。 二、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041String[] permissions = {Manifest.permission.BLUETOOTH};@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); //只有系统API大于23时，才需要判断权限是否需要获取 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { //用于判断权限是否已经获取 int i = ContextCompat.checkSelfPermission(this, permissions[0]); //权限是否已经获取 GRANTED--授权 DINED--拒绝 if (i != PackageManager.PERMISSION_GRANTED) { //如果没有被授予该权限，提示用户请求该权限 ActivityCompat.requestPermissions(this, permissions, 1); }else { Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show(); } }}@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode==1){ //未获取到权限 if (grantResults[0] != PackageManager.PERMISSION_GRANTED) { //判断用户是否点击了不再提醒；检测该权限是否还可以再申请 boolean result = this.shouldShowRequestPermissionRationale(permissions[0]); //如果不可以再申请 if (!result) { //用户需要继续使用App //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示 LogUtils.printInfo(\"请到设置界面开启相应权限\"); }else { //如果可以再申请 Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show(); } } }} 三、连续多次申请权限出现问题在进行连续多次申请时，在回调函数onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)的permissions数组会返回长度为零的数组，因为在Activity的requestPermissions()方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行onRequestPermissionsResult方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断； 12345678910111213//Activity源码public final void requestPermissions(@NonNull String[] permissions, int requestCode) { //省略部分代码 if (mHasCurrentPermissionsRequest) { Log.w(TAG, \"Can request only one set of permissions at a time\"); // Dispatch the callback with empty arrays which means a cancellation. onRequestPermissionsResult(requestCode, new String[0], new int[0]); return; } Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions); startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null); mHasCurrentPermissionsRequest = true;} 四、其他有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。 12","link":"/public/2019/09/19/Android/Android%E5%9F%BA%E7%A1%80/Android%206.0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E8%8E%B7%E5%8F%96/"},{"title":"Android后台处理","text":"Android后台处理介绍Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。 推荐在后台进行处理的三种情况App处理操作是否可以滞后进行，或者需要实时处理例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行 App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。 App操作处理是否是由系统进行触发系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。 加一个选择策略图片线程池对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁 Foreground Service操作对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。 Workmanager对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。 后台进程操作的限制为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。 Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。 Android 7.0(Api 24)限制隐式广播。 Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。","link":"/public/2019/09/30/Android/Android%E5%9F%BA%E7%A1%80/Android%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/"},{"title":"Android序列化","text":"Android序列化Android序列化对象的方法有两种： 实现Serializable接口，Java自带 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）","link":"/public/2019/11/28/Android/Android%E5%9F%BA%E7%A1%80/Android%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Android文件操作","text":"Android文件的读和写1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；2、SD卡中的文件；3、数据区(/data/data/..)的文件； 资源文件的读写raw使用InputStream in = getResources().openRawResource(R.raw.test);asset使用InputStream in = getResources().getAssets().open(fileName); Android应用数据私有目录存储（位于应用功能安装目录下）该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。 文件类型：/data/data/包名/cache ：存放的是APP的缓存信息/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码/data/data/包名/files ： 存放APP的文件信息 还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。 私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录 context.getCacheDir()用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间 文件读操作文件写操作Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。 首先需要获取权限 1234&lt;!--用于获取文件操作的权限--&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; 需要确定写入文件目录是否存在，如果不存在，则需要新建目录 Android存储公有目录Andorid开发公有目录与Context无关，使用Environment进行获取 Environment.DIRECTORY_PICTURES 图片目录 Environment.DIRECTORY_DCIM 相册目录 Environment.DIRECTORY_DOCUMENTS 文档目录 Environment.DIRECTORY_DOWNLOADS 下载目录 Environment.DIRECTORY_MOVIES 视频 1234//有参Environment.getExternalStoragePublicDirectory(String type) ;//无参Environment.getExternalStoragePublicDirectory(); Android本地文件选择","link":"/public/2019/09/19/Android/Android%E5%9F%BA%E7%A1%80/Android%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"Handler介绍","text":"Handler介绍Handler直接继承于Object类 Handler与一个线程的MessageQueue进行绑定，可以用于Message的发送与处理以及Runnable对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的Message Queue相绑定，它可以将messages以及runnables对象传递到Message Queue，并对Message Queue中的messages以及runnables对象进行处理。 Handler使用的两个主要方面：1、对messages以及runnables在将来某一个节点执行进行调度；2、在非当前线程执行其他操作 Handler对Message的调度通过post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), 以及·、sendMessageDelayed(Message, long)等方法进行，post方法可以将Runnable对象插入到队列中，当消息队列收到Runnable对象时，可以执行。sendMessage方法可以将Message对象（其中包含大量数据）插入到队列中，通过HandlerMessage方法进行处理。 当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。 当应用程序创建一个进程之后，它的主线程用于持有的Message Queue用于管理“顶级”的应用对象(Activity Broadcast Receiver等)和他们创建的窗口。当创建自己的线程时，可以通过Handler与应用的主线程进行信息交换。 Looper介绍Looper直接继承于Object Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的prepare()方法来运行一个loop，loop()方法用来处理message。 与message loop进行大部分交互都是通过Handler类来进行。 下列代码是实现一个Looper线程的方式，通过分离开的prepare()以及loop()方法初始化一个Handler与Looper进行交互。 1234567891011121314151617class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); } } MessageQueue介绍MessageQueue直接继承于Object Message不能直接添加至Message Queue中，需要通过与Looper相关联的Handler对象来实现。通过Looper.myQueue方法可以从当前线程中获取MessageQueue 从源码角度分析Handler、Looper、MessageQueue三者之间的关系Handler默认构造函数Handler()，将自己与当前线程的Looper进行绑定，如果当前线程中没有Looper对象，会报出异常。 12345678910 //Handler源码117行public Handler() { this(null, false);}//Handler源码131行 public Handler(Callback callback) { this(callback, false);} 通过Looper.prepare();为当前线程设置一个Looper具体流程：其中prepare()方法是Looper类中的静态方法；在prepare(boolean quitAllowed)方法中调用sThreadLocal.set(new Looper(quitAllowed));当前线程设置一个新的Looper在构造函数Looper(boolean quitAllowed)中，该Looper创建了一个新的MessageQueue(mQueue = new MessageQueue(quitAllowed);); 12345678910111213141516171819//Looper源码97行 public static void prepare() { prepare(true);}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed));}//Looper源码267行 private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();} 在Handler源码的192行中，通过mLooper = Looper.myLooper();来获取当前线程中的Looper 123456789101112131415161718192021222324 //Handler源码192行public Handler(Callback callback, boolean async) { mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } //Looper71行 static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //Looper97行 //Looper源码254行 public static @Nullable Looper myLooper() { return sThreadLocal.get(); } Handler发送消息机制Handler调用sendMessage(Message msg)方法最终会一步一步调用sendMessageAtTime(Message msg, long uptimeMillis)在该方法中通过MessageQueue queue = mQueue;获取到MessageQueue，调用 用enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)方法将Message加入到消息队列中 1234567891011//Handler源码中的689行 public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } Handler消息处理机制","link":"/public/2019/09/30/Android/Android%E5%9F%BA%E7%A1%80/Handler%20Looper%E4%BB%8B%E7%BB%8D/"},{"title":"getSystemService的使用","text":"getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象； 传入的Name 返回的对象 说明 WINDOW_SERVICE WindowManager 管理打开的窗口程序 LAYOUT_INFLATER_SERVICE LayoutInflater 取得xml里定义的view ACTIVITY_SERVICE ActivityManager 管理应用程序的系统状态 POWER_SERVICE PowerManger 电源的服务 ALARM_SERVICE AlarmManager 闹钟的服务 NOTIFICATION_SERVICE NotificationManager 状态栏的服务 KEYGUARD_SERVICE KeyguardManager 键盘锁的服务 LOCATION_SERVICE LocationManager 位置的服务，如GPS SEARCH_SERVICE SearchManager 搜索的服务 VEBRATOR_SERVICE Vebrator 手机震动的服务 CONNECTIVITY_SERVICE Connectivity 网络连接的服务 WIFI_SERVICE WifiManager Wi-Fi服务 TELEPHONY_SERVICE TeleponyManager 电话服务","link":"/public/2019/09/30/Android/Android%E5%9F%BA%E7%A1%80/getSystemService%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"AsyncTask异步操作","text":"知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor 一个AsyncTask对象被创建出来后,就只能执行一个异步任务。 AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数 Params：启动任务时输入的参数类型 Progress：后台任务执行中返回进度值的类型 Result：后台任务执行完成后返回结果类型 AsyncTask中三个重要函数 doInBackground：异步执行后台线程要完成的任务在此方法中进行 onPreExecute：执行后台耗时操作前调用，通常用于初始化操作 onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。","link":"/public/2019/08/20/Android/Android%E5%9F%BA%E7%A1%80/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9CAsynctask/"},{"title":"Android 蓝牙4.0开发","text":"Android 蓝牙4.0开发这是一条优雅的分割线 写在前面：本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0 尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。 首先对蓝牙进行非专业的介绍，蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！ 对GATT的介绍按照惯例先上代码 优雅的代码 ##3 权限的获取 蓝牙4.0有一个坑爹的权限是位置信息的获取 蓝牙搜索蓝牙的搜索有三种方式 方法一：BluetoothAdapter.startDiscovery()是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；蓝牙扫描广播接收器 1234567891011//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果private class DeviceReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if(BluetoothDevice.ACTION_FOUND.equals(action)){ BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); } }} 方法二：BluetoothAdapter.startScan(ScanCallback callback)在ScanCallback的onScanResult(int callbackType, ScanResult result)方法中，通过result.getDevice()可获取扫描到的Ble设备 方法三：BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)该方法已经被舍弃","link":"/public/2019/09/19/Android/Ble/Android%20ble%204.0/"},{"title":"Android开发常用操作","text":"查看签名文件信息密码是password 1keytool -list -v -keystore application.jks -storepass password","link":"/public/2019/08/15/Android/Other/%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"自定义View实现倒计时功能","text":"使用自定义View实现倒计时功能当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。 倒计时控件实现的功能 显示时间进度 计时结束后将会自动跳转到下一个Activity中 实现效果如图所示 在本篇博客中的代码会有部分缺省，源码链接 对自定义View的尺寸进行测量并绘制中间的大圆View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CountDownView extends android.support.v7.widget.AppCompatTextView { private int circleRadius; private int circleColor=0xff33b5e5; private Paint circlePaint; private Rect bounds; private int centerX; private int centerY; public CountDownView(Context context) { super(context); init(); } public void init(){ circlePaint=new Paint(); bounds=new Rect(); } public CountDownView(Context context, AttributeSet attrs) { super(context, attrs); init(); } public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec,heightMeasureSpec); circleRadius=getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2; setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight()); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); getDrawingRect(bounds); //获取控件的边界 centerX=bounds.centerX(); centerY=bounds.centerY(); //绘制中间的大圆的背景 circlePaint.setAntiAlias(true); circlePaint.setStyle(Paint.Style.FILL); circlePaint.setColor(circleColor); canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint); }} 在activity_main.xml中添加自定义控件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;com.example.wyw.countdowndemo.CountDownView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; /&gt;&lt;/LinearLayout&gt; 运行结果 绘制进度边框1234567891011private int cirlceBoundColor=0xff00ddff;@Overrideprotected void onDraw(Canvas canvas) { circlePaint.setStyle(Paint.Style.STROKE); circlePaint.setStrokeWidth(5); circlePaint.setColor(cirlceBoundColor); canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);} 绘制进度条的一条弧线进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线 1234567891011121314151617private RectF arcRectF;private int processColor=0xff99cc00;public void init(){ arcRectF=new RectF();}@Overrideprotected void onDraw(Canvas canvas) { circlePaint.setColor(processColor); //设置线冒样式 circlePaint.setStrokeCap(Paint.Cap.ROUND); arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8); canvas.drawArc(arcRectF,-90,40,false,circlePaint);} 进度条按照通过Timer不断控制绘制角度的增加123456789101112131415161718192021222324252627282930private int currentDrawTime; //已经绘制的次数private Timer timer;public void init(){ timer=new Timer(); arcRectF=new RectF();}@Overrideprotected void onDraw(Canvas canvas) { arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8); canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);}public void drawProcess(){ currentDrawTime=0; timer.schedule(new TimerTask() { @Override public void run() { postInvalidate(); currentDrawTime++; if (currentDrawTime==8) timer.cancel(); } },500,500);} 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时12345678910@Overrideprotected void onDraw(Canvas canvas) { Paint paint = getPaint(); float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2; paint.setAntiAlias(true); //防锯齿 paint.setColor(Color.WHITE); paint.setTextAlign(Paint.Align.CENTER); canvas.drawText((4000-500*currentDrawTime)/500+&quot;s&quot;,centerY,textY,paint);}","link":"/public/2018/06/20/Android/View/CountDownView/"},{"title":"LayoutInflater介绍与使用","text":"LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。 LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。 findViewById用于已载入的界面，使用findViewById来获取其中的界面元素 获取LayoutInflater实例的方法 1、通过系统服务获取布局加载器 1LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); 2、通过activity中的getLayoutInflater()方法 1LayoutInflater inflater = getLayoutInflater(); 3、通过LayoutInflater的from静态方法 1LayoutInflater inflater = LayoutInflater.from(this) 这三种方式本质都是调用Context.getSystemService() 使用inflate方法加载布局LayoutInflater提供四种加载布局的方法 public View inflate (int resource, ViewGroup root) public View inflate (int resource, ViewGroup root, boolean attachToRoot) public View inflate (XmlPullParser parser, ViewGroup root) public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot) ViewGroup root：指实例的布局所要放入的根视图boolean attachToToot：指是否附加到传入的根视图 1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。 即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View 示例：将button布局添加到LinearLayout上123456&lt;Button xmlns:android=”http://schemas.android.com/apk/res/android&quot; android:layout_width=”match_parent” android:layout_height=”wrap_content” android:text=”@string/action_attach_to_root_true” android:id=”@+id/button_ok”&gt;&lt;/Button&gt; Button的layout params类型是LinearLayout.LayoutParams 将attachRoot设置为true 1inflater.inflate(R.layout.view_button, mLinearLayout, true); 将attachRoot设置为false当attachRoot设置为false后， 123Button btn = (Button)inflater.inflate (R.layout.view_button,parent,false);parent.addView(btn); 同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。 在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可","link":"/public/2018/10/22/Android/View/LayoutInflater%E4%BD%BF%E7%94%A8/"},{"title":"Materials Design 介绍与使用","text":"CoordinatorLayout CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。 CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用 AppBarLayout AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。 AppBarLayout有五种滚动标识： scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部 enterAlways：让任意向下的滚动都会导致该view变为可见 enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。 exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠 snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开 CollapsingToolbarLayoutCollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout， BehaviorBehavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。 SnackBarSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。 如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button； ###SnackBar的使用方式 12 ToastToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置， SnackBar和Toast之间的对比 不同 Toast SnackBar 1 Toast从API1就存在 SnackBar在API23添加 2 不需要Activity，可以显示在Android Home或者其他应用才 只能显示在某一个Activity中 3 不能根据用户的操作执行Action 可以根据用户的操作执行Action 4 在用户滑动时不能消失 在用户滑动时可以消失","link":"/public/2018/09/01/Android/View/Materials%20Design/"},{"title":"使用SearchView以及RecyclerView实现条目删选","text":"使用SearchView以及RecyclerView实现条目删选## 使用SearchView以及RecyclerView实现条目删选 SearchView介绍 SearchView继承图 SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表 RecyclerView介绍RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。 代码实现搜索框的添加1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:icon=&quot;@android:drawable/ic_menu_search&quot; android:title=&quot;@string/action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; app:showAsAction=&quot;always|collapseActionView&quot; /&gt;&lt;/menu&gt; 2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件 注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView 1java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView MainActivity中的代码 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_main,menu); MenuItem menuItem=menu.findItem(R.id.action_search); SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem); searchView.setOnQueryTextListener(this); return true; } @Override public boolean onQueryTextSubmit(String query) { return false; } @Override public boolean onQueryTextChange(String newText) { return false; }} 显示效果如图所示： ![这里写图片描述](https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\) RecylerViewAdapter编写1、在build.gradle(Module:app)中添加依赖 123dependencies { implementation 'com.android.support:recyclerview-v7:27.1.0'} 2、RecyclerView列表中每一个item布局文件item_recyclerview的编写 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; app:cardCornerRadius=&quot;5dp&quot;&gt; &lt;TextView android:id=&quot;@+id/word_tv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;word&quot; android:textSize=&quot;25sp&quot; /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/LinearLayout&gt; 3、RecylerViewAdapter编写 1234567891011121314151617181920212223242526272829303132333435363738public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;{ private List&lt;String&gt;strings; public RecyclerViewAdapter(List&lt;String&gt;strings) { this.strings=strings; } @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false); ViewHolder viewHolder=new ViewHolder(view); return viewHolder; } @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) { ((ViewHolder)holder).words.setText(strings.get(position)); } @Override public int getItemCount() { return strings.size(); } public class ViewHolder extends RecyclerView.ViewHolder{ TextView words; public ViewHolder(View itemView) { super(itemView); words=(TextView)itemView.findViewById(R.id.word_tv); } }} 在MainActivity中添加RecyclerView布局1、在布局文件activity_main中添加RecyclerView布局 123456&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/main_recyclerview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt; 2、在MainActivity中为RecyclerView添加适配器 12345678910111213141516171819202122232425//省略部分代码private RecyclerView recyclerView;private RecyclerViewAdapter recyclerViewAdapter;private List&lt;String&gt;words;private RecyclerView.LayoutManager layoutManager;@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView=findViewById(R.id.main_recyclerview); layoutManager=new LinearLayoutManager(MainActivity.this); words=new ArrayList&lt;&gt;(); words.add(&quot;abc&quot;); words.add(&quot;abc&quot;); words.add(&quot;abc&quot;); recyclerViewAdapter=new RecyclerViewAdapter(words); recyclerView.setLayoutManager(layoutManager); recyclerView.setAdapter(recyclerViewAdapter);} 结果显示： ![这里写图片描述](https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\) 在MainActivity中添加筛选方法123456789private List&lt;String&gt;filter(List&lt;String&gt;strings,String text){ filterString=new ArrayList&lt;&gt;(); for (String word:words){ if (word.contains(text)) filterString.add(word); } return filterString;} 在RecyclerViewAdapter中设置筛选后的单词的显示12345 //省略部分代码public void setFilter(List&lt;String&gt;filterWords){ words=filterWords; notifyDataSetChanged(); } 当检测到SearchView中输入变化时进行单词筛选1234567@Overridepublic boolean onQueryTextChange(String newText) { filterString=filter(words,newText); recyclerViewAdapter.setFilter(filterString); return true;} 运行结果![这里写图片描述](https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)","link":"/public/2018/07/30/Android/View/%E4%BD%BF%E7%94%A8RecyclerView%E5%92%8CSearchView%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E5%88%A0%E9%99%A4/"},{"title":"Dagger2 介绍与使用","text":"在Android中使用Dagger2Dagger2介绍为什么我们需要注解依赖注入？Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。 如果一个类使用new操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。 注入模式 构造函数注入：以传递参数的方式 字段注入：以变量的方式 方法注入： “依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象” Dependency provider:使用注解@Module表示的类，用于提供可以进行注入的对象。类中的方法使用注解@Providers表示该方法的返回对象可以被依赖注入。@Moudle可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用@Inject即可 Dependency consumer：注解@Inject用于定义一个依赖。 Connection consumer and producer：使用注解@Component的接口定义module对象中provider与依赖对象之间的连接，接口的实现类由Dagger自动生成。 Dagger2的局限性 Dagger2不能自动注入域 Dagger2不能注入private类型 Dagger2 工程结构图假装有图","link":"/public/2019/10/10/Android/%E6%A1%86%E6%9E%B6/Dagger2/"},{"title":"Fasetjson 介绍与使用","text":"JSONString与HashMap之间的转换 HashMap转换为JsonString 12Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();String JSONString=JSON.toJSONString(hashMap); JsonString转换为HashMap12345Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();hashMap= JSON.parseObject(JSONString, Map.class);//错误方式hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString); 注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据 知识点 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败","link":"/public/2019/05/06/Android/%E6%A1%86%E6%9E%B6/fastjson%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Java关键字介绍","text":"Java关键字介绍staticvolatile finalfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”； 在数据中使用final一个数据不可改变有两种原因： 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。 在运行时赋初值后不可改变； 当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。 在方法中使用final final作为方法参数使用时，表示该引用不能被修改； final直接修饰方法时，有两个原因 防止子类修改该方法，避免该方法被重写(overridden) 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑） 在类中使用final禁止该类被继承 transientlong关键字在Java开发过程中，如果需要long类型的变量，需要在变量后加l 12345678long a=1000000000000l;//long b=1000000000000; //会报出Integer number too large//long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large//long b1=100*1000*1000*1000; //b1会输出一个奇怪的值 1215752192//这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围//long b1=(long)(100*1000*1000*1000);; //使用功强制类型转换，b1会输出一个奇怪的值 1215752192long b1=100l*1000l*1000l*1000l; //正确写法//long b1=100*1000*1000l*1000l; //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果","link":"/public/2019/09/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"java 内部类","text":"java 内部类内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。 内部类的作用实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。 内部类可以同时用多个实例，每个实例都有自己的状态信息； 内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类； 内部类分类局部内部类嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。 静态内部类静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式 123456789101112131415161718192021222324 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } ``` #### 匿名内部类匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型```java new Thread(new Runnable() { @Override public void run() { System.out.println(\"hello\"); } }).start(); 内部类与闭包内部类会包含对外部类的引用，形成闭包 12345678910 public class Outer{ private int a=1; public class Inner{ private int b=2; public int multi(){ return a*b; }}","link":"/public/2019/11/28/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%86%85%E9%83%A8%E7%B1%BB/"},{"title":"Java引用","text":"Java引用在java.lang.ref包中有一系列可以辅助GC灵活进行处理的类；抽象类Reference有三个子类SoftReference(软引用),WeakReference(弱引用),和PhantomReference(虚引用)，三个子类的可达性依次减弱。 当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用Reference，如果GC发现一个Object是可达的，那么不会回收该对象。 引用类型 GC回收时间 用途 生存时间 HardReference 从不 对象的一般状态 JVM停止运行时 SoftReference 内存不足时 对象缓存 内存不足时停止 WeakReference GC时 对象缓存 GC后终止 PhantomReference unknown unknown unknown SoftReference和WeakReference可以选择是否将其放入ReferenceQueue，而PhantomReference必须放入ReferenceQueue中。 注：ReferenceQueue用于PhantomReference的清理 Java基本类型与引用类型注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。","link":"/public/2019/11/28/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%BC%95%E7%94%A8/"},{"title":"Java集合","text":"Queue 接口Collection的使用方法接口Collection继承自Iterable接口 用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。 BlockingQueue接口实现类 ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小 DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口 LinkedBlockingQueue 内部以链表的形式实现 PriorityBlockingQueue 无界并发队列 SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素； 方法 add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true，如果队列已满，则返回false poll 移除并返问队列头部的元素，，如果队列为空，则返回null peek 返回队列头部的元素，如果队列为空，则返回null put 添加一个元素，如果队列满，则阻塞 take 移除并返回队列头部的元素，如果队列为空，则阻塞 List接口：实现类 ArrayList LinkedList VectorArrayListArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢； ArrayList在循环中删除元素可能会出现问题：1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏2、使用for-each进行删除，实际是调用它的迭代器来实现， LinkedListLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） VectorVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替； Java Doc里建议用Deque替代Stack接口完成栈的功能 Set接口：实现类 Hashset、TreeSet Hashset：按照哈希算法存取集合中的对象，存取速度快 TreeSet：实现Sorted接口，能够对集合中的对象进行排序 Map接口HashMap遍历Iterable和Iterator(迭代器)","link":"/public/2019/09/27/Java/Java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"},{"title":"Lambda介绍","text":"Lambda介绍Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的； Java Lambda表达式的写法Java中的Lambda表达式通常用(argument)-&gt;(body)的语法表示 12(arg1, arg2...) -&gt; { body }(type1 arg1, type2 arg2...) -&gt; { body } 一个Lambda表达式可以有零个或多个参数； Lambda表达式的主体可以包括零条或多条语句； 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。 函数式接口把只有一个抽象方法的接口叫做函数式接口（functional interface），java.lang.Runnable接口是只有一个run()方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建Runnable接口引用如下： 123Runnable r=()-&gt;Log.i(\"测试\",\"Hello Word\");//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口new Thread(()-&gt;Log.i(\"测试\",\"Hello Word\")).start(); Lambda表达式与匿名类的区别 对于关键字的使用：对于匿名类，关键字this解读为匿名类，而对于Lambda表达式，关键字this解读为Lambda的外部类 Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。 使用Lambda表达式将List中的元素按照长度进行排序123456789101112131415//采用匿名内部类写法List&lt;String&gt; list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");Collections.sort(list, new Comparator&lt;String&gt;(){ @Override public int compare(String s1, String s2){ return s1.length()-s2.length(); }});//采用Lambda写法List&lt;String&gt; list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");Collections.sort(list, (s1, s2) -&gt;{ return s1.length()-s2.length();}); 使用Lambda将List中的每个值平方，并计算和java.util.stream.Stream接口，在Java8引入，必须使用Lambda表达式作为参数，map()将input stream的元素，映射成out stream；reduce()方法用于将stream元素组合起来。 1234567891011121314//常用写法List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);int sum = 0;for(Integer tmp : list) { int x = tmp +tmp; sum = sum + x;}System.out.println(sum);// 使用Lambda写法，List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);int sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();System.out.println(sum); &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD函数式接口把只有一个抽象方法的接口叫做函数式接口（functional interface） Lambda表达式使用注意事项在Lambda表达式中不能有指向其自己的引用，关键字this指向的是闭包，而在匿名内部类中this关键字指向的是匿名函数自己， Lambda表达式的常用方法使用lambda表达式替换匿名类使用lambda表达式替换匿名类，需要用到函数式接口,如Runnable接口；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。 1234567891011//使用匿名内部类表达式方法new Thread(new Runnable(){ @Override public void run() { System.out.println(\"Test Runnable 1\");}).start();//使用匿名内部类的方式new Thread( () -&gt; System.out.println(\"Test Runnable 2\") ).start(); 在使用lambda表达式进行排序时，Comparator&lt;String&gt;中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型 12345678//使用匿名内部类方式对list进行排序Collections.sort(words, new Comparator&lt;String&gt;() {public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); }});//使用lambda表达式方式对list进行排序Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length())); 使用Lambda表达式进行点击事件处理123456789101112//非lambda表达式方法button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.i(\"info\",\"点击\"); }});//使用lambda表达式方式button.setOnClickListener((e)-&gt;{ Log.i(\"info\",\"点击\");}); 但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，setOnClickListener()方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式 12345678910 hello.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates. } }) //或者hello.setOnClickListener{ Log.i(&quot;info&quot;,&quot;点击&quot;); } 在Java中使用lambda表达式和函数式接口Predicate在java.util.function包中，包含多个类用于支持Java的函数式编程，使用java.util.function.Predicate函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为","link":"/public/2019/09/19/Java/Java%E5%9F%BA%E7%A1%80/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"String、StringBuffer、StringBuilder","text":"String、StringBuffer、StringBuilderString类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的String对象； StringBuffer和StringBuilder对象是可以改变的，变化时基于原来的对象基础上机型改变。 StringBuffer VS. String BuilderStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。 ‘+’ VS. StringBuilderbyte[]和String类型相互转化byte[]转换为String,如果是非法值，可能转换不成功 123456789//用于测试String和byte之间的相互转化String testString=&quot;1234566789&quot;;byte[] testByte=testString.getBytes();try { String string=new String(testByte, &quot;UTF-8&quot;); System.out.println(string);} catch (UnsupportedEncodingException e) { e.printStackTrace();}","link":"/public/2019/09/19/Java/Java%E5%9F%BA%E7%A1%80/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB/"},{"title":"加密算法","text":"AES加密 AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥， AES在Java中的使用 JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。 Java中的加解密由Cipher组件提供。 注： Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key) 生成秘钥12345KeyGenerator generator=KeyGenerator.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);//用于指定秘钥长度generator.init(Secret_Key_Size);SecretKey secretKey=generator.generateKey();","link":"/public/2019/11/28/Java/Java%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"title":"Java单例模式","text":"不同单例模式在多线程下的特点 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例； 123456789101112public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。 1234567public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance;} 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 12345678910public static Singleton getSingleton() { if (instance == null) { //Single Checked synchronized (Singleton.class) { if (instance == null) { //Double Checked instance = new Singleton(); } } } return instance ;} 在使用synchronized关键字之后，每次只有一个线程可以进入到该方法中，但是使用synchronized关键字会造成开销过大 于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。 1、给 instance 分配内存2、调用 Singleton 的构造函数来初始化成员变量3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。 1234567891011121314151617public class Singleton { private volatile static Singleton instance; //声明成 volatile private Singleton (){} public static Singleton getSingleton() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } volatile具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序） 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 1234567891011public class Singleton{ //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; }} 单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。 123456789public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。","link":"/public/2019/09/19/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"Java多线程之间的协作","text":"Java多线程协作Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在Object对象中有wait()和notifyAll()方法，在Java SE 5多任务库中添加Condition类，其中有await()和singal()方法。 join当一个在线程m中调用t.join()，m线程会被挂起，直至t执行结束(t.isAlive为false)；如果t线程调用t.interrupt()(在m线程之外)，则线程m中会继续执行任务。","link":"/public/2019/09/19/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C/"},{"title":"Java代理模式","text":"代理模式代理模式介绍代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。 代理模式主要由三部分组成： Subject：一个将方法暴露给client的接口 Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类 Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。 代理模式的结构 静态代理实现方式Subject 123public interface Subject{ public void doSomething();} Real Subject 123456public class RealSubject implements Subject{ @Override public void doSomething() { System.out.println(\"RealSubject 输出\"); }} Proxy 1234567public class ProxyTest extends RealSubject { @Override public void doSomething() { System.out.println(\"proxy输出\"); super.doSomething(); }} 测试类client 1234567891011public class Client { public static void main(String[] args) { RealSubject proxy=new ProxyTest(); proxy.doSomething(); }}//输出//proxy输出//RealSubject 输出 动态代理实现方式Subject 123public interface Subject{ public void doSomething();} Real Subject 123456public class RealSubject implements Subject{ @Override public void doSomething() { System.out.println(\"RealSubject 输出\"); }} Proxy 123456789101112131415161718192021public class ProxyHandler implements InvocationHandler { private Object tar; //绑定委托对象，并返回代理类 public Object bind(Object tar){ this.tar=tar; return Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this); } @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable { Object result=null; //这里可以进行所谓的AOP编程 //在调用具体函数方法项之前，执行功能处理 result=method.invoke(tar,objects); //在调用具体函数方法项之后，执行功能处理 return result; }} Client 12345678910public class Client {public static void main(String[] args) { ProxyHandler proxyHandler=new ProxyHandler(); //绑定该类实现的所有接口 Subject sub=(Subject)proxyHandler.bind(new RealSubject()); sub.doSomething(); }} 动态代理模式详解InvocationHandler接口介绍InvocationHandler 源码 123public interface InvocationHandler { Object invoke(Object var1, Method var2, Object[] var3) throws Throwable;} InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。 invoke(Object var1, Method var2, Object[] var3)方法中有三个参数： Object var1：指代代理的真实对象 Method method：指代真实对象调用的方法 Object[] args：指代真实对象调用方法时的参数 Proxy 类介绍Proxy用来动态创建一个代理对象的类，newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)方法中的参数 ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区 Class&lt;?&gt;[] var1：给代理对象提供的接口类型 InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法 源码 1234567891011121314151617181920212223242526272829public class Proxy implements Serializable { public static Object newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2) throws IllegalArgumentException { Objects.requireNonNull(var2); Class[] var3 = (Class[])var1.clone(); //用于将传入的Class进行复制 SecurityManager var4 = System.getSecurityManager(); if (var4 != null) { checkProxyAccess(Reflection.getCallerClass(), var0, var3); } //调用 getProxyClass0() 方法 Class var5 = getProxyClass0(var0, var3); try { if (var4 != null) { checkNewProxyPermission(Reflection.getCallerClass(), var5); } final Constructor var6 = var5.getConstructor(constructorParams); //通过反射类中的Constructor获取构造函数 if (!Modifier.isPublic(var5.getModifiers())) { AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() { public Void run() { var6.setAccessible(true); return null; } }); } // 通过Constructor返回代理类的实例 return var6.newInstance(var2); } //catch省略 } getProxyClass0()源码，从缓存中获取代理类对象 public class Proxy implements Serializable { //proxyClassCache对象定义 private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory()); //...... private static Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) { if (var1.length &gt; 65535) { throw new IllegalArgumentException(\"interface limit exceeded\"); } else { // proxyClassCache 来做一个中间的缓存 return (Class)proxyClassCache.get(var0, var1); } } //...... } ```java","link":"/public/2019/11/28/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"title":"Java观察者模式","text":"观察者模式、订阅者模式、回调函数对比在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应； 在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心 在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者” 本篇观察者模式主要在Android中实现在Java提供了Observer接口和Observable类方便快速实现观察者模式","link":"/public/2019/09/19/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"Kotlin Lambda表达式","text":"使用Lambda表达式遍历数组1234//valstringArrays.forEach({ it-&gt;println(it) }) Kotlin中Array的forEach()函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；action: (T) -&gt; Unit中(T) -&gt; Unit是lambda表达式的类型，即函数的类型，此函数参数类型为T返回值为Unit 1234public inline fun &lt;T&gt; Array&lt;out T&gt;.forEach(action: (T) -&gt; Unit): Unit { for (element in this) action(element)} lambda表达式作为形参的类型 123()-&gt;Int //无参数，返回Int类型(Int,Int)-&gt;Int //两个整型参数，返回Int(()-&gt;Unit,Int)-&gt;Int //一个lambda表达式参数，一个整型参数，返回Int 在kotlin中，可以把函数的最后一个lambda表达式移到括号外 123stringArrays.forEach(){ it-&gt;println(it)} 如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用 1stringArrays.forEach(::println) 使用标签从Lambda表达式中返回,其中forEachItem为自定义标签，@forEachItem与return之间不能存在空格 123stringArrays.forEach forEachItem@{ if (it==1) return@forEachItem} 在Lambda中最后一个表达式的值是默认的返回值 高阶函数高阶函数是将函数用作参数或返回值的函数","link":"/public/2019/11/28/Kotlin/Kotlin%E5%9F%BA%E7%A1%80/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"Permission to LuciusCS/test.git denied to Lrici.","text":"modified: 2017-07-27作死小能手又一次把自己玩挂了，明明有一个Github的账号，又申请了一个账号，用于测试权限的控制；然后添加到Git中，结果在Push自己原来项目的时候总是报错； remote: Permission to LuciusCS/test.git denied to Lrici.fatal: unable to access ‘https://github.com/LuciusCS/test.git/': The requested URL returned error: 403 没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了； 方法一：修改配置文件，或者只在本仓库中设置用户名 git config –global user.name “name” git config –global user.email “email” 方法二：重新创建生成SSH KEY 方法三：删除Config文件，再重建 方法四：在Git上配置多账号（特喵的，都不知道账号在哪里） 方法五：按照The requested URL returned error: 403 403错误的解决方法 重装大法：卸载Git，然后清除注册表（就差重装系统了） 以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！还是显示上面的错误！！！！ 终极方法：在凭证管理器中删除不需要账号的信息步骤： Control Panel(控制面板)——&gt;User Account and family Safety(用户账号和家庭安全)——&gt;Manage Windows Credential(凭证管理)——&gt;将跟Git有关的账号删除 再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦","link":"/public/2017/07/27/Other/Git/2017-07-27-remote-permission-denied/"},{"title":"常用Git操作","text":"常用Git操作一、将本地已有仓库推送到远程仓库 1、将本地仓库与远程仓库建立关联 1git remote add github git@github.com:Lucius/GitTest.git 查看本地仓库与远程仓库关联情况 1git remote -v 删除与远程仓库关联 1git remote rm origin 2、设置用户名和密码 12git config -global user.name &quot;&quot;git config -global user.email &quot;&quot; 3、设置SSH Key, 生成SSH Key 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -t 指定密钥类型，默认是 rsa ，可以省略。 ** -C 设置注释文字，比如邮箱。 ** -f 指定密钥文件存储文件名。 **在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去 1git branch --set-upstream-to=origin 当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现fatal: refusing to merge unrelated histories错误，需要使用下面命令： 1git pull origin master --allow-unrelated-histories 5、将本地仓库推送至远端 1git push -u origin master 如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误推送正常 二、将本地分支提交到远程 1、建立本地到上游（远端）仓的链接 1git branch --set-upstream-to=origin 2、拉取远程分支内容 1git pull --allow-unrelated-histories 3、将本地分支推送至远程 1git push origin EditBranch 三、合并多次提交1git rebase -i HEAD~3 如果在合并的过程中出现冲突需要先解决冲突，再进行合并 1git rebase --continue 如果放弃本次合并，使用 1git rebase --abort 四、Git多用户进行管理需要为每一个仓库设置user、email 第一步：取消git的global用户以及邮箱 12git config --global --unset user.namegit config --global --unset user.email 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。 12git config user.email &quot;xxxx@xx.com&quot;git config user.name &quot;xxxx&quot; 五、git reset –hard –soft与git revertgit reset --hard HEAD~1修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。 git reset --soft HEAD~1修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。 git revert与git reset区别 git reset指向原地或者向前移动指针,直接删除commit，git revert创建一个逆向commit来覆盖之前commit,指针向后移动。 在后续合并旧版本时，git revert的部分不再出现；而git reset在合并旧版本时，这些被回滚的提交还会再次被引入。 撤销 git resetgit reflog 查看操作历史，找到之前 HEAD 的 hash 值，然后 git reset --hard 到那个 hash 即可 六、git cherry-pick使用方法将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。 1234git cherry-pick &lt;commit id&gt;:单独合并一个提交git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支 七、修改git urls的路径方式将urls由SSH模式修改为Https模式将usrls由Https模式修改为SSH模式八、建立本地分支，并推送至远程九、更新fork的代码在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，","link":"/public/2019/09/19/Other/Git/Git/"},{"title":"Other/Git/Git出现问题","text":"fatal: unable to access ‘https://github.com/LuciusCS/AndroidProject.git/': Empty reply from server","link":"/public/2019/09/21/Other/Git/Git%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/"},{"title":"Android中使用JNI","text":"Android 在已有的项目中引入JNI 最简方式JNI与NDKJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发； 下载NDK和编译工具 NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。 CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。 LLDB：Android Studio 用于调试原生代码的调试程序。 安装方式： Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载 在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置 添加CMakeLists.txt和native-lib-cpp文件现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码 123456789101112131415161718192021222324252627 # 设置cmake的最低版本 cmake_minimum_required(VERSION 3.4.1) # 设置生成的so库的信息 add_library( #生成的so库的名字 native-lib # 生成的so库的类型，类型分为两种： # STATIC：静态库，为目标文件的归档文件 # SHARED：动态库，会被动态链接，在运行时被加载 SHARED # 设置源文件的位置，可以是很多个源文件，都需要添加进去 native-lib.cpp) # 从系统里查找依赖库，可添加多个 find_library( log-lib # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest log) # 配置目标库的链接，即相互依赖关系target_link_libraries( # 目标库（最终生成的库） native-lib # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用 # 如果是第三方库，可以直接引用 # 每行引用一个库 ${log-lib}) 在Andorid的Module下，右键选择 Link C++ Project with Gradle，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码 1234567android { … externalNativeBuild { cmake { path file('src/main/cpp/CMakeLists.txt') }} 在native-lib.cpp添加如下代码，方法名命名规则Java_demo_lucius_baselib_MainActivity_stringFromJNI，以Java作为开头,demo_lucius_baselib_MainActivity是“包名+调用类名”，stringFromJNI方法名。即Java_{package_and_classname}_{function_name}(JNI_arguments)，包名的.被下划线替代。 123456789#include &lt;jni.h&gt;#include &lt;string&gt;extern \"C\" JNIEXPORT jstring JNICALLJava_demo_lucius_baselib_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string text = \"String from C++\"; return env-&gt;NewStringUTF(hello.c_str());} 在上述函数JNI_arguments有JNIEnv*和jobject JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。 jobject，指向Java对象的object。 extern &quot;C&quot;只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。 在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++” 123456789101112131415public class MainActivity extends AppCompatActivity { static { //用于在运行时加载本地库 System.loadLibrary(\"native-lib\"); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); System.out.println(stringFromJNI()); } public native String stringFromJNI(); 在JNI中使用C语言，新建helloJIN.c文件12345678#include &lt;jni.h&gt; // JNI header provided by JDK#include &lt;stdio.h&gt; // C Standard IO Header// Implementation of the native method sayHello()JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) { printf(\"Hello World!\\n\"); return;} JNI基础类型介绍在jni.h文件中定义了预编译类型，区分Java、C++以及C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* \"cardinal indices and sizes\" */typedef jint jsize;#ifdef __cplusplus/* * Reference types, in C++ */class _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {};typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak;#else /* not __cplusplus *//* * Reference types, in C. */typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak;#endif /* not __cplusplus */ Java基本数据类型与Native层中的数据对应关系这些基本数据类型可以在Native层直接使用。 Java引用数据类型与Native层中的数据对应关系Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为jobjectArray类型进行使用。 在JNI中二维数组的使用 1234//获取一维数组的引用，即jintArray类型jclass intArrayClass=env-&gt;FindClass(\"[I\"); //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsizejobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null); jfieldID 和jmethodID当Native层需要调用Java的某个方法时，需用jmethodID表示，变量则用jfieldID表示。jni.h中对jfieldID和jmethodID的定义 12345struct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */ 在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。 1234567//获取jfieldID jfieldID GetFieldID(jclass clazz, const char* name, const char* sig){ return functions-&gt;GetFieldID(this, clazz, name, sig); }//获取jmethodID jmethodID GetMethodID(jclass clazz, const char* name, const char* sig){ return functions-&gt;GetMethodID(this, clazz, name, sig); } 以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用 JavaVM介绍JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。jni.h的定义中，在C++模式下，JavaVM是一个结构体；在C语言模式下JavaVM是是一个指向方法接口指针的指针。 JNIEnv介绍JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。jni.h的定义中，在C++模式下，JNIEnv是一个结构体；在C语言模式下JNIEnv是是一个指向方法接口指针的指针。 作用： 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码; 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象; 12345678#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif JNIEnv和JavaVM调用方法 对于C语言 12(*env)-&gt;方法名(env,参数列表)(*vm)-&gt;方法名(vm,参数列表) 对于C++ 12env-&gt;方法名(参数列表)vm-&gt;方法名(参数列表) 在","link":"/public/2019/09/21/Android/Android%20JNI/Android%20Studio%20JNI%E5%BC%95%E5%85%A5/"},{"title":"gradle介绍","text":"gradle介绍gradle和make以及ant不同，它基于Groovy语言，而非一种配置； Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache， 在Moudle的build.gradle中添加依赖包123456789101112android { ... }dependencies { // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary` implementation project(\":mylibrary\") // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 implementation fileTree(dir: 'libs', include: ['*.jar']) // 依赖于远程库 implementation 'com.example.android:app-magic:12.3'} 依赖包的配置有以下类型：implementation、api、compileOnly、runtimeOnly、annotationProcessor、lintChecks、lintPublish在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。 123dependencies { freeImplementation 'com.google.firebase:firebase-ads:9.8.0'} 如果需要将依赖作为变量，与flavor和build type进行结合，要在configurations代码块中进行初始化。 12345678configurations { //初始化只与freeDebugRuntimeOnly相关的依赖 freeDebugRuntimeOnly {}}dependencies { freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])} 在Debug模式下使用正式签名在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer. 123456789101112131415161718192021222324252627282930313233android{ ... signingConfigs { release { //.jks文件放在项目目录（app目录） storeFile file(\"app.jks\")//签名文件名 storePassword \"password\"//密码 keyAlias\"key0\"//别名 keyPassword\"password\"//密码 } debug { storeFile file(\"app.jks\") storePassword\"password\" keyAlias\"key0\"//别名 keyPassword\"password\" } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release } debug { signingConfig signingConfigs.release } } ....} 加速项目的构建速度优化项目配置有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个devflavor和prodflavor(发布版本)。 1234567891011121314151617181920android { ... defaultConfig {...} buildTypes {...} productFlavors { //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块； dev { minSdkVersion 21 versionNameSuffix \"-dev\" applicationIdSuffix '.dev' } prod { // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。 } }} 可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出devDemo和prodFull 12345678910111213141516171819202122232425262728293031323334353637android { ... defaultConfig {...} buildTypes {...} // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度 flavorDimensions \"stage\", \"mode\" productFlavors { dev { dimension \"stage\" minSdkVersion 21 versionNameSuffix \"-dev\" applicationIdSuffix '.dev' //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片 resConfigs \"en\", \"xxhdpi\" ... } prod { dimension \"stage\" ... } demo { dimension \"mode\" ... } full { dimension \"mode\" ... } }} 编译类型配置12345678910 android { ... buildTypes { debug { //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度` ext.enableCrashlytics = false //防止Crashlytics 每次更新编译的id ext.alwaysUpdateBuildId = false }} 在Debug版本构建的过程中使用静态常量在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。 1234567891011121314151617181920212223int MILLIS_IN_MINUTE = 1000 * 60int minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTEandroid { ... defaultConfig { //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk versionCode 1 versionName \"1.0\" ... } //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。 //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理 applicationVariants.all { variant -&gt; if (variant.buildType.name == \"release\") { variant.mergedFlavor.versionCode = minutesSinceEpoch; variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName; } }} 使用增量注解处理（incremental annotation processors）Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。 1android.enableSeparateAnnotationProcessing = true 其他方式 使用确定的依赖，避免使用+，如：’com.android.tools.build:gradle:2.+’ 使用离线模式进行编译 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。 创建自定义编译任务 将图片转换为WebP WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。 禁用PNG压缩 1234567891011121314 android { buildTypes { release { //禁用PNG压缩 crunchPngs false } } // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩 // aaptOptions { // cruncherEnabled false // }} 使用编译缓存在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，clean build会变得更快，因为其会调用缓存中的文件，而非重新生成。在gradle.gradle.properties 中指定编译缓存的路径，默认路径为&lt;user-home&gt;/.android/build-cache/ 123// 执行绝对路径或者相对路径android.buildCacheDir=&lt;path-to-directory&gt;android.enableBuildCache=true 打包编译多个版本的apk，待续","link":"/public/2019/08/10/Android/Other/Module%E7%9A%84.gradle%E9%85%8D%E7%BD%AE/"},{"title":"Java泛型","text":"Generics(泛型)一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。 Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。 如果没有泛型，参数的类型会被忽略， 装箱和拆箱在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。 将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，会返回之前缓存的对象， 1234567int a=100;int b=100;int c=200;int d=200;System.out.println(a==b);System.out.println(c==d); 输出结果为 12true;false; Java通过泛型可以自动进行装箱与拆箱。 12Integer i=new Integer(xx); 会触发自动装箱 1Integer i=xx; 不会触发自动装箱 注意：操作符== 在基础类型中以及引用类型中采用不同的定义方式，在int类型中，==用于通过值的大小定义的，而在Integer中是通过对象定义的。在比较两个类对象时应使用euqal 遍历循环for循环可以被用于实现Iterable接口的任何类中， 12345List&lt;Integer&gt;ints=Arrays.asList(1,2,3);int s=0;for(int n:ints){ s+=n;} 等价于 1234for(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();){ int n=it.next(); s+=n;} Iterable接口所有的Collection都实现了Iterable接口 泛型方法和可变参数(Generic Methods and Varargs)将任意类型的array转换成List 1234567class List{ public static&lt;T&gt; List&lt;T&gt; toList(T[] arr){ List&lt;T&gt;list=new ArrayList&lt;T&gt;(); for(T elt:arr)list.add(elt); return list; }} 将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将T[]使用T...来替代。 12345678class Lists{ public static&lt;T&gt;List&lt;T&gt;toList(T...arr){ List&lt;T&gt;list=new ArrayList&lt;T&gt;(); for(T elt:arr)list.add(elt); return list; }} 调用方式 12List&lt;Integer&gt; ints = Lists.toList(1, 2, 3); List&lt;String&gt; words = Lists.toList(\"hello\", \"world\"); 子类型和通配符(SubTyping and Wildcards)子类型和替换原则 子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。 123List&lt;Number&gt;nums=new ArrayList&lt;Number&gt;();nums.add(2);nums.add(3.14); 根据替换规则可以在Number的List中添加Integer和Double类型的对象。 12345List&lt;Integer&gt;ints=new ArrayList&lt;Integer&gt;();ints.add(2);ints.add(3);List&lt;Number&gt;nums=ints; //在编译时报错nums.add(3.14); 报错的原因是List不是List的子类型，反过来写也不要可以。但可以使用List&lt;? extends Number&gt;nums=ints，因为List是List&lt;? extends Number&gt;的子类型。 带有extends的通配符以Collection接口中的addAll方法为例 1234567interface Collection&lt;E&gt;{ ... public boolean addAll(Collection&lt;? extends E&gt;c); ...} ? extends E表示可以使用E的子类型作为参数添加到Collection中 123456List&lt;Number&gt;nums=new ArrayList&lt;Number&gt;();List&lt;Integer&gt;ints=Array.asList(1,2);List&lt;Double&gt;dbls=Array.asList(2.23,3.55);nums.addAll(ints);nums.addAll(dbls); 在此情况下是被允许的，因为List是Collection的一个子类型，同时ints的数据类型List是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。 带有super的通配符将一个List拷贝到另外一个List 1234567public static &lt;T&gt;void copy(List&lt;? super T&gt;dst,List&lt;? extend T&gt;src){ for(int i=0;i&lt;src.size();i++){ dst.set(i,src.get(i)); }} ? super T的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;典型例子 123456List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(2,3,\"four\");List&lt;Integer&gt;ints=Array.asList(5,6);Collection.copy(objs,ints);Collection.&lt;Object&gt;copy(objs,ints);Collection.&lt;Number&gt;copy(objs,ints);Collection.&lt;Integer&gt;copy(objs,ints); 通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。 Get和Put原则？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance） 不变（invariant）的 数组在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。 1234Integer[] ints=new Integer[]{1,2,3};Number[] nums=ints;num[2]=3.14; //运行时错误 Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。 与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List不会被认为是List的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List会被认为是List&lt;? extends T&gt;的子类型。 1234List&lt;Integer&gt;ints=Array.asList(1,2,3);List&lt;Number nums&gt;=ints; //在编译时会报错List&lt;? extends Number&gt;nums1=ints; //编译通过nums1.set(2,3.14) //编译错误 第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。 在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。 Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters） 使用通配符判断Collection中是否有指定的对象 12345678910111213141516interface Collection&lt;E&gt;{ ... public boolean contains(Object o); public boolean containsAll(Collection&lt;?&gt;c); ...}...Object obj=\"one\";List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(\"one\",2,3.14,4);List&lt;Integer&gt;ints=Arrays.asList(2,4);objs.contains(obj);objs.containsAll(ints);ints.contains(obj);ints.containsAll(objs);... 在containsAll(Collection&lt;?&gt;c)方法中 Collection&lt;?&gt;c是Collection&lt;?&gt;c的缩写(abbreviation)，继承Object是通配符常用的方式。 类型参数可以通过类型参数来替换通配符的编码方式 1234567interface Collection&lt;E&gt;{ ... public boolean contains(E o); public boolean containsAll(Collection&lt;? extend E&gt;c); ...} 但实际在编译的过程中使用 123456789...Object obj=\"one\";List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(\"one\",2,3.14,4);List&lt;Integer&gt;ints=Arrays.asList(2,4);objs.contains(obj);objs.containsAll(ints);ints.contains(obj); //编译时报错ints.containsAll(objs); //编译时报错... 两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。","link":"/public/2019/09/19/Java/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/"},{"title":"Java多线程基础","text":"Runnable接口仅调用Runnable的run()方法不能产生一个新的线程，新线程的执行必须通过Thread.start()方法来执行。 通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。 实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。 Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。 Thread类Thread类的构造函数需要Runnable实例，调用Thread类的start()方法，可以对线程进行必要额初始化，然后执行Runnable实例的run()方法。 静态方法Thread.yield()用于通知CPU从一个线程切换至另外一个线程； 注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。 多线程框架Executor的使用Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。 ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。 Executors中的shutdown()方法用于停止向Executor中提交新的任务，在shutdown()方法调用之前提交的同步线程任务则会继续执行。 注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理 Executor、Executors、ExecutorService区别 Executor是一个接口，用于并发提交的任务，只有execute()一个方法，没有返回值，不能对任务进行任何操作。 123public interface Executor { void execute(Runnable var1);} Executors类提供不同的工厂方法来创建不同类型的线程池，包括：newSingleThreadExecutor()、newFixedThreadPool(int numOfThreads)、newCachedThreadPool() 123456789public class Executors { //... public static ExecutorService newFixedThreadPool(int var0) { return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } //...} ExecutorService 是继承自Exxecutor的接口，其中有异步执行和关闭线程池的方法。可以通过submit()方法来提交任务，同时可以对任务进行取消等操作。 123456789101112public interface ExecutorService extends Executor { //... void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); //... } 不同线程池的使用CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。 1ExecutorService exec = Executors.newCachedThreadPool(); FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。 1ExecutorService exec = Executors.newFixedThreadPool(5); SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。 1Executors.newSingleThreadExecutor(); 任务的回调使用Callable和Future,一个产生结果，一个拿到结果 每一个Runnable都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用Callable接口，而非Runnable接口。 Callable接口带有type类型参数，该参数表示call()方法（非run()）方法执行完成后的返回值，必须通过调用ExecutorService submit()调用来执行。 submit()方法返回一个一个Future对象，可以通过调用Future的isDone()方法来判断当前任务是否执行结束。调用Future的get()方法，如果当前任务没有结束，则会被阻塞，直至任务结束 1234567891011121314151617181920212223242526272829class CallableResult implements Callable&lt;String&gt; { private int id; public TaskWithResult(int id) { this.id = id; } public String call() { return \"result\" + id; } } public class CallableDemo { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;Future&lt;String&gt;&gt;(); for(int i = 0; i &lt; 10; i++) results.add(exec.submit(new CallableResult(i))); for(Future&lt;String&gt; fs : results) try { System.out.println(fs.get()); } catch(InterruptedException e) { System.out.println(e); return; } catch(ExecutionException e) { System.out.println(e); } finally{ exec.shutdown(); } } } 任务的暂停通过调用TimeUnit.MILLISECONDS.sleep(100);来阻塞当前线程指定的时间。 线程优先级 JDK有十中不同的优先级。 线程优先级Thread.MIN_PRIORIT、Thread.MAX_PRIORITY，通过setPriority()方法进行设置，以及getPriority()方法进行获取。 1public void run() {Thread.currentThread().setPriority(priority); 守护线程Daemon threads守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在thread.start();之前调用daemon.setDaemon(true); 如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用isDaemon()方法进行查看是否为守护线程。 数据共享synchronized关键字使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。 12synchronized void f() { /* ... */ } 当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。 在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。 Lock对象的使用在调用lock()方法后，一定需要添加在try-finally的代码块，并在finally中调用unlock()方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在try代码块中实现，这样可以保证锁释放之前返回需要的值。如果lock.lock()方法调用失败会出现什么情况 1234567891011private Lock lock = new ReentrantLock();int num=0;public int f(){ lock.lock(); try { Thread.yield(); return num++; }finally { lock.unlock(); } 当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。 12345678910111213boolean captured = false; try { captured = lock.tryLock(2, TimeUnit.SECONDS); //限制请求次数 //captured = lock.tryLock(); //不限制请求次数 } catch(InterruptedException e) { throw new RuntimeException(e); } try { System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured); } finally { if(captured) lock.unlock(); } 原子性和波动性（Atomicity and Volality（易变的））原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是synchronized而非volatile。 原子操作被应用于除long和double的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（long和double类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在long和double数据类型使用volatile关键字可以保证其操作的原子性。 在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。 当一个变量volatile关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。volatile关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。volatile关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。 atomicity和volatility是两个不同的概念，原子性操作如果是非volatile类型的，那么其不会被立即刷到内存中；如果一个变量在一个synchronized的方法或者代码块中，那么变量也会被刷到内存中。 Atomic classes （原子类）在Java SE 5中介绍了特殊的原子类：Atomiclnteger, AtomicLong, AtomicReference；对其操作时提供了原子类型的状态。 临界区在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。 使用synchronized创建临界区 12345678910111213141516 synchronized(syncObject) { // This code can be accessed }class PairManager2 extends PairManager { public void increment() { Pair temp; synchronized(this) { p.incrementX(); p.incrementY(); emp = getPair(); } store(temp); }} 使用功Lock锁创建临界区 123456789101112131415class ExplicitPairManager2 extends PairManager { private Lock lock = new ReentrantLock(); public void increment() { Pair temp; lock.lock(); try { p.incrementX(); p.incrementY(); temp = getPair(); } finally { lock.unlock(); } store(temp); } }","link":"/public/2019/09/19/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"title":"Java线程间通信","text":"线程间通信 使用单向管道（Pipe）传递数据 共享内存（Shared Memory）通信 使用阻塞队列（Blocking Queue）实现生产者-消费者模式 处理消息队列（Message Queue） wait/notify机制等待/通知机制主要由Object类中的三个方法进行保证 1、wait()；notify();notifyAll()上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；wait();notify();notifyAll()只有在被synchronized修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出IllegalMonitorStateException异常。 1)wait()让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用notify()或者notifyAll()时唤醒当前线程。wait()也可以作为任务同步的一种方式。 注：调用sleep()和yield()方法不能释放当前的对象锁wait()方法有两种用法： wait(long timeout)等待一定的时间，但与sleep()方法不同，其会释放对象锁 使用wait()等待notify()或者notifyAll()唤醒。 2)notify()唤醒一个正在等待相应对象锁的线程，使其进入就绪队列； 3)notifyAll()唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过synchronized(x)来获取对象锁。 123synchronized(x) { x.notifyAll();} 2、方法调用与线程状态关系 每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列 ConditionCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用； 对应关系 Condition中的await()对应Object的wait() Condition中的signal()对应Object的notify() Condition中的signalAll()对应Object中的notifyAll(); Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同 生产者消费者模型线程锁控制代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Service { //线程锁 private ReentrantLock lock=new ReentrantLock(); //生产者线程控制 private Condition conditionCustomer=lock.newCondition(); //消费者线程控制 private Condition conditionProducer=lock.newCondition(); //用于表示需要生产 private boolean hasValue=false; //用于随机消费时间； private static Random rand = new Random(2000); //用于生产者 public void produce(){ try { lock.lock(); while (hasValue){ System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\"); conditionCustomer.await(); } System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\"); Thread.sleep(rand.nextInt(500)); hasValue=true; System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\"); System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\"); System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"); //唤起所有的消费者线程 conditionProducer.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } //用于消费者 public void custome(){ try{ lock.lock(); while (!hasValue){ System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\"); conditionProducer.await(); } System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\"); Thread.sleep(rand.nextInt(4000)); hasValue=false; System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\"); System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \"); System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"); //唤起所有的生产者线程 conditionCustomer.signalAll(); } catch (InterruptedException e) { e.printStackTrace(); }finally { lock.unlock(); } }} 消费者线程 12345678910111213public class CustomerThread extends Thread { private Service service; public CustomerThread(Service service) { this.service = service; } @Override public void run() { while (true){ service.custome(); } }} 测试代码 123456789101112131415161718public class Customer_ServiceMain { public static void main(String[] args) throws InterruptedException { Service service=new Service(); CustomerThread[] customerThread=new CustomerThread[10]; ProducerThread[] producerThreads=new ProducerThread[10]; for (int i=0;i&lt;3;i++){ customerThread[i]=new CustomerThread(service); customerThread[i].setName(\"生产者Thread：\"+i); producerThreads[i]=new ProducerThread(service); producerThreads[i].setName(\"消费者Thread：\"+i); customerThread[i].start(); producerThreads[i].start(); } } } 运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。 123456789101112131415161718192021222324252627+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.消费线程：生产者Thread：1await消费线程：生产者Thread：0await线程：消费者Thread：2生产中线程：消费者Thread：2生产完毕消费者Thread：2唤醒所有消费者线程 ....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.生产线程：消费者Thread：2await生产线程：消费者Thread：1await生产线程：消费者Thread：0await线程：生产者Thread：2消费中线程：生产者Thread：2消费完毕生产者Thread：2唤醒所有生产者线程 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.生产线程：消费者Thread：1await生产线程：消费者Thread：0await线程：生产者Thread：2消费中线程：生产者Thread：2消费完毕生产者Thread：2唤醒所有生产者线程 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.消费线程：生产者Thread：2await消费线程：生产者Thread：1await消费线程：生产者Thread：0await线程：消费者Thread：2生产中线程：消费者Thread：2生产完毕消费者Thread：2唤醒所有消费者线程 ....+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 线程间通信管道模式CountDownLatch的使用用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。 任务执行线程 123456789101112131415161718192021222324252627282930 public class Task extends Thread { private static Random random = new Random(100); private final CountDownLatch latch; //使用CountDownLatch会被自动要求加上此构造函数 public Task(CountDownLatch latch, String name) { this.latch = latch; this.setName(name); } @Override public void run() { try { doWork(); //用于倒数技术 latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } public void doWork() throws InterruptedException { //random.nextInt(2000)在Java中是线程安全的来自TIJ TimeUnit.MILLISECONDS.sleep(random.nextInt(1000)); System.out.println(this.getName() + \"completed\"); }} 等待任务执行完毕，需要唤醒的线程 123456789101112131415161718 public class WaitingTask implements Runnable { private final CountDownLatch latch; public WaitingTask(CountDownLatch latch) { this.latch = latch; } @Override public void run() { try { latch.await(); System.out.println(\"Latch阻塞运行至waiting class\"); } catch (InterruptedException e) { e.printStackTrace(); } }} 测试代码 12345678910111213141516171819public class TestCountDown { static final int SIZE = 10; public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newFixedThreadPool(5); //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数 CountDownLatch latch = new CountDownLatch(SIZE); // for (int i=0;i&lt;10;i++){ //可以有多个等待线程 exec.execute(new WaitingTask(latch)); // } for (int i = 0; i &lt; SIZE; i++) { exec.execute(new Task(latch,\"线程\"+i)); } System.out.println(\"启动所有任务\"); exec.shutdown(); //任务只有在执行完毕后才会结束 }} 任务执行结果 123456789启动所有任务线程0completed线程4completed线程1completed线程2completed线程3completedLatch阻塞运行至waiting classProcess finished with exit code 0 CyclicBarrier的使用CyclicBarrier类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于join)，与CountDownLatch类的使用类似，CountDownLatch类只能执行一次，而CyclicBarrier可以进行多次使用。以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮； 运动员代码 123456789101112131415161718192021222324252627282930313233343536public class Athlete extends Thread { //用于表示耗时 private double time =90; private static Random rand = new Random(1); private static CyclicBarrier cyclicBarrier; public Athlete(CyclicBarrier cyclicBarrier){ this.cyclicBarrier=cyclicBarrier; } public synchronized double getTime(){ return time; } @Override public void run() { try { while (!Thread.interrupted()){ synchronized (this){ time =(double)(rand.nextInt(20)+90)/10; System.out.println(getName()+\"跑步耗时：\"+ getTime()); } Thread.sleep(1000); cyclicBarrier.await(); } } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }} 所有运动员跑完标志输出代码 123456789101112public class RunningCtrl extends Thread{ public RunningCtrl(){ } @Override public void run() { super.run(); System.out.println(\"++++++++++++++++++++++++++++++++\"); }} 测试代码 1234567891011121314public class CyclicBarrierMain { public static void main(String[] args) { RunningCtrl runningCtrl=new RunningCtrl(); CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl); ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt;5; i++) { Athlete athlete = new Athlete(cyclicBarrier); athlete.setName(\"选手：\"+i); exec.execute(athlete); } }} 运行结果 12345678910111213141516171819202122232425262728293031323334353637选手：0跑步耗时：9.5选手：1跑步耗时：9.8选手：4跑步耗时：10.4选手：2跑步耗时：9.7选手：3跑步耗时：10.3++++++++++++++++++++++++++++++++选手：0跑步耗时：10.4选手：2跑步耗时：9.8选手：1跑步耗时：9.6选手：4跑步耗时：9.4选手：3跑步耗时：10.8++++++++++++++++++++++++++++++++选手：4跑步耗时：9.9选手：1跑步耗时：10.7选手：3跑步耗时：9.2选手：2跑步耗时：9.3选手：0跑步耗时：10.3++++++++++++++++++++++++++++++++选手：1跑步耗时：10.4选手：2跑步耗时：9.2选手：0跑步耗时：9.9选手：3跑步耗时：10.2选手：4跑步耗时：10.6++++++++++++++++++++++++++++++++选手：4跑步耗时：10.2选手：2跑步耗时：10.9选手：0跑步耗时：10.6选手：3跑步耗时：10.0选手：1跑步耗时：10.4++++++++++++++++++++++++++++++++选手：2跑步耗时：10.8选手：4跑步耗时：10.9选手：1跑步耗时：10.7选手：3跑步耗时：10.3选手：0跑步耗时：9.2++++++++++++++++++++++++++++++++ DelayQueue的使用DelayQueue是一个无界的阻塞队列，实现Delayed接口。只有当delay被激发时，该对象才能从队列中获取数据 线程间通信管道模式","link":"/public/2019/09/19/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"title":"Retrofit 框架介绍与使用","text":"Retrofit 框架使用请求内容与返回值使用PostMan进行请求测试请求：https://api.github.com/search/repositories?q=android 返回值： Header: Body: 1234567891011121314151617181920212223242526272829303132333435363738{ \"total_count\": 943593, \"incomplete_results\": false, \"items\": [ { \"id\": 82128465, \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\", \"name\": \"Android\", \"full_name\": \"open-android/Android\", \"private\": false, \"owner\": { \"login\": \"open-android\", \"id\": 23095877, \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\", \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\", //…… }, \"html_url\": \"https://github.com/open-android/Android\", \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\", \"fork\": false, \"url\": \"https://api.github.com/repos/open-android/Android\", //…… }, { \"id\": 12544093, \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\", \"name\": \"Android\", \"full_name\": \"hmkcode/Android\", \"private\": false, \"owner\": { \"login\": \"hmkcode\", \"id\": 3790597, //…… }, //…… } ]} 引入Retrofit依赖12implementation 'com.squareup.retrofit2:retrofit:2.5.0'implementation 'com.squareup.retrofit2:converter-gson:2.5.0' 根据返回的请求结果定义Repository Bean类返回的报文采用google.gson进行处理，金处理必要的值 123456789101112131415public class RepoBean { //用于表示Repo id private int id; //用于表示RepoName private String name; //用于表示完整名称 //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注 @SerializedName(\"full_name\") private String fullName; //省略getter和setter //……} 根据返回的请求结果定义一次查询结果12345678910111213public class SearchRepoBean { //用于表示仓库数量 @SerializedName(\"total_count\") private int totalCount; //用于表示是否为完整结果 private boolean incompleteResults; //用于表示持有的所有的仓库类 private List&lt;RepoBean&gt;items; //省略getter和setter //……} 定义网络请求API接口1234567public interface GithubService { //@Get注解，表示以Get方法发送网络请求 //返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义 @GET(\"search/repositories\") Call&lt;SearchRepoBean&gt; getRepoInfo(@Query(\"q\") String query);} 初始化Retrofit实例，生成接口实现类1234567Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") //设置网络请求的URL地址 .addConverterFactory(GsonConverterFactory.create()) //设置数据解析器 .build();githubService = retrofit.create(GithubService.class); 进行网络请求123456789101112131415161718192021Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(\"Android\"); //同步请求方式 //call.request(); //异步请求方式 call.enqueue(new Callback&lt;SearchRepoBean&gt;() { @Override public void onResponse(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response) { //输出请求结果 // LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size()); // List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;(); // repoBeans.addAll(response.body().getItems()); // for (int i=repoBeans.size()-1;i&gt;=0;i--){ // LogUtils.printInfo(repoBeans.get(i).getFullName()); // } } @Override public void onFailure(Call&lt;SearchRepoBean&gt; call, Throwable t) { } }); 将请求值的返回设为LiveData将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现 1234public interface GithubService { @GET(\"search/repositories\") LiveData&lt;SearchRepoBean&gt; getRepoInfo(@Query(\"q\") String query);} 自定义LiveDataCallAdapterFactory 12345678910111213141516public class LiveDataCallAdapterFactory extends CallAdapter.Factory { @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { //用于获取泛型的参数 Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType); Class&lt;?&gt; rawObserverType = getRawType(observerType); LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = new LiveDataCallAdapter&lt;&gt;(rawObserverType); return liveDataCallAdapter; }} 自定义 LiveDataCallAdapter 12345678910111213141516171819202122232425262728293031323334353637383940public class LiveDataCallAdapter&lt;R&gt; implements CallAdapter&lt;R, LiveData&lt;SearchRepoBean&gt;&gt; { private Type responseType; public LiveDataCallAdapter(Type responseType){ this.responseType=responseType; } @Override public Type responseType() { return responseType; } @Override public LiveData&lt;SearchRepoBean&gt; adapt(final Call&lt;R&gt; call) { LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=new LiveData&lt;SearchRepoBean&gt;() { @Override protected void onActive() { super.onActive(); call.enqueue(new Callback&lt;R&gt;() { @Override public void onResponse(Call&lt;R&gt; call, Response&lt;R&gt; response) { postValue((SearchRepoBean) response.body()); } @Override public void onFailure(Call&lt;R&gt; call, Throwable t) { LogUtils.printInfo(\"error\"); } }); } }; //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值 return searchRepoBeanLiveData;}} 为Retrofit实例添加CallAdapterFactory 12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(new LiveDataCallAdapterFactory()) .build(); 调用方法 12345678repoBeanLiveData = githubService.getRepoInfo(\"Android\");repoBeanLiveData.observe(GithubApiActivity.this, new Observer&lt;SearchRepoBean&gt;() { @Override public void onChanged(SearchRepoBean searchRepoBean) { //输出结果 } }); 添加通用的响应实体通过LiveDataCallAdapter 和LiveDataCallAdapterFactory 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为SearchRepoBean类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。 定义一个通用的响应实体 123456789101112131415161718192021222324 public class ApiResponse&lt;T&gt; { public ApiResponseSuccess&lt;T&gt; create(Response&lt;T&gt; response) { if (response.isSuccessful()) { return new ApiResponseSuccess&lt;T&gt;(response.body()); } else { return null; } } //用于表示返回成功的值 public static class ApiResponseSuccess&lt;T&gt; extends ApiResponse&lt;T&gt; { /用于表示请求返回成功的内容，在本代码中是SearchRepoBean private T body; public ApiResponseSuccess(T body) { this.body = body; } public T getBody() { return body; } }} 修改LiveDataCallAdapterFactory 123456789101112131415public class LiveDataCallAdapterFactory extends CallAdapter.Factory { @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { //用于获取泛型的参数 //return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; //observerType为ApiResponse&lt;SearchRepoBean&gt; Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType); //bodyType为SearchRepoBean Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType); LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = new LiveDataCallAdapter&lt;&gt;(bodyType); return liveDataCallAdapter; }} 修改LiveDataCallAdapter 1234567891011121314151617181920212223242526272829303132333435 public class LiveDataCallAdapter&lt;R&gt; implements CallAdapter&lt;R,LiveData&lt;ApiResponse&lt;R&gt;&gt;&gt; { private Type responseType; public LiveDataCallAdapter(Type responseType){ this.responseType=responseType; } @Override public Type responseType() { return responseType; } @Override public LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(final Call&lt;R&gt; call) { LiveData&lt;ApiResponse&lt;R&gt;&gt; result=new LiveData&lt;ApiResponse&lt;R&gt;&gt;() { @Override protected void onActive() { super.onActive(); call.enqueue(new Callback&lt;R&gt;() { @Override public void onResponse(Call&lt;R&gt; call, Response&lt;R&gt; response) { postValue(new ApiResponse&lt;R&gt;().create(response)); } @Override public void onFailure(Call&lt;R&gt; call, Throwable t) { // LogUtils.printInfo(\"+++++!2312qwqweww31\"); } }); } }; return result; }} 修改调用方法 12345678repoBeanLiveData = githubService.getRepoInfo(\"Android\");repoBeanLiveData.observe(GithubApiActivity.this, new Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() { @Override public void onChanged(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse) { SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody(); //输出结果 }}); 源码详解Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型 1234567891011121314151617181920public final class Retrofit { public static final class Builder { public Builder baseUrl(String baseUrl) { checkNotNull(baseUrl, \"baseUrl == null\"); return baseUrl(HttpUrl.get(baseUrl)); } public Builder baseUrl(HttpUrl baseUrl) { checkNotNull(baseUrl, \"baseUrl == null\"); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) { throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl); } this.baseUrl = baseUrl; return this; } } } Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory 1234public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(checkNotNull(factory, \"factory == null\")); return this;} Converter接口源码，核心是T convert(F value),将F类型的数据转换为T类型 123456789101112131415161718192021222324252627282930313233public interface Converter&lt;F, T&gt; { //将F类型的数据转换为T类型 @Nullable T convert(F value) throws IOException; //根据数据类型创建Converter创建 Converter abstract class Factory { //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。 public @Nullable Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { return null; } //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody public @Nullable Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { return null; } //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String public @Nullable Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) { return null; } protected static Type getParameterUpperBound(int index, ParameterizedType type) { return Utils.getParameterUpperBound(index, type); } protected static Class&lt;?&gt; getRawType(Type type) { return Utils.getRawType(type); } }} Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用 12345678910public final class Retrofit { final List&lt;CallAdapter.Factory&gt; callAdapterFactories; //………… public Builder addCallAdapterFactory(CallAdapter.Factory factory) { callAdapterFactories.add(checkNotNull(factory, \"factory == null\")); return this; } //…………} 最终用来创建Service的代码retrofit.create(GithubService.class)create()采用代理的方式进行创建， 123456789101112131415161718192021222324252627282930public final class Retrofit { //…… public &lt;T&gt; T create(final Class&lt;T&gt; service) { //判断定义的接口服务是否可用 Utils.validateServiceInterface(service); if (validateEagerly) { eagerlyValidateMethods(service); } return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // 如果是Object本身的方法，正常调用后返回 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } //如果是platform默认的方法，正常调用后返回 if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } //解析我们定义的网络请求的方法 return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } }); } //……} loadServiceMethod(Method method)源码解析,其实际上是HttpServiceMethod对象 12345678910111213141516ServiceMethod&lt;?&gt; loadServiceMethod(Method method) { //从解析的缓存中获取 ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); } } return result;} static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)源码 1234567891011abstract class ServiceMethod&lt;T&gt; { static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) { //RequestFactory负责解析接口并且生成Request RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); //………… return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); } abstract T invoke(Object[] args);} HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//将一个接口方法转变为一个Http请求final class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; { static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码 CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method); //…… Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; return new HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter); } private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter( Retrofit retrofit, Method method) { Type returnType = method.getGenericReturnType(); Annotation[] annotations = method.getAnnotations(); try { //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations); } catch (RuntimeException e) { // Wide exception range because factories are user code. throw methodError(method, e, \"Unable to create call adapter for %s\", returnType); } } //………… private final RequestFactory requestFactory; private final okhttp3.Call.Factory callFactory; private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter; private final Converter&lt;ResponseBody, ResponseT&gt; responseConverter; private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory, CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter, Converter&lt;ResponseBody, ResponseT&gt; responseConverter) { this.requestFactory = requestFactory; this.callFactory = callFactory; this.callAdapter = callAdapter; this.responseConverter = responseConverter; } //代理调用的invoke最终会调用下面invoke方法 @Override ReturnT invoke(Object[] args) { return callAdapter.adapt( new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter)); }}`call.enqueue(new Callback&lt;SearchRepoBean&gt;() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})````javafinal class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; { //…… @Override public void enqueue(final Callback&lt;T&gt; callback) { //…… call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { Response&lt;T&gt; response; //…… try { callback.onResponse(OkHttpCall.this, response); } catch (Throwable t) { t.printStackTrace(); } } }); } //……}","link":"/public/2019/12/20/Android/%E6%A1%86%E6%9E%B6/Retrofit%202.5%20%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"结构化组件介绍与使用","text":"结构化组件介绍结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。 ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁 Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。 结构化组件推荐结构化组件的工作原理介绍如图所示， Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。 SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。 Dao：用于获取数据的Object，将Sql语句映射为Funcation，通常需要在SQLite OpenHelper中进行定义，但使用Room持久化层，只需调用方法即可，不需要再SQLite OpenHelper中进行定义。 Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在SQLite Openhelper中进行处理），Room数据库使用Dao来操作SQLite Database。 Repository：使用Repository来操作多种数据源。 ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源， LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。LiveData可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，LiveData可以自动感知与它相关的组件的生命周期的改变。","link":"/public/2019/08/19/Android/%E6%A1%86%E6%9E%B6/AAC/Android%20Architecture%20Components/"},{"title":"Android生命周期感知组件详解","text":"Android生命周期感知组件详解使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 onStart() onStop()中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。 Lifecycle类 Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。 Event 由framework层分发的以及Lifecycle类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调 State 表示由Lifecycle对象跟踪的组件的当前的状态 LifecycleOwnerLifecycleOwner是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。 源码： 123456789public interface LifecycleOwner { /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. * @NonNull Lifecycle getLifecycle();} 一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现LifecycleOwner接口。 LifecycleObserverLifecycleObserver接口可以与实现LifecycleOwner接口的类配合使用，实现LifecycleOwner接口的类提供Lifecycle，而LifecycleObserver可以注册至被观察者。","link":"/public/2018/07/08/Android/%E6%A1%86%E6%9E%B6/AAC/Android%20Lifecycle-Aware%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"title":"Databinding点击事件的实现","text":"Databinding点击事件的几种实现方式 代码片段 123456789101112131415161718//BaseActivity中public void click(View view){}public void click1(){}public void click2(int id){}//xml文件中&lt;variable name=&quot;activity&quot; type=&quot;.BaseActivity&quot; /&gt;&lt;variable name=&quot;user&quot; type=&quot;.User&quot; /&gt; 1、@{activity.click}click函数带有参数 123456&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;点击事件&quot; android:onClick=&quot;@{activity.click}&quot;/&gt; 2、@{()-&gt;activity.click()}click函数无参数 123456&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;点击事件&quot; android:onClick=&quot;@{()-&gt;activity.click1()}&quot;/&gt; 3、@{activity::click}click带参数 123456&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;点击事件&quot; android:onClick=&quot;@{activity::click}&quot;/&gt; 4、@{()-&gt;activity.click(user.id)}123456&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;点击事件&quot; android:onClick=&quot;@{()-&gt;activity.click2(user.id)}&quot;/&gt; 5、@{()-&gt;activity.click(3)}123456&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;点击事件&quot; android:onClick=&quot;@{()-&gt;activity.click2(3)}&quot;/&gt; 6、自定义View中DataBinding的点击事件7、在RecyclerView中的item添加点击事件12345678// 按钮点击 holder.getBinding.getRoot().findViewById(R.id.btn_edit) .setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { // todo } }); DataBinding赋值操作方法一： Databinding特殊用法12345678910&lt;CheckBox android:id=&quot;@+id/showName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;TextView android:text=&quot;@{user.firstName}&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;@{showName.checked ? View.VISIBLE : View.GONE}&quot; /&gt; 注意事项在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误","link":"/public/2018/04/06/Android/%E6%A1%86%E6%9E%B6/AAC/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"LiveData介绍与使用","text":"LiveData介绍LiveData是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。LiveData是一个抽象类，其继承关系如下： LiveData的优势 保证UI界面与数据相匹配 无内存泄漏 观察者绑定至Lifecycle，当观察者的生命周期结束后，其会自动清理 不会由于Activity stop而发生崩溃 如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据 合理的数据配置 如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 数据共享 可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。 在具有生命周期的对象中使用LiveData定义被观察者在定义被观察者对象时通常使用MutableLiveData类，在Activity中定义一个被观察的对象： 12 MutableLiveData&lt;String&gt; mutableLiveData=new MutableLiveData&lt;&gt;(); 注册观察者：12345678910@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mutableLiveData.observe(this, new Observer&lt;String&gt;() { @Override public void onChanged(String s) { Log.i(\"输出数据：\",s); } });} 被观察者mutableLiveData的数据修改有两种方式：setValue(T value)和postValue(T value)。当被观察者数据在UI主线程中进行修改时，使用setValue(T value)，当被观察者在子线程中使用时，使用postValue(T value)； 通过setValue(T value)修改被观察者并通知观察者1mutableLiveData.setValue(&quot;TEST&quot;); setValue(T value)源码： 1234567@MainThreadprotected void setValue(T value) { assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常 mVersion++; mData = value; dispatchingValue(null); //用于数据分发通知观察者} 在setValue(T value)中调用dispatchingValue(null)，用于通知观察者。 dispatchingValue(@Nullable ObserverWrapper initiator)源码 12345678910111213141516171819//参数ObserverWrapper是每一个观察者的封装void dispatchingValue(@Nullable ObserverWrapper initiator) { //... do { mDispatchInvalidated = false; //... //遍历所有的观察者，并进行通知 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { //considerNotify用于通知观察者 considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } while (mDispatchInvalidated); mDispatchingValue = false;} 在dispatchingValue(@Nullable ObserverWrapper initiator)方法中调用considerNotify(ObserverWrapper observer)通知观察者 1234567891011121314private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);} 通过postValue(T value)修改被观察者并通知观察者123456new Thread(new Runnable() { @Override public void run() { mutableLiveData.postValue(&quot;TEST&quot;); }}).start(); postValue(T value)源码： 12345678910111213protected void postValue(T value) { boolean postTask; synchronized (mDataLock) { postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { return; } //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行 ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);} mPostValueRunnable源码： 12345678private final Runnable mPostValueRunnable = new Runnable() { @Override public void run() { //... //依然是调用setValue对数据进行修改 setValue((T) newValue); }}; 在不具有生命周期的对象中使用LiveData12345678910111213141516171819202122232425262728public class TestLiveDataBean { MutableLiveData&lt;String&gt; mutableLiveData = new MutableLiveData&lt;&gt;(); Observer&lt;String&gt; observer; public TestLiveDataBean() { observer = new Observer&lt;String&gt;() { @Override public void onChanged(String s) { LogUtils.printInfo(s); } }; //添加观察者 mutableLiveData.observeForever(observer); } public void setValue() { //无论setValue是否在UI主线程中，都可以用postValue mutableLiveData.postValue(&quot;测试&quot;); //当在子线程中调用setValue报错 //mutableLiveData.setValue(&quot;测试&quot;); } public void removeObserver() { mutableLiveData.removeObserver(observer); }} observeForever()与removeOberver()方法需要成对进行使用，通过observeForever()方法添加观察者，该方法只能在主线程中调用; 123456789101112131415@MainThreadpublic void observeForever(@NonNull Observer&lt;? super T&gt; observer) { assertMainThread(\"observeForever\"); AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing instanceof LiveData.LifecycleBoundObserver) { throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); } if (existing != null) { return; } wrapper.activeStateChanged(true);} 观察者使用完毕后，需要通过removeOberver()方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用 removeObserver(@NonNull final Observer&lt;? super T&gt; observer)源码： 1234567891011@MainThreadpublic void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) { assertMainThread(\"removeObserver\"); ObserverWrapper removed = mObservers.remove(observer); if (removed == null) { return; } removed.detachObserver(); removed.activeStateChanged(false);} MediatorLiveData介绍MediatorLiveData是LiveData的一个子类，可以将LiveData的数据源合并至一起；当任一LiveData数据源的数据发生改变后，都会触发MediatorLiveData的观察者。 继承LiveData进行数据共享","link":"/public/2019/04/23/Android/%E6%A1%86%E6%9E%B6/AAC/Android%20Livedata%E8%AF%A6%E8%A7%A3/"},{"title":"Android框架组件paging+room的使用","text":"Android框架组件paging+room的使用简介：DataSourceDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本， 创建一个PagedList被观察者的对象，需要将一个DataSource.Factory的实例传递给LivePagedListBuilder对象。一个DataSource对象为单一的PagedList加载pages。当数据更新时，工厂类会创建一个PagedSource的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供DataSource.Factory对象，或者可以自己创建DataSource.Factory Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下： 12@Query(\"SELECT * FROM COUNTRIES\")public abstract DataSource.Factory&lt;Integer,Country&gt; getCountries(); PagedListPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。 PagedListAdapterPagedListAdapter是一个RecyclerView.Adapter用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？ 将架构组件添加到项目中在build.gradle中添加下面的依赖 12345678910111213 //recyclerView implementation 'com.android.support:recyclerview-v7:27.1.0' // ViewModel and LiveData implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot; annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;// Room implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot; annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot; // Paging implementation &quot;android.arch.paging:runtime:1.0.1&quot; 创建DataSource创建实体创建Dao层DataSource.Factory(在Room中实现)创建 创建数据库创建ViewModelLivePagedListBuilder会使用 LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。 创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法： setPageSize(int)： setPrefetchDistance(int)： setInitialLoadSizeHint(int)：设置页面中第一次显示的数量 setEnablePlaceholders(boolean) ： 在onCreate方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。 创建Adapter使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用DiffCallback来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法： areItemsTheSame:判断是否指向了同一个数据元素。 areContentsTheSame:判断","link":"/public/2018/12/05/Android/%E6%A1%86%E6%9E%B6/AAC/Paging%E5%92%8CRoom%E4%BD%BF%E7%94%A8/"},{"title":"Room数据库","text":"1、数据库在表中可以指定多个主键 12345678910111213@Entity(primaryKeys = {\"firstName\", \"lastName\"})public class User{ public String firstName; public String lastName; //使用Ignore使得该变量不生成表段名 @Ignore Bitmap bitmap;} 如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns 123456public class RemotePerson extends Person { @PrimaryKey public int id; public boolean hasVpn;} 2、Entity进行嵌套如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded 12345678910111213141516171819public class Address { public String street; public String state; public String city; @ColumnInfo(name = &quot;post_code&quot;) public int postCode;} @Entitypublic class Person{ @PrimaryKey public int id; public String firstName; @Embedded public Address address;} 这样在Person表中有id,firstName,street,state,city,post_code等字段 3、插入数据产生冲突时操作1234567@Daopublic interface UserDao{ //插入如果冲突则替换 @Insert(onConflict = OnConflictStrategy.REPLACE) public void insertUser(User ... users);} 用于对数据表中某一列进行更新123@Query(&quot;UPDATE item SET quantity = quantity + 1 WHERE id = :id&quot;)void updateQuantity(int id)//item为表名","link":"/public/2019/11/05/Android/%E6%A1%86%E6%9E%B6/AAC/Room%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"WorkManager介绍与使用","text":"WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。 在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。 当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。 WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service WorkManager可以执行两种类型的任务 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中 12WorkManager workManager=workManager.getInstance();workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build()); 因为没有加其他的限制条件，所以上述任务只会执行一次； 多次任务，如：每天将应用数据同步至服务器； 创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中 1234new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();WorkManager.getInstance().enqueue(dataCheckWork);","link":"/public/2018/12/20/Android/%E6%A1%86%E6%9E%B6/AAC/WorkManager%E4%BB%8B%E7%BB%8D/"},{"title":"使用框架组件Room和Lifecycle来创建应用","text":"使用框架组件Room和Lifecycle来创建应用在build.gradle(Module:app)中添加依赖 12345678//Room组件implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;//lifestyle组件implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot; 创建一个Entity实体在应用中数据是words，每一个word都是一个实体，创建一个Word类，同时需要创建构造函数以及getter方法，只要这样Room才会实例化Object 假装右图！！！！ 代码如下： 12345678public class Word { private String mWord; public Word(@NonNull String word) {this.mWord = word;} public String getWord(){return this.mWord;}} 要使得Word类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。 @Entity(tableName = &quot;word_table&quot;) 每一个@Entity类代表数据表中的一个实体。 @PrimaryKey 每一个实体都需要一个主键，为了表示方便，在这里将每一个word自身作为其主键。 @NonNull 声明参数、域或者方法的返回值不为空。 @ColumnInfo(name = &quot;word&quot;) 当需要指定与类中的成员变量不同的列名时使用。 123456789101112@Entity(tableName = \"word_table\")public class Word { @PrimaryKey @NonNull @ColumnInfo(name = \"word\") private String mWord; public Word(String word) {this.mWord = word;} public String getWord(){return this.mWord;}} 创建Dao在Dao(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，在默认状态下，所有的查询语句都需要在单独的线程中运行。Room使用Dao可以使得代码更加简洁。 创建一个新的接口声明为WordDao 使用功注解@Dao来定义该类为Room的一个Dao类 声明插入一个word的方法void insert(Word word) 为该方法添加@Insert注解，在方法中不需要提供任何sql语句（还有@Delete以及@Update等注解）。 声明一个删除所有words的方法void deleteAll(); 使用@Query注解，用于查询以及其他操作，@Query(&quot;DELETE FROM word_table&quot;)。 创建一个获取所有单词的方法，getAllWords();返回值为List,通过注解的方式为此方法添加SQL查询语句@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;) 123456789101112@Daopublic interface WordDao { @Insert void insert(Word word); @Query(&quot;DELETE FROM word_table&quot;) void deleteAll(); @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;) List&lt;Word&gt; getAllWords();} LiveData类的使用当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。 LiveData是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用LiveData类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新LiveData 当你需要离开Room独立使用LiveData时，你需要更新数据，因为LiveData方法没有公有的方法来更新已经存储的数据。 在WordDao中，将getAllWords的返回值包裹在LiveData中 12@Query(\"SELECT * from word_table ORDER BY word ASC\")LiveData&lt;List&lt;Word&gt;&gt; getAllWords(); 添加Room数据库Room数据库层介绍Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在SQLiteOpenHelper中处理的单调的工作。 Room使用Dao来查询数据库。 在默认状态下，Room不可以在主线程中操作数据库，LiveData通过自动的方式在后台进程中实现异步查询。 Room在编译的时候检查数据库的Sql语句 Room类需要时抽象类并继承自RoomDatabase Room数据库在整个App中需要以单例模式初始化。 实现Room数据库 创建一个public abstract类继承自RoomDatabase，public abstract class WordRoomDatabase extends RoomDatabase {} 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。@Database(entities = {Word.class}, version = 1) 定义与数据库操作相关的Dao，并使用抽象方法，代码如下： 12345@Database(entities = {Word.class}, version = 1)public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao wordDao();} 4.将WordRoomDatabase设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。 代码如下： 123456789101112private static WordRoomDatabase INSTANCE;public static WordRoomDatabase getDatabase(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { // Create database here } } } return INSTANCE;} 5.添加获取到数据库的代码 代码如下： 123INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, \"word_database\") .build(); 完整代码如下： 1234567891011121314151617181920212223@Database(entities = {Word.class}, version = 1)public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao wordDao(); private static WordRoomDatabase INSTANCE; static WordRoomDatabase getDatabase(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, \"word_database\") .build(); } } } return INSTANCE; }} 创建一个RepositoryRepository介绍Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，Repository类用于操作数据。 假装有图~ Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。 实现Repository1.创建一个名为WordRepository的公有类 2.创建Dao类型的成员变量以及word列表 12private WordDao mWordDao;private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; 3.添加构造函数，获得数据库的控制并初始化成员变量 12345WordRepository(Application application) { WordRoomDatabase db = WordRoomDatabase.getDatabase(application); mWordDao = db.wordDao(); mAllWords = mWordDao.getAllWords();} 4.添加getAllWords()方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的LiveData将会通知订阅者。 123LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords;} 5.封装insert()方法，insert()方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。 123public void insert (Word word) { new insertAsyncTask(mWordDao).execute(word);} 6.insertAsyncTask方法 1234567891011121314private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; { private WordDao mAsyncTaskDao; insertAsyncTask(WordDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final Word... params) { mAsyncTaskDao.insert(params[0]); return null; }} 完整代码： 1234567891011121314151617181920212223242526272829303132333435public class WordRepository { private WordDao mWordDao; private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; WordRepository(Application application) { WordRoomDatabase db = WordRoomDatabase.getDatabase(application); mWordDao = db.wordDao(); mAllWords = mWordDao.getAllWords(); } LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; } public void insert (Word word) { new insertAsyncTask(mWordDao).execute(word); } private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; { private WordDao mAsyncTaskDao; insertAsyncTask(WordDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final Word... params) { mAsyncTaskDao.insert(params[0]); return null; } }} 创建一个ViewModelViewModel是用于向UI提供数据以及服务信息配置改变，ViewModel起着Repository与UI之间的交流中心的作用。可以使用ViewModel在fragment之间共享数据。ViewModel也是lifecycle library的一部分。 ViewModel使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：Activity以及Fragment的主要作用是在屏幕中绘制UI，而ViewModel的作用是控制操作UI需要的所有的数据。 在ViewModel中使用LiveData来表示那些UI显示过程中会发生改变的数据，使用LiveData主要有以下的优点： 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。 Repository以及UI通过ViewModel彻底分离开来，在ViewModel中不会调用数据库中的内容。 实现ViewModel 创建WordViewModel类，继承自AndroidViewModel 1public class WordViewModel extends AndroidViewModel {} 创建Repository的成员变量 ```java private WordRepository mRepository; 12345* 创建LiveData成员变量用于缓存word列表```java private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; 创建构造函数 12345 public WordViewModel (Application application) { super(application); mRepository = new WordRepository(application); mAllWords = mRepository.getAllWords();} 创建getter方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。 1LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; } 创建insert()方法，用于调用Repostory中的insert()方法，这样随UI可以完全隐藏insert()方法的实现。 WordViewModel类的完整实现方法如下： 12345678910111213141516public class WordViewModel extends AndroidViewModel { private WordRepository mRepository; private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; public WordViewModel (Application application) { super(application); mRepository = new WordRepository(application); mAllWords = mRepository.getAllWords(); } LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; } public void insert(Word word) { mRepository.insert(word); }} 注：不可以向ViewModel实例中传递Context参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。 Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在ViewModel中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。","link":"/public/2018/12/20/Android/%E6%A1%86%E6%9E%B6/AAC/Lifecycle%E5%92%8CRoom%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"使用框架组件Room和Lifecycle来创建应用","text":"使用框架组件Room和Lifecycle来创建应用在build.gradle(Module:app)中添加依赖 12345678//Room组件implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;//lifestyle组件implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot; 创建一个Entity实体在应用中数据是words，每一个word都是一个实体，创建一个Word类，同时需要创建构造函数以及getter方法，只要这样Room才会实例化Object 假装右图！！！！ 代码如下： 12345678public class Word { private String mWord; public Word(@NonNull String word) {this.mWord = word;} public String getWord(){return this.mWord;}} 要使得Word类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。 @Entity(tableName = &quot;word_table&quot;) 每一个@Entity类代表数据表中的一个实体。 @PrimaryKey 每一个实体都需要一个主键，为了表示方便，在这里将每一个word自身作为其主键。 @NonNull 声明参数、域或者方法的返回值不为空。 @ColumnInfo(name = &quot;word&quot;) 当需要指定与类中的成员变量不同的列名时使用。 123456789101112@Entity(tableName = \"word_table\")public class Word { @PrimaryKey @NonNull @ColumnInfo(name = \"word\") private String mWord; public Word(String word) {this.mWord = word;} public String getWord(){return this.mWord;}} 创建Dao在Dao(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，在默认状态下，所有的查询语句都需要在单独的线程中运行。Room使用Dao可以使得代码更加简洁。 创建一个新的接口声明为WordDao 使用功注解@Dao来定义该类为Room的一个Dao类 声明插入一个word的方法void insert(Word word) 为该方法添加@Insert注解，在方法中不需要提供任何sql语句（还有@Delete以及@Update等注解）。 声明一个删除所有words的方法void deleteAll(); 使用@Query注解，用于查询以及其他操作，@Query(&quot;DELETE FROM word_table&quot;)。 创建一个获取所有单词的方法，getAllWords();返回值为List,通过注解的方式为此方法添加SQL查询语句@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;) 123456789101112@Daopublic interface WordDao { @Insert void insert(Word word); @Query(&quot;DELETE FROM word_table&quot;) void deleteAll(); @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;) List&lt;Word&gt; getAllWords();} LiveData类的使用当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。 LiveData是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用LiveData类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新LiveData 当你需要离开Room独立使用LiveData时，你需要更新数据，因为LiveData方法没有公有的方法来更新已经存储的数据。 在WordDao中，将getAllWords的返回值包裹在LiveData中 12@Query(\"SELECT * from word_table ORDER BY word ASC\")LiveData&lt;List&lt;Word&gt;&gt; getAllWords(); 添加Room数据库Room数据库层介绍Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在SQLiteOpenHelper中处理的单调的工作。 Room使用Dao来查询数据库。 在默认状态下，Room不可以在主线程中操作数据库，LiveData通过自动的方式在后台进程中实现异步查询。 Room在编译的时候检查数据库的Sql语句 Room类需要时抽象类并继承自RoomDatabase Room数据库在整个App中需要以单例模式初始化。 实现Room数据库 创建一个public abstract类继承自RoomDatabase，public abstract class WordRoomDatabase extends RoomDatabase {} 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。@Database(entities = {Word.class}, version = 1) 定义与数据库操作相关的Dao，并使用抽象方法，代码如下： 12345@Database(entities = {Word.class}, version = 1)public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao wordDao();} 4.将WordRoomDatabase设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。 代码如下： 123456789101112private static WordRoomDatabase INSTANCE;public static WordRoomDatabase getDatabase(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { // Create database here } } } return INSTANCE;} 5.添加获取到数据库的代码 代码如下： 123INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, \"word_database\") .build(); 完整代码如下： 1234567891011121314151617181920212223@Database(entities = {Word.class}, version = 1)public abstract class WordRoomDatabase extends RoomDatabase { public abstract WordDao wordDao(); private static WordRoomDatabase INSTANCE; static WordRoomDatabase getDatabase(final Context context) { if (INSTANCE == null) { synchronized (WordRoomDatabase.class) { if (INSTANCE == null) { INSTANCE = Room.databaseBuilder(context.getApplicationContext(), WordRoomDatabase.class, \"word_database\") .build(); } } } return INSTANCE; }} 创建一个RepositoryRepository介绍Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，Repository类用于操作数据。 假装有图~ Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。 实现Repository1.创建一个名为WordRepository的公有类 2.创建Dao类型的成员变量以及word列表 12private WordDao mWordDao;private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; 3.添加构造函数，获得数据库的控制并初始化成员变量 12345WordRepository(Application application) { WordRoomDatabase db = WordRoomDatabase.getDatabase(application); mWordDao = db.wordDao(); mAllWords = mWordDao.getAllWords();} 4.添加getAllWords()方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的LiveData将会通知订阅者。 123LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords;} 5.封装insert()方法，insert()方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。 123public void insert (Word word) { new insertAsyncTask(mWordDao).execute(word);} 6.insertAsyncTask方法 1234567891011121314private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; { private WordDao mAsyncTaskDao; insertAsyncTask(WordDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final Word... params) { mAsyncTaskDao.insert(params[0]); return null; }} 完整代码： 1234567891011121314151617181920212223242526272829303132333435public class WordRepository { private WordDao mWordDao; private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; WordRepository(Application application) { WordRoomDatabase db = WordRoomDatabase.getDatabase(application); mWordDao = db.wordDao(); mAllWords = mWordDao.getAllWords(); } LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; } public void insert (Word word) { new insertAsyncTask(mWordDao).execute(word); } private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; { private WordDao mAsyncTaskDao; insertAsyncTask(WordDao dao) { mAsyncTaskDao = dao; } @Override protected Void doInBackground(final Word... params) { mAsyncTaskDao.insert(params[0]); return null; } }} 创建一个ViewModelViewModel是用于向UI提供数据以及服务信息配置改变，ViewModel起着Repository与UI之间的交流中心的作用。可以使用ViewModel在fragment之间共享数据。ViewModel也是lifecycle library的一部分。 ViewModel使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：Activity以及Fragment的主要作用是在屏幕中绘制UI，而ViewModel的作用是控制操作UI需要的所有的数据。 在ViewModel中使用LiveData来表示那些UI显示过程中会发生改变的数据，使用LiveData主要有以下的优点： 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。 Repository以及UI通过ViewModel彻底分离开来，在ViewModel中不会调用数据库中的内容。 实现ViewModel 创建WordViewModel类，继承自AndroidViewModel 1public class WordViewModel extends AndroidViewModel {} 创建Repository的成员变量 ```java private WordRepository mRepository; 12345* 创建LiveData成员变量用于缓存word列表```java private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; 创建构造函数 12345 public WordViewModel (Application application) { super(application); mRepository = new WordRepository(application); mAllWords = mRepository.getAllWords();} 创建getter方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。 1LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; } 创建insert()方法，用于调用Repostory中的insert()方法，这样随UI可以完全隐藏insert()方法的实现。 WordViewModel类的完整实现方法如下： 12345678910111213141516public class WordViewModel extends AndroidViewModel { private WordRepository mRepository; private LiveData&lt;List&lt;Word&gt;&gt; mAllWords; public WordViewModel (Application application) { super(application); mRepository = new WordRepository(application); mAllWords = mRepository.getAllWords(); } LiveData&lt;List&lt;Word&gt;&gt; getAllWords() { return mAllWords; } public void insert(Word word) { mRepository.insert(word); }} 注：不可以向ViewModel实例中传递Context参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。 Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在ViewModel中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。","link":"/public/2019/11/19/Android/%E6%A1%86%E6%9E%B6/AAC/Room%E5%92%8CLifecycle%E6%9E%84%E5%BB%BA%E7%A8%8B%E5%BA%8F/"},{"title":"Android生命周期感知组件","text":"modified: 2018-08-09 Android生命周期感知组件介绍(Android lifecycle-aware components)lifecycle-aware组件介绍 ViewModel：为绑定在特定生命周期的对象提供创建以及恢复的方法，ViewModel通常保存View的数据或者用于与其他组件进行通信，例如data repository LifecycleOwner/LifecycleRegisterOwner：LifecycleOwner以及LifecycleRegisterOwner都是需要在AppCompatActivity或者Support Fragment类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。 LiveData:通过LiveData可以通过多个组件来观察到数据的变化。LiveData不会影响应用中的组件如：Activity、Service、Fragment或者其他LifecycleOwner的生命周期。LiveData可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。 布局文件中添加计时器123456789&lt;Chronometer android:id=\"@+id/chronometer\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 12345678910public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer); chronometer.start(); }} 当旋转屏幕时，由于Activity重建，使得计时器被重置 添加ViewMedel添加ViewModel来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用ViewModel也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。 使用ViewModel来留存计时器（Chronometer）的状态ChronometerViewModel中的代码 12345678910111213141516171819202122232425public class ChronometerViewModel extends ViewModel { private MutableLiveData&lt;Long&gt;mElapsedTime=new MutableLiveData&lt;&gt;(); private long mInitialTime; public ChronometerViewModel(){ mInitialTime= SystemClock.elapsedRealtime(); Timer timer=new Timer(); timer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { final long newValue=(SystemClock.elapsedRealtime()-mInitialTime)/1000; mElapsedTime.postValue(newValue); } },1000,1000); } public LiveData&lt;Long&gt;getElapsedTime(){ return mElapsedTime; }} 在MainActivity中添加代码 1chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class); this指代的是LifecycleOwner的一个实例，ViewModel与LifecycleOwner保活时间一样长，当ViewModel的所有者的配置信息（如：屏幕旋转）发生变化时，ViewModel不会被销毁，当其所有者重新被实例化时，会与已经存在的ViewModel重新建立联系。其生命周期如图所示： 将Activity中使用的数据使用LiveData进行封装将计时控件chronometer使用Timer来设置，每隔一秒钟更新一次UI，将相应的代码放在ChronometerViewModel中，而让Activity只保持用户与UI之间的交流操作。 MainActivity中的完整代码 12345678910111213141516171819202122232425public class MainActivity extends AppCompatActivity { private ChronometerViewModel chronometerViewModel; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class); subscribe(); } private void subscribe(){ final Observer&lt;Long&gt;elapseTimeObserver=new Observer&lt;Long&gt;() { @Override public void onChanged(@Nullable Long aLong) { ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+\"秒\"); } }; chronometerViewModel.getElapsedTime().observe(this,elapseTimeObserver); }} 当timer每隔一秒通知MainActivity时，MainActivity将会更新一下UI，为避免内存泄漏，ViewModel中没有指向Activity的引用。 ViewModel并不直接改变View，在使用ViewModel中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。 注：为了将数据暴露给观察者，需要使用LiveData对数据进行封装 LiveData是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。 运行结果： 在旋转屏幕后计时器继续未重置。","link":"/public/2018/08/09/Android/Android%E5%9F%BA%E7%A1%80/Android-ViewModel%E4%BB%8B%E7%BB%8D/"},{"title":"Android Broadcast介绍","text":"Android Broadcast介绍modified: 2018-08-01Android应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。 手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。 广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。 广播中的一些变化 在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO 在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效 从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。 接收广播手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。在Android 8.0(API 26)之后建议使用第二种方式 在menifest文件中声明receiver通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。 1、menifest文件配置12345678&lt;receiver android:name=\".receiver.BroadcastReceiverTest\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"/&gt; &lt;action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 2、继承BroadcastReceiver类当用户手机充电时，将会弹出充电的提示。 1234567public class BroadcastReceiverTest extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show(); }} 通过Context-register的方式注册Receiver###1、创建一个BroadcastReceiverTest实例 1BroadcastReceiverTest br=new BroadcastReceiverTest() ###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播 1234//用于监控网络的状态变化IntentFilter intentFilter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);this.registerReceiver(br,intentFilter); 注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。 ###3、停止接收广播 停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。 一定要记得unregister receiver，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(防止广播被重复多次注册)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。 Broadcast对进程的影响BroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。 当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。 因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。 12345678910111213141516171819public class BroadcastReceiverTest extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show(); final PendingResult pendingResult=goAsync(); AsyncTask&lt;String,Integer,String&gt;asyncTask=new AsyncTask&lt;String, Integer, String&gt;() { @Override protected String doInBackground(String... strings) { Log.i(\"+++++++++\",\"++++\"); pendingResult.finish(); return \"测试\"; } }; asyncTask.execute(); }} 发送广播Android提供三种方式发送广播 通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。 通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。 通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。 发送广播的例子 1234Intent intent = new Intent();intent.setAction(\"com.example.broadcast.MY_NOTIFICATION\");intent.putExtra(\"data\",\"Notice me senpai!\");sendBroadcast(intent); 广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。 注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。 通过permissions限制广播的发送广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。 带有权限的广播发送当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。例如： 1sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS); 这一条广播的接收者，只能是已经在manifest文件中申请了权限的App 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 带有权限的广播接收无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。发送广播的App一定要取得相应的权限 例如：在manifest文件中添加权限限制。 1234567891011121314&lt;receiver android:name=\".MyBroadcastReceiver\" android:permission=\"android.permission.SEND_SMS\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.AIRPLANE_MODE\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;``` 使用context-register方式注册广播权限限制```javaIntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );","link":"/public/2018/08/01/Android/Android%E5%9F%BA%E7%A1%80/Android-broadcast%E4%BB%8B%E7%BB%8D/"},{"title":"Android Service介绍","text":"Android开发Service介绍Service是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。 不同类型的Service介绍Foreground serviceForeground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service) Background serviceBackground service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。 注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。 Bound当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。 不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。 Service的使用创建一个Service,需要创建Service的子类，并在其中重写回调函数。 函数的介绍onStartCommend()其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。 onBind()其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null onCreate()在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。 onDestory()当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。 在menifest中声明一个service1234567&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=\".ExampleService\" /&gt; ... &lt;/application&gt;&lt;/manifest&gt; 注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service 创建一个Started service当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。 应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。 例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。 注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。 两个可以继承启动的service类Service类Service类是所有service的基类，当在继承这一个类的时候，需要创建一个新的线程，使得service可以再其中完成它的工作 （很重要），service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。 IntentService类IntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。 继承IntentService类在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类 IntentService类所做的工作 创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。 创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。 当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。 提供onBind()的默认实现方法，并返回null。 提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。 为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。 创建一个Bound ServiceBound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。 给用户发送notifications当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity 运行foreground serviceforeground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。 谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。 让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。 12//代码 service的生命周期service的生命周期从创建至销毁有两种情况 通过调用startService()创建service其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service 通过调用bindService()创建service其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。","link":"/public/2018/07/31/Android/Android%E5%9F%BA%E7%A1%80/Android-service%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/public/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"pat","slug":"pat","link":"/public/tags/pat/"},{"name":"Android","slug":"Android","link":"/public/tags/Android/"},{"name":"JNI","slug":"JNI","link":"/public/tags/JNI/"},{"name":"Java","slug":"Java","link":"/public/tags/Java/"},{"name":"Git","slug":"Git","link":"/public/tags/Git/"},{"name":"Kotlin","slug":"Kotlin","link":"/public/tags/Kotlin/"}],"categories":[{"name":"Android","slug":"Android","link":"/public/categories/Android/"},{"name":"Java","slug":"Java","link":"/public/categories/Java/"},{"name":"数据结构","slug":"数据结构","link":"/public/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Other","slug":"Other","link":"/public/categories/Other/"},{"name":"Kotlin","slug":"Kotlin","link":"/public/categories/Kotlin/"},{"name":"PAT","slug":"PAT","link":"/public/categories/PAT/"}]}