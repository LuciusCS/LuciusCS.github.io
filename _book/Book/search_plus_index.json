{"./":{"url":"./","title":"introduction","keywords":"","body":"My Awesome Book This file file serves as your book's preface, a great place to describe your book's content and ideas. Copyright © jsliang.top 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 09:22:37 "},"Directory/Java Directory.html":{"url":"Directory/Java Directory.html","title":"Java","keywords":"","body":"Java文章目录 Java基础 Java线程间通信 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 14:54:45 "},"Java/Java基础.html":{"url":"Java/Java基础.html","title":"Java基础","keywords":"","body":"Queue 接口 BlockingQueue接口 实现类 ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小 DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口 LinkedBlockingQueue 内部以链表的形式实现 PriorityBlockingQueue 无界并发队列 SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素； 方法 add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true，如果队列已满，则返回false poll 移除并返问队列头部的元素，，如果队列为空，则返回null peek 返回队列头部的元素，如果队列为空，则返回null put 添加一个元素，如果队列满，则阻塞 take 移除并返回队列头部的元素，如果队列为空，则阻塞 List接口：实现类 ArrayList LinkedList Vector ArrayList ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢； ArrayList在循环中删除元素可能会出现问题： 1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏 2、使用for-each进行删除，实际是调用它的迭代器来实现， LinkedList LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） Vector Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替； Java Doc里建议用Deque替代Stack接口完成栈的功能 Set接口：实现类 Hashset、TreeSet Hashset：按照哈希算法存取集合中的对象，存取速度快 TreeSet：实现Sorted接口，能够对集合中的对象进行排序 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 14:54:45 "},"Java/Java线程间通信.html":{"url":"Java/Java线程间通信.html","title":"Java基础","keywords":"","body":"线程间通信 使用单向管道（Pipe）传递数据 共享内存（Shared Memory）通信 使用阻塞队列（Blocking Queue）实现生产者-消费者模式 处理消息队列（Message Queue） wait/notify机制 等待/通知机制主要由Object类中的三个方法进行保证 1、wait()；notify();notifyAll() 上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作； 1)wait() 让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态； 2)notify() 唤醒一个正在等待相应对象锁的线程，使其进入就绪队列； 3)notifyAll() 唤醒所有正在等待相应对象锁的线程，使他们进入就绪队列； 2、方法调用与线程状态关系 每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列 Condition Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用； 对应关系 Condition中的await()对应Object的wait() Condition中的signal()对应Object的notify() Condition中的signalAll()对应Object中的notifyAll(); Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同 生产者消费者模型 线程间通信管道模式 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook文件修订时间： 2019-09-11 14:54:45 "}}