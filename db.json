{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/assets/Android JNI.png","path":"assets/Android JNI.png","modified":0,"renderable":0},{"_id":"source/assets/Android JNI1.png","path":"assets/Android JNI1.png","modified":0,"renderable":0},{"_id":"source/assets/Android JNI2.png","path":"assets/Android JNI2.png","modified":0,"renderable":0},{"_id":"source/assets/Android JNI3.png","path":"assets/Android JNI3.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg1.png","path":"assets/GitImg1.png","modified":0,"renderable":0},{"_id":"source/assets/Android safe.png","path":"assets/Android safe.png","modified":0,"renderable":0},{"_id":"source/assets/Android safe1.png","path":"assets/Android safe1.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg2.png","path":"assets/GitImg2.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg3.png","path":"assets/GitImg3.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg4.png","path":"assets/GitImg4.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg5.png","path":"assets/GitImg5.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg7.png","path":"assets/GitImg7.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg6.png","path":"assets/GitImg6.png","modified":0,"renderable":0},{"_id":"source/assets/Retrofit.png","path":"assets/Retrofit.png","modified":0,"renderable":0},{"_id":"source/assets/android_basis_permission.png","path":"assets/android_basis_permission.png","modified":0,"renderable":0},{"_id":"source/assets/lifecycle.png","path":"assets/lifecycle.png","modified":0,"renderable":0},{"_id":"source/assets/livedata.png","path":"assets/livedata.png","modified":0,"renderable":0},{"_id":"source/assets/proxy-design-pattern.jpg","path":"assets/proxy-design-pattern.jpg","modified":0,"renderable":0},{"_id":"source/img/3953273590_704e3899d5_m.jpg","path":"img/3953273590_704e3899d5_m.jpg","modified":0,"renderable":0},{"_id":"source/img/20170726/Image11.png","path":"img/20170726/Image11.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image1.png","path":"img/20170726/Image1.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image12.png","path":"img/20170726/Image12.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image13.png","path":"img/20170726/Image13.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image14.png","path":"img/20170726/Image14.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image15.png","path":"img/20170726/Image15.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image17.png","path":"img/20170726/Image17.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image18.png","path":"img/20170726/Image18.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image2.png","path":"img/20170726/Image2.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image3.png","path":"img/20170726/Image3.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image4.png","path":"img/20170726/Image4.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image5.png","path":"img/20170726/Image5.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image6.png","path":"img/20170726/Image6.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image7.png","path":"img/20170726/Image7.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image8.png","path":"img/20170726/Image8.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image9.png","path":"img/20170726/Image9.png","modified":0,"renderable":0},{"_id":"source/img/20170727/Image1.png","path":"img/20170727/Image1.png","modified":0,"renderable":0},{"_id":"source/img/20170727/Image3.png","path":"img/20170727/Image3.png","modified":0,"renderable":0},{"_id":"source/img/20170727/Image4.png","path":"img/20170727/Image4.png","modified":0,"renderable":0},{"_id":"source/img/20170727/Image5.png","path":"img/20170727/Image5.png","modified":0,"renderable":0},{"_id":"source/img/20170727/Image6.png","path":"img/20170727/Image6.png","modified":0,"renderable":0},{"_id":"source/img/20170727/Thumbs.db","path":"img/20170727/Thumbs.db","modified":0,"renderable":0},{"_id":"source/img/20170731/Thumbs.db","path":"img/20170731/Thumbs.db","modified":0,"renderable":0},{"_id":"source/img/20170802/001.gif","path":"img/20170802/001.gif","modified":0,"renderable":0},{"_id":"source/img/20170802/002.gif","path":"img/20170802/002.gif","modified":0,"renderable":0},{"_id":"source/img/20170802/004.jpg","path":"img/20170802/004.jpg","modified":0,"renderable":0},{"_id":"source/img/20170802/Thumbs.db","path":"img/20170802/Thumbs.db","modified":0,"renderable":0},{"_id":"source/img/201807/view_model.png","path":"img/201807/view_model.png","modified":0,"renderable":0},{"_id":"source/img/201807/service_lifecycle.png","path":"img/201807/service_lifecycle.png","modified":0,"renderable":0},{"_id":"source/img/201807/view_model1.png","path":"img/201807/view_model1.png","modified":0,"renderable":0},{"_id":"source/img/201807/view_model2.png","path":"img/201807/view_model2.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_list1.png","path":"img/DataStructure/adjacency_list1.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix1.png","path":"img/DataStructure/adjacency_matrix1.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix2.png","path":"img/DataStructure/adjacency_matrix2.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix3.png","path":"img/DataStructure/adjacency_matrix3.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/binary_tree.jpg","path":"img/DataStructure/binary_tree.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/binary_tree_result.png","path":"img/DataStructure/binary_tree_result.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap3.jpg","path":"img/DataStructure/heap3.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap2.jpg","path":"img/DataStructure/heap2.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap_sort.jpg","path":"img/DataStructure/heap_sort.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap7.jpg","path":"img/DataStructure/heap7.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/quick_sort.jpg","path":"img/DataStructure/quick_sort.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree1.png","path":"img/DataStructure/huffman_tree1.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/quick_sort_01.jpg","path":"img/DataStructure/quick_sort_01.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree3.png","path":"img/DataStructure/huffman_tree3.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/thread_binary_tree.jpg","path":"img/DataStructure/thread_binary_tree.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/threaded_binary_tree.jpg","path":"img/DataStructure/threaded_binary_tree.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-1.jpg","path":"img/head/abstract-1.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-10.jpg","path":"img/head/abstract-10.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-3.jpg","path":"img/head/abstract-3.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-4.jpg","path":"img/head/abstract-4.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-5.jpg","path":"img/head/abstract-5.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-6.jpg","path":"img/head/abstract-6.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-7.jpg","path":"img/head/abstract-7.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-8.jpg","path":"img/head/abstract-8.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree.png","path":"img/DataStructure/huffman_tree.png","modified":0,"renderable":0},{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/og_image.png","path":"images/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/wechat_donate.png","path":"images/wechat_donate.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"source/img/20170726/Image16.png","path":"img/20170726/Image16.png","modified":0,"renderable":0},{"_id":"source/img/20170731/001.png","path":"img/20170731/001.png","modified":0,"renderable":0},{"_id":"source/img/20170731/insertsort.gif","path":"img/20170731/insertsort.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/Merge_sort.gif","path":"img/DataStructure/Merge_sort.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_list.jpg","path":"img/DataStructure/adjacency_list.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix.jpg","path":"img/DataStructure/adjacency_matrix.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap.jpg","path":"img/DataStructure/heap.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap1.jpg","path":"img/DataStructure/heap1.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap5.jpg","path":"img/DataStructure/heap5.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap8.jpg","path":"img/DataStructure/heap8.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree2.jpg","path":"img/DataStructure/huffman_tree2.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-11.jpg","path":"img/head/abstract-11.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-12.jpg","path":"img/head/abstract-12.jpg","modified":0,"renderable":0},{"_id":"source/img/head/abstract-2.jpg","path":"img/head/abstract-2.jpg","modified":0,"renderable":0},{"_id":"source/img/head/head4.jpeg","path":"img/head/head4.jpeg","modified":0,"renderable":0},{"_id":"themes/icarus/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/alipay_donate.png","path":"images/alipay_donate.png","modified":0,"renderable":1},{"_id":"source/img/20170726/Thumbs.db","path":"img/20170726/Thumbs.db","modified":0,"renderable":0},{"_id":"source/img/20170802/003.jpg","path":"img/20170802/003.jpg","modified":0,"renderable":0},{"_id":"source/img/head/head11.jpg","path":"img/head/head11.jpg","modified":0,"renderable":0},{"_id":"source/img/head/head2.jpeg","path":"img/head/head2.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head3.jpeg","path":"img/head/head3.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head6.jpeg","path":"img/head/head6.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head8.png","path":"img/head/head8.png","modified":0,"renderable":0},{"_id":"source/img/002.jpeg","path":"img/002.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head10.jpeg","path":"img/head/head10.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head12.jpeg","path":"img/head/head12.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head14.jpeg","path":"img/head/head14.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head15.jpeg","path":"img/head/head15.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head7.jpeg","path":"img/head/head7.jpeg","modified":0,"renderable":0},{"_id":"source/img/008.jpg","path":"img/008.jpg","modified":0,"renderable":0},{"_id":"source/img/head/head5.jpeg","path":"img/head/head5.jpeg","modified":0,"renderable":0},{"_id":"source/img/head/head1.jpeg","path":"img/head/head1.jpeg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/Merge_sort_01.gif","path":"img/DataStructure/Merge_sort_01.gif","modified":0,"renderable":0},{"_id":"source/img/head/head13.jpeg","path":"img/head/head13.jpeg","modified":0,"renderable":0},{"_id":"source/img/006.jpeg","path":"img/006.jpeg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap6.jpg","path":"img/DataStructure/heap6.jpg","modified":0,"renderable":0},{"_id":"source/img/head/head9.png","path":"img/head/head9.png","modified":0,"renderable":0},{"_id":"source/img/007.jpeg","path":"img/007.jpeg","modified":0,"renderable":0},{"_id":"source/img/005.jpeg","path":"img/005.jpeg","modified":0,"renderable":0},{"_id":"source/img/003.jpeg","path":"img/003.jpeg","modified":0,"renderable":0},{"_id":"source/img/009.jpeg","path":"img/009.jpeg","modified":0,"renderable":0},{"_id":"source/img/001.jpeg","path":"img/001.jpeg","modified":0,"renderable":0},{"_id":"source/img/008 - Copy.jpeg","path":"img/008 - Copy.jpeg","modified":0,"renderable":0},{"_id":"source/img/004.jpeg","path":"img/004.jpeg","modified":0,"renderable":0},{"_id":"source/img/0010 原图.jpeg","path":"img/0010 原图.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/icarus/.gitignore","hash":"d1841a9f4c79119ea348d4274483cc679b0f5946","modified":1582802873698},{"_id":"themes/icarus/LICENSE","hash":"62e3701684087bc9a66f0b20386036ede9b430b7","modified":1582802531910},{"_id":"themes/icarus/README.md","hash":"921a87a50b130e1324fc0111e325d949ff74e1df","modified":1582802531910},{"_id":"themes/icarus/_config.yml","hash":"dfae2f6052b19ca2e81da3fe3b8e4e0087de5e7f","modified":1582957868235},{"_id":"themes/icarus/package.json","hash":"77068f22af71471a21ce3828018e9dc1e68feb5a","modified":1582802531940},{"_id":"source/_posts/hello-world.md","hash":"856d0cc1acc738b5c3e199e8dc24045f32173cb0","modified":1582941407885},{"_id":"source/assets/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1569027130121},{"_id":"source/assets/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1569027130121},{"_id":"source/assets/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1569027130122},{"_id":"source/assets/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1569027130123},{"_id":"source/assets/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1568199763467},{"_id":"source/assets/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1569027130123},{"_id":"source/assets/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1569027130124},{"_id":"source/assets/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1568199763467},{"_id":"source/assets/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1568199763468},{"_id":"source/assets/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1568199763468},{"_id":"source/assets/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1568199763469},{"_id":"source/assets/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1568199763470},{"_id":"source/assets/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1568199763469},{"_id":"source/assets/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1575112472249},{"_id":"source/assets/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1568886074783},{"_id":"source/assets/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1575112472249},{"_id":"source/assets/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1575112472249},{"_id":"source/assets/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1574943623105},{"_id":"source/img/3953273590_704e3899d5_m.jpg","hash":"50258aa007b4a30d3e49c8d52ffb2fe78a0a47ff","modified":1568179743000},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"e50411021e3c85860fc4b96f446267ba9871dcde","modified":1582802531910},{"_id":"themes/icarus/.history/_config_20200227194552.yml","hash":"49e60500f66cb377a59ce6c4ce4231454413e2bc","modified":1582804191091},{"_id":"themes/icarus/.history/_config_20200227194951.yml","hash":"91cb10160b86b7cfa2a738a968b11b6f04733df3","modified":1582804191984},{"_id":"themes/icarus/.history/_config_20200227195838.yml","hash":"4885f8887e761fd40f8600aa5600fedc98f8046b","modified":1582804718462},{"_id":"themes/icarus/.history/_config_20200227195541.yml","hash":"138b95c9765800be88301d088948ce105b00fe24","modified":1582804541465},{"_id":"themes/icarus/.history/_config_20200227195840.yml","hash":"4885f8887e761fd40f8600aa5600fedc98f8046b","modified":1582804720478},{"_id":"themes/icarus/.history/_config_20200227195939.yml","hash":"f20297385004473731eb52342b40ee61cabe0fb6","modified":1582804779651},{"_id":"themes/icarus/.history/_config_20200227200018.yml","hash":"efa67d925ad66267a1414d965152ef15a963fe79","modified":1582804818626},{"_id":"themes/icarus/.history/_config_20200227200019.yml","hash":"efa67d925ad66267a1414d965152ef15a963fe79","modified":1582804819481},{"_id":"themes/icarus/.history/_config_20200227200315.yml","hash":"a5bf4608b09b31f68ca4af0ae1432fe9c5727ae7","modified":1582804995211},{"_id":"themes/icarus/.history/_config_20200227200505.yml","hash":"f7647f6778110773dc4bdec40149f40171d00320","modified":1582805105725},{"_id":"themes/icarus/.history/_config_20200227200630.yml","hash":"c4ae62bdef2838372a6647edc7c06a396c4e1c98","modified":1582805190162},{"_id":"themes/icarus/.history/_config_20200227200743.yml","hash":"c4ae62bdef2838372a6647edc7c06a396c4e1c98","modified":1582805263703},{"_id":"themes/icarus/.history/_config_20200227200633.yml","hash":"c4ae62bdef2838372a6647edc7c06a396c4e1c98","modified":1582805193361},{"_id":"themes/icarus/.history/_config_20200227202614.yml","hash":"5971d8f9fb1111375f6308cf3753086ec7a8b7b5","modified":1582806374713},{"_id":"themes/icarus/.history/_config_20200227203141.yml","hash":"6cf43e3ff954246b494d5a86ef2b063dfa2b5487","modified":1582806701176},{"_id":"themes/icarus/.history/_config_20200227203638.yml","hash":"6cf43e3ff954246b494d5a86ef2b063dfa2b5487","modified":1582806998596},{"_id":"themes/icarus/.history/_config_20200227203640.yml","hash":"6cf43e3ff954246b494d5a86ef2b063dfa2b5487","modified":1582807000094},{"_id":"themes/icarus/.history/_config_20200228191845.yml","hash":"1d242f84a61e7b1678d08b46303f8188d50276e1","modified":1582888725633},{"_id":"themes/icarus/.history/_config_20200228193811.yml","hash":"b4f20e2897d2c9e15b8202500912cede7f58df54","modified":1582889891666},{"_id":"themes/icarus/.history/_config_20200228192222.yml","hash":"49c2d2edc77e58a3305790e8d37debb80a843277","modified":1582888942039},{"_id":"themes/icarus/.history/_config_20200228202111.yml","hash":"603362536c53c3e5ec5a425c50c70443299121a3","modified":1582892471248},{"_id":"themes/icarus/.history/_config_20200228204406.yml","hash":"b4f20e2897d2c9e15b8202500912cede7f58df54","modified":1582893846798},{"_id":"themes/icarus/languages/de.yml","hash":"ef43979c403b3a221585d5dd0b7205627437818e","modified":1582802531918},{"_id":"themes/icarus/languages/en.yml","hash":"55f97341ef33ccc685508aa262dd5c3b75eb5da8","modified":1582802531918},{"_id":"themes/icarus/languages/es.yml","hash":"f0ea2c482a8bc5ed43452ecc7ebe601504e0cc54","modified":1582802531919},{"_id":"themes/icarus/languages/fr.yml","hash":"b85a2d4fcc790a8b84326235850eb54532f6b75e","modified":1582802531919},{"_id":"themes/icarus/languages/id.yml","hash":"ee655e6a045eb28ea480a348bbefd10ef115494b","modified":1582802531919},{"_id":"themes/icarus/languages/ja.yml","hash":"3c921f24b19a797b2ae23cf621a35bb9b043ddf9","modified":1582802531919},{"_id":"themes/icarus/languages/ko.yml","hash":"2d12f3975b576afb025df773e30521b58abd015e","modified":1582802531920},{"_id":"themes/icarus/languages/pl.yml","hash":"a6dbd568cb18104685b20ab7b5767f455628f61c","modified":1582802531920},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"28ae713d8d26ab875104684e604592f4c495b638","modified":1582802531920},{"_id":"themes/icarus/languages/ru.yml","hash":"62451109780acfe2db8630248005697c10a68a61","modified":1582802531920},{"_id":"themes/icarus/languages/tr.yml","hash":"2e334f0f98756256754f48d8dff3baa045700283","modified":1582802531920},{"_id":"themes/icarus/languages/vn.yml","hash":"cd2d57a3fe6389bdd76f193c6c662d242960ed02","modified":1582802531921},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"1ca3f7b92872443c79b5f8026272b3bd21b4dd46","modified":1582802531921},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"3f66c8c96138784aca7bf2af5b72c5a8b8b47eab","modified":1582802531921},{"_id":"themes/icarus/layout/categories.ejs","hash":"5df2ae61ec3869d265113d695e2e25aaa60e8e67","modified":1582802531922},{"_id":"themes/icarus/layout/archive.ejs","hash":"32a56ca892464c5b91b27033eb4544848105f1a1","modified":1582802531922},{"_id":"themes/icarus/layout/category.ejs","hash":"3526103940eccd83937bcb6d1a59e9a285bec920","modified":1582802531922},{"_id":"themes/icarus/layout/index.ejs","hash":"44d905e3077e8a723ed6b714cca3047a68ce85e2","modified":1582802531929},{"_id":"themes/icarus/layout/page.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1582802531929},{"_id":"themes/icarus/layout/layout.ejs","hash":"14ffb4a07adc9f882166d4406996301f005b8162","modified":1582802531929},{"_id":"themes/icarus/layout/post.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1582802531933},{"_id":"themes/icarus/layout/tag.ejs","hash":"8ba86c65f9f4680266102344144a6669a241e0d8","modified":1582802531936},{"_id":"themes/icarus/layout/tags.ejs","hash":"9b185ad009855aa645e6fb5ccb28c022571852d0","modified":1582802531936},{"_id":"themes/icarus/scripts/index.js","hash":"9cfc27c4242440afa262218912698274c0eb5810","modified":1582802531940},{"_id":"source/_posts/Directory/Android Directory.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387698},{"_id":"source/_posts/Directory/Kotlin Directory.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387698},{"_id":"source/_posts/Directory/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387699},{"_id":"source/_posts/Kotlin/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387705},{"_id":"source/_posts/.history/hello-world_20200227105354.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1582891780523},{"_id":"source/_posts/.history/hello-world_20200228200940.md","hash":"4dfead1a938f8b500ea80dc56029b4f15c3034bd","modified":1582891780547},{"_id":"source/_posts/.history/hello-world_20200228201154.md","hash":"2d4fdd149fe56cbad8536f2aa7ae17e3531f880a","modified":1582891914359},{"_id":"source/_posts/.history/hello-world_20200228201457.md","hash":"d62952915059c3e1ff515e3975bc7c71708c48f0","modified":1582892097802},{"_id":"source/_posts/.history/hello-world_20200228201619.md","hash":"2d4fdd149fe56cbad8536f2aa7ae17e3531f880a","modified":1582892179450},{"_id":"source/_posts/.history/hello-world_20200228202609.md","hash":"e6796ecdde83984fb24ab09a3ad2b17f0f3e567f","modified":1582892769339},{"_id":"source/_posts/.history/hello-world_20200228205320.md","hash":"9d2a3dcd2820d484c7d849250cc49182e15278a9","modified":1582894400699},{"_id":"source/_posts/.history/hello-world_20200228205403.md","hash":"9d2a3dcd2820d484c7d849250cc49182e15278a9","modified":1582894443218},{"_id":"source/_posts/.history/hello-world_20200229095347.md","hash":"d24a82c53ff98af8f72dfac138fdeed9f93fd945","modified":1582941227193},{"_id":"source/_posts/.history/hello-world_20200229095420.md","hash":"b5391b82d72a6d1fbaa0620d83a8e6f93afdc334","modified":1582941260897},{"_id":"source/_posts/.history/hello-world_20200229095421.md","hash":"b5391b82d72a6d1fbaa0620d83a8e6f93afdc334","modified":1582941261650},{"_id":"source/_posts/.history/hello-world_20200229095646.md","hash":"64e09ad6ce5d9cee870008455975e0c9066a9ae1","modified":1582941406132},{"_id":"source/_posts/.history/hello-world_20200229095647.md","hash":"856d0cc1acc738b5c3e199e8dc24045f32173cb0","modified":1582941407906},{"_id":"source/_posts/Data_Structure/2017-07-27-data-structure-binary-tree-visit.md","hash":"c0458de61bf3329c55ba1a39110060b7e281ccd9","modified":1582944879698},{"_id":"source/_posts/Data_Structure/2017-07-27-data-structure-stack.md","hash":"fcde33b4afc4854faaffe32bd6c279d2b2437ee4","modified":1582944904425},{"_id":"source/_posts/Data_Structure/2017-07-31-data-structure-insert-sort.md","hash":"2d6f5b71f5846aa049d54960aabce5660683e048","modified":1582945562573},{"_id":"source/_posts/Data_Structure/2017-07-31-data-structure-search.md","hash":"10016da61b1024f48365dc5fb021b94b8823e6c5","modified":1582944933171},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-queue.md","hash":"50a10c10f4fb447ae2a6eb95204746e547d4a670","modified":1582945610470},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-radix-sort.md","hash":"8521721aa0d917e3debcb7892f98d62ae88598ff","modified":1582944958899},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary.md","hash":"958c4f4191488d904ab71e11a9cbc4e16b8da272","modified":1582944977798},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-stack-use.md","hash":"1531ca5c1abb76051b42cd828e3f937be05325f6","modified":1582944997263},{"_id":"source/_posts/Data_Structure/2017-08-04-data-structure-merge-sort.md","hash":"f152e0f1c63afd68a00a6e1ef8a80f23628bec7f","modified":1582945649727},{"_id":"source/_posts/Data_Structure/2017-08-04-data-structure-quick-sort.md","hash":"a99d985b1eef50ca68a7975b067ac0c279621cc6","modified":1582945662774},{"_id":"source/_posts/Data_Structure/2017-08-26-data-structure-adjaceny-matrix.md","hash":"58fa2f57a683652ee4f1934e8856a22408d11d42","modified":1582945954839},{"_id":"source/_posts/Data_Structure/2017-08-08-data-structure-threaded-binary-tree.md","hash":"4bd0bbb59e748028a746932f2ac540d10891789e","modified":1582946156111},{"_id":"source/_posts/Data_Structure/2017-08-26-data-structure-build-heap.md","hash":"800141a04fb0cde861d702d0bb3b8c679946648e","modified":1582945984558},{"_id":"source/_posts/Data_Structure/2017-08-27-data-structure-adjacency-list.md","hash":"206d81cd5e420e7633c3c9b58b49882cba81cbc7","modified":1582945764129},{"_id":"source/_posts/Data_Structure/2017-08-27-data-structure-heap-sort.md","hash":"9c49f1ebd93334fa71c2bf6a11a2ffbad727a88e","modified":1582945778054},{"_id":"source/_posts/Data_Structure/2017-08-28-data-structure-huffman-tree.md","hash":"bf2590ae8a967adf4ada4fafa98dd16bd7de08a4","modified":1582945802118},{"_id":"source/_posts/Directory/Java Directory.md","hash":"13fb0e571c973f7fb389d475b68061b9e6ee8262","modified":1569832122967},{"_id":"source/_posts/Directory/Other Directory.md","hash":"2b907e72131a8d568b572d44651f1b189e013889","modified":1569832122968},{"_id":"source/_posts/Java/README.md","hash":"24b0d9176a16957b14a6a943ed36c4feaac179bb","modified":1569832122977},{"_id":"source/_posts/Other/README.md","hash":"0bd2702af6d56ae251bd7dceb320714de41c59e3","modified":1570515581311},{"_id":"source/_posts/Other/函数式编程.md","hash":"516bdceada3fc781b46635a814e9c3496bd3af7b","modified":1568886074781},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1001.md","hash":"216702ce32c4e75d97c5c25307054d2e8cca20a7","modified":1582944785190},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1002.md","hash":"81415202c7625889ef55e3fb26d3213a0e9f946e","modified":1582944775709},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1005.md","hash":"32b53286ca86b04469e1c4538c1dfe5977b30be6","modified":1582944761919},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1007.md","hash":"6c2b70c543cf41f782f8900eb4094edc31b067e4","modified":1582944752008},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1008.md","hash":"26f3a2083f633e5bd8907a66cbf944df546db194","modified":1582944741946},{"_id":"source/_posts/PAT/2017-07-31-pat-advanced-1006.md","hash":"970d003b0b112c6406657291fe9d000a6651a29d","modified":1582944727434},{"_id":"source/_posts/PAT/2017-08-01-pat-advanced-1011.md","hash":"9ebe4a4bc65249944d8f4bb7050914132a6f8e42","modified":1582944713905},{"_id":"source/_posts/PAT/2017-08-01-pat-advanced-1060.md","hash":"fed4cefe0bd33490bd5a78d34e6da5c28bc86d7d","modified":1582944689639},{"_id":"source/_posts/assets/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1569027130121},{"_id":"source/_posts/assets/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1569027130121},{"_id":"source/_posts/assets/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1569027130122},{"_id":"source/_posts/assets/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1569027130123},{"_id":"source/_posts/assets/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1569027130123},{"_id":"source/_posts/assets/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1569027130124},{"_id":"source/_posts/assets/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1568199763467},{"_id":"source/_posts/assets/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1568199763467},{"_id":"source/_posts/assets/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1568199763468},{"_id":"source/_posts/assets/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1568199763468},{"_id":"source/_posts/assets/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1568199763469},{"_id":"source/_posts/assets/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1568199763469},{"_id":"source/_posts/assets/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1568199763470},{"_id":"source/_posts/assets/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1575112472249},{"_id":"source/_posts/assets/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1568886074783},{"_id":"source/_posts/assets/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1575112472249},{"_id":"source/_posts/assets/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1575112472249},{"_id":"source/_posts/assets/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1574943623105},{"_id":"source/img/20170726/Image11.png","hash":"e0c11295b7c6577b35cd0823489efeb2e05c547c","modified":1568179743000},{"_id":"source/img/20170726/Image1.png","hash":"a375dd730a00316fb9f483c48d01e75aded2c67e","modified":1568179743000},{"_id":"source/img/20170726/Image12.png","hash":"545907b9b1449448c3cadbfdd9da5aade1250ef4","modified":1568179743000},{"_id":"source/img/20170726/Image13.png","hash":"8d7cdf29bce3d2a83d6a14a688cc3c8f7cbed49d","modified":1568179743000},{"_id":"source/img/20170726/Image14.png","hash":"b24df030353b9fefae8015d044daf177fe05f5a1","modified":1568179743000},{"_id":"source/img/20170726/Image15.png","hash":"9fb214cc781a01dbb2dbe18fbc20fc800f6e8013","modified":1568179743000},{"_id":"source/img/20170726/Image17.png","hash":"8d41d9c4f3886a51d3f900edd6609fdd3d736890","modified":1568179743000},{"_id":"source/img/20170726/Image18.png","hash":"055331e05df5d64b605d2d58e5061672e108faaa","modified":1568179743000},{"_id":"source/img/20170726/Image2.png","hash":"43f9bfbfad80d540d57beda5480e67fc415f4b66","modified":1568179743000},{"_id":"source/img/20170726/Image3.png","hash":"127eccc0d73e654731ec779a7c28fb591b2ef28f","modified":1568179743000},{"_id":"source/img/20170726/Image4.png","hash":"e391f03b3787074d9f7be1ea7387848c350b0f35","modified":1568179743000},{"_id":"source/img/20170726/Image5.png","hash":"4eb6f78614962547a93913f98faf327203d1794f","modified":1568179743000},{"_id":"source/img/20170726/Image6.png","hash":"2b63aa98f0cedef44776a31e17fbc8cc0dbd84f3","modified":1568179743000},{"_id":"source/img/20170726/Image7.png","hash":"46ce3306766c3f5f19b4c97dea961e75b735ed9b","modified":1568179743000},{"_id":"source/img/20170726/Image8.png","hash":"fa5f08785a32a1982f4e1e8ce166ede400ad7958","modified":1568179743000},{"_id":"source/img/20170726/Image9.png","hash":"b9b8483009389028e67d0a5cd49731cf15f88e4b","modified":1568179743000},{"_id":"source/img/20170727/Image1.png","hash":"c1b937ef5f0ccffeb5f91696831af6d2deae2abf","modified":1568179743000},{"_id":"source/img/20170727/Image3.png","hash":"b6b42814093bbca53a964c22db752433097fed29","modified":1568179743000},{"_id":"source/img/20170727/Image4.png","hash":"36d2556b3af92a35ed0f937fd60c0fe5df28cdd3","modified":1568179743000},{"_id":"source/img/20170727/Image5.png","hash":"b327a63bb3e432fb28f3cd58950f172f3e9951d1","modified":1568179743000},{"_id":"source/img/20170727/Image6.png","hash":"b64ae70890b57d812838c5d8ee19583082087d6b","modified":1568179743000},{"_id":"source/img/20170727/Thumbs.db","hash":"e2c7562503f8eaa0557aaf1c1642fb45c16fd857","modified":1568179743000},{"_id":"source/img/20170731/Thumbs.db","hash":"dc573d7906b851495e4f5384d64e070bc179c2a7","modified":1568179743000},{"_id":"source/img/20170802/001.gif","hash":"e27cbb6e1860d72c6f980e717beaf1e51013b07e","modified":1568179743000},{"_id":"source/img/20170802/002.gif","hash":"ab765e2f86c6524c1c44597805966757e7628e6b","modified":1568179743000},{"_id":"source/img/20170802/004.jpg","hash":"011dc1b91ffc54c403dd3aa2eb00f6c405823fbb","modified":1568179743000},{"_id":"source/img/20170802/Thumbs.db","hash":"766f400ee841f98a0728569d5be4838dd4f9fdf9","modified":1568179743000},{"_id":"source/img/201807/view_model.png","hash":"ef194d46df905157b4c65466468fd4681f499270","modified":1568179743000},{"_id":"source/img/201807/service_lifecycle.png","hash":"5c1d2bf331a1475fccd7e91f29af4e5a7b26f9b4","modified":1568179743000},{"_id":"source/img/201807/view_model1.png","hash":"4ba78ac2452498f9e27df4bd91727f7eca4a7220","modified":1568179743000},{"_id":"source/img/201807/view_model2.png","hash":"3b13867ed6ef01bad9bd6d4d6678bb11d1be541c","modified":1568179743000},{"_id":"source/img/DataStructure/adjacency_list1.png","hash":"cb0b1017a9c47dc6cfae862436b34d7177e7aca3","modified":1568179743000},{"_id":"source/img/DataStructure/adjacency_matrix1.png","hash":"810a07fbc8e384a32fa69a556d22290b94343e14","modified":1568179743000},{"_id":"source/img/DataStructure/adjacency_matrix2.png","hash":"956ce82807f386760265152a560c21bb1a209e4c","modified":1568179743000},{"_id":"source/img/DataStructure/adjacency_matrix3.png","hash":"753eb3efbe2a104e3659a46f395e0e3e0c348ee9","modified":1568179743000},{"_id":"source/img/DataStructure/binary_tree.jpg","hash":"f124b7ead17dc866c7726d5c0095de35f0338231","modified":1568179743000},{"_id":"source/img/DataStructure/binary_tree_result.png","hash":"6e887cacde537b36a667ba915033e54138a1f396","modified":1568179743000},{"_id":"source/img/DataStructure/heap3.jpg","hash":"37a570aaa9ce98c1b619c55121297d9f689725b7","modified":1568179743000},{"_id":"source/img/DataStructure/heap2.jpg","hash":"ff257b33be988c0f480fd2298d8b656b8e335198","modified":1568179743000},{"_id":"source/img/DataStructure/heap_sort.jpg","hash":"eb5166b07005b4bbf2b5937b2e12eff1f5fdc396","modified":1568179743000},{"_id":"source/img/DataStructure/heap7.jpg","hash":"1f62e84ec84a32f5cc47c21d6367a7bbc1f7940b","modified":1568179743000},{"_id":"source/img/DataStructure/quick_sort.jpg","hash":"a83f57425b47b1087d74a6c4ee22cc632a460eea","modified":1568179743000},{"_id":"source/img/DataStructure/huffman_tree1.png","hash":"1bcf8ad33c94ff370c9e7a022c618bc108216d51","modified":1568179743000},{"_id":"source/img/DataStructure/quick_sort_01.jpg","hash":"7bf4d9c95393f6f764a27c7b649ee0454859ee55","modified":1568179743000},{"_id":"source/img/DataStructure/huffman_tree3.png","hash":"0c3d5180fbfc7560effb45068ed45fd32993fe57","modified":1568179743000},{"_id":"source/img/DataStructure/thread_binary_tree.jpg","hash":"4eae3ccc3de99620b5c978925919e747efcff67c","modified":1568179743000},{"_id":"source/img/DataStructure/threaded_binary_tree.jpg","hash":"42c53b95e0112e8b0407178fb6b83b2fe5e49105","modified":1568179743000},{"_id":"source/img/head/abstract-1.jpg","hash":"d0715ea88f6d2b141fc61a26ebdc2bdae5e22daf","modified":1568179743000},{"_id":"source/img/head/abstract-10.jpg","hash":"a28c4d5b2d376a27b6cb110618ed5f5015db8b88","modified":1568179743000},{"_id":"source/img/head/abstract-3.jpg","hash":"f9cfd59619122ce6abd3c16773e2b94dd30e8a14","modified":1568179743000},{"_id":"source/img/head/abstract-4.jpg","hash":"ec72f4266c0b8b26c54acd3cf0592ffbd2b0cd83","modified":1568179743000},{"_id":"source/img/head/abstract-5.jpg","hash":"59e43d16c6c0e78a570b1c048a7e1ee6b2a66809","modified":1568179743000},{"_id":"source/img/head/abstract-6.jpg","hash":"5ed0c433cbbfa810f85fe44bac49a01abd722cba","modified":1568179743000},{"_id":"source/img/head/abstract-7.jpg","hash":"461d49385ff51918bc8f951a64c4811a31a77170","modified":1568179743000},{"_id":"source/img/head/abstract-8.jpg","hash":"5927dc5eff774995feca29cbe2ab0a3c53f22130","modified":1568179743000},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"b921f7ab80c3de92291ce2c9081baa4464133787","modified":1582802531911},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"7c7cec251070d72c33139d5c19bef03dc9a57e15","modified":1582802531911},{"_id":"source/img/DataStructure/huffman_tree.png","hash":"8c4fa46aaf9c54f20a937ef0cac565e7c2422c61","modified":1568179743000},{"_id":"themes/icarus/includes/common/utils.js","hash":"4099226113e3d631b58452f529d58cf00758fd24","modified":1582802531911},{"_id":"themes/icarus/includes/generators/categories.js","hash":"6aef75f08a11a06e5c72d9b0b768c3aa7462080c","modified":1582802531912},{"_id":"themes/icarus/includes/generators/category.js","hash":"1f40399fc0d56f89490d669c6399cd40b9465e93","modified":1582802531912},{"_id":"themes/icarus/includes/generators/insight.js","hash":"8fcac981ab9537fc110ff8a6d00f67bd6f41aeec","modified":1582802531912},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"10ed3f19f2bc317e4c706f74bc8cc27c87c533e4","modified":1582802531912},{"_id":"themes/icarus/includes/helpers/config.js","hash":"f1becefd247f03bf5b31347ffda23e9480bb4566","modified":1582802531913},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"f020fad32fd9977a17b19b755bb9e5fd506fc5a9","modified":1582802531913},{"_id":"themes/icarus/includes/helpers/override.js","hash":"ede8fc3132b2ab557d51b521264d5574fc8fb6d0","modified":1582802531913},{"_id":"themes/icarus/includes/helpers/site.js","hash":"4142e0b3418ff2ef186979d8bb7023f54ca3185d","modified":1582802531913},{"_id":"themes/icarus/includes/helpers/page.js","hash":"1486792ec2528fa656ad258d588a6d261bd94467","modified":1582802531913},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"7625a4adbaaf4ce80ef4af2c34b4cdae194a0c4b","modified":1582802531914},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"e2a6c34d7ac9a5af828670da4ff1ce92ed298e49","modified":1582802531914},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"90ccc9987856958eb3ddf5a1a0ed564e7098559f","modified":1582802531914},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"bc47f29f158b5c61de45c3b7ab7b8932e145bed6","modified":1582802531914},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"6b65be067c332fba3c901e863a5802089a2149a3","modified":1582802531915},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"5424cb681dbb475908f3708d8635380cf48a610e","modified":1582802531915},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"1920b18326cae129b92973a8954d922e3b5449fe","modified":1582802531915},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"cb99fedec56fb1b1df72d90769d245fb0dd08a9d","modified":1582802531915},{"_id":"themes/icarus/includes/generators/tags.js","hash":"ee929b68019b4759099d292257971d3267c5abd7","modified":1582802531912},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"1ef55aafe89be3b3aee110cbea319ff0a7cf0df8","modified":1582802531915},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"cde56bce96c74ea40d8ebe5824e0b6b0b46c051a","modified":1582802531915},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"222a535e4fe9517ca4b6089a704fd38d6bec1a8a","modified":1582802531916},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"cf52737b5be1d3e8a71af89ec617cb12ea39393f","modified":1582802531916},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"b36aa88d2fc573eaa97df93ce5e00ad8610f6f16","modified":1582802531916},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"82045466b47540eaaac619f6d4365115860abfa7","modified":1582802531916},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"a69b003cd482c2fe4495705c5e075d73e7e54ceb","modified":1582802531917},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"d7d0c360ae885a2bf1ebcb7089265bf524da5af6","modified":1582802531917},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"73d0ff7bc3e40d7178fb5627fec2a41c15c585e6","modified":1582802531917},{"_id":"themes/icarus/includes/utils/lru.js","hash":"0538e293f46091315938ed7fc87ecaf3a53f8d19","modified":1582802531917},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"e5e0c9c0fe24352d5e3f06370fe29597831824ce","modified":1582802531922},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"4361769d1aa3a321da6de8891bfe668c1bf7ba77","modified":1582802531923},{"_id":"themes/icarus/layout/comment/changyan.locals.js","hash":"ebbf95d3d6fe947f8f2b70363148a389cec04df5","modified":1582802531923},{"_id":"themes/icarus/layout/comment/disqus.locals.js","hash":"14c7a55a0c3be3185c52e5bc9ce82bb505758790","modified":1582802531923},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"780e933c7b2297843208c78085f7ab99f63dec38","modified":1582802531923},{"_id":"themes/icarus/layout/comment/facebook.locals.js","hash":"e63545f9b9ce54fcd5d0fdf97a0dfe3fb552f0d8","modified":1582802531923},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"d52b3569994ad85e3b809b96173ca44097c83c09","modified":1582802531924},{"_id":"themes/icarus/layout/comment/gitalk.locals.js","hash":"f1f2e209d34ec15137b09c4840e51932aa82010c","modified":1582802531924},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"d5e1a396e23df4e75e139d12846290bdb08ba01e","modified":1582802531924},{"_id":"themes/icarus/layout/comment/gitment.locals.js","hash":"f1f2e209d34ec15137b09c4840e51932aa82010c","modified":1582802531924},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"55bfe636859f118b40750bd36e2c3ef1a2ec4c0e","modified":1582802531924},{"_id":"themes/icarus/layout/comment/isso.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531924},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"792a1e44b71ed8048903ea898aeaf74a6c109037","modified":1582802531925},{"_id":"themes/icarus/layout/comment/livere.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531925},{"_id":"themes/icarus/layout/comment/utterances.ejs","hash":"fac2c6382d8ea93c1aab9dab16fbce6c12193269","modified":1582802531925},{"_id":"themes/icarus/layout/comment/utterances.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531925},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"31471cd05018583249b4c09a78cf1d02e7987244","modified":1582802531925},{"_id":"themes/icarus/layout/comment/valine.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531925},{"_id":"themes/icarus/layout/common/article.ejs","hash":"ac22def9b6229dd4102c18b4e6aae3329e6f87a5","modified":1582802531926},{"_id":"themes/icarus/layout/common/article.locals.js","hash":"5330bb3f8dbebd7add4be133b0f43741b7615dbe","modified":1582802531926},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"d8c5406073d284b37bf0eed0805f67acd5761616","modified":1582941144229},{"_id":"themes/icarus/layout/common/footer.locals.js","hash":"9a8a5f8e7cb746a46262deeed64a61d3ecda9d1b","modified":1582802531926},{"_id":"themes/icarus/layout/common/head.ejs","hash":"0942538abea7c9b4b6db418d9c45e894cb0beb25","modified":1582802531927},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"a112cebca5316ed444103efc6de298e9dc355d77","modified":1582802531927},{"_id":"themes/icarus/layout/common/navbar.locals.js","hash":"c489aec088b079da7e93a7be59720a4e658c7dff","modified":1582802531927},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"92efd4c3f4a47d8423fe7e09ecdddb2e335553cc","modified":1582802531927},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"ab31313e825d65d4d5a633225814a881a90f07d5","modified":1582802531927},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"4e316230392bc8aa84d61306832cecce8544d1dc","modified":1582802531928},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"c3b24c01f6d9ae8aac4dab9af658ba7b6566419f","modified":1582802531928},{"_id":"themes/icarus/layout/donate/alipay.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531928},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"79171794ca43d66b8f7ed549f96dc6e46bfd5b76","modified":1582802531928},{"_id":"themes/icarus/layout/donate/patreon.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531928},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"969b013fff396934543adb868dfec7cef6eee392","modified":1582802531929},{"_id":"themes/icarus/layout/donate/paypal.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531929},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"456b0dcdd005ff04210c1cebbddd2b9fa2a94dca","modified":1582802531929},{"_id":"themes/icarus/layout/donate/wechat.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531929},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"d83bf233d398ef3bb3c9a93a101cf4e0a1d8c58f","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/animejs.locals.js","hash":"57a0770ed07b5ffb2220a296fb862fd2dea9b9b2","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"371699761b0eceeffba2d6adb53b045d516b3660","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/back-to-top.locals.js","hash":"57a0770ed07b5ffb2220a296fb862fd2dea9b9b2","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"b29d5b8e6c155010a18fac71d9e6dc0d5e0d0db4","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/baidu-analytics.locals.js","hash":"b0c5adc41f9f9f764e9760b5b8b72c6dc705d95c","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"4285b0ae608c7c54e4ecbebb6d22d4cd1be28f70","modified":1582802531930},{"_id":"themes/icarus/layout/plugin/busuanzi.locals.js","hash":"20267ab6493a0863be1bf2d4dfad5604546c7210","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"5415bb022663c94ad0125f87e909ab2ee86b40c4","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"810948096dec70a55cc68d443d50faef9e8d76ca","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/gallery.locals.js","hash":"69a5297ab1b5d055fb557113f7867404ab9b5ef4","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/google-analytics.locals.js","hash":"b0c5adc41f9f9f764e9760b5b8b72c6dc705d95c","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"46622b19f0b6a3a8db6183f82f72a93a2b862ec4","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/hotjar.locals.js","hash":"3ea362b078fd7340807c85eabb6aa45690bd2bea","modified":1582802531931},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"3cf9f7eb54d9074746a4f7d56f25904417692beb","modified":1582802531932},{"_id":"themes/icarus/layout/plugin/mathjax.locals.js","hash":"22956a4f26fb3db4365d74b2cb0b57b8a0139293","modified":1582802531932},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"3f4a588a5a7221697a8d6889753bacae8a2e7b37","modified":1582802531932},{"_id":"themes/icarus/layout/plugin/outdated-browser.locals.js","hash":"69a5297ab1b5d055fb557113f7867404ab9b5ef4","modified":1582802531932},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"9f5c9821483062ed3eb043d7c6fb8a840936e063","modified":1582802531932},{"_id":"themes/icarus/layout/plugin/progressbar.locals.js","hash":"20267ab6493a0863be1bf2d4dfad5604546c7210","modified":1582802531932},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"c5a79c1450abf38317e697ef7a819858ff6ae898","modified":1582802531933},{"_id":"themes/icarus/layout/search/baidu.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531933},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"1a00151869919b230f1c0a0bec10475e24b81c97","modified":1582802531933},{"_id":"themes/icarus/layout/search/google-cse.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531934},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"b22352d27cd0636898207a840a20b6c85267b23b","modified":1582802531934},{"_id":"themes/icarus/layout/search/insight.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531934},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"9cc26da261527bbba8b0180e0f73e0c6ae5416b5","modified":1582802531935},{"_id":"themes/icarus/layout/share/addthis.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531935},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"04930e5dde7d47ddb1375730504edbfb59afaed5","modified":1582802531935},{"_id":"themes/icarus/layout/share/addtoany.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531935},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"90e24e50c1dc18c22fbb9fa24320bf669e8a6283","modified":1582802531935},{"_id":"themes/icarus/layout/share/bdshare.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531935},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"b59c0708480ead768d15ef53ce028b5f1a715960","modified":1582802531936},{"_id":"themes/icarus/layout/share/sharejs.locals.js","hash":"74ca321ba6b946dd41081048f365845df9091817","modified":1582802531936},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"307d905cd39ac4908ef5589829a18777f314428d","modified":1582802531936},{"_id":"themes/icarus/layout/share/sharethis.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531936},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"96950a7e27b7b0b808d5b5a81f192d5e0fec1967","modified":1582802531936},{"_id":"themes/icarus/layout/widget/archive.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531937},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"17e58e537645c4434a1140377ae3e7f43cca4927","modified":1582802531937},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"bf99172a93b4c2ca6b6c8763d96ed1aba9dc7556","modified":1582802531937},{"_id":"themes/icarus/layout/widget/category.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531937},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"443c7dd3c3e11c5f1dec6e63f49dee48a2e0f315","modified":1582802531937},{"_id":"themes/icarus/layout/widget/links.locals.js","hash":"858444815fa442a871ba0bd9b1ce2e7b27297245","modified":1582802531937},{"_id":"themes/icarus/layout/widget/profile.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582802531938},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"53768bf260c34f8621aaf14911d3f97ad5b58053","modified":1582802531938},{"_id":"themes/icarus/layout/widget/recent_posts.locals.js","hash":"78c28ef3ec6e8c4e21c1f8296f58c370e429eb1c","modified":1582802531938},{"_id":"themes/icarus/layout/widget/subscribe_email.ejs","hash":"5aa11b4b076ed147b0b2566ce215d245493e9de2","modified":1582802531938},{"_id":"themes/icarus/layout/widget/subscribe_email.locals.js","hash":"4e4e2510d22e1650faf6c7818b3a117abcba789d","modified":1582802531938},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"e41aff420cc4ea1c454de49bd8af0e7a93f3db3f","modified":1582802531939},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"9c22ce29afca4ed6261eaf86d7393b0c73334ff4","modified":1582802531939},{"_id":"themes/icarus/layout/widget/tagcloud.locals.js","hash":"01915ead507c6acaf66effac75bc3babed8a48bc","modified":1582802531939},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"4d86e28e0008997435b8faa786db6e56b7133aef","modified":1582802531939},{"_id":"themes/icarus/layout/widget/toc.locals.js","hash":"a8e3bbbdf8f36f94ded34ff908ce74526b94e3da","modified":1582802531940},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"ab0304e684db5e2f45520a511df5aa36a04d2f2a","modified":1582802531941},{"_id":"themes/icarus/source/css/insight.css","hash":"10aedd26a4930166b826d72b25cdbd509609b84b","modified":1582802531941},{"_id":"themes/icarus/source/css/progressbar.css","hash":"a3ef2b1ee0ee0889a82c3c693e53139fd4c0d143","modified":1582802531941},{"_id":"themes/icarus/source/css/search.css","hash":"b2fb780ce22684998a47b282a57f603511b040b2","modified":1582802531941},{"_id":"themes/icarus/source/css/style.styl","hash":"802ac5c845a2fd7979bec8fc88a9ec35aca22942","modified":1582802531942},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1582802531942},{"_id":"themes/icarus/source/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1582802531942},{"_id":"themes/icarus/source/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1582802531943},{"_id":"themes/icarus/source/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1582802531944},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1582802531944},{"_id":"themes/icarus/source/images/wechat_donate.png","hash":"34177b6a5d7eb05babc4a5fd1b7952daf65056cf","modified":1582804364277},{"_id":"themes/icarus/source/js/animation.js","hash":"eabfccd284ca67920dd7977aa664d8b32b1911f7","modified":1582802531944},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"0c59b27d77fbf53fe9197d0856f87114b2bb33aa","modified":1582802531945},{"_id":"themes/icarus/source/js/gallery.js","hash":"c161252f214d787a9fd895c4c5124579169445d1","modified":1582802531945},{"_id":"themes/icarus/source/js/main.js","hash":"bc2267b464ae86d972088d2fdc9da4f608015f4e","modified":1582802531945},{"_id":"themes/icarus/source/js/insight.js","hash":"c8669315f46c197efe9e9cd448d5b983049f348d","modified":1582802531945},{"_id":"source/_posts/Android/Other/Groovy介绍.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569832122958},{"_id":"source/_posts/Android/View/ActionBar和ToolBar的使用.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569832122961},{"_id":"source/_posts/Android/框架/RxJava2.0.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074750},{"_id":"source/_posts/Java/Java基础/Java 输入输出操作.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074768},{"_id":"source/_posts/Java/Java多线程/Java锁机制.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074777},{"_id":"source/_posts/Java/Java虚拟机/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074778},{"_id":"source/_posts/Kotlin/Kotlin基础/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1574943623104},{"_id":"source/_posts/Other/Git/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074780},{"_id":"source/_posts/Other/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568189080930},{"_id":"source/img/20170726/Image16.png","hash":"90c9977aaafb00de1689593624021b02ad144a96","modified":1568179743000},{"_id":"source/img/20170731/001.png","hash":"a5205f3db29fe11646ad8c0c580daef28b2473c4","modified":1568179743000},{"_id":"source/img/20170731/insertsort.gif","hash":"5fc8daa9296837453ccbc8c7f9c2494bbd1fcdda","modified":1568179743000},{"_id":"source/img/DataStructure/Merge_sort.gif","hash":"8c074d46d4c96077d11f9e8cab9ff5d95bdc3da0","modified":1568179743000},{"_id":"source/img/DataStructure/adjacency_list.jpg","hash":"44905436617f72027e8001cc11f74694508e78a6","modified":1568179743000},{"_id":"source/img/DataStructure/adjacency_matrix.jpg","hash":"b9a9e2e34290fa182102bec682ae532be806025d","modified":1568179743000},{"_id":"source/img/DataStructure/heap.jpg","hash":"f2f37a05d4bda669871ad1efc123a69621657406","modified":1568179743000},{"_id":"source/img/DataStructure/heap1.jpg","hash":"96a7319b82d0dc5e949799cc57a1a272672f85b9","modified":1568179743000},{"_id":"source/img/DataStructure/heap5.jpg","hash":"74d134ee991b8afec74f5a9f9b18df3c28122bb4","modified":1568179743000},{"_id":"source/img/DataStructure/heap8.jpg","hash":"109e6c65abd6a6d02d127dd4c95bc0bd0972d3fd","modified":1568179743000},{"_id":"source/img/DataStructure/huffman_tree2.jpg","hash":"d6a9e2244379a111969c694004d7efb42a8a901b","modified":1568179743000},{"_id":"source/img/head/abstract-11.jpg","hash":"5530006198c8661d073c2abe6450c5281f2c1f9b","modified":1568179743000},{"_id":"source/img/head/abstract-12.jpg","hash":"1909308a3be803cb2a8884fee01544c374e0f671","modified":1568179743000},{"_id":"source/img/head/abstract-2.jpg","hash":"8c427ec200839e10e871857fbc485cf8a0f89783","modified":1568179743000},{"_id":"source/img/head/head4.jpeg","hash":"7e2ed107864f98ddbd40bf8a5d95f932f494c9ff","modified":1568179743000},{"_id":"themes/icarus/source/images/avatar.jpg","hash":"08eaa857c1a207880486fa8745233d56f624664a","modified":1582799224671},{"_id":"themes/icarus/source/images/alipay_donate.png","hash":"451d6a847df4bd48e0c0217242fe357f4e31e3ff","modified":1582804415019},{"_id":"source/_posts/.history/Data_Structure/2017-07-27-data-structure-binary-tree-visit_20190911132902.md","hash":"1894d5df7112d753949d818b9ceac33b25d8950b","modified":1582944879693},{"_id":"source/_posts/.history/Data_Structure/2017-07-27-data-structure-binary-tree-visit_20200229105439.md","hash":"c0458de61bf3329c55ba1a39110060b7e281ccd9","modified":1582944879714},{"_id":"source/_posts/.history/Data_Structure/2017-07-27-data-structure-stack_20190911132902.md","hash":"868312b8dd7e7fbed492459f577cc937051712b3","modified":1582944904420},{"_id":"source/_posts/.history/Data_Structure/2017-07-27-data-structure-stack_20200229105504.md","hash":"fcde33b4afc4854faaffe32bd6c279d2b2437ee4","modified":1582944904442},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20190911132902.md","hash":"fde4a999bf4ba8b72b662fc1a7aa316f6683a744","modified":1582944918298},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229105518.md","hash":"5b206218e8724f54ca9eedcf6274ba529c78952b","modified":1582944918336},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-search_20190911132902.md","hash":"510bf336ef47a882786db088cf4e678a3a1c01ba","modified":1582944930459},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-search_20200229105530.md","hash":"d8d8962f3bb41cd6e7a32c34e9d7a772b82e3d1d","modified":1582944930479},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-search_20200229105533.md","hash":"10016da61b1024f48365dc5fb021b94b8823e6c5","modified":1582944933187},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-queue_20190911132902.md","hash":"ec485b55b84474d8af93616d7aa1f23043d1ea7f","modified":1582944947307},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-queue_20200229105547.md","hash":"b11ee7e784ff8e8b6bc79dfc2d78ea2cd72deb05","modified":1582944947343},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-radix-sort_20190911132902.md","hash":"83975c6242d7bcbe37812990a120667ade1afec0","modified":1582944958895},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-radix-sort_20200229105558.md","hash":"8521721aa0d917e3debcb7892f98d62ae88598ff","modified":1582944958917},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary_20190911132902.md","hash":"9e2fd7ec3c722c6e5262d63c9a490dee7f47b866","modified":1582944977794},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary_20200229105617.md","hash":"958c4f4191488d904ab71e11a9cbc4e16b8da272","modified":1582944977814},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-stack-use_20190911132902.md","hash":"579f70c3d74af06d5ac66c5af4dee813843852f7","modified":1582944997260},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-stack-use_20200229105637.md","hash":"1531ca5c1abb76051b42cd828e3f937be05325f6","modified":1582944997288},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-merge-sort_20190911132902.md","hash":"c84bd9a85034bff3c5f5dddd141ddea367bf20ba","modified":1582945013261},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-merge-sort_20200229105653.md","hash":"3365a60eac34483fbe7b0f4f97d5b5e11db6309c","modified":1582945013280},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-quick-sort_20190911132902.md","hash":"295341389b1d5732173b2edebc4ec300790eb849","modified":1582945027597},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-quick-sort_20200229105707.md","hash":"2cd0bb2c8606b6ed84fae8c8e3b4d78033444d6f","modified":1582945027617},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-quick-sort_20200229105709.md","hash":"62393f6b8e57fb8420284e540e0e49b47a7d42ff","modified":1582945029863},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20190911132902.md","hash":"ad669547e7155c8e8ab0ae36b88d3ecc940c837e","modified":1582945052157},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20200229105732.md","hash":"f186fe085f91be026777a269fb41e14fd73e62b3","modified":1582945052180},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-adjaceny-matrix_20190911132902.md","hash":"a687cffcbf7c70bf6dece60550c7b7733368fff6","modified":1582945072693},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-adjaceny-matrix_20200229105752.md","hash":"ced6017a4569d7018f90fc886269cec67d6bfe8c","modified":1582945072730},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-build-heap_20190911132902.md","hash":"6df924e2311aa29c129e561db6f876c476bce963","modified":1582945085645},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-build-heap_20200229105805.md","hash":"0899be962d5c162256488902a534c958bd86983a","modified":1582945085665},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-adjacency-list_20190911132902.md","hash":"bc05f4ebe297f4ea1c486b15de5fa82f32d9dcf8","modified":1582945111269},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-adjacency-list_20200229105831.md","hash":"fde4ad976ca71db22309c9f946c66da0364c59db","modified":1582945111287},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-heap-sort_20190911132902.md","hash":"0bb1bf03d25c3207778798655507c394e6fef4dc","modified":1582945121571},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-heap-sort_20200229105841.md","hash":"edb09205af66a11b80d27d68ae8bafa6031df444","modified":1582945121591},{"_id":"source/_posts/.history/Data_Structure/2017-08-28-data-structure-huffman-tree_20190911132902.md","hash":"01ecbef90fda2126a3a29a7bd3fc97352d411e6c","modified":1582945130140},{"_id":"source/_posts/.history/Data_Structure/2017-08-28-data-structure-huffman-tree_20200229105850.md","hash":"6a53ec02c82bc803cf0727b313b82773862ea663","modified":1582945130159},{"_id":"source/_posts/.history/Data_Structure/2017-08-28-data-structure-huffman-tree_20200229105917.md","hash":"909a7375c7f2b9f26d6fcb304096daaf1c991b45","modified":1582945157424},{"_id":"source/_posts/.history/Data_Structure/2017-08-28-data-structure-huffman-tree_20200229105922.md","hash":"4eb497836370237ee1df2fd4fb596f66e1dc8af1","modified":1582945162317},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1001_20190911132902.md","hash":"8496192ee79331cbeba223832d69ae1918a4c848","modified":1582944572709},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1001_20200229104932.md","hash":"f9d539c2c42d9554bc4f614632bf588f4230b8b4","modified":1582944572769},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1001_20200229105036.md","hash":"28b2d952a8c758d844639b31d25c07b9c54469f2","modified":1582944636805},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1001_20200229105305.md","hash":"216702ce32c4e75d97c5c25307054d2e8cca20a7","modified":1582944785206},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1002_20190911132902.md","hash":"6efc042273df64c87a6198cebc83d17645ae41da","modified":1582944775707},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1002_20200229105255.md","hash":"81415202c7625889ef55e3fb26d3213a0e9f946e","modified":1582944775729},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1005_20190911132902.md","hash":"fe65b66be28db6e220a3b8c62e50bd90e71a0a46","modified":1582944761916},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1005_20200229105241.md","hash":"32b53286ca86b04469e1c4538c1dfe5977b30be6","modified":1582944761934},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1007_20190911132902.md","hash":"88ec539e44336ff72523970dccb458efe4086d84","modified":1582944752003},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1007_20200229105232.md","hash":"6c2b70c543cf41f782f8900eb4094edc31b067e4","modified":1582944752030},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1008_20190911132902.md","hash":"d167a64defe8522a755601241fd9aec12805bb89","modified":1582944741941},{"_id":"source/_posts/.history/PAT/2017-07-27-pat-advanced-1008_20200229105221.md","hash":"26f3a2083f633e5bd8907a66cbf944df546db194","modified":1582944742020},{"_id":"source/_posts/.history/PAT/2017-07-31-pat-advanced-1006_20190911132902.md","hash":"bf9f16906d05e14b2e99fd34dc3fe63dcc0be45d","modified":1582944727430},{"_id":"source/_posts/.history/PAT/2017-07-31-pat-advanced-1006_20200229105207.md","hash":"970d003b0b112c6406657291fe9d000a6651a29d","modified":1582944727453},{"_id":"source/_posts/.history/PAT/2017-08-01-pat-advanced-1011_20190911132902.md","hash":"0f89600587bbf0c2848ae211742d3b32323748c6","modified":1582944713900},{"_id":"source/_posts/.history/PAT/2017-08-01-pat-advanced-1011_20200229105153.md","hash":"9ebe4a4bc65249944d8f4bb7050914132a6f8e42","modified":1582944713922},{"_id":"source/_posts/.history/PAT/2017-08-01-pat-advanced-1060_20190911132902.md","hash":"63fbb04e911a4f02c61f51a343104f0699d77427","modified":1582944689634},{"_id":"source/_posts/.history/PAT/2017-08-01-pat-advanced-1060_20200229105129.md","hash":"fed4cefe0bd33490bd5a78d34e6da5c28bc86d7d","modified":1582944689660},{"_id":"source/_posts/Android/Advanced/应用启动流程.md","hash":"a58fff4d430f4f621334f42b9d5516b05cc97a7c","modified":1569832122949},{"_id":"source/_posts/Android/Android JNI/Android JNI敏感信息保护.md","hash":"8ed1df1c39fae52463680f8ec6c97b5771aa5829","modified":1569027130111},{"_id":"source/_posts/Android/Android JNI/Android Studio JNI引入.md","hash":"add31391ebb33ebab227c43ceaf6d3725d70a05e","modified":1569572634029},{"_id":"source/_posts/Android/Android反编译/Android应用防止二次打包.md","hash":"2e7b9abf111de9139789e381821a93c35a4ba20b","modified":1575112472181},{"_id":"source/_posts/Android/Android基础/2018-07-31-android-service-introduction.md","hash":"d74550da0aa141878bd8581e5484db723d20056a","modified":1582946222276},{"_id":"source/_posts/Android/Android基础/2018-08-01-android-broadcast-introduction.md","hash":"953c2f488c2cd78f6cb7d246dc05def26dc17287","modified":1582944804912},{"_id":"source/_posts/Android/Android基础/2018-08-09-android-ViewModel-introduction.md","hash":"9ebc58ae00a9f23acf7deadcdcb2d7c4c8d662af","modified":1582946203550},{"_id":"source/_posts/Android/Android基础/Android 6.0动态权限获取.md","hash":"68ffbb4bfcecd76e89eb52376ecadf052f195dd7","modified":1582942026918},{"_id":"source/_posts/Android/Android基础/Android后台任务.md","hash":"c184467607dff62825ed43781d74051b81e5e511","modified":1569832122954},{"_id":"source/_posts/Android/Android基础/Android序列化.md","hash":"306b94cf57b3ed51b14b4e1cee5e114206968f42","modified":1575112472183},{"_id":"source/_posts/Android/Android基础/Android文件操作.md","hash":"be7f0b0a418b2171365576bf44534c58342ac721","modified":1569832122954},{"_id":"source/_posts/Android/Android基础/Handler Looper介绍.md","hash":"8d223a887d0a52cfa5b39d6d517f694def0b954b","modified":1569832122955},{"_id":"source/_posts/Android/Android基础/getSystemService的使用.md","hash":"99ff57afc3eec0af7400ce4a3ec561e6ea6e4425","modified":1569832122956},{"_id":"source/_posts/Android/Android基础/异步操作Asynctask.md","hash":"c13b42d8a167b45bc9e896d5156045908b235af0","modified":1569832122957},{"_id":"source/_posts/Android/Android基础/数据储存.md","hash":"5290902296e6a6b3d7d085229845e565bb6f7a2f","modified":1575112472183},{"_id":"source/_posts/Android/Ble/Android ble 4.0.md","hash":"e7f3d5879c4f49a78f98d19eae1ea7b4c38d7eb1","modified":1568886074745},{"_id":"source/_posts/Android/Other/Module的.gradle配置.md","hash":"5ba2bcf9e2eeb98e512290033e5f7e36221ad158","modified":1569832122959},{"_id":"source/_posts/Android/Other/常用操作.md","hash":"24cdf5e606de40677f384604324c8e75b873bbba","modified":1569832122960},{"_id":"source/_posts/Android/View/CountDownView.md","hash":"34969feb7164adf78ab07cff7163dda1a4bea976","modified":1568886074746},{"_id":"source/_posts/Android/View/LayoutInflater使用.md","hash":"1f81cd7a8c86ab03baababb5ae1b1f7362e97cdf","modified":1569832122961},{"_id":"source/_posts/Android/View/Materials Design.md","hash":"20db81d50ec3504c11ff3157c9cc825b0f774a0a","modified":1569832122962},{"_id":"source/_posts/Android/View/使用RecyclerView和SearchView实现查找删除.md","hash":"eb84bdcb6a53bbc1057ef874e2f07bb5b4226959","modified":1568886074746},{"_id":"source/_posts/Android/框架/Dagger2.md","hash":"74838a04cf11a7e2176bcbe03cd112ab4fd834a7","modified":1582697579620},{"_id":"source/_posts/Android/框架/Retrofit 2.5 框架使用与源码分析.md","hash":"63ecd99aa82c8f2ce3c04d86357d1837cf669f88","modified":1582941528659},{"_id":"source/_posts/Android/框架/fastjson的使用.md","hash":"9fbf6f1dc654a1fffe925b3bc53a408ffc0258a6","modified":1575112472191},{"_id":"source/_posts/Java/Java基础/Java关键字.md","hash":"2f5e7ba1a0866b1b12a7e83d21a3f18bbbdc4185","modified":1575112472244},{"_id":"source/_posts/Java/Java基础/Java内部类.md","hash":"a1c55ad26f41cbd7267176e857eba2934cb5da0c","modified":1575112472244},{"_id":"source/_posts/Java/Java基础/Java引用.md","hash":"7712fe8cbc67e55eb130d0492a15a0b5646345ce","modified":1575112472244},{"_id":"source/_posts/Java/Java基础/Java集合.md","hash":"09ed16a3dcdaf0888356fb3012ed1ddc9cca6482","modified":1569832122971},{"_id":"source/_posts/Java/Java基础/Java泛型.md","hash":"01bff38ada294b76778b42e02e59f73e609922ec","modified":1569832122970},{"_id":"source/_posts/Java/Java基础/Lambda表达式.md","hash":"fcf731b1a26c81e12ff02fa5153e1b8613c1ba5f","modified":1575112472245},{"_id":"source/_posts/Java/Java基础/README.md","hash":"2473632a9b8b7929660935a32ac9e52c6aa3773d","modified":1582697581241},{"_id":"source/_posts/Java/Java基础/String、StringBuffer、StringBuilder区别.md","hash":"530f3ea4b8d13d60e820fc6035d5d7ee66e3679c","modified":1575112472245},{"_id":"source/_posts/Java/Java基础/加密算法.md","hash":"626f50f19938100a5873d9e89d3f20f6b69f455e","modified":1575112472246},{"_id":"source/_posts/Java/Java多线程/Java多线程与单例模式.md","hash":"33a8651c0045e6cb69d98324a041605759549ec9","modified":1569832122973},{"_id":"source/_posts/Java/Java多线程/Java多线程之间的协作.md","hash":"08f3c6a7a5b09651a8d5fc15a99099b2b3a824a5","modified":1568886074776},{"_id":"source/_posts/Java/Java多线程/Java多线程基础.md","hash":"547ef2a2f9d0e0f837893fd0a379ec13b56a398c","modified":1569832122974},{"_id":"source/_posts/Java/Java多线程/Java线程间通信.md","hash":"958844981cc1b7f046f681c8afd34dbc8d3b5a45","modified":1569832122975},{"_id":"source/_posts/Java/Java多线程/README.md","hash":"6e7ea48e601390b974b362e9959faaedd72b7801","modified":1570515581310},{"_id":"source/_posts/Java/设计模式/代理模式.md","hash":"14c279e81c811ea4073c30f5e3de9161592294c7","modified":1575112472246},{"_id":"source/_posts/Java/设计模式/README.md","hash":"98205ee0e71ca34d296822574453bcf41a2e575e","modified":1570515581311},{"_id":"source/_posts/Java/设计模式/观察者模式.md","hash":"c54c4421f5496dbc0c4beb82a5942fbb9f812d47","modified":1569832122978},{"_id":"source/_posts/Kotlin/Kotlin基础/Lambda表达式.md","hash":"084f4cb3a6eeef13c46f94c04e63dad67b94789e","modified":1575112472247},{"_id":"source/_posts/Other/Git/2017-07-27-remote-permission-denied.md","hash":"ef0752a43ced81cdf0b5bb766e10b6d27071a3ea","modified":1582945868907},{"_id":"source/_posts/Other/Git/Git.md","hash":"b36ae043f905c612fb7cf148a20b23d2164bcfd8","modified":1575112472247},{"_id":"source/_posts/Other/Git/Git出现问题.md","hash":"f5c0a7e6af607bfedee6f095fc8aaf901f8c698a","modified":1569027130120},{"_id":"source/_posts/Other/Img/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1568199763460},{"_id":"source/_posts/Other/Img/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1568199763460},{"_id":"source/_posts/Other/Img/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1568199763461},{"_id":"source/_posts/Other/Img/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1568199763461},{"_id":"source/_posts/Other/Img/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1568199763462},{"_id":"source/_posts/Other/Img/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1568199763462},{"_id":"source/_posts/Other/Img/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1568199763463},{"_id":"source/_posts/Other/Img/Image 10 - Copy.png","hash":"6f08a05e55011c24f423d5498fa6b2677d549235","modified":1568199763464},{"_id":"source/_posts/Other/Img/Image 2 - Copy.png","hash":"be3b346e0fb058b5999f9a096d2a889fc223be47","modified":1568199763464},{"_id":"source/_posts/Other/Img/Image 3 - Copy.png","hash":"84dfcf80bb621bbc32490b6155ac80cefaab1d14","modified":1568199763465},{"_id":"source/_posts/Other/Img/Image 8 - Copy.png","hash":"de3fa169a3a6d8d0f5aac98c94cc837baad495c8","modified":1568199763466},{"_id":"source/img/20170726/Thumbs.db","hash":"ee48e951388f6679a722e9f2ce67266926a35b05","modified":1568179743000},{"_id":"source/img/20170802/003.jpg","hash":"6f6cc25f13e0cdf862cd134b92e6feba89d86ea4","modified":1568179743000},{"_id":"source/img/head/head11.jpg","hash":"d7ff9d7855c023528d0ff4f4b2caf3e6dc7cf717","modified":1568179743000},{"_id":"source/img/head/head2.jpeg","hash":"27463b3d6d1dc5f6a2831b9c555312831eaad2bc","modified":1568179743000},{"_id":"source/img/head/head3.jpeg","hash":"9668f2fb85062bdd79b6447b4a5054085886124e","modified":1568179743000},{"_id":"source/img/head/head6.jpeg","hash":"c6ee0a98d9a72582ca0d6b6475ac3a55bd6f96f8","modified":1568179743000},{"_id":"source/img/head/head8.png","hash":"4b6bf0531edfef1c6f86f587474f96134ad16644","modified":1568179743000},{"_id":"themes/icarus/.history/layout/common/footer_20200227192210.ejs","hash":"f2f349865fbeff42495cf24cd220737530f5bdf1","modified":1582889691768},{"_id":"themes/icarus/.history/layout/common/footer_20200228193451.ejs","hash":"beead183e78c67945b4a3b1acf285aa9e8599b1d","modified":1582889691837},{"_id":"themes/icarus/.history/layout/common/footer_20200228193457.ejs","hash":"beead183e78c67945b4a3b1acf285aa9e8599b1d","modified":1582889697223},{"_id":"themes/icarus/.history/layout/common/footer_20200228193813.ejs","hash":"beead183e78c67945b4a3b1acf285aa9e8599b1d","modified":1582889893147},{"_id":"themes/icarus/.history/layout/common/footer_20200228194526.ejs","hash":"55c4bd2a927e6af38dcf84edfae22c63f16e39de","modified":1582890326384},{"_id":"themes/icarus/.history/layout/common/footer_20200228194718.ejs","hash":"0e878dcc8279c04efe05e1f101cff0ffd30ebf90","modified":1582890438146},{"_id":"themes/icarus/.history/layout/common/footer_20200228200431.ejs","hash":"beead183e78c67945b4a3b1acf285aa9e8599b1d","modified":1582891471644},{"_id":"themes/icarus/.history/layout/common/footer_20200228200512.ejs","hash":"4cfc8eaef6b26bb58b610603d246af87b71c860f","modified":1582891513028},{"_id":"themes/icarus/.history/layout/common/footer_20200229095119.ejs","hash":"3efc7f8a39b4581c654663d02229b27c0cd5c232","modified":1582941079809},{"_id":"themes/icarus/.history/layout/common/footer_20200229095120.ejs","hash":"3efc7f8a39b4581c654663d02229b27c0cd5c232","modified":1582941080343},{"_id":"themes/icarus/.history/layout/common/footer_20200229095224.ejs","hash":"d8c5406073d284b37bf0eed0805f67acd5761616","modified":1582941144267},{"_id":"source/_posts/Java/Java基础/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572634079},{"_id":"source/_posts/Java/设计模式/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1574943623102},{"_id":"source/img/002.jpeg","hash":"1620698a57a7fc021e7bbbfb00c2636d571639d2","modified":1568179743000},{"_id":"source/img/head/head10.jpeg","hash":"4331127a333d40d9ff16623870478c176b53f84c","modified":1568179743000},{"_id":"source/img/head/head12.jpeg","hash":"0cab73cd97964fb2d2c09c699b18e13189952796","modified":1568179743000},{"_id":"source/img/head/head14.jpeg","hash":"b16b65105258818c16845d8084d57158f635f4b9","modified":1568179743000},{"_id":"source/img/head/head15.jpeg","hash":"834c7a85e87500144217992047d57eb3805b5da2","modified":1568179743000},{"_id":"source/img/head/head7.jpeg","hash":"05617269e76eb84c8fd5f271e1d34bc42a2f1e0d","modified":1568179743000},{"_id":"source/_posts/.history/Android/Android基础/2018-07-31-android-service-introduction_20200229104758.md","hash":"f728165f678ed4590798be4a10874886ee3c3f9e","modified":1582944478502},{"_id":"source/_posts/.history/Android/Android基础/2018-07-31-android-service-introduction_20200229105318.md","hash":"4930a1e6e122e2e1dcb70b20de316e94d485f801","modified":1582944798464},{"_id":"source/_posts/.history/Android/Android基础/2018-07-31-android-service-introduction_20190911132902.md","hash":"e3f803486528791acef1a38a14a82fa5963626e6","modified":1582944478453},{"_id":"source/_posts/.history/Android/Android基础/2018-08-01-android-broadcast-introduction_20190911132902.md","hash":"244f60893a555b72316a410d36eaf9b5705d8389","modified":1582944544685},{"_id":"source/_posts/.history/Android/Android基础/2018-08-01-android-broadcast-introduction_20200229104904.md","hash":"06ed1ce9779e7eb803eee50d576e17d6b46909ce","modified":1582944544754},{"_id":"source/_posts/.history/Android/Android基础/2018-08-01-android-broadcast-introduction_20200229105324.md","hash":"953c2f488c2cd78f6cb7d246dc05def26dc17287","modified":1582944804933},{"_id":"source/_posts/.history/Android/Android基础/2018-08-09-android-ViewModel-introduction_20190911132902.md","hash":"146653cc43e63735402419f613fb9f75a9e450fc","modified":1582944814707},{"_id":"source/_posts/.history/Android/Android基础/2018-08-09-android-ViewModel-introduction_20200229105334.md","hash":"3ff3addf1252dafe9c11f83c25fece89f633956b","modified":1582944814747},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20191130191431.md","hash":"7008ffb8e3729190b796329f63f04a4921da3be4","modified":1582891372990},{"_id":"source/_posts/.history/Android/Android基础/2018-08-09-android-ViewModel-introduction_20200229105337.md","hash":"6fb72669a1ea73e57aff520ecd7b3bc08432a965","modified":1582944817678},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200253.md","hash":"a9a6bc92f5e8b593d082dd726e241fb3dda935e1","modified":1582891373745},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200534.md","hash":"d540890de15f82d6cd375c0d4a54feedc6fce960","modified":1582891534800},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200552.md","hash":"7fa92764272ad7743f7cd0783002b8a3cf348a5d","modified":1582891552614},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200612.md","hash":"bbe162fe12a9f148ef5c54bc937f0c476e4638a8","modified":1582891572772},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200622.md","hash":"ca1f264cb76bceb5896bf763120912319146bfd1","modified":1582891582039},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200740.md","hash":"e49f31dd1e1cf8a1328bef454db9725c6a4c818b","modified":1582891660564},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200747.md","hash":"e49f31dd1e1cf8a1328bef454db9725c6a4c818b","modified":1582891667917},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228200946.md","hash":"4a49922604b3be3eab48d509130833c3c8f8fbf3","modified":1582891786721},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228201501.md","hash":"40ef05d2ed9faf6fbc8a1cb9c361d3e7bb286d25","modified":1582892101090},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228201624.md","hash":"4a49922604b3be3eab48d509130833c3c8f8fbf3","modified":1582892184058},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228202044.md","hash":"74369f59b8f74ba4fb33e08fec950798c333db25","modified":1582892444856},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228205319.md","hash":"d2aae78e6f6b73e62f06b3010b210056df43059d","modified":1582894399371},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228205408.md","hash":"d2aae78e6f6b73e62f06b3010b210056df43059d","modified":1582894448248},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200228205410.md","hash":"d2aae78e6f6b73e62f06b3010b210056df43059d","modified":1582894450302},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200229095348.md","hash":"4f0dad67a3f8c4a0cc3e6b0aff9c539297721304","modified":1582941228374},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200229095730.md","hash":"4f0dad67a3f8c4a0cc3e6b0aff9c539297721304","modified":1582941450969},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200229095858.md","hash":"d9c027b7fc6795ae1e3586a9efdd6d54549c73d0","modified":1582941539006},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200229095859.md","hash":"d9c027b7fc6795ae1e3586a9efdd6d54549c73d0","modified":1582941539674},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200229095952.md","hash":"68ffbb4bfcecd76e89eb52376ecadf052f195dd7","modified":1582941592668},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20191130191431.md","hash":"06feb65e9eedf5c88c0f4865d8f4ba02b2003a8c","modified":1582891942092},{"_id":"source/_posts/.history/Android/Android基础/Android 6.0动态权限获取_20200229100706.md","hash":"68ffbb4bfcecd76e89eb52376ecadf052f195dd7","modified":1582942026926},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228201222.md","hash":"79b0923e50c9dc45145ad8f2bd590821e428616b","modified":1582891942133},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228201405.md","hash":"8a59e8beaa8b397bf50a12d69df7bd399dbe2184","modified":1582892045193},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228201505.md","hash":"84489b1e94b853d5144fdecd24c342941fd263b5","modified":1582892105221},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228201614.md","hash":"8a59e8beaa8b397bf50a12d69df7bd399dbe2184","modified":1582892174487},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228202608.md","hash":"3bb5f4948fa8ac8a4924bb5faa9b11d3888880f4","modified":1582892768432},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228203346.md","hash":"30f8fdbf341187f43ec610188ba8706f10eb9dee","modified":1582893226570},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228205305.md","hash":"05677f15cfc3172f396ebd00d1c0ec147bec0cbb","modified":1582894385819},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200229095353.md","hash":"7750f165a5cc1ec5e0ef0bc42a542996c8dca304","modified":1582941233741},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228205355.md","hash":"05677f15cfc3172f396ebd00d1c0ec147bec0cbb","modified":1582894435380},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200228205321.md","hash":"05677f15cfc3172f396ebd00d1c0ec147bec0cbb","modified":1582894401464},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200229095713.md","hash":"54dde017a64cfb6d14587a12becb1c489462506a","modified":1582941433794},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200229095718.md","hash":"edd145f1856d868d241c56dde478e1ddc07436ac","modified":1582941438764},{"_id":"source/_posts/.history/Android/框架/Retrofit 2.5 框架使用与源码分析_20200229095848.md","hash":"63ecd99aa82c8f2ce3c04d86357d1837cf669f88","modified":1582941528692},{"_id":"source/_posts/.history/Other/Git/2017-07-27-remote-permission-denied_20190911132902.md","hash":"c44f5ee468c391ef9e75cd8c4443e555314d8feb","modified":1582944502969},{"_id":"source/_posts/.history/Other/Git/2017-07-27-remote-permission-denied_20200229104822.md","hash":"8b0b69bd95155aacf3af0402a3d2e889bc09080a","modified":1582944503018},{"_id":"source/_posts/.history/Other/Git/2017-07-27-remote-permission-denied_20200229104829.md","hash":"984e68ad259323750c8ab265d4df2c1641495426","modified":1582944509539},{"_id":"source/_posts/.history/Other/Git/2017-07-27-remote-permission-denied_20200229104843.md","hash":"1d1a76c6a3bf1fecc1700df1b0fa6689f28fb958","modified":1582944523082},{"_id":"source/_posts/.history/Other/Git/2017-07-27-remote-permission-denied_20200229104847.md","hash":"4391ac5a7f434c2c9bf3b89c53d71be223e9b8ba","modified":1582944527391},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1569027130113},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1569027130113},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1569027130114},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1569027130115},{"_id":"source/_posts/Android/Android反编译/Img/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1569832122951},{"_id":"source/_posts/Android/Android反编译/Img/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1569832122952},{"_id":"source/_posts/Android/框架/AAC/Android Architecture Components.md","hash":"0d2bf3d9ad21a054f35e8043db9b395b430b52d2","modified":1568886074748},{"_id":"source/_posts/Android/框架/AAC/Android Lifecycle-Aware组件详解.md","hash":"cde60dc864ec69fa4142a46019c53a07ba00c0df","modified":1575112472184},{"_id":"source/_posts/Android/框架/AAC/Android Livedata详解.md","hash":"5ad10e0877968b3a7aa102b5ec21e25e519b08ea","modified":1582697579606},{"_id":"source/_posts/Android/框架/AAC/DataBinding的使用.md","hash":"be22fd962a95158208d175711e4e61a53a29245d","modified":1582697579613},{"_id":"source/_posts/Android/框架/AAC/Lifecycle和Room的使用.md","hash":"08f9c8c79baa6fdf62e64d5e329b76f934b05c0f","modified":1575112472187},{"_id":"source/_posts/Android/框架/AAC/Paging和Room使用.md","hash":"b28ac7c5bf98c6c1b1990af8c53796d0752ddce8","modified":1569832122964},{"_id":"source/_posts/Android/框架/AAC/Room和Lifecycle构建程序.md","hash":"08f9c8c79baa6fdf62e64d5e329b76f934b05c0f","modified":1568886074749},{"_id":"source/_posts/Android/框架/AAC/Room数据库.md","hash":"c95d64e9f7142b4ca96e7481be2c209136836942","modified":1569832122965},{"_id":"source/_posts/Android/框架/AAC/WorkManager介绍.md","hash":"1ab63edfbf3b88d73515e69bab6d54b8033290c8","modified":1569832122965},{"_id":"source/_posts/Java/设计模式/Img/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1574943623103},{"_id":"source/img/008.jpg","hash":"2c065fff8ee830b4abb51124c7685fdb3e1fb240","modified":1568179743000},{"_id":"source/img/head/head5.jpeg","hash":"7e8dbba776326e67a5308fa033134aba0397b24d","modified":1568179743000},{"_id":"source/_posts/Android/框架/Img/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1575112472188},{"_id":"source/img/head/head1.jpeg","hash":"919d374168544f9bdc5027c7d6606b78472dbc72","modified":1568179743000},{"_id":"source/_posts/Android/框架/AAC/Img/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1575112472186},{"_id":"source/_posts/Android/框架/AAC/Img/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1575112472186},{"_id":"source/_posts/Java/Java基础/Img/collection.png","hash":"38dfaafd4896d4e584b8508aa9a1a86942170104","modified":1569832122970},{"_id":"source/img/DataStructure/Merge_sort_01.gif","hash":"cd1e80c9283020a8c465236497cbcd06e2a27fcc","modified":1568179743000},{"_id":"source/img/head/head13.jpeg","hash":"8120574c276d4fdb4ffb3fc2c973400a904b2abb","modified":1568179743000},{"_id":"source/img/006.jpeg","hash":"49607adbaac612cc0783c6ca921607cb9cad716b","modified":1568179743000},{"_id":"source/img/DataStructure/heap6.jpg","hash":"0912d02ba1bab1c5dfada1787bc6a3a8f175b951","modified":1568179743000},{"_id":"source/img/head/head9.png","hash":"f3d61516e0bdc1ded6fbd2e74373a8617c022f23","modified":1568179743000},{"_id":"source/_posts/Android/Advanced/Img/application_start.png","hash":"6395d26d20169517eabbbb36f2a4c010a7be6b7f","modified":1569832122947},{"_id":"source/img/007.jpeg","hash":"c702228fd507a2130e1697639d40ac1b2c524602","modified":1568179743000},{"_id":"source/img/005.jpeg","hash":"0de07377509cc7358f8243f8bd5c09a1f828d870","modified":1568179743000},{"_id":"source/img/003.jpeg","hash":"6a3c0edf34a4a6ea2ab7418768bbf2b1111aed1b","modified":1568179743000},{"_id":"source/img/009.jpeg","hash":"d24146bbba16d4710ce43c90857f1e349fc0d95d","modified":1568179743000},{"_id":"source/img/001.jpeg","hash":"755049d37a0cd7db995eae797517cbf560b609bc","modified":1568179743000},{"_id":"source/img/008 - Copy.jpeg","hash":"e5872101a0a03f257e0dabeaaa3ba3ff852175c8","modified":1568179743000},{"_id":"source/img/004.jpeg","hash":"6434a4a293ec3b1d974151b6126d7f0e1ec61aea","modified":1568179743000},{"_id":"source/img/0010 原图.jpeg","hash":"87453164794997c5aa11c39d3428c930f351e852","modified":1568179743000},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110336.md","hash":"2edf359aee7ee4992f114bb520cab0dcdd75f197","modified":1582945416841},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110347.md","hash":"6103a1c61bc612b29b4a9137ee4d0df1a9dc4067","modified":1582945427050},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110413.md","hash":"6103a1c61bc612b29b4a9137ee4d0df1a9dc4067","modified":1582945453895},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110431.md","hash":"8e930ce55f0250905434c96e5123396fcb7ab2ce","modified":1582945471016},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110509.md","hash":"22fc81a7ac7982d75aa0f7bac49173c895e557f3","modified":1582945509234},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110530.md","hash":"b0e43dfc1b3e73329d8afc7e54af4d7187be8ca0","modified":1582945530135},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110554.md","hash":"ffab00f4b2cb2393490f5b89f5dabe52c52d441c","modified":1582945554187},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110557.md","hash":"ffab00f4b2cb2393490f5b89f5dabe52c52d441c","modified":1582945557022},{"_id":"source/_posts/.history/Data_Structure/2017-07-31-data-structure-insert-sort_20200229110602.md","hash":"2d6f5b71f5846aa049d54960aabce5660683e048","modified":1582945562592},{"_id":"source/_posts/.history/Data_Structure/2017-08-02-data-structure-queue_20200229110650.md","hash":"50a10c10f4fb447ae2a6eb95204746e547d4a670","modified":1582945610487},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-merge-sort_20200229110729.md","hash":"f152e0f1c63afd68a00a6e1ef8a80f23628bec7f","modified":1582945649745},{"_id":"source/_posts/.history/Data_Structure/2017-08-04-data-structure-quick-sort_20200229110742.md","hash":"a99d985b1eef50ca68a7975b067ac0c279621cc6","modified":1582945662793},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20200229110751.md","hash":"7be3ab038279efb20d0e361e3b37d96c57b4f243","modified":1582945671687},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20200229110806.md","hash":"7be3ab038279efb20d0e361e3b37d96c57b4f243","modified":1582945686568},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20200229110812.md","hash":"0359b28f507236ee6f04a21ce5f495342dd3ba6a","modified":1582945692908},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-adjaceny-matrix_20200229110822.md","hash":"b3f9db0225221cc9f841e4c162dd8f5013306a5c","modified":1582945702455},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-adjaceny-matrix_20200229110825.md","hash":"b3f9db0225221cc9f841e4c162dd8f5013306a5c","modified":1582945705828},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-adjaceny-matrix_20200229110830.md","hash":"6763bd43ea7c10daefda11817983c3290f2329e6","modified":1582945710678},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-build-heap_20200229110843.md","hash":"fb64d8777980622d72865d09728591f2ceb1d205","modified":1582945723430},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-build-heap_20200229110850.md","hash":"ef4532157dc084aeb8d540dd79fd77b9f3e8a2fd","modified":1582945730194},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-adjacency-list_20200229110924.md","hash":"206d81cd5e420e7633c3c9b58b49882cba81cbc7","modified":1582945764144},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-heap-sort_20200229110934.md","hash":"9c49f1ebd93334fa71c2bf6a11a2ffbad727a88e","modified":1582945774504},{"_id":"source/_posts/.history/Data_Structure/2017-08-27-data-structure-heap-sort_20200229110938.md","hash":"9c49f1ebd93334fa71c2bf6a11a2ffbad727a88e","modified":1582945778060},{"_id":"source/_posts/.history/Data_Structure/2017-08-28-data-structure-huffman-tree_20200229110954.md","hash":"af343d7812e0bc2e9e2820aecbb44934cf80a585","modified":1582945794710},{"_id":"source/_posts/.history/Data_Structure/2017-08-28-data-structure-huffman-tree_20200229111002.md","hash":"bf2590ae8a967adf4ada4fafa98dd16bd7de08a4","modified":1582945802139},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-build-heap_20200229110907.md","hash":"d07de4fceffcf734d394f987e55f0accd00fb2d7","modified":1582945747024},{"_id":"source/_posts/.history/Other/Git/2017-07-27-remote-permission-denied_20200229111108.md","hash":"ef0752a43ced81cdf0b5bb766e10b6d27071a3ea","modified":1582945868930},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-adjaceny-matrix_20200229111234.md","hash":"58fa2f57a683652ee4f1934e8856a22408d11d42","modified":1582945954858},{"_id":"source/_posts/.history/Data_Structure/2017-08-26-data-structure-build-heap_20200229111304.md","hash":"800141a04fb0cde861d702d0bb3b8c679946648e","modified":1582945984581},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20200229111520.md","hash":"bf28143586c989bd2626b3a505ece5ae2052dc59","modified":1582946121004},{"_id":"source/_posts/.history/Data_Structure/2017-08-08-data-structure-threaded-binary-tree_20200229111556.md","hash":"4bd0bbb59e748028a746932f2ac540d10891789e","modified":1582946156129},{"_id":"source/_posts/.history/Android/Android基础/2018-08-09-android-ViewModel-introduction_20200229111643.md","hash":"9ebc58ae00a9f23acf7deadcdcb2d7c4c8d662af","modified":1582946203557},{"_id":"source/_posts/.history/Android/Android基础/2018-07-31-android-service-introduction_20200229111702.md","hash":"d74550da0aa141878bd8581e5484db723d20056a","modified":1582946222296},{"_id":"public/content.json","hash":"9d5ae341e898cfc250cea9fcfb50cbb6da9623e0","modified":1582958781583},{"_id":"public/2020/02/29/Android/Android基础/2018-08-09-android-ViewModel-introduction/index.html","hash":"aa737b69ccd31905abe0023180b3db80292cfd43","modified":1582958994811},{"_id":"public/2020/02/29/Android/Android基础/2018-08-01-android-broadcast-introduction/index.html","hash":"205502ab44abcd47d6177f6570c84937ddb4d1c2","modified":1582958994811},{"_id":"public/2020/02/29/Android/Android基础/2018-07-31-android-service-introduction/index.html","hash":"0592b3a28a02a1cc0011d86ecf057c271eacd6c2","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-28-data-structure-huffman-tree/index.html","hash":"dca60fedb6ad51991392a4cff5efc617b6a99695","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-27-data-structure-heap-sort/index.html","hash":"43d2dc553611e0781e353fdebb3865aaf1b83778","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-27-data-structure-adjacency-list/index.html","hash":"6e2298e8c1a239d5ee4787f82540c024f1ff33eb","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-26-data-structure-build-heap/index.html","hash":"b9681c48d9f7ba642d15b02c368e63b0c9411cd5","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-26-data-structure-adjaceny-matrix/index.html","hash":"0bf60097c9a11f54d644cbc7fc4dbf75defe11e7","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-08-data-structure-threaded-binary-tree/index.html","hash":"75817125016fc4aa460d4eb92db33ec5963fcc49","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-04-data-structure-quick-sort/index.html","hash":"316d1485e8a3b7cc5ab5c12601e1100b09674c33","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-04-data-structure-merge-sort/index.html","hash":"7ee66e2d8b7f68b2155713fcc7699dce6af1b0d9","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-02-data-structure-stack-use/index.html","hash":"25cea1f0e88d9a1f4f7e06f5ab91d7a5bfbc3bc4","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary/index.html","hash":"7a1eb4841c812bf0777734586a76201bb2f3bdfd","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-02-data-structure-radix-sort/index.html","hash":"60c9286c2aecce245ee5241e45827b908effc985","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-08-02-data-structure-queue/index.html","hash":"157c1436eb2aa64dfbb05450cce60c3fe6f8cb8b","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-07-31-data-structure-search/index.html","hash":"d7a7af19f81c6dcc4dd826fea2ba717e0550b05c","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-07-31-data-structure-insert-sort/index.html","hash":"16c433e738523dc727581065d091b49ce2fdaefd","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-07-27-data-structure-stack/index.html","hash":"d508b30cf1fab1b5ec0153985e5b6cca566541d9","modified":1582958994811},{"_id":"public/2020/02/29/Data_Structure/2017-07-27-data-structure-binary-tree-visit/index.html","hash":"b88258b1bff5131de9b83781fdc71a33ae0a5246","modified":1582958994811},{"_id":"public/2020/02/29/Other/Git/2017-07-27-remote-permission-denied/index.html","hash":"0426081172e99d53df0281bbca0b9ca34b4c805a","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-08-01-pat-advanced-1060/index.html","hash":"aec47277e99b176a115326cb22c7d964182a9c2f","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-08-01-pat-advanced-1011/index.html","hash":"b51aa68739de913cd4cdfb021c8eea2d3f5e7dd1","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-07-31-pat-advanced-1006/index.html","hash":"426411d68f778a68add6eae648d8432da17a524d","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-07-27-pat-advanced-1008/index.html","hash":"1a8dc3b32a807dda3c999f2ab692b9d50a616daa","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-07-27-pat-advanced-1007/index.html","hash":"32d41778ee2397ff0406f32d1de8f84170df5093","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-07-27-pat-advanced-1005/index.html","hash":"0ea6c43d16b19fd5275959c019afb32c91990759","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-07-27-pat-advanced-1002/index.html","hash":"b3ec59c5bcd2d100e1acd10fa7218af156797ade","modified":1582958994811},{"_id":"public/2020/02/29/PAT/2017-07-27-pat-advanced-1001/index.html","hash":"c29af05eebeb7cfa23b73a1702603f58df26f094","modified":1582958994811},{"_id":"public/2020/02/27/hello-world/index.html","hash":"9e5dad496992b0077aa4bc6391e5e05960ca6bdf","modified":1582958994811},{"_id":"public/2019/11/30/Android/框架/Retrofit 2.5 框架使用与源码分析/index.html","hash":"2d47756d9014bc09cc45543275c3ab4f7d37127a","modified":1582958994811},{"_id":"public/2019/11/28/Kotlin/Kotlin基础/README/index.html","hash":"eaca8002bf83bc4404804a10d517e14d9233dcca","modified":1582958994811},{"_id":"public/2019/11/28/Kotlin/Kotlin基础/Lambda表达式/index.html","hash":"ddaffe467434a83f709fd5c0213a97537246e4a1","modified":1582958994811},{"_id":"public/2019/11/28/Java/设计模式/Img/README/index.html","hash":"0ac69e09eab97eb7d87038894d5f1e4008c788f4","modified":1582958994811},{"_id":"public/2019/11/28/Java/Java基础/加密算法/index.html","hash":"3e01e19fc9a062bf3119d9a95466c9dc6023a113","modified":1582958994811},{"_id":"public/2019/11/28/Java/Java基础/Java引用/index.html","hash":"33caf35934711e2fcc1c5aa6e8f35fc37048c40d","modified":1582958994811},{"_id":"public/2019/11/28/Android/框架/AAC/Android Livedata详解/index.html","hash":"e393b1d0ecee36236847bfce253671d108828807","modified":1582958994811},{"_id":"public/2019/11/28/Android/Android基础/数据储存/index.html","hash":"eae400328d8b55e104793360b328b8b1d1e7893d","modified":1582958994811},{"_id":"public/2019/11/28/Android/框架/AAC/Android Lifecycle-Aware组件详解/index.html","hash":"174a59f9e340cccd15cb6ec0f96f2eae66d2c307","modified":1582958994811},{"_id":"public/2019/11/28/Android/Android基础/Android序列化/index.html","hash":"7c72e4e068cb4bd65e3cd1d0de3574c269892670","modified":1582958994811},{"_id":"public/2019/11/28/Java/设计模式/代理模式/index.html","hash":"bdb5f3312493b61399b919d300429549e6a0cb66","modified":1582958994811},{"_id":"public/2019/11/28/Java/Java基础/Java内部类/index.html","hash":"63d5012713ad77c185e86046dafdef258e88293e","modified":1582958994811},{"_id":"public/2019/09/30/Android/Other/常用操作/index.html","hash":"dae1508cd0b4793be5229f42c9da71d544d2c1d2","modified":1582958994811},{"_id":"public/2019/09/30/Android/Other/Module的.gradle配置/index.html","hash":"53c7fc9490d48881b731447a2a0a73987e130158","modified":1582958994811},{"_id":"public/2019/09/30/Android/Other/Groovy介绍/index.html","hash":"1b4ff666bc298f02fa0e4f963880f17019a6c9bf","modified":1582958994811},{"_id":"public/2019/09/30/Android/Android反编译/Android应用防止二次打包/index.html","hash":"91f2ea3c9abb8c2a4f22d996ac823dbeac7521d6","modified":1582958994811},{"_id":"public/2019/09/30/Android/Advanced/应用启动流程/index.html","hash":"18036f8a0ea86ae884a9ed94c35779f25ee4d6da","modified":1582958994811},{"_id":"public/2019/09/30/Android/Android基础/Android后台任务/index.html","hash":"c2f51dcc4a11d6042a5b212a068e27a4a0f95bad","modified":1582958994811},{"_id":"public/2019/09/30/Android/框架/AAC/WorkManager介绍/index.html","hash":"af2fa8c232ef5f37c78780b24730fb3d6a031d37","modified":1582958994811},{"_id":"public/2019/09/30/Android/框架/AAC/Room数据库/index.html","hash":"c8e6ddbf3f999beb94e78f3bebcb86a663e482fc","modified":1582958994811},{"_id":"public/2019/09/30/Android/框架/AAC/Paging和Room使用/index.html","hash":"612c83fd7df84a1911f0298538b5b2de66b8a291","modified":1582958994811},{"_id":"public/2019/09/30/Android/框架/AAC/Lifecycle和Room的使用/index.html","hash":"eb3b3c4cc28c12c2a996f5bdc94d663883794758","modified":1582958994811},{"_id":"public/2019/09/30/Android/框架/AAC/DataBinding的使用/index.html","hash":"1dc88285708d66a61bf407abea577b34d8c2c6a3","modified":1582958994811},{"_id":"public/2019/09/30/Android/View/Materials Design/index.html","hash":"9493bab7b2c5ceff2bcc6fa11eccb09b1f84c738","modified":1582958994811},{"_id":"public/2019/09/30/Android/View/ActionBar和ToolBar的使用/index.html","hash":"087060e3c439b0a7abe8705d2d34324fe8543424","modified":1582958994811},{"_id":"public/2019/09/30/Android/View/LayoutInflater使用/index.html","hash":"0716c6b4c46a2b84efda68950090456360709217","modified":1582958994811},{"_id":"public/2019/09/30/Android/Android基础/异步操作Asynctask/index.html","hash":"ce52230fd33169619364e68707fae67bd430fa52","modified":1582958994811},{"_id":"public/2019/09/30/Android/Android基础/Handler Looper介绍/index.html","hash":"646523b92cfedd0c2d61fa67b01588a59070aea1","modified":1582958994811},{"_id":"public/2019/09/30/Android/Android基础/getSystemService的使用/index.html","hash":"8579cafd4ccbb4213cd78b3eddb0b8a398dcf4b9","modified":1582958994811},{"_id":"public/2019/09/27/Java/Java基础/Img/README/index.html","hash":"4a1713989c3b589dd6aa900d6998afecd983f5f2","modified":1582958994811},{"_id":"public/2019/09/27/Java/Java基础/Java集合/index.html","hash":"842d3af9ca00918df945bde2b36dedabdf2b42f0","modified":1582958994811},{"_id":"public/2019/09/27/Android/框架/fastjson的使用/index.html","hash":"4c4c1de0539772bb5059d5bd6ae3f37f044056ff","modified":1582958994811},{"_id":"public/2019/09/21/Android/Android JNI/Android Studio JNI引入/index.html","hash":"c5877f16545910e07f00c7c8de2f45a82c711052","modified":1582958994811},{"_id":"public/2019/09/21/Android/Android JNI/Android JNI敏感信息保护/index.html","hash":"ff32b175b8c21146244b48b603a05fb195c966bd","modified":1582958994811},{"_id":"public/2019/09/21/Other/Git/Git出现问题/index.html","hash":"d6163621c923c7b8c22fbf119d85488cb035ddb7","modified":1582958994811},{"_id":"public/2019/09/19/Other/Git/README/index.html","hash":"6b761ebc90464b4bfed501d4df9190411d08b172","modified":1582958994811},{"_id":"public/2019/09/19/Other/Git/Git/index.html","hash":"a604d50b3bba2a25750d0c54788f2970851b1cfb","modified":1582958994811},{"_id":"public/2019/09/19/Java/设计模式/观察者模式/index.html","hash":"4c5fb25be803b71cf65ead7464de192ba74d32ba","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java虚拟机/README/index.html","hash":"ac9092ab92c870809622df03a53d51e54c0604fb","modified":1582958994811},{"_id":"public/2019/09/19/Java/设计模式/README/index.html","hash":"fc9a3202fdd62fe729bf70f97c6d6d77698d7f79","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java多线程/Java线程间通信/index.html","hash":"bd5c9cdf6be386ca570bd6e6dea4094d96dac1b1","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java多线程/Java锁机制/index.html","hash":"d5caabcbe913f9a74114895a3359e2996603da91","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java多线程/README/index.html","hash":"0f57ccc1301929ee4bfdf77a161b1160908563d1","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java多线程/Java多线程基础/index.html","hash":"cee79ac2859bb48c944cdd6b7815b7fb1ac3707a","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java多线程/Java多线程之间的协作/index.html","hash":"8511054b2bc6a42fd0c33d05f179bca826cd55d8","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java多线程/Java多线程与单例模式/index.html","hash":"91634dc97a6c3d52965f692c4f47c87084c897ef","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java基础/String、StringBuffer、StringBuilder区别/index.html","hash":"dd94344f10b69571611c2c7814eaf61a56a92cf9","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java基础/README/index.html","hash":"6444d2e7d28c11eca90b26c83a48d858626dced8","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java基础/Lambda表达式/index.html","hash":"1e0e485d6694acbc35d4ab4eeec5b2ac191435ed","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java基础/Java泛型/index.html","hash":"67e9cee20e5cd17e531c256efc3abd55675da116","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java基础/Java关键字/index.html","hash":"48b338ca4f1e4b8f740847b380b3a0a2efbad19a","modified":1582958994811},{"_id":"public/2019/09/19/Java/Java基础/Java 输入输出操作/index.html","hash":"c56d78fcf6b3fe07041e08ca2ceb0ae22f6ae380","modified":1582958994811},{"_id":"public/2019/09/19/Android/框架/AAC/Room和Lifecycle构建程序/index.html","hash":"64ee3489fe350c1ff703f96dfae0b768c4c6f041","modified":1582958994811},{"_id":"public/2019/09/19/Android/框架/AAC/Android Architecture Components/index.html","hash":"12dc01cfe4c79df0d4c95fb44dc8f0e690a9e4e0","modified":1582958994811},{"_id":"public/2019/09/19/Android/View/使用RecyclerView和SearchView实现查找删除/index.html","hash":"3118ee8525b37555a4d6fa6f25b7578aca71d983","modified":1582958994811},{"_id":"public/2019/09/19/Android/View/CountDownView/index.html","hash":"69eb9ff1f2e59a3be27d91b57a3910fc37bd98bc","modified":1582958994811},{"_id":"public/2019/09/19/Android/Ble/Android ble 4.0/index.html","hash":"13efdf47e0390dc445e574ab0072d529d1fe1ef9","modified":1582958994811},{"_id":"public/2019/09/19/Other/函数式编程/index.html","hash":"79cb8f536572b6eb7f6554b52860344d0faff129","modified":1582958994811},{"_id":"public/2019/09/19/Android/框架/Dagger2/index.html","hash":"1231dcf0d2c4736ecb82582cca2219513c01a722","modified":1582958994811},{"_id":"public/2019/09/19/Android/框架/RxJava2.0/index.html","hash":"c7e66ef308fb329449793edaf228e8029c6669b7","modified":1582958994811},{"_id":"public/2019/09/19/Android/Android基础/Android文件操作/index.html","hash":"4928c22106494bec5153f2774ac6cdcfc0d42fd8","modified":1582958994811},{"_id":"public/2019/09/19/Android/Android基础/Android 6.0动态权限获取/index.html","hash":"836bee9d7d461fa1a703f9d99b671c36d476fb5e","modified":1582958994811},{"_id":"public/2019/09/11/Directory/Other Directory/index.html","hash":"8a882538bcc6f05fac0a731a121c89f89a30bbf4","modified":1582958994811},{"_id":"public/2019/09/11/Other/README/index.html","hash":"4992fb429a6a492e9a62420d557d5b65685c446f","modified":1582958994811},{"_id":"public/2019/09/11/Other/Img/README/index.html","hash":"1b3c07827670b08479b24623230834ccbb8904ce","modified":1582958994811},{"_id":"public/2019/09/11/Java/README/index.html","hash":"b0bc9adcd1d6f11c4f6b43e0a8c690b2d6b948cb","modified":1582958994811},{"_id":"public/2019/09/11/Kotlin/README/index.html","hash":"0dc5da33da614c8ab0ab09bdd8050bb2d32e0f96","modified":1582958994811},{"_id":"public/2019/09/11/Directory/README/index.html","hash":"44b08564cbe00db89cb8953be687d1a1add92288","modified":1582958994811},{"_id":"public/2019/09/11/Directory/Android Directory/index.html","hash":"b109a427664fa1f1e5e57e01f3116f7387022a22","modified":1582958994811},{"_id":"public/2019/09/11/Directory/Java Directory/index.html","hash":"5eb1c44a7e82bcf560f1e5d1ff31b5ce52846339","modified":1582958994811},{"_id":"public/2019/09/11/Directory/Kotlin Directory/index.html","hash":"dfabd447db4f3536d8c2b1c65a24d103004d1cff","modified":1582958994811},{"_id":"public/archives/index.html","hash":"7c25f26c73d5e7222921511d9062471152295cb1","modified":1582958994811},{"_id":"public/archives/page/2/index.html","hash":"c476b76b31d86cde904312da6395083e8b93699a","modified":1582958994811},{"_id":"public/archives/page/3/index.html","hash":"e5c0ae2330c9e69d2738066dc03a5ee57a9e4be9","modified":1582958994811},{"_id":"public/archives/page/4/index.html","hash":"a77267d0b18161bb834b0af296e409717f829041","modified":1582958994811},{"_id":"public/archives/page/5/index.html","hash":"6931192086e471d38f62e088fcf28d963351538b","modified":1582958994811},{"_id":"public/archives/page/6/index.html","hash":"cf9f70c90b8b00ebf3f379c5c8e90834428902e2","modified":1582958994811},{"_id":"public/archives/page/7/index.html","hash":"b5380545d3d4ff43900d4d8bbc6614dcab525f7b","modified":1582958994811},{"_id":"public/archives/page/8/index.html","hash":"e419aac6e2a8bf86ff37f4f475a3d133dc8b2c3d","modified":1582958994811},{"_id":"public/archives/page/9/index.html","hash":"d4f5cc388a22167c29e5ce62c626c28fe3d4e9c7","modified":1582958994811},{"_id":"public/archives/page/10/index.html","hash":"411d6ff98c42c8bcc36a71912971fbdb9df8389c","modified":1582958994811},{"_id":"public/archives/2019/index.html","hash":"8e040cc38b65c0a880c3acd76a6cd86c28ed18b8","modified":1582958994811},{"_id":"public/archives/2019/page/2/index.html","hash":"3cc17e1a1ae343e4448629f8a085cd5221ac80f0","modified":1582958994811},{"_id":"public/archives/2019/page/3/index.html","hash":"7966e1613bde53e10ef3de03cd4663692bdac1a2","modified":1582958994811},{"_id":"public/archives/2019/page/4/index.html","hash":"8ed1a013ae63f01a92f59fc0d9b99ca47eb92e5d","modified":1582958994811},{"_id":"public/archives/2019/page/5/index.html","hash":"377c9dd9cc1ae2639c4033af54a0e3ebcf8aba76","modified":1582958994811},{"_id":"public/archives/2019/page/6/index.html","hash":"483957efafcc6630e8f8fe535cfa0f999e08067e","modified":1582958994811},{"_id":"public/archives/2019/page/7/index.html","hash":"587b38c3a48c85dd4be8c172b4cad4b6d4e552ca","modified":1582958994811},{"_id":"public/archives/2019/page/8/index.html","hash":"d77fc0f2238ec9c3f1050473cdbebe52e09c37a6","modified":1582958994811},{"_id":"public/archives/2019/09/index.html","hash":"1bcdd91508a45560b84e3ddae9ed3b566ba96caa","modified":1582958994811},{"_id":"public/archives/2019/09/page/2/index.html","hash":"7a545d5561a49a0731c0295da32470c01ea2d3c5","modified":1582958994811},{"_id":"public/archives/2019/09/page/3/index.html","hash":"88ec08e0ff3c466fc260de8924144bbce74d4bb2","modified":1582958994811},{"_id":"public/archives/2019/09/page/4/index.html","hash":"89b7535e70f575be24b6501e956207a2542c6222","modified":1582958994811},{"_id":"public/archives/2019/09/page/5/index.html","hash":"b765e698727ec6119deb5c1f344804c66d6599fc","modified":1582958994811},{"_id":"public/archives/2019/09/page/6/index.html","hash":"67074c694e1253bab7b5a392abfcaa304b24ac1c","modified":1582958994811},{"_id":"public/archives/2019/11/index.html","hash":"2c36d43962b8ef5a9e2cd93d12baa0f73484a7e4","modified":1582958994811},{"_id":"public/archives/2019/11/page/2/index.html","hash":"7c416cf54232b58bacd40adde60bb3520d8fab31","modified":1582958994811},{"_id":"public/archives/2020/index.html","hash":"9ac2eec46a6384a2b1980e014ba4512a677ad9a2","modified":1582958994811},{"_id":"public/archives/2020/page/2/index.html","hash":"2677a8c4a68cc52bc7dc8cdc5c92e136450112ae","modified":1582958994811},{"_id":"public/archives/2020/page/3/index.html","hash":"5e56a9513ea4674528f13e00eeef3cf03df18d15","modified":1582958994811},{"_id":"public/archives/2020/02/index.html","hash":"3d48292f228646d1a0796c27a38a9e83c5ab7631","modified":1582958994811},{"_id":"public/archives/2020/02/page/2/index.html","hash":"63a40b6da7a9ce1e96378602e8d612285c1cbcb4","modified":1582958994811},{"_id":"public/archives/2020/02/page/3/index.html","hash":"7c439994da87b0dc64eba59667d8829c27a190a1","modified":1582958994811},{"_id":"public/categories/Android/index.html","hash":"e898cc9d3a2bc08fd70d5e42794b52ec54ed6286","modified":1582958994811},{"_id":"public/index.html","hash":"53d5886caf887433613c9b862cd3e61b4b3d7e31","modified":1582958994811},{"_id":"public/page/2/index.html","hash":"407209fb563c2e92316498bef8a40917631936bc","modified":1582958994811},{"_id":"public/page/3/index.html","hash":"7c03043a63512c87b5493ce281c1b50a95f6a57d","modified":1582958994811},{"_id":"public/page/4/index.html","hash":"efb06197800c4914a2797573c5f996d0b8e87e6e","modified":1582958994811},{"_id":"public/page/5/index.html","hash":"6eb18145b7d3d6882977f5b576318d0e2dca3e5d","modified":1582958994811},{"_id":"public/page/6/index.html","hash":"85ec673d6cf21779827fc45c2db3f640033f6c77","modified":1582958994811},{"_id":"public/page/7/index.html","hash":"aa0561e664f163fe1aa55a6b56393dc1b4e3f5e6","modified":1582958994811},{"_id":"public/page/8/index.html","hash":"667ee914850a2a6541430976d51167b1be63d32c","modified":1582958994811},{"_id":"public/page/9/index.html","hash":"ee4f56842822a869c3fbe6c28933f378cf0570c1","modified":1582958994811},{"_id":"public/page/10/index.html","hash":"08ecbb9391a6da1184546e53ed9ae2fb472fd744","modified":1582958994811},{"_id":"public/tags/数据结构/index.html","hash":"6907d2fc3c6346ee94bd88ed3ff29e661505b9e9","modified":1582958994811},{"_id":"public/tags/数据结构/page/2/index.html","hash":"4bac766f549e5d116a7f7adb7fb37809dcca61c0","modified":1582958994811},{"_id":"public/tags/pat/index.html","hash":"74e42945a5b915a7a86143df460172bb99fa8909","modified":1582958994811},{"_id":"public/tags/Android/index.html","hash":"fc7571ff268b8343f75ab4ff2a1d20690bad2640","modified":1582958994811},{"_id":"public/tags/error/index.html","hash":"72cd716b348f9a387896a644293eac2a12ce3aa3","modified":1582958994811},{"_id":"public/tags/git/index.html","hash":"e70c9811c86d4296ec2526c252de8c5037d22a50","modified":1582958994811},{"_id":"public/categories/index.html","hash":"b3bff50f1aea96d048541feb998ae2113952b735","modified":1582958994811},{"_id":"public/tags/index.html","hash":"2d82df268aeed376da581f81141ab61063290d1b","modified":1582958994811},{"_id":"public/assets/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1582946225771},{"_id":"public/assets/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1582946225771},{"_id":"public/assets/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1582946225771},{"_id":"public/assets/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1582946225771},{"_id":"public/assets/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1582946225771},{"_id":"public/assets/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1582946225771},{"_id":"public/assets/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1582946225771},{"_id":"public/assets/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1582946225771},{"_id":"public/assets/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1582946225771},{"_id":"public/assets/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1582946225771},{"_id":"public/assets/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1582946225771},{"_id":"public/assets/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1582946225771},{"_id":"public/assets/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1582946225771},{"_id":"public/assets/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1582946225771},{"_id":"public/assets/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1582946225771},{"_id":"public/img/20170726/Image11.png","hash":"e0c11295b7c6577b35cd0823489efeb2e05c547c","modified":1582946225771},{"_id":"public/assets/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1582946225771},{"_id":"public/img/20170726/Image12.png","hash":"545907b9b1449448c3cadbfdd9da5aade1250ef4","modified":1582946225771},{"_id":"public/img/20170726/Image1.png","hash":"a375dd730a00316fb9f483c48d01e75aded2c67e","modified":1582946225771},{"_id":"public/img/20170726/Image13.png","hash":"8d7cdf29bce3d2a83d6a14a688cc3c8f7cbed49d","modified":1582946225771},{"_id":"public/img/20170726/Image14.png","hash":"b24df030353b9fefae8015d044daf177fe05f5a1","modified":1582946225771},{"_id":"public/img/20170726/Image15.png","hash":"9fb214cc781a01dbb2dbe18fbc20fc800f6e8013","modified":1582946225771},{"_id":"public/img/20170726/Image17.png","hash":"8d41d9c4f3886a51d3f900edd6609fdd3d736890","modified":1582946225771},{"_id":"public/assets/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1582946225771},{"_id":"public/img/20170726/Image18.png","hash":"055331e05df5d64b605d2d58e5061672e108faaa","modified":1582946225771},{"_id":"public/img/20170726/Image3.png","hash":"127eccc0d73e654731ec779a7c28fb591b2ef28f","modified":1582946225771},{"_id":"public/img/20170726/Image2.png","hash":"43f9bfbfad80d540d57beda5480e67fc415f4b66","modified":1582946225771},{"_id":"public/img/20170726/Image5.png","hash":"4eb6f78614962547a93913f98faf327203d1794f","modified":1582946225771},{"_id":"public/img/3953273590_704e3899d5_m.jpg","hash":"50258aa007b4a30d3e49c8d52ffb2fe78a0a47ff","modified":1582946225771},{"_id":"public/assets/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1582946225771},{"_id":"public/img/20170726/Image7.png","hash":"46ce3306766c3f5f19b4c97dea961e75b735ed9b","modified":1582946225771},{"_id":"public/img/20170726/Image4.png","hash":"e391f03b3787074d9f7be1ea7387848c350b0f35","modified":1582946225771},{"_id":"public/img/20170726/Image6.png","hash":"2b63aa98f0cedef44776a31e17fbc8cc0dbd84f3","modified":1582946225771},{"_id":"public/img/20170726/Image8.png","hash":"fa5f08785a32a1982f4e1e8ce166ede400ad7958","modified":1582946225771},{"_id":"public/img/20170726/Image9.png","hash":"b9b8483009389028e67d0a5cd49731cf15f88e4b","modified":1582946225771},{"_id":"public/img/20170727/Image3.png","hash":"b6b42814093bbca53a964c22db752433097fed29","modified":1582946225771},{"_id":"public/img/20170727/Image4.png","hash":"36d2556b3af92a35ed0f937fd60c0fe5df28cdd3","modified":1582946225771},{"_id":"public/img/20170727/Image1.png","hash":"c1b937ef5f0ccffeb5f91696831af6d2deae2abf","modified":1582946225771},{"_id":"public/img/20170727/Image5.png","hash":"b327a63bb3e432fb28f3cd58950f172f3e9951d1","modified":1582946225771},{"_id":"public/img/20170727/Image6.png","hash":"b64ae70890b57d812838c5d8ee19583082087d6b","modified":1582946225771},{"_id":"public/img/20170802/001.gif","hash":"e27cbb6e1860d72c6f980e717beaf1e51013b07e","modified":1582946225771},{"_id":"public/img/20170802/002.gif","hash":"ab765e2f86c6524c1c44597805966757e7628e6b","modified":1582946225771},{"_id":"public/img/201807/view_model.png","hash":"ef194d46df905157b4c65466468fd4681f499270","modified":1582946225771},{"_id":"public/img/20170802/004.jpg","hash":"011dc1b91ffc54c403dd3aa2eb00f6c405823fbb","modified":1582946225771},{"_id":"public/img/201807/view_model1.png","hash":"4ba78ac2452498f9e27df4bd91727f7eca4a7220","modified":1582946225771},{"_id":"public/img/201807/service_lifecycle.png","hash":"5c1d2bf331a1475fccd7e91f29af4e5a7b26f9b4","modified":1582946225771},{"_id":"public/img/DataStructure/adjacency_list1.png","hash":"cb0b1017a9c47dc6cfae862436b34d7177e7aca3","modified":1582946225771},{"_id":"public/img/201807/view_model2.png","hash":"3b13867ed6ef01bad9bd6d4d6678bb11d1be541c","modified":1582946225771},{"_id":"public/img/20170731/Thumbs.db","hash":"dc573d7906b851495e4f5384d64e070bc179c2a7","modified":1582946225771},{"_id":"public/img/DataStructure/adjacency_matrix1.png","hash":"810a07fbc8e384a32fa69a556d22290b94343e14","modified":1582946225771},{"_id":"public/img/DataStructure/adjacency_matrix2.png","hash":"956ce82807f386760265152a560c21bb1a209e4c","modified":1582946225771},{"_id":"public/img/DataStructure/adjacency_matrix3.png","hash":"753eb3efbe2a104e3659a46f395e0e3e0c348ee9","modified":1582946225771},{"_id":"public/img/DataStructure/binary_tree_result.png","hash":"6e887cacde537b36a667ba915033e54138a1f396","modified":1582946225771},{"_id":"public/img/20170802/Thumbs.db","hash":"766f400ee841f98a0728569d5be4838dd4f9fdf9","modified":1582946225771},{"_id":"public/img/DataStructure/binary_tree.jpg","hash":"f124b7ead17dc866c7726d5c0095de35f0338231","modified":1582946225771},{"_id":"public/img/DataStructure/heap3.jpg","hash":"37a570aaa9ce98c1b619c55121297d9f689725b7","modified":1582946225771},{"_id":"public/img/20170727/Thumbs.db","hash":"e2c7562503f8eaa0557aaf1c1642fb45c16fd857","modified":1582946225771},{"_id":"public/img/DataStructure/heap2.jpg","hash":"ff257b33be988c0f480fd2298d8b656b8e335198","modified":1582946225771},{"_id":"public/img/DataStructure/quick_sort.jpg","hash":"a83f57425b47b1087d74a6c4ee22cc632a460eea","modified":1582946225771},{"_id":"public/img/DataStructure/heap_sort.jpg","hash":"eb5166b07005b4bbf2b5937b2e12eff1f5fdc396","modified":1582946225771},{"_id":"public/img/DataStructure/heap7.jpg","hash":"1f62e84ec84a32f5cc47c21d6367a7bbc1f7940b","modified":1582946225771},{"_id":"public/img/DataStructure/huffman_tree1.png","hash":"1bcf8ad33c94ff370c9e7a022c618bc108216d51","modified":1582946225771},{"_id":"public/img/DataStructure/threaded_binary_tree.jpg","hash":"42c53b95e0112e8b0407178fb6b83b2fe5e49105","modified":1582946225771},{"_id":"public/img/DataStructure/huffman_tree3.png","hash":"0c3d5180fbfc7560effb45068ed45fd32993fe57","modified":1582946225771},{"_id":"public/img/DataStructure/quick_sort_01.jpg","hash":"7bf4d9c95393f6f764a27c7b649ee0454859ee55","modified":1582946225771},{"_id":"public/img/head/abstract-1.jpg","hash":"d0715ea88f6d2b141fc61a26ebdc2bdae5e22daf","modified":1582946225771},{"_id":"public/img/head/abstract-3.jpg","hash":"f9cfd59619122ce6abd3c16773e2b94dd30e8a14","modified":1582946225771},{"_id":"public/img/head/abstract-4.jpg","hash":"ec72f4266c0b8b26c54acd3cf0592ffbd2b0cd83","modified":1582946225771},{"_id":"public/img/head/abstract-10.jpg","hash":"a28c4d5b2d376a27b6cb110618ed5f5015db8b88","modified":1582946225771},{"_id":"public/img/DataStructure/thread_binary_tree.jpg","hash":"4eae3ccc3de99620b5c978925919e747efcff67c","modified":1582946225771},{"_id":"public/img/head/abstract-5.jpg","hash":"59e43d16c6c0e78a570b1c048a7e1ee6b2a66809","modified":1582946225771},{"_id":"public/img/head/abstract-6.jpg","hash":"5ed0c433cbbfa810f85fe44bac49a01abd722cba","modified":1582946225771},{"_id":"public/img/head/abstract-8.jpg","hash":"5927dc5eff774995feca29cbe2ab0a3c53f22130","modified":1582946225771},{"_id":"public/img/head/abstract-7.jpg","hash":"461d49385ff51918bc8f951a64c4811a31a77170","modified":1582946225771},{"_id":"public/img/DataStructure/huffman_tree.png","hash":"8c4fa46aaf9c54f20a937ef0cac565e7c2422c61","modified":1582946225771},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1582946225771},{"_id":"public/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1582946225771},{"_id":"public/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1582946225771},{"_id":"public/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1582946225771},{"_id":"public/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1582946225771},{"_id":"public/images/wechat_donate.png","hash":"34177b6a5d7eb05babc4a5fd1b7952daf65056cf","modified":1582946225771},{"_id":"public/img/20170726/Image16.png","hash":"90c9977aaafb00de1689593624021b02ad144a96","modified":1582946225771},{"_id":"public/img/20170731/insertsort.gif","hash":"5fc8daa9296837453ccbc8c7f9c2494bbd1fcdda","modified":1582946225771},{"_id":"public/img/DataStructure/Merge_sort.gif","hash":"8c074d46d4c96077d11f9e8cab9ff5d95bdc3da0","modified":1582946225771},{"_id":"public/img/20170731/001.png","hash":"a5205f3db29fe11646ad8c0c580daef28b2473c4","modified":1582946225771},{"_id":"public/img/DataStructure/adjacency_matrix.jpg","hash":"b9a9e2e34290fa182102bec682ae532be806025d","modified":1582946225771},{"_id":"public/img/DataStructure/adjacency_list.jpg","hash":"44905436617f72027e8001cc11f74694508e78a6","modified":1582946225771},{"_id":"public/img/DataStructure/heap1.jpg","hash":"96a7319b82d0dc5e949799cc57a1a272672f85b9","modified":1582946225771},{"_id":"public/img/DataStructure/heap8.jpg","hash":"109e6c65abd6a6d02d127dd4c95bc0bd0972d3fd","modified":1582946225771},{"_id":"public/img/DataStructure/huffman_tree2.jpg","hash":"d6a9e2244379a111969c694004d7efb42a8a901b","modified":1582946225771},{"_id":"public/img/DataStructure/heap5.jpg","hash":"74d134ee991b8afec74f5a9f9b18df3c28122bb4","modified":1582946225771},{"_id":"public/img/head/abstract-11.jpg","hash":"5530006198c8661d073c2abe6450c5281f2c1f9b","modified":1582946225771},{"_id":"public/img/head/head4.jpeg","hash":"7e2ed107864f98ddbd40bf8a5d95f932f494c9ff","modified":1582946225771},{"_id":"public/img/DataStructure/heap.jpg","hash":"f2f37a05d4bda669871ad1efc123a69621657406","modified":1582946225771},{"_id":"public/img/head/abstract-2.jpg","hash":"8c427ec200839e10e871857fbc485cf8a0f89783","modified":1582946225771},{"_id":"public/img/head/abstract-12.jpg","hash":"1909308a3be803cb2a8884fee01544c374e0f671","modified":1582946225771},{"_id":"public/images/avatar.jpg","hash":"08eaa857c1a207880486fa8745233d56f624664a","modified":1582946225771},{"_id":"public/images/alipay_donate.png","hash":"451d6a847df4bd48e0c0217242fe357f4e31e3ff","modified":1582946225771},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1582946225771},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1582946225771},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1582946225771},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1582946225771},{"_id":"public/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1582946225771},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1582946225771},{"_id":"public/js/main.js","hash":"9b7063b2faf8cc43e8539d777285e20574011769","modified":1582946225771},{"_id":"public/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1582946225771},{"_id":"public/img/20170802/003.jpg","hash":"6f6cc25f13e0cdf862cd134b92e6feba89d86ea4","modified":1582946225771},{"_id":"public/img/head/head2.jpeg","hash":"27463b3d6d1dc5f6a2831b9c555312831eaad2bc","modified":1582946225771},{"_id":"public/img/head/head3.jpeg","hash":"9668f2fb85062bdd79b6447b4a5054085886124e","modified":1582946225771},{"_id":"public/img/head/head11.jpg","hash":"d7ff9d7855c023528d0ff4f4b2caf3e6dc7cf717","modified":1582946225771},{"_id":"public/img/head/head8.png","hash":"4b6bf0531edfef1c6f86f587474f96134ad16644","modified":1582946225771},{"_id":"public/img/head/head10.jpeg","hash":"4331127a333d40d9ff16623870478c176b53f84c","modified":1582946225771},{"_id":"public/img/head/head15.jpeg","hash":"834c7a85e87500144217992047d57eb3805b5da2","modified":1582946225771},{"_id":"public/img/head/head6.jpeg","hash":"c6ee0a98d9a72582ca0d6b6475ac3a55bd6f96f8","modified":1582946225771},{"_id":"public/css/style.css","hash":"666763ad6166f499d68a31ee2638e78d20174e6b","modified":1582946225771},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1582946225771},{"_id":"public/img/head/head14.jpeg","hash":"b16b65105258818c16845d8084d57158f635f4b9","modified":1582946225771},{"_id":"public/img/head/head12.jpeg","hash":"0cab73cd97964fb2d2c09c699b18e13189952796","modified":1582946225771},{"_id":"public/img/head/head5.jpeg","hash":"7e8dbba776326e67a5308fa033134aba0397b24d","modified":1582946225771},{"_id":"public/img/20170726/Thumbs.db","hash":"ee48e951388f6679a722e9f2ce67266926a35b05","modified":1582946225771},{"_id":"public/img/DataStructure/Merge_sort_01.gif","hash":"cd1e80c9283020a8c465236497cbcd06e2a27fcc","modified":1582946225771},{"_id":"public/img/head/head7.jpeg","hash":"05617269e76eb84c8fd5f271e1d34bc42a2f1e0d","modified":1582946225771},{"_id":"public/img/head/head1.jpeg","hash":"919d374168544f9bdc5027c7d6606b78472dbc72","modified":1582946225771},{"_id":"public/img/002.jpeg","hash":"1620698a57a7fc021e7bbbfb00c2636d571639d2","modified":1582946225771},{"_id":"public/img/DataStructure/heap6.jpg","hash":"0912d02ba1bab1c5dfada1787bc6a3a8f175b951","modified":1582946225771},{"_id":"public/img/008.jpg","hash":"2c065fff8ee830b4abb51124c7685fdb3e1fb240","modified":1582946225771},{"_id":"public/img/head/head9.png","hash":"f3d61516e0bdc1ded6fbd2e74373a8617c022f23","modified":1582946225771},{"_id":"public/img/head/head13.jpeg","hash":"8120574c276d4fdb4ffb3fc2c973400a904b2abb","modified":1582946225771},{"_id":"public/img/006.jpeg","hash":"49607adbaac612cc0783c6ca921607cb9cad716b","modified":1582946225771},{"_id":"public/img/007.jpeg","hash":"c702228fd507a2130e1697639d40ac1b2c524602","modified":1582946225771},{"_id":"public/img/005.jpeg","hash":"0de07377509cc7358f8243f8bd5c09a1f828d870","modified":1582946225771},{"_id":"public/img/009.jpeg","hash":"d24146bbba16d4710ce43c90857f1e349fc0d95d","modified":1582946225771},{"_id":"public/img/003.jpeg","hash":"6a3c0edf34a4a6ea2ab7418768bbf2b1111aed1b","modified":1582946225771},{"_id":"public/img/001.jpeg","hash":"755049d37a0cd7db995eae797517cbf560b609bc","modified":1582946225771},{"_id":"public/img/008 - Copy.jpeg","hash":"e5872101a0a03f257e0dabeaaa3ba3ff852175c8","modified":1582946225771},{"_id":"public/img/004.jpeg","hash":"6434a4a293ec3b1d974151b6126d7f0e1ec61aea","modified":1582946225771},{"_id":"public/img/0010 原图.jpeg","hash":"87453164794997c5aa11c39d3428c930f351e852","modified":1582946225771},{"_id":"source/_posts/.history/Android/Android基础/Android后台任务_20190930162841.md","hash":"c184467607dff62825ed43781d74051b81e5e511","modified":1582948049335},{"_id":"source/_posts/.history/Android/Android基础/Android后台任务_20200229114729.md","hash":"c184467607dff62825ed43781d74051b81e5e511","modified":1582948049363}],"Category":[{"name":"Android","_id":"ck770ryha0028isuiau9iemq8"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","thumbnail":"/assets/Android JNI.png","toc":true,"description":"测试摘要","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nthumbnail: /assets/Android JNI.png\ntoc: true\ndescription: 测试摘要\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-02-27T03:04:11.132Z","updated":"2020-02-29T01:56:47.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rye30000isui39oz6dm8","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"_content":"","source":"_posts/Directory/Android Directory.md","raw":"","slug":"Directory/Android Directory","published":1,"date":"2019-09-11T01:29:47.698Z","updated":"2019-09-11T01:29:47.698Z","title":"Directory/Android Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryes0001isui9odfccx3","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Directory/Kotlin Directory.md","raw":"","slug":"Directory/Kotlin Directory","published":1,"date":"2019-09-11T01:29:47.698Z","updated":"2019-09-11T01:29:47.698Z","title":"Directory/Kotlin Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryet0002isuiexrf1vgg","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Directory/README.md","raw":"","slug":"Directory/README","published":1,"date":"2019-09-11T01:29:47.699Z","updated":"2019-09-11T01:29:47.699Z","title":"Directory/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryeu0003isui6jx8e8gf","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Kotlin/README.md","raw":"","slug":"Kotlin/README","published":1,"date":"2019-09-11T01:29:47.705Z","updated":"2019-09-11T01:29:47.705Z","title":"Kotlin/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryev0004isuidlf03mwr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"二叉树的前序、中序、后序遍历","description":"递归构建二叉树、二叉树的三种遍历方式都是通过递归进行","_content":"\n* 二叉树的结构体\nmodified: 2017-07-27\n\n```c\ntypedef struct binaryTree {\n\tchar item;\n\tstruct binaryTree *lChild;\n\tstruct binaryTree *rChild;\n\n}binaryTree, *pBinaryTree;\n\n```\n\n* 二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；'#'作为递归的结束；\n\n```c\npBinaryTree createBinaryTree() {\n\n\tchar tmp = '0';\n\tpBinaryTree treeNode = NULL;\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\t//为加入的节点分配新的内存空间\n\t\ttreeNode = (binaryTree*)malloc(sizeof(binaryTree));\n\t\ttreeNode->item = tmp;\n\n\t\t//递归调用产生二叉树\n\t\ttreeNode->lChild = createBinaryTree();\n\t\ttreeNode->rChild = createBinaryTree();\n\n\t}\n\treturn treeNode;\n\n}\n\n```\n\n* 先序遍历二叉树\n\n```c\nvoid preVisitBiTree(pBinaryTree root) {\n\tif (root)\n\t{\n\t\t//先遍历根节点\n\t\tprintf(\"%c\", root->item);\n\t\t//遍历左子树\n\t\tpreVisitBiTree(root->lChild);\n\t\t//遍历右子树\n\t\tpreVisitBiTree(root->rChild);\n\n\t}\n}\n```\n\n* 中序遍历二叉树\n\n```c\nvoid inVisitBiTree(pBinaryTree inRoot) {\n\n\tif (inRoot)\n\t{\n\t\t//先遍历左子树\n\t\tinVisitBiTree(inRoot -> lChild );\n\t\t//遍历根节点\n\t\tprintf(\"%c\", inRoot->item);\n\t\t//遍历右子树\n\t\tinVisitBiTree(inRoot->rChild);\n\t}\n\n}\n\n\n```\n\n* 后序遍历二叉树\n\n```c\nvoid lastVisitBiTree(pBinaryTree lastRoot) {\n\n\tif (lastRoot)\n\t{\n\t\t//遍历左子树\n\t\tinVisitBiTree(lastRoot->lChild);\n\t\t//遍历右子树\n\t\tinVisitBiTree(lastRoot->rChild);\n\t\t//遍历根节点\n\t\tprintf(\"%c\", lastRoot->item);\n\t}\n}\n\n```\n\n### 三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\n\n\n### 测试：\n\n测试用例：ABC##D##E#F##\n\n\n```c\n\nint main() {\n\n\t//构建一颗二叉树\n\tpBinaryTree binaryTree = createBinaryTree();\n\t//采用先序遍历的方式遍历输出二叉树\n\tpreVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\t//采用中序遍历的方式输出二叉树\n\tinVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\tlastVisitBiTree(binaryTree);\n\tprintf(\"测试二叉树\");\n\treturn 0;\n}\n\n```","source":"_posts/Data_Structure/2017-07-27-data-structure-binary-tree-visit.md","raw":"---\n\ntitle: \"二叉树的前序、中序、后序遍历\"\ndescription: \"递归构建二叉树、二叉树的三种遍历方式都是通过递归进行\"\ntags: [数据结构]\n\n---\n\n* 二叉树的结构体\nmodified: 2017-07-27\n\n```c\ntypedef struct binaryTree {\n\tchar item;\n\tstruct binaryTree *lChild;\n\tstruct binaryTree *rChild;\n\n}binaryTree, *pBinaryTree;\n\n```\n\n* 二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；'#'作为递归的结束；\n\n```c\npBinaryTree createBinaryTree() {\n\n\tchar tmp = '0';\n\tpBinaryTree treeNode = NULL;\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\t//为加入的节点分配新的内存空间\n\t\ttreeNode = (binaryTree*)malloc(sizeof(binaryTree));\n\t\ttreeNode->item = tmp;\n\n\t\t//递归调用产生二叉树\n\t\ttreeNode->lChild = createBinaryTree();\n\t\ttreeNode->rChild = createBinaryTree();\n\n\t}\n\treturn treeNode;\n\n}\n\n```\n\n* 先序遍历二叉树\n\n```c\nvoid preVisitBiTree(pBinaryTree root) {\n\tif (root)\n\t{\n\t\t//先遍历根节点\n\t\tprintf(\"%c\", root->item);\n\t\t//遍历左子树\n\t\tpreVisitBiTree(root->lChild);\n\t\t//遍历右子树\n\t\tpreVisitBiTree(root->rChild);\n\n\t}\n}\n```\n\n* 中序遍历二叉树\n\n```c\nvoid inVisitBiTree(pBinaryTree inRoot) {\n\n\tif (inRoot)\n\t{\n\t\t//先遍历左子树\n\t\tinVisitBiTree(inRoot -> lChild );\n\t\t//遍历根节点\n\t\tprintf(\"%c\", inRoot->item);\n\t\t//遍历右子树\n\t\tinVisitBiTree(inRoot->rChild);\n\t}\n\n}\n\n\n```\n\n* 后序遍历二叉树\n\n```c\nvoid lastVisitBiTree(pBinaryTree lastRoot) {\n\n\tif (lastRoot)\n\t{\n\t\t//遍历左子树\n\t\tinVisitBiTree(lastRoot->lChild);\n\t\t//遍历右子树\n\t\tinVisitBiTree(lastRoot->rChild);\n\t\t//遍历根节点\n\t\tprintf(\"%c\", lastRoot->item);\n\t}\n}\n\n```\n\n### 三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\n\n\n### 测试：\n\n测试用例：ABC##D##E#F##\n\n\n```c\n\nint main() {\n\n\t//构建一颗二叉树\n\tpBinaryTree binaryTree = createBinaryTree();\n\t//采用先序遍历的方式遍历输出二叉树\n\tpreVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\t//采用中序遍历的方式输出二叉树\n\tinVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\tlastVisitBiTree(binaryTree);\n\tprintf(\"测试二叉树\");\n\treturn 0;\n}\n\n```","slug":"Data_Structure/2017-07-27-data-structure-binary-tree-visit","published":1,"date":"2020-02-29T02:45:08.831Z","updated":"2020-02-29T02:54:39.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryfn0005isui4cqf0xji","content":"<ul>\n<li>二叉树的结构体<br>modified: 2017-07-27</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">lChild</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">rChild</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;binaryTree, *pBinaryTree;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；’#’作为递归的结束；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\tpBinaryTree treeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">'#'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//为加入的节点分配新的内存空间</span></span><br><span class=\"line\">\t\ttreeNode = (binaryTree*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(binaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用产生二叉树</span></span><br><span class=\"line\">\t\ttreeNode-&gt;lChild = createBinaryTree();</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild = createBinaryTree();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>先序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preVisitBiTree</span><span class=\"params\">(pBinaryTree root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, root-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;rChild);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>中序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree inRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot -&gt; lChild );</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, inRoot-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>后序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lastVisitBiTree</span><span class=\"params\">(pBinaryTree lastRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lastRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;rChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, lastRoot-&gt;item);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"><a href=\"#三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\" class=\"headerlink\" title=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"></a>三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别</h3><h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><p>测试用例：ABC##D##E#F##</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//构建一颗二叉树</span></span><br><span class=\"line\">\tpBinaryTree binaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"comment\">//采用先序遍历的方式遍历输出二叉树</span></span><br><span class=\"line\">\tpreVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//采用中序遍历的方式输出二叉树</span></span><br><span class=\"line\">\tinVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\tlastVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"测试二叉树\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>二叉树的结构体<br>modified: 2017-07-27</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">lChild</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">rChild</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;binaryTree, *pBinaryTree;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；’#’作为递归的结束；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\tpBinaryTree treeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">'#'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//为加入的节点分配新的内存空间</span></span><br><span class=\"line\">\t\ttreeNode = (binaryTree*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(binaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用产生二叉树</span></span><br><span class=\"line\">\t\ttreeNode-&gt;lChild = createBinaryTree();</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild = createBinaryTree();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>先序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preVisitBiTree</span><span class=\"params\">(pBinaryTree root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, root-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;rChild);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>中序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree inRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot -&gt; lChild );</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, inRoot-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>后序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lastVisitBiTree</span><span class=\"params\">(pBinaryTree lastRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lastRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;rChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, lastRoot-&gt;item);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"><a href=\"#三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\" class=\"headerlink\" title=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"></a>三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别</h3><h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><p>测试用例：ABC##D##E#F##</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//构建一颗二叉树</span></span><br><span class=\"line\">\tpBinaryTree binaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"comment\">//采用先序遍历的方式遍历输出二叉树</span></span><br><span class=\"line\">\tpreVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//采用中序遍历的方式输出二叉树</span></span><br><span class=\"line\">\tinVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\tlastVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"测试二叉树\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"排序算法","description":"插入排序","_content":"\n# 排序算法\nmodified: 2017-08-02\n\n## 插入排序有直接插入排序、折半插入排序、希尔排序等\n\n### 直接插入排序\n\n直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。\n\n\t/images/20170731/insertsort.gif\n\n\nC语言代码实现\n\n```c\n\nvoid StrightInsertSort(int array[], int length) {\n\n\tint tmp;     //用于保存将要插入的array[i]\n\tfor (int i = 1; i < length; i++) {\n\t\ttmp = array[i];\n\t\tfor (int j = i; j >= 0; j--)\n\t\t{\n\t\t\tif (tmp >= array[j - 1] || j == 0)\n\t\t\t{\n\t\t\t\tarray[j] = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 折半插入排序\n\n折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；\n\nC语言代码实现\n\n```c\nvoid BInsertSort(int array[], int length) {\n\tint tmp;\n\tint start, end, mid;\n\n\n\tfor (int i = 1; i < length; i++)\n\t{\n\t\ttmp = array[i];\n\t\tstart = 0; end = i - 1; mid = (end + start) / 2;\n\n\t\t//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值\n\t\tif (tmp >= array[i - 1])\n\t\t{\n\t\t\tarray[i] = tmp;\n\t\t}\n\t\telse if (tmp <= array[0]) {\n\t\t\tfor (int j = i; j > 0; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[0] = tmp;\n\t\t}\n        //进行折半查找排序\n\t\telse\n\t\t{\n\t\t\twhile (start < end)\n\t\t\t{\n\t\t\t\tif (tmp > array[mid])\n\t\t\t\t{\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t\telse if (tmp < array[mid])\n\t\t\t\t{\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i; j > start; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[start] = tmp;\n\n\t\t}\n\t}\n\n}\n\n```\n\n\n### 希尔排序\n\n希尔排序（Shell's Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；\n\n\n\t/images/20170731/001.png\n\n\n* 颜色相同的为一个分组\n\nC语言代码实现\n\n```c\n\nvoid shell_sort(int arr[], int length) {\n\tint gap, i, j;\n\tint tmp;\n\tfor (gap = length / 2; gap > 0; gap /= 2)\n\t{\n        //下面两个for循环是对每一个分组进行插入排序\n\t\tfor (i = gap; i < length; i++)\n\t\t{\n\t\t\ttmp = arr[i];\n\t\t\tfor (j = i - gap; j >= 0 && arr[j] > tmp; j-=gap)\n\t\t\t{\n\t\t\t\tarr[j + gap] = arr[j];\n\t\t\t}\n\t\t\tarr[j + gap] = tmp;\n\t\t}\n\t}\n\n}\n\n```","source":"_posts/Data_Structure/2017-07-31-data-structure-insert-sort.md","raw":"---\ntitle: \"排序算法\"\ndescription: \"插入排序\"\ntags: [数据结构]\n---\n\n# 排序算法\nmodified: 2017-08-02\n\n## 插入排序有直接插入排序、折半插入排序、希尔排序等\n\n### 直接插入排序\n\n直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。\n\n\t/images/20170731/insertsort.gif\n\n\nC语言代码实现\n\n```c\n\nvoid StrightInsertSort(int array[], int length) {\n\n\tint tmp;     //用于保存将要插入的array[i]\n\tfor (int i = 1; i < length; i++) {\n\t\ttmp = array[i];\n\t\tfor (int j = i; j >= 0; j--)\n\t\t{\n\t\t\tif (tmp >= array[j - 1] || j == 0)\n\t\t\t{\n\t\t\t\tarray[j] = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 折半插入排序\n\n折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；\n\nC语言代码实现\n\n```c\nvoid BInsertSort(int array[], int length) {\n\tint tmp;\n\tint start, end, mid;\n\n\n\tfor (int i = 1; i < length; i++)\n\t{\n\t\ttmp = array[i];\n\t\tstart = 0; end = i - 1; mid = (end + start) / 2;\n\n\t\t//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值\n\t\tif (tmp >= array[i - 1])\n\t\t{\n\t\t\tarray[i] = tmp;\n\t\t}\n\t\telse if (tmp <= array[0]) {\n\t\t\tfor (int j = i; j > 0; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[0] = tmp;\n\t\t}\n        //进行折半查找排序\n\t\telse\n\t\t{\n\t\t\twhile (start < end)\n\t\t\t{\n\t\t\t\tif (tmp > array[mid])\n\t\t\t\t{\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t\telse if (tmp < array[mid])\n\t\t\t\t{\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i; j > start; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[start] = tmp;\n\n\t\t}\n\t}\n\n}\n\n```\n\n\n### 希尔排序\n\n希尔排序（Shell's Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；\n\n\n\t/images/20170731/001.png\n\n\n* 颜色相同的为一个分组\n\nC语言代码实现\n\n```c\n\nvoid shell_sort(int arr[], int length) {\n\tint gap, i, j;\n\tint tmp;\n\tfor (gap = length / 2; gap > 0; gap /= 2)\n\t{\n        //下面两个for循环是对每一个分组进行插入排序\n\t\tfor (i = gap; i < length; i++)\n\t\t{\n\t\t\ttmp = arr[i];\n\t\t\tfor (j = i - gap; j >= 0 && arr[j] > tmp; j-=gap)\n\t\t\t{\n\t\t\t\tarr[j + gap] = arr[j];\n\t\t\t}\n\t\t\tarr[j + gap] = tmp;\n\t\t}\n\t}\n\n}\n\n```","slug":"Data_Structure/2017-07-31-data-structure-insert-sort","published":1,"date":"2020-02-29T02:45:08.886Z","updated":"2020-02-29T03:06:02.573Z","_id":"ck770ryfo0006isuicgrt24ud","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h1><p>modified: 2017-08-02</p>\n<h2 id=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"><a href=\"#插入排序有直接插入排序、折半插入排序、希尔排序等\" class=\"headerlink\" title=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"></a>插入排序有直接插入排序、折半插入排序、希尔排序等</h2><h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><p>直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。</p>\n<pre><code>/images/20170731/insertsort.gif</code></pre><p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrightInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;     <span class=\"comment\">//用于保存将要插入的array[i]</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>] || j == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = tmp;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><p>折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；</p>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start, <span class=\"built_in\">end</span>, mid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\tstart = <span class=\"number\">0</span>; <span class=\"built_in\">end</span> = i - <span class=\"number\">1</span>; mid = (<span class=\"built_in\">end</span> + start) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[i] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt;= <span class=\"built_in\">array</span>[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">//进行折半查找排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (start &lt; <span class=\"built_in\">end</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (tmp &gt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tstart = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">end</span> = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; start; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[start] = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>希尔排序（Shell’s Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；</p>\n<pre><code>/images/20170731/001.png</code></pre><ul>\n<li>颜色相同的为一个分组</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> gap, i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (gap = length / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面两个for循环是对每一个分组进行插入排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = gap; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; tmp; j-=gap)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tarr[j + gap] = arr[j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tarr[j + gap] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h1><p>modified: 2017-08-02</p>\n<h2 id=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"><a href=\"#插入排序有直接插入排序、折半插入排序、希尔排序等\" class=\"headerlink\" title=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"></a>插入排序有直接插入排序、折半插入排序、希尔排序等</h2><h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><p>直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。</p>\n<pre><code>/images/20170731/insertsort.gif</code></pre><p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrightInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;     <span class=\"comment\">//用于保存将要插入的array[i]</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>] || j == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = tmp;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><p>折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；</p>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start, <span class=\"built_in\">end</span>, mid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\tstart = <span class=\"number\">0</span>; <span class=\"built_in\">end</span> = i - <span class=\"number\">1</span>; mid = (<span class=\"built_in\">end</span> + start) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[i] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt;= <span class=\"built_in\">array</span>[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">//进行折半查找排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (start &lt; <span class=\"built_in\">end</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (tmp &gt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tstart = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">end</span> = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; start; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[start] = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>希尔排序（Shell’s Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；</p>\n<pre><code>/images/20170731/001.png</code></pre><ul>\n<li>颜色相同的为一个分组</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> gap, i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (gap = length / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面两个for循环是对每一个分组进行插入排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = gap; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; tmp; j-=gap)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tarr[j + gap] = arr[j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tarr[j + gap] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"顺序栈的表示与实现","description":null,"_content":"\nmodified: 2017-7-28\n本文采用C语言，利用结构体来实现顺序栈\n\n* 用于定义栈的大小，以及再栈满的时候，扩充栈\n\n```c\n#define STACK_SIZE 50\n#define STACK_INCREMENT 10\n```\n\n* 采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈\n\n```c\ntypedef struct {\n\tint stackSize;  //栈容量\n\tint *base;      //栈底指针\n\tint *top;       //栈顶指针\n}SqStack, *pStack;\n\n```\n\n* 初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针\n\n```c\nvoid initStack(pStack p) {\n\tp->base = (int *)malloc(STACK_SIZE * sizeof(int));\n\tif (p->base != NULL)\n\t{\n\t\tp->top = p->base;\n\t\tp->stackSize = STACK_SIZE;\n\t}\n\telse\n\t{\n\t\tprintf(\"分配内存失败\");\n\t}\n}\n\n```\n\n* 栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false\n\n```c\nbool isEmpty(pStack p) {\n\treturn p->top == p->base ? true : false;\n}\n```\n\n* 栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较\n\n```c\nbool isFull(pStack p) {\n\treturn (p->top - p->base) >= STACK_SIZE ? true : false;\n}\n\n```\n\n* 入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；\n\n```c\nvoid push(pStack p, int topElement) {\n\tint *q = NULL;\n\tif (isFull(p))\n\t{\n\t\tq = (int *)realloc(p->base, STACK_INCREMENT * sizeof(int));  // 重新调整内存块的大小\n\n\t\tp->base = q;\n\t\tp->stackSize = p->stackSize + STACK_INCREMENT;\n\t}\n\t*(p->top)++ = topElement;\n}\n\n```\n\n* 出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；\n\n```c\nvoid pop(pStack p, int *topElement) {\n\tif (isEmpty(p))\n\t{\n\t\tprintf(\"空栈\");\n\n\t}\n\n\tp->top--;\n\t*topElement = *p->top;\n}\n\n\n```\n\n* 求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一\n\n```c\nint getStackTop(SqStack s) {\n\tint topElement;\n\tif (isEmpty(&s))\n\t{\n\t\treturn 0;\n\t}\n\ttopElement = *(s.top - 1);\n\treturn topElement;\n\n}\n\n```\n\n* 清空栈，不断将让栈中元素出栈，直至栈空\n\n```c\nvoid clearStack(SqStack s) {\n\twhile (!isEmpty(&s))\n\t{\n\t\tint tmp;\n\t\tpop(&s, &tmp);\n\t}\n\n}\n```\n\n* 求栈当前大小\n\n```c\nint getStackLength(SqStack s) {\n\tint i = 0;\n\tint *q = s.top;\n\n\twhile (q != s.base)\n\t{\n\t\tq--;\n\t\ti++;\n\t}\n\treturn i;\n}\n```\n\n","source":"_posts/Data_Structure/2017-07-27-data-structure-stack.md","raw":"---\ntitle: 顺序栈的表示与实现\ndescription:\ntags: [数据结构]\n---\n\nmodified: 2017-7-28\n本文采用C语言，利用结构体来实现顺序栈\n\n* 用于定义栈的大小，以及再栈满的时候，扩充栈\n\n```c\n#define STACK_SIZE 50\n#define STACK_INCREMENT 10\n```\n\n* 采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈\n\n```c\ntypedef struct {\n\tint stackSize;  //栈容量\n\tint *base;      //栈底指针\n\tint *top;       //栈顶指针\n}SqStack, *pStack;\n\n```\n\n* 初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针\n\n```c\nvoid initStack(pStack p) {\n\tp->base = (int *)malloc(STACK_SIZE * sizeof(int));\n\tif (p->base != NULL)\n\t{\n\t\tp->top = p->base;\n\t\tp->stackSize = STACK_SIZE;\n\t}\n\telse\n\t{\n\t\tprintf(\"分配内存失败\");\n\t}\n}\n\n```\n\n* 栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false\n\n```c\nbool isEmpty(pStack p) {\n\treturn p->top == p->base ? true : false;\n}\n```\n\n* 栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较\n\n```c\nbool isFull(pStack p) {\n\treturn (p->top - p->base) >= STACK_SIZE ? true : false;\n}\n\n```\n\n* 入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；\n\n```c\nvoid push(pStack p, int topElement) {\n\tint *q = NULL;\n\tif (isFull(p))\n\t{\n\t\tq = (int *)realloc(p->base, STACK_INCREMENT * sizeof(int));  // 重新调整内存块的大小\n\n\t\tp->base = q;\n\t\tp->stackSize = p->stackSize + STACK_INCREMENT;\n\t}\n\t*(p->top)++ = topElement;\n}\n\n```\n\n* 出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；\n\n```c\nvoid pop(pStack p, int *topElement) {\n\tif (isEmpty(p))\n\t{\n\t\tprintf(\"空栈\");\n\n\t}\n\n\tp->top--;\n\t*topElement = *p->top;\n}\n\n\n```\n\n* 求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一\n\n```c\nint getStackTop(SqStack s) {\n\tint topElement;\n\tif (isEmpty(&s))\n\t{\n\t\treturn 0;\n\t}\n\ttopElement = *(s.top - 1);\n\treturn topElement;\n\n}\n\n```\n\n* 清空栈，不断将让栈中元素出栈，直至栈空\n\n```c\nvoid clearStack(SqStack s) {\n\twhile (!isEmpty(&s))\n\t{\n\t\tint tmp;\n\t\tpop(&s, &tmp);\n\t}\n\n}\n```\n\n* 求栈当前大小\n\n```c\nint getStackLength(SqStack s) {\n\tint i = 0;\n\tint *q = s.top;\n\n\twhile (q != s.base)\n\t{\n\t\tq--;\n\t\ti++;\n\t}\n\treturn i;\n}\n```\n\n","slug":"Data_Structure/2017-07-27-data-structure-stack","published":1,"date":"2020-02-29T02:45:08.862Z","updated":"2020-02-29T02:55:04.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryfs0008isui9arv8vd5","content":"<p>modified: 2017-7-28<br>本文采用C语言，利用结构体来实现顺序栈</p>\n<ul>\n<li>用于定义栈的大小，以及再栈满的时候，扩充栈</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_SIZE 50</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_INCREMENT 10</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize;  <span class=\"comment\">//栈容量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;      <span class=\"comment\">//栈底指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *top;       <span class=\"comment\">//栈顶指针</span></span><br><span class=\"line\">&#125;SqStack, *pStack;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initStack</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\tp-&gt;base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(STACK_SIZE * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p-&gt;base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tp-&gt;top = p-&gt;base;</span><br><span class=\"line\">\t\tp-&gt;stackSize = STACK_SIZE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"分配内存失败\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p-&gt;top == p-&gt;base ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (p-&gt;top - p-&gt;base) &gt;= STACK_SIZE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFull(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">realloc</span>(p-&gt;base, STACK_INCREMENT * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));  <span class=\"comment\">// 重新调整内存块的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tp-&gt;base = q;</span><br><span class=\"line\">\t\tp-&gt;stackSize = p-&gt;stackSize + STACK_INCREMENT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*(p-&gt;top)++ = topElement;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> *topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"空栈\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tp-&gt;top--;</span><br><span class=\"line\">\t*topElement = *p-&gt;top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackTop</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> topElement;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttopElement = *(s.top - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> topElement;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>清空栈，不断将让栈中元素出栈，直至栈空</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clearStack</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\tpop(&amp;s, &amp;tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>求栈当前大小</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackLength</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = s.top;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q != s.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq--;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-7-28<br>本文采用C语言，利用结构体来实现顺序栈</p>\n<ul>\n<li>用于定义栈的大小，以及再栈满的时候，扩充栈</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_SIZE 50</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_INCREMENT 10</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize;  <span class=\"comment\">//栈容量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;      <span class=\"comment\">//栈底指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *top;       <span class=\"comment\">//栈顶指针</span></span><br><span class=\"line\">&#125;SqStack, *pStack;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initStack</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\tp-&gt;base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(STACK_SIZE * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p-&gt;base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tp-&gt;top = p-&gt;base;</span><br><span class=\"line\">\t\tp-&gt;stackSize = STACK_SIZE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"分配内存失败\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p-&gt;top == p-&gt;base ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (p-&gt;top - p-&gt;base) &gt;= STACK_SIZE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFull(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">realloc</span>(p-&gt;base, STACK_INCREMENT * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));  <span class=\"comment\">// 重新调整内存块的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tp-&gt;base = q;</span><br><span class=\"line\">\t\tp-&gt;stackSize = p-&gt;stackSize + STACK_INCREMENT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*(p-&gt;top)++ = topElement;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> *topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"空栈\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tp-&gt;top--;</span><br><span class=\"line\">\t*topElement = *p-&gt;top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackTop</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> topElement;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttopElement = *(s.top - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> topElement;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>清空栈，不断将让栈中元素出栈，直至栈空</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clearStack</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\tpop(&amp;s, &amp;tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>求栈当前大小</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackLength</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = s.top;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q != s.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq--;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"查找算法","description":"插入排序","_content":"\n### 折半查找\nmodified: 2017-07-31\n折半查找即二分查找的实现\n\n```c\nint BinarySearch(int data[], int search,int length) {\n\tint end = length-1 ;\n\tint start = 0;\n\tint mid = (start + end) / 2;\n\n\twhile (start<=end)\n\t{\n\t\tif (data[mid] == search)\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (data[mid] > search)\n\t\t{\n\t\t\tend = mid-1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstart = mid+1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\n\t}\n\treturn -1;\n\n}\n\n```","source":"_posts/Data_Structure/2017-07-31-data-structure-search.md","raw":"---\n\ntitle: \"查找算法\"\ndescription: \"插入排序\"\ntags: [数据结构]\n\n\n\n---\n\n### 折半查找\nmodified: 2017-07-31\n折半查找即二分查找的实现\n\n```c\nint BinarySearch(int data[], int search,int length) {\n\tint end = length-1 ;\n\tint start = 0;\n\tint mid = (start + end) / 2;\n\n\twhile (start<=end)\n\t{\n\t\tif (data[mid] == search)\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (data[mid] > search)\n\t\t{\n\t\t\tend = mid-1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstart = mid+1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\n\t}\n\treturn -1;\n\n}\n\n```","slug":"Data_Structure/2017-07-31-data-structure-search","published":1,"date":"2020-02-29T02:45:08.893Z","updated":"2020-02-29T02:55:33.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryfs0009isuifk6r56bt","content":"<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><p>modified: 2017-07-31<br>折半查找即二分查找的实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BinarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> search,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">end</span> = length<span class=\"number\">-1</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (start&lt;=<span class=\"built_in\">end</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (data[mid] == search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[mid] &gt; search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">end</span> = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstart = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><p>modified: 2017-07-31<br>折半查找即二分查找的实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BinarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> search,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">end</span> = length<span class=\"number\">-1</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (start&lt;=<span class=\"built_in\">end</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (data[mid] == search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[mid] &gt; search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">end</span> = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstart = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"队列的表示与实现","description":"数据结构中队列的实现","_content":"\nmodified: 2017-08-02\n队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；\n\n## 链队列——队列的链式表示和实现\n\n链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。\n\n\t/source/img/20170802/002.gif\n\n\n* 注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点\n\n\nC语言实现代码\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n//单链队列，队列的链式存储结构，队列是由队头指向队尾\ntypedef struct QNode {\n\tchar data;\n\tstruct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct {\n\tQueuePtr  front;   //队头指针\n\tQueuePtr rare;     //队尾指针\n}LinkQueue;\n\n\n//用于初始化队列\nvoid initQueue(LinkQueue &lq) {\n\tlq.front = lq.rare = (QueuePtr)malloc(sizeof(QNode));\n\tlq.rare->next = NULL;\n\n}\n//用于插入队列\nvoid enQueue(LinkQueue &lq,char data) {\n\t//插入元素为Q的新的队尾元素 data\n\tQueuePtr p;\n\tp = (QueuePtr)malloc(sizeof(QNode));\n\tp->data = data;\n\tp->next = NULL;\n\tlq.rare->next = p;\n\tlq.rare = lq.rare->next;\n}\n//用于取出头元素，在操作之前首先需要判断是不是空队列\nvoid reQueue(LinkQueue &lq) {\n\tif (lq.front==lq.rare)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\telse\n\t{\n\t\tQueuePtr q;\n        //因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值\n\t\tprintf(\"%c\",lq.front->next->data);  \n\t\tq = lq.front;\n\t\tlq.front = lq.front->next;\n\t\tfree(q);\n\t}\n}\nint main() {\n\tLinkQueue lq;\n\tinitQueue(lq);\n\tenQueue(lq,'a');\n\tenQueue(lq,'b');\n\treQueue(lq);\n\treQueue(lq);\n\treturn 0;\n}\n\n```\n\n## 循环队列——队列的顺序表示和实现\n\n队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；\n\n/source/img/20170802/004.jpg\n\n\n* 初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；\n\n/source/img/20170802/003.jpg\n\n\n* 当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。\n\nC语言代码实现\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#define maxsize 100\ntypedef struct {\n\tint *base;    //用于为队列分配空间\n\tint front;\n\tint rear;\n}sqqueue;\n\n//初始化队列\nvoid initqueue(sqqueue &sq) {\n\t//构造一个空队列\n\tsq.base = (int *)malloc(maxsize*sizeof(int));\n\tif (!sq.base)\n\t{\n\t\tprintf(\"构造队列失败\");\n\t}\n\tsq.front = sq.rear = 0;\n}\n\n//入队\nvoid enqueue(sqqueue &sq,int e) {\n\t//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头\n\tif ((sq.rear+1)%maxsize==sq.front)\n\t{\n\t\tprintf(\"队列为满\");\n\t}\n\tsq.base[sq.rear] = e;\n\tsq.rear = (sq.rear + 1) % maxsize;  //转了一圈后sq.rare会超过maxsize\n\n}\n\n//出队\nvoid requeue(sqqueue &sq) {\n\t//用于判断队是否为空\n\tif (sq.rear==sq.front)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\tprintf(\"%d\\n\",sq.base[sq.front]);\n\tsq.front = (sq.front + 1) % maxsize;\n}\n\nint main() {\n\tsqqueue sq;\n\tinitqueue(sq);\n\tenqueue(sq,10);\n\tenqueue(sq,15);\n\trequeue(sq);\n\trequeue(sq);\n\treturn 0;\n}\n\n```\n","source":"_posts/Data_Structure/2017-08-02-data-structure-queue.md","raw":"---\n\ntitle: \"队列的表示与实现\"\ndescription: \"数据结构中队列的实现\"\ntags: [数据结构]\n\n\n---\n\nmodified: 2017-08-02\n队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；\n\n## 链队列——队列的链式表示和实现\n\n链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。\n\n\t/source/img/20170802/002.gif\n\n\n* 注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点\n\n\nC语言实现代码\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n//单链队列，队列的链式存储结构，队列是由队头指向队尾\ntypedef struct QNode {\n\tchar data;\n\tstruct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct {\n\tQueuePtr  front;   //队头指针\n\tQueuePtr rare;     //队尾指针\n}LinkQueue;\n\n\n//用于初始化队列\nvoid initQueue(LinkQueue &lq) {\n\tlq.front = lq.rare = (QueuePtr)malloc(sizeof(QNode));\n\tlq.rare->next = NULL;\n\n}\n//用于插入队列\nvoid enQueue(LinkQueue &lq,char data) {\n\t//插入元素为Q的新的队尾元素 data\n\tQueuePtr p;\n\tp = (QueuePtr)malloc(sizeof(QNode));\n\tp->data = data;\n\tp->next = NULL;\n\tlq.rare->next = p;\n\tlq.rare = lq.rare->next;\n}\n//用于取出头元素，在操作之前首先需要判断是不是空队列\nvoid reQueue(LinkQueue &lq) {\n\tif (lq.front==lq.rare)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\telse\n\t{\n\t\tQueuePtr q;\n        //因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值\n\t\tprintf(\"%c\",lq.front->next->data);  \n\t\tq = lq.front;\n\t\tlq.front = lq.front->next;\n\t\tfree(q);\n\t}\n}\nint main() {\n\tLinkQueue lq;\n\tinitQueue(lq);\n\tenQueue(lq,'a');\n\tenQueue(lq,'b');\n\treQueue(lq);\n\treQueue(lq);\n\treturn 0;\n}\n\n```\n\n## 循环队列——队列的顺序表示和实现\n\n队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；\n\n/source/img/20170802/004.jpg\n\n\n* 初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；\n\n/source/img/20170802/003.jpg\n\n\n* 当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。\n\nC语言代码实现\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#define maxsize 100\ntypedef struct {\n\tint *base;    //用于为队列分配空间\n\tint front;\n\tint rear;\n}sqqueue;\n\n//初始化队列\nvoid initqueue(sqqueue &sq) {\n\t//构造一个空队列\n\tsq.base = (int *)malloc(maxsize*sizeof(int));\n\tif (!sq.base)\n\t{\n\t\tprintf(\"构造队列失败\");\n\t}\n\tsq.front = sq.rear = 0;\n}\n\n//入队\nvoid enqueue(sqqueue &sq,int e) {\n\t//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头\n\tif ((sq.rear+1)%maxsize==sq.front)\n\t{\n\t\tprintf(\"队列为满\");\n\t}\n\tsq.base[sq.rear] = e;\n\tsq.rear = (sq.rear + 1) % maxsize;  //转了一圈后sq.rare会超过maxsize\n\n}\n\n//出队\nvoid requeue(sqqueue &sq) {\n\t//用于判断队是否为空\n\tif (sq.rear==sq.front)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\tprintf(\"%d\\n\",sq.base[sq.front]);\n\tsq.front = (sq.front + 1) % maxsize;\n}\n\nint main() {\n\tsqqueue sq;\n\tinitqueue(sq);\n\tenqueue(sq,10);\n\tenqueue(sq,15);\n\trequeue(sq);\n\trequeue(sq);\n\treturn 0;\n}\n\n```\n","slug":"Data_Structure/2017-08-02-data-structure-queue","published":1,"date":"2020-02-29T02:45:08.900Z","updated":"2020-02-29T03:06:50.470Z","_id":"ck770ryft000aisuifl7b2vuy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-02<br>队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；</p>\n<h2 id=\"链队列——队列的链式表示和实现\"><a href=\"#链队列——队列的链式表示和实现\" class=\"headerlink\" title=\"链队列——队列的链式表示和实现\"></a>链队列——队列的链式表示和实现</h2><p>链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。</p>\n<pre><code>/source/img/20170802/002.gif</code></pre><ul>\n<li>注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//单链队列，队列的链式存储结构，队列是由队头指向队尾</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQueuePtr  front;   <span class=\"comment\">//队头指针</span></span><br><span class=\"line\">\tQueuePtr rare;     <span class=\"comment\">//队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\tlq.front = lq.rare = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tlq.rare-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于插入队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enQueue</span><span class=\"params\">(LinkQueue &amp;lq,<span class=\"keyword\">char</span> data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//插入元素为Q的新的队尾元素 data</span></span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\tp = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tp-&gt;data = data;</span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tlq.rare-&gt;next = p;</span><br><span class=\"line\">\tlq.rare = lq.rare-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于取出头元素，在操作之前首先需要判断是不是空队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lq.front==lq.rare)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"队列为空\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tQueuePtr q;</span><br><span class=\"line\">        <span class=\"comment\">//因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,lq.front-&gt;next-&gt;data);  </span><br><span class=\"line\">\t\tq = lq.front;</span><br><span class=\"line\">\t\tlq.front = lq.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tLinkQueue lq;</span><br><span class=\"line\">\tinitQueue(lq);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">'a'</span>);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">'b'</span>);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环队列——队列的顺序表示和实现\"><a href=\"#循环队列——队列的顺序表示和实现\" class=\"headerlink\" title=\"循环队列——队列的顺序表示和实现\"></a>循环队列——队列的顺序表示和实现</h2><p>队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；</p>\n<p>/source/img/20170802/004.jpg</p>\n<ul>\n<li>初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；</li>\n</ul>\n<p>/source/img/20170802/003.jpg</p>\n<ul>\n<li>当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxsize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;    <span class=\"comment\">//用于为队列分配空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;sqqueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initqueue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空队列</span></span><br><span class=\"line\">\tsq.base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(maxsize*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sq.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"构造队列失败\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.front = sq.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(sqqueue &amp;sq,<span class=\"keyword\">int</span> e)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((sq.rear+<span class=\"number\">1</span>)%maxsize==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"队列为满\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.base[sq.rear] = e;</span><br><span class=\"line\">\tsq.rear = (sq.rear + <span class=\"number\">1</span>) % maxsize;  <span class=\"comment\">//转了一圈后sq.rare会超过maxsize</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">requeue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队是否为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sq.rear==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"队列为空\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,sq.base[sq.front]);</span><br><span class=\"line\">\tsq.front = (sq.front + <span class=\"number\">1</span>) % maxsize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tsqqueue sq;</span><br><span class=\"line\">\tinitqueue(sq);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">10</span>);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">15</span>);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-02<br>队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；</p>\n<h2 id=\"链队列——队列的链式表示和实现\"><a href=\"#链队列——队列的链式表示和实现\" class=\"headerlink\" title=\"链队列——队列的链式表示和实现\"></a>链队列——队列的链式表示和实现</h2><p>链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。</p>\n<pre><code>/source/img/20170802/002.gif</code></pre><ul>\n<li>注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//单链队列，队列的链式存储结构，队列是由队头指向队尾</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQueuePtr  front;   <span class=\"comment\">//队头指针</span></span><br><span class=\"line\">\tQueuePtr rare;     <span class=\"comment\">//队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\tlq.front = lq.rare = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tlq.rare-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于插入队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enQueue</span><span class=\"params\">(LinkQueue &amp;lq,<span class=\"keyword\">char</span> data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//插入元素为Q的新的队尾元素 data</span></span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\tp = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tp-&gt;data = data;</span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tlq.rare-&gt;next = p;</span><br><span class=\"line\">\tlq.rare = lq.rare-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于取出头元素，在操作之前首先需要判断是不是空队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lq.front==lq.rare)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"队列为空\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tQueuePtr q;</span><br><span class=\"line\">        <span class=\"comment\">//因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,lq.front-&gt;next-&gt;data);  </span><br><span class=\"line\">\t\tq = lq.front;</span><br><span class=\"line\">\t\tlq.front = lq.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tLinkQueue lq;</span><br><span class=\"line\">\tinitQueue(lq);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">'a'</span>);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">'b'</span>);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环队列——队列的顺序表示和实现\"><a href=\"#循环队列——队列的顺序表示和实现\" class=\"headerlink\" title=\"循环队列——队列的顺序表示和实现\"></a>循环队列——队列的顺序表示和实现</h2><p>队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；</p>\n<p>/source/img/20170802/004.jpg</p>\n<ul>\n<li>初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；</li>\n</ul>\n<p>/source/img/20170802/003.jpg</p>\n<ul>\n<li>当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxsize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;    <span class=\"comment\">//用于为队列分配空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;sqqueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initqueue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空队列</span></span><br><span class=\"line\">\tsq.base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(maxsize*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sq.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"构造队列失败\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.front = sq.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(sqqueue &amp;sq,<span class=\"keyword\">int</span> e)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((sq.rear+<span class=\"number\">1</span>)%maxsize==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"队列为满\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.base[sq.rear] = e;</span><br><span class=\"line\">\tsq.rear = (sq.rear + <span class=\"number\">1</span>) % maxsize;  <span class=\"comment\">//转了一圈后sq.rare会超过maxsize</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">requeue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队是否为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sq.rear==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"队列为空\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,sq.base[sq.front]);</span><br><span class=\"line\">\tsq.front = (sq.front + <span class=\"number\">1</span>) % maxsize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tsqqueue sq;</span><br><span class=\"line\">\tinitqueue(sq);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">10</span>);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">15</span>);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"基数排序（Radix Sort）","description":"基数排序","_content":"modified: 2017-08-03\n\n桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；\n\n基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n基数排序可以看做是多次桶排序\n\n\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n//从个位开始，最低位优先（Least Significant Digital first）\nvoid radixSort(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 1;\n\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//第一次分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i]/index)% 10][0]++;\n\t\t\tradix[(num[i]/index) % 10][radix[(num[i]/index )% 10][0]] = num[i];\n\t\t}\n\t\t//第一次回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index * 10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\",num[i]);\n\t}\n\n}\n\n\n//从最高位开始，最高位优先（Most Significant Digit first）\nvoid radixSortMSD(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 10000\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i] / index) % 10][0]++;\n\t\t\tradix[(num[i] / index) % 10][radix[(num[i] / index) % 10][0]] = num[i];\n\t\t}\n\t\t//回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index /10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\", num[i]);\n\t}\n\n}\n\n\nint main() {\n\tint num[10] = {0,10,12,5665,285,125,554,26,7895,12};\n\tradixSortMSD(num, 10);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n```\n","source":"_posts/Data_Structure/2017-08-02-data-structure-radix-sort.md","raw":"---\n\ntitle: \"基数排序（Radix Sort）\"\ndescription: \"基数排序\"\n\ntags: [数据结构]\n\n\n\n---\nmodified: 2017-08-03\n\n桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；\n\n基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n基数排序可以看做是多次桶排序\n\n\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n//从个位开始，最低位优先（Least Significant Digital first）\nvoid radixSort(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 1;\n\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//第一次分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i]/index)% 10][0]++;\n\t\t\tradix[(num[i]/index) % 10][radix[(num[i]/index )% 10][0]] = num[i];\n\t\t}\n\t\t//第一次回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index * 10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\",num[i]);\n\t}\n\n}\n\n\n//从最高位开始，最高位优先（Most Significant Digit first）\nvoid radixSortMSD(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 10000\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i] / index) % 10][0]++;\n\t\t\tradix[(num[i] / index) % 10][radix[(num[i] / index) % 10][0]] = num[i];\n\t\t}\n\t\t//回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index /10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\", num[i]);\n\t}\n\n}\n\n\nint main() {\n\tint num[10] = {0,10,12,5665,285,125,554,26,7895,12};\n\tradixSortMSD(num, 10);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n```\n","slug":"Data_Structure/2017-08-02-data-structure-radix-sort","published":1,"date":"2020-02-29T02:45:08.910Z","updated":"2020-02-29T02:55:58.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryfv000disui5nau0ucw","content":"<p>modified: 2017-08-03</p>\n<p>桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；</p>\n<p>基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<p>基数排序可以看做是多次桶排序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从个位开始，最低位优先（Least Significant Digital first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index)% <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index) % <span class=\"number\">10</span>][radix[(num[i]/index )% <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index * <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从最高位开始，最高位优先（Most Significant Digit first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSortMSD</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">10000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][radix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index /<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">10</span>,<span class=\"number\">12</span>,<span class=\"number\">5665</span>,<span class=\"number\">285</span>,<span class=\"number\">125</span>,<span class=\"number\">554</span>,<span class=\"number\">26</span>,<span class=\"number\">7895</span>,<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">\tradixSortMSD(num, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-03</p>\n<p>桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；</p>\n<p>基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<p>基数排序可以看做是多次桶排序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从个位开始，最低位优先（Least Significant Digital first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index)% <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index) % <span class=\"number\">10</span>][radix[(num[i]/index )% <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index * <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从最高位开始，最高位优先（Most Significant Digit first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSortMSD</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">10000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][radix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index /<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">10</span>,<span class=\"number\">12</span>,<span class=\"number\">5665</span>,<span class=\"number\">285</span>,<span class=\"number\">125</span>,<span class=\"number\">554</span>,<span class=\"number\">26</span>,<span class=\"number\">7895</span>,<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">\tradixSortMSD(num, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"排序算法总结","description":"","_content":"\n\nmodified: 2017-08-02\n\n各种排序算法的总结\n\n## 插入排序\n\n## 非比较型排序\n\n### 桶排序\n\n### 基数排序\n\n### 计数排序","source":"_posts/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary.md","raw":"---\n\ntitle: \"排序算法总结\"\ndescription: \"\"\ntags: [数据结构]\n\n\n\n---\n\n\nmodified: 2017-08-02\n\n各种排序算法的总结\n\n## 插入排序\n\n## 非比较型排序\n\n### 桶排序\n\n### 基数排序\n\n### 计数排序","slug":"Data_Structure/2017-08-02-data-structure-sort-algorithm-summary","published":1,"date":"2020-02-29T02:45:08.918Z","updated":"2020-02-29T02:56:17.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryfw000fisui0oq47uh3","content":"<p>modified: 2017-08-02</p>\n<p>各种排序算法的总结</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><h2 id=\"非比较型排序\"><a href=\"#非比较型排序\" class=\"headerlink\" title=\"非比较型排序\"></a>非比较型排序</h2><h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-02</p>\n<p>各种排序算法的总结</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><h2 id=\"非比较型排序\"><a href=\"#非比较型排序\" class=\"headerlink\" title=\"非比较型排序\"></a>非比较型排序</h2><h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3>"},{"title":"栈的应用——需要再次进行编辑","description":"使用栈实现进制转换、括号匹配的检验、行编辑程序","_content":"\nmodified: 2017-08-02\n##　使用栈实现进制转换、括号匹配的检验、行编辑程序\n\n### 使用栈实现进制的转换\n\n* 将十进制转换为二进制\n\nC语言实现代码\n\n```c\nvoid conversion(int num) {\n\tSqStack stack;\n\tinitStack(&stack);\n\twhile (num / 2)\n\t{\n\t\tpush(&stack, num % 2);\n\t\tnum /= 2;\n\t}\n\tpush(&stack, num);\n\n\tint tmp = 0;\n\twhile (!isEmpty(&stack))\n\t{\n\t\tpop(&stack, &tmp);\n\t\tprintf(\"%d\", tmp);\n\n\t}\n}\n\n```\n\n### 使用栈实现括号匹配的检验\n\n```c\nvoid check_symbol() {\n\tchar s[50] = { 0 };\n\tprintf(\"请输入一串括号\");\n\tscanf(\"%s\", s);\n\tSqStack stack;\n\tinitStack(&stack);\n\tpush(&stack, s[0]);\n\tfor (int i = 1; s[i] != 0; i++)\n\t{\n\t\tif (!isEmpty(&stack))\n\t\t{\n\t\t\tif (getStackTop(stack) == (int) '{'&&s[i] == (int)'}' || getStackTop(stack) == (int) '('&&s[i] == (int)')') {\n\t\t\t\tint tmp;\n\t\t\t\tpop(&stack, &tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpush(&stack, s[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp;\n\t\t\tpush(&stack, s[i]);\n\t\t}\n\n\n\t}\n\tif (isEmpty(&stack))\n\t{\n\t\tprintf(\"括号匹配\");\n\t}\n\telse\n\t{\n\t\tprintf(\"括号不匹配\");\n\t}\n\n}\n\n```\n\n### 使用栈实现行编辑器\n\n```c\n\nvoid lineEdit() {\n\t//首先初始化栈\n\tSqStack stack;\n\tinitStack(&stack);\n\tchar ch = getchar();\n\twhile (ch != EOF)\n\t{\n\t\twhile (ch != EOF&&ch!='\\n') {\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '@':clearStack(stack);\n\t\t\t\tbreak;\n\t\t\tcase '#':if (isEmpty(&stack))\n\t\t\t\tbreak;\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t int tmp;\n\t\t\t\t\t\t pop(&stack, &tmp);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\t\t\tdefault:\n\t\t\t\tpush(&stack, ch); break;\n\t\t\t}\n\t\t\tch = getchar();\n\t\t}\n\t\tch = getchar();\n\t}\n\n\t//用于将存储在栈中的内容输出\n\tif (ch == EOF) {\n\t\twhile (!isEmpty(&stack))\n\t\t{\n\t\t\tint tmp;\n\t\t\tpop(&stack, &tmp);\n\t\t\tprintf(\"%c\", tmp);\n\t\t}\n\t}\n}\n\n```","source":"_posts/Data_Structure/2017-08-02-data-structure-stack-use.md","raw":"---\ntitle: 栈的应用——需要再次进行编辑\ndescription: 使用栈实现进制转换、括号匹配的检验、行编辑程序\ntags: [数据结构]\n\n---\n\nmodified: 2017-08-02\n##　使用栈实现进制转换、括号匹配的检验、行编辑程序\n\n### 使用栈实现进制的转换\n\n* 将十进制转换为二进制\n\nC语言实现代码\n\n```c\nvoid conversion(int num) {\n\tSqStack stack;\n\tinitStack(&stack);\n\twhile (num / 2)\n\t{\n\t\tpush(&stack, num % 2);\n\t\tnum /= 2;\n\t}\n\tpush(&stack, num);\n\n\tint tmp = 0;\n\twhile (!isEmpty(&stack))\n\t{\n\t\tpop(&stack, &tmp);\n\t\tprintf(\"%d\", tmp);\n\n\t}\n}\n\n```\n\n### 使用栈实现括号匹配的检验\n\n```c\nvoid check_symbol() {\n\tchar s[50] = { 0 };\n\tprintf(\"请输入一串括号\");\n\tscanf(\"%s\", s);\n\tSqStack stack;\n\tinitStack(&stack);\n\tpush(&stack, s[0]);\n\tfor (int i = 1; s[i] != 0; i++)\n\t{\n\t\tif (!isEmpty(&stack))\n\t\t{\n\t\t\tif (getStackTop(stack) == (int) '{'&&s[i] == (int)'}' || getStackTop(stack) == (int) '('&&s[i] == (int)')') {\n\t\t\t\tint tmp;\n\t\t\t\tpop(&stack, &tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpush(&stack, s[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp;\n\t\t\tpush(&stack, s[i]);\n\t\t}\n\n\n\t}\n\tif (isEmpty(&stack))\n\t{\n\t\tprintf(\"括号匹配\");\n\t}\n\telse\n\t{\n\t\tprintf(\"括号不匹配\");\n\t}\n\n}\n\n```\n\n### 使用栈实现行编辑器\n\n```c\n\nvoid lineEdit() {\n\t//首先初始化栈\n\tSqStack stack;\n\tinitStack(&stack);\n\tchar ch = getchar();\n\twhile (ch != EOF)\n\t{\n\t\twhile (ch != EOF&&ch!='\\n') {\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '@':clearStack(stack);\n\t\t\t\tbreak;\n\t\t\tcase '#':if (isEmpty(&stack))\n\t\t\t\tbreak;\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t int tmp;\n\t\t\t\t\t\t pop(&stack, &tmp);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\t\t\tdefault:\n\t\t\t\tpush(&stack, ch); break;\n\t\t\t}\n\t\t\tch = getchar();\n\t\t}\n\t\tch = getchar();\n\t}\n\n\t//用于将存储在栈中的内容输出\n\tif (ch == EOF) {\n\t\twhile (!isEmpty(&stack))\n\t\t{\n\t\t\tint tmp;\n\t\t\tpop(&stack, &tmp);\n\t\t\tprintf(\"%c\", tmp);\n\t\t}\n\t}\n}\n\n```","slug":"Data_Structure/2017-08-02-data-structure-stack-use","published":1,"date":"2020-02-29T02:45:08.927Z","updated":"2020-02-29T02:56:37.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryfy000iisui3b5x7nyr","content":"<p>modified: 2017-08-02<br>##　使用栈实现进制转换、括号匹配的检验、行编辑程序</p>\n<h3 id=\"使用栈实现进制的转换\"><a href=\"#使用栈实现进制的转换\" class=\"headerlink\" title=\"使用栈实现进制的转换\"></a>使用栈实现进制的转换</h3><ul>\n<li>将十进制转换为二进制</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conversion</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (num / <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpush(&amp;<span class=\"built_in\">stack</span>, num % <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tnum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用栈实现括号匹配的检验\"><a href=\"#使用栈实现括号匹配的检验\" class=\"headerlink\" title=\"使用栈实现括号匹配的检验\"></a>使用栈实现括号匹配的检验</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check_symbol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入一串括号\"</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s);</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; s[i] != <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">'&#123;'</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">'&#125;'</span> || getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">'('</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"括号匹配\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"括号不匹配\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用栈实现行编辑器\"><a href=\"#使用栈实现行编辑器\" class=\"headerlink\" title=\"使用栈实现行编辑器\"></a>使用栈实现行编辑器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lineEdit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//首先初始化栈</span></span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ch != EOF&amp;&amp;ch!=<span class=\"string\">'\\n'</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'@'</span>:clearStack(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'#'</span>:<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\t\t\t pop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t &#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, ch); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tch = getchar();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于将存储在栈中的内容输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch == EOF) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-02<br>##　使用栈实现进制转换、括号匹配的检验、行编辑程序</p>\n<h3 id=\"使用栈实现进制的转换\"><a href=\"#使用栈实现进制的转换\" class=\"headerlink\" title=\"使用栈实现进制的转换\"></a>使用栈实现进制的转换</h3><ul>\n<li>将十进制转换为二进制</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conversion</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (num / <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpush(&amp;<span class=\"built_in\">stack</span>, num % <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tnum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用栈实现括号匹配的检验\"><a href=\"#使用栈实现括号匹配的检验\" class=\"headerlink\" title=\"使用栈实现括号匹配的检验\"></a>使用栈实现括号匹配的检验</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check_symbol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入一串括号\"</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s);</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; s[i] != <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">'&#123;'</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">'&#125;'</span> || getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">'('</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">')'</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"括号匹配\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"括号不匹配\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用栈实现行编辑器\"><a href=\"#使用栈实现行编辑器\" class=\"headerlink\" title=\"使用栈实现行编辑器\"></a>使用栈实现行编辑器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lineEdit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//首先初始化栈</span></span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ch != EOF&amp;&amp;ch!=<span class=\"string\">'\\n'</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'@'</span>:clearStack(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">'#'</span>:<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\t\t\t pop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t &#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, ch); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tch = getchar();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于将存储在栈中的内容输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch == EOF) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"归并排序","description":"","_content":"modified: 2017-08-04\n\n归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。\n\n归并排序的基本思路是\n\n* 将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；\n* 将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；\n* 重复步骤2，直到所有元素排序完毕；\n\n\n\t/images/DataStructure/Merge_sort.gif\n\n\n\n\t/images/DataStructure/Merge_sort_01.gif\n\n\n\n要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。\n\n使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列\n\n\n```c\n\n//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，\n//左右有序两部分的分界点，右侧有序部分的终点，\n//tmp[]是大小为last-first的数组，用于临时存放排序的数列\n\nvoid mergeArray(int a[],int first,int mid,int last,int tmp[]) {\n\tint i = first;\n\tint j = mid+1;\n\tint k = 0;    //K用作tmp[]的索引\n\n    //将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中\n\twhile (i<=mid&&j<=last)\n\t\ta[i] < a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];\n\twhile (i <= mid)\n\t\ttmp[k++] = a[i++];\n\twhile (j <= last)\n\t\ttmp[k++] = a[j++];\n   \n\twhile (k > 0)\n\t\ta[--j] = tmp[--k];\n}\n```\n\n\n```c\nvoid mergeSort(int a[],int first,int last,int tmp[]) {\n\tif (first<last)\n\t{\n\t\tint mid = (first + last) / 2;\n\t\tmergeSort(a,first,mid,tmp);  //左边有序\n\t\tmergeSort(a, mid+1, last, tmp);//右边有序\n\t\tmergeArray(a,first,mid,last,tmp);  //将两个数组合并\n\t}\n}\n\n````\n有序数组的归并以及归并排序的测试\n\n```c\n\nint main() {\n\n\tint a[7] = {7,8,9,10,1,2,3};\n\tint tmp[7];\n\tprintf(\"测试数组归并\\n\");\n\n\tmergeArray(a, 1, 3, 5, tmp);\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tprintf(\"测试数组归并排序\\n\");\n\tmergeSort(a,0,6,tmp);\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```","source":"_posts/Data_Structure/2017-08-04-data-structure-merge-sort.md","raw":"---\ntitle: \"归并排序\"\ndescription: \"\"\ntags: [数据结构]\n\n\n\n---\nmodified: 2017-08-04\n\n归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。\n\n归并排序的基本思路是\n\n* 将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；\n* 将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；\n* 重复步骤2，直到所有元素排序完毕；\n\n\n\t/images/DataStructure/Merge_sort.gif\n\n\n\n\t/images/DataStructure/Merge_sort_01.gif\n\n\n\n要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。\n\n使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列\n\n\n```c\n\n//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，\n//左右有序两部分的分界点，右侧有序部分的终点，\n//tmp[]是大小为last-first的数组，用于临时存放排序的数列\n\nvoid mergeArray(int a[],int first,int mid,int last,int tmp[]) {\n\tint i = first;\n\tint j = mid+1;\n\tint k = 0;    //K用作tmp[]的索引\n\n    //将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中\n\twhile (i<=mid&&j<=last)\n\t\ta[i] < a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];\n\twhile (i <= mid)\n\t\ttmp[k++] = a[i++];\n\twhile (j <= last)\n\t\ttmp[k++] = a[j++];\n   \n\twhile (k > 0)\n\t\ta[--j] = tmp[--k];\n}\n```\n\n\n```c\nvoid mergeSort(int a[],int first,int last,int tmp[]) {\n\tif (first<last)\n\t{\n\t\tint mid = (first + last) / 2;\n\t\tmergeSort(a,first,mid,tmp);  //左边有序\n\t\tmergeSort(a, mid+1, last, tmp);//右边有序\n\t\tmergeArray(a,first,mid,last,tmp);  //将两个数组合并\n\t}\n}\n\n````\n有序数组的归并以及归并排序的测试\n\n```c\n\nint main() {\n\n\tint a[7] = {7,8,9,10,1,2,3};\n\tint tmp[7];\n\tprintf(\"测试数组归并\\n\");\n\n\tmergeArray(a, 1, 3, 5, tmp);\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tprintf(\"测试数组归并排序\\n\");\n\tmergeSort(a,0,6,tmp);\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```","slug":"Data_Structure/2017-08-04-data-structure-merge-sort","published":1,"date":"2020-02-29T02:45:08.936Z","updated":"2020-02-29T03:07:29.727Z","_id":"ck770ryfy000kisuiakmt8wc7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-04</p>\n<p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。</p>\n<p>归并排序的基本思路是</p>\n<ul>\n<li>将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；</li>\n<li>将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；</li>\n<li>重复步骤2，直到所有元素排序完毕；</li>\n</ul>\n<pre><code>/images/DataStructure/Merge_sort.gif\n\n\n\n/images/DataStructure/Merge_sort_01.gif</code></pre><p>要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。</p>\n<p>使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，</span></span><br><span class=\"line\"><span class=\"comment\">//左右有序两部分的分界点，右侧有序部分的终点，</span></span><br><span class=\"line\"><span class=\"comment\">//tmp[]是大小为last-first的数组，用于临时存放排序的数列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeArray</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = first;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;    <span class=\"comment\">//K用作tmp[]的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i&lt;=mid&amp;&amp;j&lt;=last)</span><br><span class=\"line\">\t\ta[i] &lt; a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= mid)</span><br><span class=\"line\">\t\ttmp[k++] = a[i++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt;= last)</span><br><span class=\"line\">\t\ttmp[k++] = a[j++];</span><br><span class=\"line\">   </span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\ta[--j] = tmp[--k];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (first&lt;last)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (first + last) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tmergeSort(a,first,mid,tmp);  <span class=\"comment\">//左边有序</span></span><br><span class=\"line\">\t\tmergeSort(a, mid+<span class=\"number\">1</span>, last, tmp);<span class=\"comment\">//右边有序</span></span><br><span class=\"line\">\t\tmergeArray(a,first,mid,last,tmp);  <span class=\"comment\">//将两个数组合并</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>有序数组的归并以及归并排序的测试</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"测试数组归并\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmergeArray(a, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"测试数组归并排序\\n\"</span>);</span><br><span class=\"line\">\tmergeSort(a,<span class=\"number\">0</span>,<span class=\"number\">6</span>,tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-04</p>\n<p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。</p>\n<p>归并排序的基本思路是</p>\n<ul>\n<li>将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；</li>\n<li>将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；</li>\n<li>重复步骤2，直到所有元素排序完毕；</li>\n</ul>\n<pre><code>/images/DataStructure/Merge_sort.gif\n\n\n\n/images/DataStructure/Merge_sort_01.gif</code></pre><p>要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。</p>\n<p>使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，</span></span><br><span class=\"line\"><span class=\"comment\">//左右有序两部分的分界点，右侧有序部分的终点，</span></span><br><span class=\"line\"><span class=\"comment\">//tmp[]是大小为last-first的数组，用于临时存放排序的数列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeArray</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = first;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;    <span class=\"comment\">//K用作tmp[]的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i&lt;=mid&amp;&amp;j&lt;=last)</span><br><span class=\"line\">\t\ta[i] &lt; a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= mid)</span><br><span class=\"line\">\t\ttmp[k++] = a[i++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt;= last)</span><br><span class=\"line\">\t\ttmp[k++] = a[j++];</span><br><span class=\"line\">   </span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\ta[--j] = tmp[--k];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (first&lt;last)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (first + last) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tmergeSort(a,first,mid,tmp);  <span class=\"comment\">//左边有序</span></span><br><span class=\"line\">\t\tmergeSort(a, mid+<span class=\"number\">1</span>, last, tmp);<span class=\"comment\">//右边有序</span></span><br><span class=\"line\">\t\tmergeArray(a,first,mid,last,tmp);  <span class=\"comment\">//将两个数组合并</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>有序数组的归并以及归并排序的测试</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"测试数组归并\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmergeArray(a, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"测试数组归并排序\\n\"</span>);</span><br><span class=\"line\">\tmergeSort(a,<span class=\"number\">0</span>,<span class=\"number\">6</span>,tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"快速排序","description":"快速排序3","_content":"modified: 2017-08-02\n快速排序可以理解为：快速排序=挖坑填数+分治算法；\n\n快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；\n\n步骤为：\n\n* 从数列中选出一个元素，作为基准（pivot）\n* 将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。\n* 递归地把小于基准元素的子序列和大于基准的子序列进行排序\n\n递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 \n\n\n* 进行一次排序的过程(挖坑填数)\n  \n\n\t/images/DataStructure/quick_sort.jpg\n\n\n* 快速排序的全过程\n\n\n\t/images/DataStructure/quick_sort_01.jpg\n\n\n使用C语言实现代码\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n//分治算法是基于递归的\n\nvoid quickSort(int arr[],int left,int right) {\n\tif (left<right)\n\t{\n\t\tint i = left, j = right, tmp = arr[left];   //将最左边的数选为基准数字\n\t\t//先从右向左搜索比tmp小的数\n\t\twhile (i<j)\n\t\t{\n\t\t\twhile (i<j&&tmp <= arr[j])\n\t\t\t\tj--;\n\t\t\tif (i<j)\n\t\t\t\tarr[i++] = arr[j];   //将右边的数挖出放到左边的位置\n\t\t\t//从左至右搜索比tmp大的数\n\t\t\twhile (i<j&&tmp >arr[i])\n\t\t\t\ti++;\n\t\t\tif (i<j)\n\t\t\t\tarr[j--] = arr[i];   //将左边的数挖出放入右边的空位\n\t\t}\n\t\tarr[i] = tmp;     \n\t\tquickSort(arr, left, i - 1);   //递归调用\n\t\tquickSort(arr, i + 1, right);  //递归调用\n\t}\n\n}\n\n\nint main() {\n\tint a[5] = { 5,4,3,2,1 };\n\tquickSort(a, 0, 4);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%d\",a[i]);\n\t}\n\t\t\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n```","source":"_posts/Data_Structure/2017-08-04-data-structure-quick-sort.md","raw":"---\ntitle: \"快速排序\"\ndescription: \"快速排序3\"\ntags: [数据结构]\n\n---\nmodified: 2017-08-02\n快速排序可以理解为：快速排序=挖坑填数+分治算法；\n\n快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；\n\n步骤为：\n\n* 从数列中选出一个元素，作为基准（pivot）\n* 将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。\n* 递归地把小于基准元素的子序列和大于基准的子序列进行排序\n\n递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 \n\n\n* 进行一次排序的过程(挖坑填数)\n  \n\n\t/images/DataStructure/quick_sort.jpg\n\n\n* 快速排序的全过程\n\n\n\t/images/DataStructure/quick_sort_01.jpg\n\n\n使用C语言实现代码\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n//分治算法是基于递归的\n\nvoid quickSort(int arr[],int left,int right) {\n\tif (left<right)\n\t{\n\t\tint i = left, j = right, tmp = arr[left];   //将最左边的数选为基准数字\n\t\t//先从右向左搜索比tmp小的数\n\t\twhile (i<j)\n\t\t{\n\t\t\twhile (i<j&&tmp <= arr[j])\n\t\t\t\tj--;\n\t\t\tif (i<j)\n\t\t\t\tarr[i++] = arr[j];   //将右边的数挖出放到左边的位置\n\t\t\t//从左至右搜索比tmp大的数\n\t\t\twhile (i<j&&tmp >arr[i])\n\t\t\t\ti++;\n\t\t\tif (i<j)\n\t\t\t\tarr[j--] = arr[i];   //将左边的数挖出放入右边的空位\n\t\t}\n\t\tarr[i] = tmp;     \n\t\tquickSort(arr, left, i - 1);   //递归调用\n\t\tquickSort(arr, i + 1, right);  //递归调用\n\t}\n\n}\n\n\nint main() {\n\tint a[5] = { 5,4,3,2,1 };\n\tquickSort(a, 0, 4);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%d\",a[i]);\n\t}\n\t\t\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n```","slug":"Data_Structure/2017-08-04-data-structure-quick-sort","published":1,"date":"2020-02-29T02:45:08.943Z","updated":"2020-02-29T03:07:42.774Z","_id":"ck770ryg0000misui3anicmaj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-02<br>快速排序可以理解为：快速排序=挖坑填数+分治算法；</p>\n<p>快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；</p>\n<p>步骤为：</p>\n<ul>\n<li>从数列中选出一个元素，作为基准（pivot）</li>\n<li>将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。</li>\n<li>递归地把小于基准元素的子序列和大于基准的子序列进行排序</li>\n</ul>\n<p>递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 </p>\n<ul>\n<li>进行一次排序的过程(挖坑填数)</li>\n</ul>\n<pre><code>/images/DataStructure/quick_sort.jpg</code></pre><ul>\n<li>快速排序的全过程</li>\n</ul>\n<pre><code>/images/DataStructure/quick_sort_01.jpg</code></pre><p>使用C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//分治算法是基于递归的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left&lt;right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = left, j = right, tmp = arr[left];   <span class=\"comment\">//将最左边的数选为基准数字</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//先从右向左搜索比tmp小的数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i&lt;j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &lt;= arr[j])</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[i++] = arr[j];   <span class=\"comment\">//将右边的数挖出放到左边的位置</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//从左至右搜索比tmp大的数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &gt;arr[i])</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[j--] = arr[i];   <span class=\"comment\">//将左边的数挖出放入右边的空位</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarr[i] = tmp;     </span><br><span class=\"line\">\t\tquickSort(arr, left, i - <span class=\"number\">1</span>);   <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\tquickSort(arr, i + <span class=\"number\">1</span>, right);  <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">5</span>] = &#123; <span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\tquickSort(a, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-02<br>快速排序可以理解为：快速排序=挖坑填数+分治算法；</p>\n<p>快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；</p>\n<p>步骤为：</p>\n<ul>\n<li>从数列中选出一个元素，作为基准（pivot）</li>\n<li>将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。</li>\n<li>递归地把小于基准元素的子序列和大于基准的子序列进行排序</li>\n</ul>\n<p>递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 </p>\n<ul>\n<li>进行一次排序的过程(挖坑填数)</li>\n</ul>\n<pre><code>/images/DataStructure/quick_sort.jpg</code></pre><ul>\n<li>快速排序的全过程</li>\n</ul>\n<pre><code>/images/DataStructure/quick_sort_01.jpg</code></pre><p>使用C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"comment\">//分治算法是基于递归的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left&lt;right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = left, j = right, tmp = arr[left];   <span class=\"comment\">//将最左边的数选为基准数字</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//先从右向左搜索比tmp小的数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i&lt;j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &lt;= arr[j])</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[i++] = arr[j];   <span class=\"comment\">//将右边的数挖出放到左边的位置</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//从左至右搜索比tmp大的数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &gt;arr[i])</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[j--] = arr[i];   <span class=\"comment\">//将左边的数挖出放入右边的空位</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarr[i] = tmp;     </span><br><span class=\"line\">\t\tquickSort(arr, left, i - <span class=\"number\">1</span>);   <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\tquickSort(arr, i + <span class=\"number\">1</span>, right);  <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">5</span>] = &#123; <span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\tquickSort(a, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"图的邻接矩阵表示","description":"图的邻接矩阵表示","_content":"\nmodified: 2017-08-04\n### 邻接矩阵\n\n>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。\n\n有向图的邻接矩阵表示:\n\n/source/img/DataStructure/adjacency_matrix.jpg\n\n无向图的邻接矩阵的表示(图中边的权重为1)：\n\n/source/img/DataStructure/adjacency_matrix1.png\n\n\n### 带权无向图邻接矩阵的代码实现\n\n* 图的结构定义\n\n```c\ntypedef struct MGraph {\n\tint numVertices, numEdges;                          //图中实际顶点的个数和边的条数\n\tchar VerticesList[maxVertices];                     //顶点数组\n\tint Edge[maxVertices][maxVertices];                 //邻接矩阵，使用二维数组表示\n};\n```\n\n* 图的初始化\n\n```c\nvoid InitGraph(MGraph &G) {\n\tG.numVertices = 0;\n\tG.numEdges = 0;\n\tfor (int i = 0; i < maxVertices; i++)                //邻接矩阵初始化\n\t{\n\t\tG.VerticesList[i] = '0'; \n\t\tfor (int j = 0; j < maxVertices; j++)            //若为非带权图，全部赋值为0\n\t\t\tG.Edge[i][j] = ((i == j) ? 0 : maxWeight);   //maxWeight代表无穷大\n\t}\n}\n```\n\n* 从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1\n\n```c\nint GetVertexPos(MGraph G, char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i] == x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n```\n\n* 输入创建使用邻接矩阵表示的带权无向图\n\n```c\nvoid CreateGraph(MGraph &G, int numVertex, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图\n\tchar e;\n\tG.numVertices = numVertex;\n\tG.numEdges = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor (int i = 0; i < numVertex; i++)\n\t{\n\t\tscanf(\"%c\", &e);\n\t\tG.VerticesList[i] = e;\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();                  //如果不使用getchar(),则缓冲区内还会有回车键\n\t\tscanf(\"%c %c %d\", &e1, &e2, &weight);\n\t\tif (GetVertexPos(G, e1) !=-1&& GetVertexPos(G, e2) !=-1)\n\t\t{\n\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;\n\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     \n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"输入顶点错误，请重新输入\\n\");\n\t\t}\n\t}\n}\n```\n\n注：若需要带权的有向图只需将```G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;  ```注释即可\n\n* 以下图为例测试\n\n/source/img/DataStructure/adjacency_matrix2.png\n\n\n\n```c\nint main() {\n\n\tMGraph G;\n\tInitGraph(G);\n\tCreateGraph(G, 5, 7);\n\tprintf(\"\\n结果输出\\n\");\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tfor (int j = 0; j < 7; j++)\n\t\t{\n\t\t\tprintf(\"%d \",G.Edge[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 测试结果\n/source/img/DataStructure/adjacency_matrix3.png\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp)\n","source":"_posts/Data_Structure/2017-08-26-data-structure-adjaceny-matrix.md","raw":"---\ntitle: \"图的邻接矩阵表示\"\ndescription: \"图的邻接矩阵表示\"\ntags: [数据结构]\n\n\n\n\n---\n\nmodified: 2017-08-04\n### 邻接矩阵\n\n>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。\n\n有向图的邻接矩阵表示:\n\n/source/img/DataStructure/adjacency_matrix.jpg\n\n无向图的邻接矩阵的表示(图中边的权重为1)：\n\n/source/img/DataStructure/adjacency_matrix1.png\n\n\n### 带权无向图邻接矩阵的代码实现\n\n* 图的结构定义\n\n```c\ntypedef struct MGraph {\n\tint numVertices, numEdges;                          //图中实际顶点的个数和边的条数\n\tchar VerticesList[maxVertices];                     //顶点数组\n\tint Edge[maxVertices][maxVertices];                 //邻接矩阵，使用二维数组表示\n};\n```\n\n* 图的初始化\n\n```c\nvoid InitGraph(MGraph &G) {\n\tG.numVertices = 0;\n\tG.numEdges = 0;\n\tfor (int i = 0; i < maxVertices; i++)                //邻接矩阵初始化\n\t{\n\t\tG.VerticesList[i] = '0'; \n\t\tfor (int j = 0; j < maxVertices; j++)            //若为非带权图，全部赋值为0\n\t\t\tG.Edge[i][j] = ((i == j) ? 0 : maxWeight);   //maxWeight代表无穷大\n\t}\n}\n```\n\n* 从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1\n\n```c\nint GetVertexPos(MGraph G, char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i] == x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n```\n\n* 输入创建使用邻接矩阵表示的带权无向图\n\n```c\nvoid CreateGraph(MGraph &G, int numVertex, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图\n\tchar e;\n\tG.numVertices = numVertex;\n\tG.numEdges = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor (int i = 0; i < numVertex; i++)\n\t{\n\t\tscanf(\"%c\", &e);\n\t\tG.VerticesList[i] = e;\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();                  //如果不使用getchar(),则缓冲区内还会有回车键\n\t\tscanf(\"%c %c %d\", &e1, &e2, &weight);\n\t\tif (GetVertexPos(G, e1) !=-1&& GetVertexPos(G, e2) !=-1)\n\t\t{\n\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;\n\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     \n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"输入顶点错误，请重新输入\\n\");\n\t\t}\n\t}\n}\n```\n\n注：若需要带权的有向图只需将```G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;  ```注释即可\n\n* 以下图为例测试\n\n/source/img/DataStructure/adjacency_matrix2.png\n\n\n\n```c\nint main() {\n\n\tMGraph G;\n\tInitGraph(G);\n\tCreateGraph(G, 5, 7);\n\tprintf(\"\\n结果输出\\n\");\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tfor (int j = 0; j < 7; j++)\n\t\t{\n\t\t\tprintf(\"%d \",G.Edge[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 测试结果\n/source/img/DataStructure/adjacency_matrix3.png\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp)\n","slug":"Data_Structure/2017-08-26-data-structure-adjaceny-matrix","published":1,"date":"2020-02-29T02:45:08.960Z","updated":"2020-02-29T03:12:34.839Z","_id":"ck770ryg1000oisui5hvuba4o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-04</p>\n<h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><blockquote>\n<p>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。</p>\n</blockquote>\n<p>有向图的邻接矩阵表示:</p>\n<p>/source/img/DataStructure/adjacency_matrix.jpg</p>\n<p>无向图的邻接矩阵的表示(图中边的权重为1)：</p>\n<p>/source/img/DataStructure/adjacency_matrix1.png</p>\n<h3 id=\"带权无向图邻接矩阵的代码实现\"><a href=\"#带权无向图邻接矩阵的代码实现\" class=\"headerlink\" title=\"带权无向图邻接矩阵的代码实现\"></a>带权无向图邻接矩阵的代码实现</h3><ul>\n<li>图的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MGraph</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdges;                          <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> VerticesList[maxVertices];                     <span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Edge[maxVertices][maxVertices];                 <span class=\"comment\">//邻接矩阵，使用二维数组表示</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>图的初始化</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitGraph</span><span class=\"params\">(MGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numEdges = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)                <span class=\"comment\">//邻接矩阵初始化</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i] = <span class=\"string\">'0'</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; maxVertices; j++)            <span class=\"comment\">//若为非带权图，全部赋值为0</span></span><br><span class=\"line\">\t\t\tG.Edge[i][j] = ((i == j) ? <span class=\"number\">0</span> : maxWeight);   <span class=\"comment\">//maxWeight代表无穷大</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetVertexPos</span><span class=\"params\">(MGraph G, <span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i] == x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>输入创建使用邻接矩阵表示的带权无向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateGraph</span><span class=\"params\">(MGraph &amp;G, <span class=\"keyword\">int</span> numVertex, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> e;</span><br><span class=\"line\">\tG.numVertices = numVertex;</span><br><span class=\"line\">\tG.numEdges = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertex; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;e);</span><br><span class=\"line\">\t\tG.VerticesList[i] = e;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点和权重\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();                  <span class=\"comment\">//如果不使用getchar(),则缓冲区内还会有回车键</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c %c %d\"</span>, &amp;e1, &amp;e2, &amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GetVertexPos(G, e1) !=<span class=\"number\">-1</span>&amp;&amp; GetVertexPos(G, e2) !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     </span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"输入顶点错误，请重新输入\\n\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注：若需要带权的有向图只需将<code>G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;</code>注释即可</p>\n<ul>\n<li>以下图为例测试</li>\n</ul>\n<p>/source/img/DataStructure/adjacency_matrix2.png</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMGraph G;</span><br><span class=\"line\">\tInitGraph(G);</span><br><span class=\"line\">\tCreateGraph(G, <span class=\"number\">5</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n结果输出\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">7</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,G.Edge[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试结果<br>/source/img/DataStructure/adjacency_matrix3.png</li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp\">源码下载</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-04</p>\n<h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><blockquote>\n<p>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。</p>\n</blockquote>\n<p>有向图的邻接矩阵表示:</p>\n<p>/source/img/DataStructure/adjacency_matrix.jpg</p>\n<p>无向图的邻接矩阵的表示(图中边的权重为1)：</p>\n<p>/source/img/DataStructure/adjacency_matrix1.png</p>\n<h3 id=\"带权无向图邻接矩阵的代码实现\"><a href=\"#带权无向图邻接矩阵的代码实现\" class=\"headerlink\" title=\"带权无向图邻接矩阵的代码实现\"></a>带权无向图邻接矩阵的代码实现</h3><ul>\n<li>图的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MGraph</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdges;                          <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> VerticesList[maxVertices];                     <span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Edge[maxVertices][maxVertices];                 <span class=\"comment\">//邻接矩阵，使用二维数组表示</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>图的初始化</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitGraph</span><span class=\"params\">(MGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numEdges = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)                <span class=\"comment\">//邻接矩阵初始化</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i] = <span class=\"string\">'0'</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; maxVertices; j++)            <span class=\"comment\">//若为非带权图，全部赋值为0</span></span><br><span class=\"line\">\t\t\tG.Edge[i][j] = ((i == j) ? <span class=\"number\">0</span> : maxWeight);   <span class=\"comment\">//maxWeight代表无穷大</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetVertexPos</span><span class=\"params\">(MGraph G, <span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i] == x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>输入创建使用邻接矩阵表示的带权无向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateGraph</span><span class=\"params\">(MGraph &amp;G, <span class=\"keyword\">int</span> numVertex, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> e;</span><br><span class=\"line\">\tG.numVertices = numVertex;</span><br><span class=\"line\">\tG.numEdges = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertex; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;e);</span><br><span class=\"line\">\t\tG.VerticesList[i] = e;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点和权重\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();                  <span class=\"comment\">//如果不使用getchar(),则缓冲区内还会有回车键</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c %c %d\"</span>, &amp;e1, &amp;e2, &amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GetVertexPos(G, e1) !=<span class=\"number\">-1</span>&amp;&amp; GetVertexPos(G, e2) !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     </span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"输入顶点错误，请重新输入\\n\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注：若需要带权的有向图只需将<code>G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;</code>注释即可</p>\n<ul>\n<li>以下图为例测试</li>\n</ul>\n<p>/source/img/DataStructure/adjacency_matrix2.png</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMGraph G;</span><br><span class=\"line\">\tInitGraph(G);</span><br><span class=\"line\">\tCreateGraph(G, <span class=\"number\">5</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n结果输出\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">7</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,G.Edge[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试结果<br>/source/img/DataStructure/adjacency_matrix3.png</li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp\">源码下载</a></p>\n"},{"title":"创建大根堆与小根堆","description":"大根堆与小根堆的建立","_content":"modified: 2017-08-26\n### 堆的概念\n\n> n个元素序列{k0,k1,k2...ki...kn-1},当且仅当满足下列关系时称之为堆：\n(ki <= k2i+1,ki <= k2i+2)或者(ki >= k2i+1,ki >= k2i+2), (i = 0,1,2,3,4...(n-2)/2)\n\n注：i从0开始与从1开始，需要改变末尾元素的下标值\n\n#### 堆的性质\n\n>* 堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n>* 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）\n\n\n大根堆与小根堆\n\n/source/img/DataStructure/heap.jpg\n\n\n### 小根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp):\n\n#### 小根堆的建立过程\n\n如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：\n\n/source/img/DataStructure/heap1.jpg\n\n\n\n* 小根堆的结构定义\n\n```c\ntypedef struct minHeap{\n    int heap[HeapSize];      //存放小根堆中元素的数组\n    int n;                  //小根堆当前元素的个数，初始值为0\n}minHeap;\n```\n\n* 自顶向下调整\n\n自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆\n\n```c\nvoid shifDown(minHeap &H, int m) {\n\t//m是开始调整的结点,n是调整结束的点\n\tint tmp = H.heap[m];  //j是i的左子女\n\tfor (int j = 2 * m + 1; j <= H.n-1; j=2*j+1) {\n\t\tif (j<H.n-1&&H.heap[j]>H.heap[j + 1])\n\t\t\tj++;\n\t\tif (tmp <= H.heap[j])\n\t\t\tbreak;\n\t\telse {\n\t\t\ttmp = H.heap[m];\n\t\t\tH.heap[m] = H.heap[j];\n\t\t\tH.heap[j] = tmp;\n\t\t\tm = j;\n\t\t}\n\t}\n}\n\n```\n\n* 构建小根堆\n\n构建的是从下到上，调整的时候是从上至下\n\n\n```c\nvoid createMinHeap(minHeap &H, int arr[], int n) {\n\tfor ( int i = 0; i < n; i++)\n\t\tH.heap[i] = arr[i];\n\tH.n = n;\n\tfor (int i = (H.n - 2) / 2; i >=0;i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H,i);                       //局部自上向下筛选\n\t}\n} \n```\n\n* 自底向上调整小根堆\n\n```c\nvoid shifUp(minHeap &H,int start) {\n\tint j= start;\n\tint i = (j - 1) / 2;\n\tint tmp = H.heap[start];\n\twhile (j>0)\n\t{\n\t\tif (H.heap[i] <= tmp) break;\n\t\telse\n\t\t{\n\t\t\tH.heap[j] = H.heap[i];\n\t\t\tj = i;\n\t\t\ti = (i - 1) / 2;\n\t\t}\n\n\t}\n\tH.heap[j] = tmp;\n}\n\n```\n\n* 小根堆的插入，采用局部自下向上调整\n\n小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用```shifUp```自下向上，一层一层向上调整；\n\n```c\nvoid Insert(minHeap &H,int x) {\n\tif (H.n==HeapSize)\n\t{\n\t\tprintf(\"堆满\");\n\t}\n\tH.heap[H.n] = x;\n\tshifUp(H, H.n);\n\tH.n++;\n}\n```\n\n* 小根堆的删除\n\n小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用```shiftDown```从堆顶向下进行调整\n\n```c\nint Remove(minHeap &H,int &x) {\n\tif (!H.n)\n\t\treturn 0;               //堆空返回0\n\tx = H.heap[0];\n\tH.heap[0] = H.heap[H.n - 1];\n\tH.n--;\n\tfor (int i = (H.n - 2) / 2; i >= 0; i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H, i);                          //局部自上向下筛选\n\t}\n\treturn 1;\n}\n```\n\n* 运行测试\n\n```c\n\n\nint main() {\n\tint arr[8] = { 53,17,78,9,45,65,87,23};\n\tminHeap H;\n\tcreateMinHeap(H,arr,8);\n\n\tprintf(\"小根堆的建立\\n\");\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tprintf(\"\\n小根堆的插入元素10\\n\");\n\tInsert(H,10);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tint x;\n\tx=Remove(H);\n\tprintf(\"\\n小根堆的删除\\n\");\n\tprintf(\"删除的元素为\\n%d\\n\",x);\n\tprintf(\"删除堆顶元素，进行调整后的元素为\\n\");\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n* 运行结果\n\n\n/source/img/DataStructure/heap8.jpg\n\n\n\n\n### 大根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp)\n\n大根堆的建立过程与小根堆的建立过程是相似的；\n\n* 大根堆的结构定义\n\n```c\ntypedef struct MaxHeap {\n\tint heap[HeapSize];\n\tint n;\n}MaxHeap;\n\n```\n\n* 采用自上而下的调整方法\n\n```c\nvoid shiftHeap(MaxHeap &H,int m) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2*m+1; i <=H.n-1 ; i=i*2+1)\n\t{\n\t\tif (i<H.n-1&&H.heap[i]<H.heap[i+1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n\n```\n\n* 大根堆的建立\n\n```c\nvoid createHeap(MaxHeap &H, int arr[],int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\n\tfor (int i = (n-2)/2; i >=0; i--)\n\t{\n\t\tshiftHeap(H, i);\n\t}\n}\n\n```\n\n* 代码测试\n\n```c\nint main() {\n\tint arr[8] = {1,2,3,4,5,6,7,8};\n\tMaxHeap H;\n\tcreateHeap(H, arr,8);\n\tprintf(\"大根堆的创建结果\\n\");\n\tfor (int  i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n* 测试结果\n\n/source/img/DataStructure/heap3.jpg\n\n\n* 结果以树的形式表示\n/source/img/DataStructure/heap2.jpg\n\n\n\n\n\n","source":"_posts/Data_Structure/2017-08-26-data-structure-build-heap.md","raw":"---\ntitle: \"创建大根堆与小根堆\"\ndescription: \"大根堆与小根堆的建立\"\ntags: [数据结构]\n\n\n\n\n---\nmodified: 2017-08-26\n### 堆的概念\n\n> n个元素序列{k0,k1,k2...ki...kn-1},当且仅当满足下列关系时称之为堆：\n(ki <= k2i+1,ki <= k2i+2)或者(ki >= k2i+1,ki >= k2i+2), (i = 0,1,2,3,4...(n-2)/2)\n\n注：i从0开始与从1开始，需要改变末尾元素的下标值\n\n#### 堆的性质\n\n>* 堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n>* 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）\n\n\n大根堆与小根堆\n\n/source/img/DataStructure/heap.jpg\n\n\n### 小根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp):\n\n#### 小根堆的建立过程\n\n如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：\n\n/source/img/DataStructure/heap1.jpg\n\n\n\n* 小根堆的结构定义\n\n```c\ntypedef struct minHeap{\n    int heap[HeapSize];      //存放小根堆中元素的数组\n    int n;                  //小根堆当前元素的个数，初始值为0\n}minHeap;\n```\n\n* 自顶向下调整\n\n自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆\n\n```c\nvoid shifDown(minHeap &H, int m) {\n\t//m是开始调整的结点,n是调整结束的点\n\tint tmp = H.heap[m];  //j是i的左子女\n\tfor (int j = 2 * m + 1; j <= H.n-1; j=2*j+1) {\n\t\tif (j<H.n-1&&H.heap[j]>H.heap[j + 1])\n\t\t\tj++;\n\t\tif (tmp <= H.heap[j])\n\t\t\tbreak;\n\t\telse {\n\t\t\ttmp = H.heap[m];\n\t\t\tH.heap[m] = H.heap[j];\n\t\t\tH.heap[j] = tmp;\n\t\t\tm = j;\n\t\t}\n\t}\n}\n\n```\n\n* 构建小根堆\n\n构建的是从下到上，调整的时候是从上至下\n\n\n```c\nvoid createMinHeap(minHeap &H, int arr[], int n) {\n\tfor ( int i = 0; i < n; i++)\n\t\tH.heap[i] = arr[i];\n\tH.n = n;\n\tfor (int i = (H.n - 2) / 2; i >=0;i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H,i);                       //局部自上向下筛选\n\t}\n} \n```\n\n* 自底向上调整小根堆\n\n```c\nvoid shifUp(minHeap &H,int start) {\n\tint j= start;\n\tint i = (j - 1) / 2;\n\tint tmp = H.heap[start];\n\twhile (j>0)\n\t{\n\t\tif (H.heap[i] <= tmp) break;\n\t\telse\n\t\t{\n\t\t\tH.heap[j] = H.heap[i];\n\t\t\tj = i;\n\t\t\ti = (i - 1) / 2;\n\t\t}\n\n\t}\n\tH.heap[j] = tmp;\n}\n\n```\n\n* 小根堆的插入，采用局部自下向上调整\n\n小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用```shifUp```自下向上，一层一层向上调整；\n\n```c\nvoid Insert(minHeap &H,int x) {\n\tif (H.n==HeapSize)\n\t{\n\t\tprintf(\"堆满\");\n\t}\n\tH.heap[H.n] = x;\n\tshifUp(H, H.n);\n\tH.n++;\n}\n```\n\n* 小根堆的删除\n\n小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用```shiftDown```从堆顶向下进行调整\n\n```c\nint Remove(minHeap &H,int &x) {\n\tif (!H.n)\n\t\treturn 0;               //堆空返回0\n\tx = H.heap[0];\n\tH.heap[0] = H.heap[H.n - 1];\n\tH.n--;\n\tfor (int i = (H.n - 2) / 2; i >= 0; i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H, i);                          //局部自上向下筛选\n\t}\n\treturn 1;\n}\n```\n\n* 运行测试\n\n```c\n\n\nint main() {\n\tint arr[8] = { 53,17,78,9,45,65,87,23};\n\tminHeap H;\n\tcreateMinHeap(H,arr,8);\n\n\tprintf(\"小根堆的建立\\n\");\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tprintf(\"\\n小根堆的插入元素10\\n\");\n\tInsert(H,10);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tint x;\n\tx=Remove(H);\n\tprintf(\"\\n小根堆的删除\\n\");\n\tprintf(\"删除的元素为\\n%d\\n\",x);\n\tprintf(\"删除堆顶元素，进行调整后的元素为\\n\");\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n* 运行结果\n\n\n/source/img/DataStructure/heap8.jpg\n\n\n\n\n### 大根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp)\n\n大根堆的建立过程与小根堆的建立过程是相似的；\n\n* 大根堆的结构定义\n\n```c\ntypedef struct MaxHeap {\n\tint heap[HeapSize];\n\tint n;\n}MaxHeap;\n\n```\n\n* 采用自上而下的调整方法\n\n```c\nvoid shiftHeap(MaxHeap &H,int m) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2*m+1; i <=H.n-1 ; i=i*2+1)\n\t{\n\t\tif (i<H.n-1&&H.heap[i]<H.heap[i+1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n\n```\n\n* 大根堆的建立\n\n```c\nvoid createHeap(MaxHeap &H, int arr[],int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\n\tfor (int i = (n-2)/2; i >=0; i--)\n\t{\n\t\tshiftHeap(H, i);\n\t}\n}\n\n```\n\n* 代码测试\n\n```c\nint main() {\n\tint arr[8] = {1,2,3,4,5,6,7,8};\n\tMaxHeap H;\n\tcreateHeap(H, arr,8);\n\tprintf(\"大根堆的创建结果\\n\");\n\tfor (int  i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n* 测试结果\n\n/source/img/DataStructure/heap3.jpg\n\n\n* 结果以树的形式表示\n/source/img/DataStructure/heap2.jpg\n\n\n\n\n\n","slug":"Data_Structure/2017-08-26-data-structure-build-heap","published":1,"date":"2020-02-29T02:45:08.970Z","updated":"2020-02-29T03:13:04.558Z","_id":"ck770ryg1000qisui8dhg3nd4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-26</p>\n<h3 id=\"堆的概念\"><a href=\"#堆的概念\" class=\"headerlink\" title=\"堆的概念\"></a>堆的概念</h3><blockquote>\n<p>n个元素序列{k0,k1,k2…ki…kn-1},当且仅当满足下列关系时称之为堆：<br>(ki &lt;= k2i+1,ki &lt;= k2i+2)或者(ki &gt;= k2i+1,ki &gt;= k2i+2), (i = 0,1,2,3,4…(n-2)/2)</p>\n</blockquote>\n<p>注：i从0开始与从1开始，需要改变末尾元素的下标值</p>\n<h4 id=\"堆的性质\"><a href=\"#堆的性质\" class=\"headerlink\" title=\"堆的性质\"></a>堆的性质</h4><blockquote>\n<ul>\n<li>堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>\n<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）</li>\n</ul>\n</blockquote>\n<p>大根堆与小根堆</p>\n<p>/source/img/DataStructure/heap.jpg</p>\n<h3 id=\"小根堆的建立源码\"><a href=\"#小根堆的建立源码\" class=\"headerlink\" title=\"小根堆的建立源码:\"></a>小根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp\">源码</a>:</h3><h4 id=\"小根堆的建立过程\"><a href=\"#小根堆的建立过程\" class=\"headerlink\" title=\"小根堆的建立过程\"></a>小根堆的建立过程</h4><p>如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：</p>\n<p>/source/img/DataStructure/heap1.jpg</p>\n<ul>\n<li>小根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minHeap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap[HeapSize];      <span class=\"comment\">//存放小根堆中元素的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;                  <span class=\"comment\">//小根堆当前元素的个数，初始值为0</span></span><br><span class=\"line\">&#125;minHeap;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自顶向下调整</li>\n</ul>\n<p>自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifDown</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//m是开始调整的结点,n是调整结束的点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];  <span class=\"comment\">//j是i的左子女</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; j &lt;= H.n<span class=\"number\">-1</span>; j=<span class=\"number\">2</span>*j+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[j]&gt;H.heap[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &lt;= H.heap[j])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttmp = H.heap[m];</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[j];</span><br><span class=\"line\">\t\t\tH.heap[j] = tmp;</span><br><span class=\"line\">\t\t\tm = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构建小根堆</li>\n</ul>\n<p>构建的是从下到上，调整的时候是从上至下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMinHeap</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>;i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H,i);                       <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自底向上调整小根堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifUp</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j= start;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = (j - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (H.heap[i] &lt;= tmp) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[j] = H.heap[i];</span><br><span class=\"line\">\t\t\tj = i;</span><br><span class=\"line\">\t\t\ti = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[j] = tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>小根堆的插入，采用局部自下向上调整</li>\n</ul>\n<p>小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用<code>shifUp</code>自下向上，一层一层向上调整；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (H.n==HeapSize)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"堆满\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[H.n] = x;</span><br><span class=\"line\">\tshifUp(H, H.n);</span><br><span class=\"line\">\tH.n++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>小根堆的删除</li>\n</ul>\n<p>小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用<code>shiftDown</code>从堆顶向下进行调整</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Remove</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!H.n)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;               <span class=\"comment\">//堆空返回0</span></span><br><span class=\"line\">\tx = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tH.heap[<span class=\"number\">0</span>] = H.heap[H.n - <span class=\"number\">1</span>];</span><br><span class=\"line\">\tH.n--;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H, i);                          <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123; <span class=\"number\">53</span>,<span class=\"number\">17</span>,<span class=\"number\">78</span>,<span class=\"number\">9</span>,<span class=\"number\">45</span>,<span class=\"number\">65</span>,<span class=\"number\">87</span>,<span class=\"number\">23</span>&#125;;</span><br><span class=\"line\">\tminHeap H;</span><br><span class=\"line\">\tcreateMinHeap(H,arr,<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"小根堆的建立\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n小根堆的插入元素10\\n\"</span>);</span><br><span class=\"line\">\tInsert(H,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\tx=Remove(H);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n小根堆的删除\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"删除的元素为\\n%d\\n\"</span>,x);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"删除堆顶元素，进行调整后的元素为\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果</li>\n</ul>\n<p>/source/img/DataStructure/heap8.jpg</p>\n<h3 id=\"大根堆的建立源码\"><a href=\"#大根堆的建立源码\" class=\"headerlink\" title=\"大根堆的建立源码\"></a>大根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp\">源码</a></h3><p>大根堆的建立过程与小根堆的建立过程是相似的；</p>\n<ul>\n<li>大根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MaxHeap</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> heap[HeapSize];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;MaxHeap;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>采用自上而下的调整方法</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeap</span><span class=\"params\">(MaxHeap &amp;H,<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>*m+<span class=\"number\">1</span>; i &lt;=H.n<span class=\"number\">-1</span> ; i=i*<span class=\"number\">2</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[i]&lt;H.heap[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>大根堆的建立</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeap</span><span class=\"params\">(MaxHeap &amp;H, <span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n<span class=\"number\">-2</span>)/<span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeap(H, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>代码测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">\tMaxHeap H;</span><br><span class=\"line\">\tcreateHeap(H, arr,<span class=\"number\">8</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"大根堆的创建结果\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>测试结果</li>\n</ul>\n<p>/source/img/DataStructure/heap3.jpg</p>\n<ul>\n<li>结果以树的形式表示<br>/source/img/DataStructure/heap2.jpg</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-26</p>\n<h3 id=\"堆的概念\"><a href=\"#堆的概念\" class=\"headerlink\" title=\"堆的概念\"></a>堆的概念</h3><blockquote>\n<p>n个元素序列{k0,k1,k2…ki…kn-1},当且仅当满足下列关系时称之为堆：<br>(ki &lt;= k2i+1,ki &lt;= k2i+2)或者(ki &gt;= k2i+1,ki &gt;= k2i+2), (i = 0,1,2,3,4…(n-2)/2)</p>\n</blockquote>\n<p>注：i从0开始与从1开始，需要改变末尾元素的下标值</p>\n<h4 id=\"堆的性质\"><a href=\"#堆的性质\" class=\"headerlink\" title=\"堆的性质\"></a>堆的性质</h4><blockquote>\n<ul>\n<li>堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>\n<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）</li>\n</ul>\n</blockquote>\n<p>大根堆与小根堆</p>\n<p>/source/img/DataStructure/heap.jpg</p>\n<h3 id=\"小根堆的建立源码\"><a href=\"#小根堆的建立源码\" class=\"headerlink\" title=\"小根堆的建立源码:\"></a>小根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp\">源码</a>:</h3><h4 id=\"小根堆的建立过程\"><a href=\"#小根堆的建立过程\" class=\"headerlink\" title=\"小根堆的建立过程\"></a>小根堆的建立过程</h4><p>如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：</p>\n<p>/source/img/DataStructure/heap1.jpg</p>\n<ul>\n<li>小根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minHeap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap[HeapSize];      <span class=\"comment\">//存放小根堆中元素的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;                  <span class=\"comment\">//小根堆当前元素的个数，初始值为0</span></span><br><span class=\"line\">&#125;minHeap;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自顶向下调整</li>\n</ul>\n<p>自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifDown</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//m是开始调整的结点,n是调整结束的点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];  <span class=\"comment\">//j是i的左子女</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; j &lt;= H.n<span class=\"number\">-1</span>; j=<span class=\"number\">2</span>*j+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[j]&gt;H.heap[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &lt;= H.heap[j])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttmp = H.heap[m];</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[j];</span><br><span class=\"line\">\t\t\tH.heap[j] = tmp;</span><br><span class=\"line\">\t\t\tm = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构建小根堆</li>\n</ul>\n<p>构建的是从下到上，调整的时候是从上至下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMinHeap</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>;i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H,i);                       <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自底向上调整小根堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifUp</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j= start;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = (j - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (H.heap[i] &lt;= tmp) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[j] = H.heap[i];</span><br><span class=\"line\">\t\t\tj = i;</span><br><span class=\"line\">\t\t\ti = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[j] = tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>小根堆的插入，采用局部自下向上调整</li>\n</ul>\n<p>小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用<code>shifUp</code>自下向上，一层一层向上调整；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (H.n==HeapSize)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"堆满\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[H.n] = x;</span><br><span class=\"line\">\tshifUp(H, H.n);</span><br><span class=\"line\">\tH.n++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>小根堆的删除</li>\n</ul>\n<p>小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用<code>shiftDown</code>从堆顶向下进行调整</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Remove</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!H.n)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;               <span class=\"comment\">//堆空返回0</span></span><br><span class=\"line\">\tx = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tH.heap[<span class=\"number\">0</span>] = H.heap[H.n - <span class=\"number\">1</span>];</span><br><span class=\"line\">\tH.n--;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H, i);                          <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123; <span class=\"number\">53</span>,<span class=\"number\">17</span>,<span class=\"number\">78</span>,<span class=\"number\">9</span>,<span class=\"number\">45</span>,<span class=\"number\">65</span>,<span class=\"number\">87</span>,<span class=\"number\">23</span>&#125;;</span><br><span class=\"line\">\tminHeap H;</span><br><span class=\"line\">\tcreateMinHeap(H,arr,<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"小根堆的建立\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n小根堆的插入元素10\\n\"</span>);</span><br><span class=\"line\">\tInsert(H,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\tx=Remove(H);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n小根堆的删除\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"删除的元素为\\n%d\\n\"</span>,x);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"删除堆顶元素，进行调整后的元素为\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果</li>\n</ul>\n<p>/source/img/DataStructure/heap8.jpg</p>\n<h3 id=\"大根堆的建立源码\"><a href=\"#大根堆的建立源码\" class=\"headerlink\" title=\"大根堆的建立源码\"></a>大根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp\">源码</a></h3><p>大根堆的建立过程与小根堆的建立过程是相似的；</p>\n<ul>\n<li>大根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MaxHeap</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> heap[HeapSize];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;MaxHeap;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>采用自上而下的调整方法</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeap</span><span class=\"params\">(MaxHeap &amp;H,<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>*m+<span class=\"number\">1</span>; i &lt;=H.n<span class=\"number\">-1</span> ; i=i*<span class=\"number\">2</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[i]&lt;H.heap[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>大根堆的建立</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeap</span><span class=\"params\">(MaxHeap &amp;H, <span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n<span class=\"number\">-2</span>)/<span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeap(H, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>代码测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">\tMaxHeap H;</span><br><span class=\"line\">\tcreateHeap(H, arr,<span class=\"number\">8</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"大根堆的创建结果\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" %d \"</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>测试结果</li>\n</ul>\n<p>/source/img/DataStructure/heap3.jpg</p>\n<ul>\n<li>结果以树的形式表示<br>/source/img/DataStructure/heap2.jpg</li>\n</ul>\n"},{"title":"图的邻接表存储","description":"图的邻接表存储","_content":"modified: 2017-08-27\n### 邻接表\n\n>邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;\n\n/source/img/DataStructure/adjacency_list.jpg\n\n\n* 使用邻接表表示图的数据结构\n\n```c\ntypedef struct EdgeNode {       //边结点的定义\n\tint dest;                   //边的另一个定点的位置\n\tint cost;                   //边上的权重\n\tstruct EdgeNode *link;      //下一条边链指针\n};\n\ntypedef struct VertexNode {       //顶点的定义\n\tchar data;              \n\tstruct  EdgeNode *first;     //边链表的头指针\n};\ntypedef struct ALGraph {          //图的定义\n\tVertexNode VerticesList[maxVertices];     //顶点表（各边链表的头结点）\n\tint numVertices, numEdge;      //图中实际顶点的个数和边的条数\n};\n\n```\n\n* 初始化邻接表\n\n```c\nvoid initGraph(ALGraph &G) {\n\tG.numEdge = 0;\n\tG.numVertices = 0;\n\tfor (int i = 0; i < maxVertices; i++)\n\t{\n\t\tG.VerticesList[i].first = NULL;\n\t}\n}\n\n```\n* 获取顶点在图的数组中的位置，如果不存在则返回-1\n\n```c\nint getVertices(ALGraph G,char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i].data==x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n* 创建一个带权的有向图\n\n```c\nvoid createGraph(ALGraph &G, int numVertices, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息\n\tG.numVertices = numVertices;\n\tG.numEdge = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor ( int i = 0; i < numVertices; i++)\n\t{\n\t\tscanf(\"%c\",&G.VerticesList[i].data);\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < G.numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();\n\t\tscanf(\"%c %c %d\",&e1,&e2,&weight);\n\t\tif (getVertices(G,e1)!=-1&& getVertices(G, e2) != -1)\n\t\t{\n\t\t\tEdgeNode *p, *q;\n\t\t\tp = G.VerticesList[getVertices(G, e1)].first;\n\t\t\tq = (EdgeNode *)malloc(sizeof(EdgeNode));\n\t\t\tif (p==NULL)\n\t\t\t{\n\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (p->link != NULL)\n\t\t\t\t{\n\t\t\t\t\tp = p->link;\n\t\t\t\t}\n\t\t\t\tp->link= q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t  printf(\"顶点输入错误，请重新输入\\n\");\n\t}\n}\n\n```\n\n\n* 测试代码（以上面的无向图为例，因为`createGraph`为构建有向图，只需将无向图看作双向有向图即可）\n\n```c\n\nint main() {\n\tALGraph G;\n\tinitGraph(G);\n\tcreateGraph(G, 4, 3);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"%c \",G.VerticesList[i]);\n\t\tEdgeNode *p = G.VerticesList[i].first;\n\t\twhile (p!= NULL)\n\t\t{\n\t\t\tprintf(\"%d \", p->dest);\n\t\t\tprintf(\"%d \",p->cost);\n\t\t\tp = p->link;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n/source/img/DataStructure/adjacency_list1.png\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp)\n","source":"_posts/Data_Structure/2017-08-27-data-structure-adjacency-list.md","raw":"---\n\ntitle: \"图的邻接表存储\"\ndescription: \"图的邻接表存储\"\ntags: [数据结构]\n\n\n\n\n---\nmodified: 2017-08-27\n### 邻接表\n\n>邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;\n\n/source/img/DataStructure/adjacency_list.jpg\n\n\n* 使用邻接表表示图的数据结构\n\n```c\ntypedef struct EdgeNode {       //边结点的定义\n\tint dest;                   //边的另一个定点的位置\n\tint cost;                   //边上的权重\n\tstruct EdgeNode *link;      //下一条边链指针\n};\n\ntypedef struct VertexNode {       //顶点的定义\n\tchar data;              \n\tstruct  EdgeNode *first;     //边链表的头指针\n};\ntypedef struct ALGraph {          //图的定义\n\tVertexNode VerticesList[maxVertices];     //顶点表（各边链表的头结点）\n\tint numVertices, numEdge;      //图中实际顶点的个数和边的条数\n};\n\n```\n\n* 初始化邻接表\n\n```c\nvoid initGraph(ALGraph &G) {\n\tG.numEdge = 0;\n\tG.numVertices = 0;\n\tfor (int i = 0; i < maxVertices; i++)\n\t{\n\t\tG.VerticesList[i].first = NULL;\n\t}\n}\n\n```\n* 获取顶点在图的数组中的位置，如果不存在则返回-1\n\n```c\nint getVertices(ALGraph G,char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i].data==x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n* 创建一个带权的有向图\n\n```c\nvoid createGraph(ALGraph &G, int numVertices, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息\n\tG.numVertices = numVertices;\n\tG.numEdge = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor ( int i = 0; i < numVertices; i++)\n\t{\n\t\tscanf(\"%c\",&G.VerticesList[i].data);\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < G.numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();\n\t\tscanf(\"%c %c %d\",&e1,&e2,&weight);\n\t\tif (getVertices(G,e1)!=-1&& getVertices(G, e2) != -1)\n\t\t{\n\t\t\tEdgeNode *p, *q;\n\t\t\tp = G.VerticesList[getVertices(G, e1)].first;\n\t\t\tq = (EdgeNode *)malloc(sizeof(EdgeNode));\n\t\t\tif (p==NULL)\n\t\t\t{\n\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (p->link != NULL)\n\t\t\t\t{\n\t\t\t\t\tp = p->link;\n\t\t\t\t}\n\t\t\t\tp->link= q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t  printf(\"顶点输入错误，请重新输入\\n\");\n\t}\n}\n\n```\n\n\n* 测试代码（以上面的无向图为例，因为`createGraph`为构建有向图，只需将无向图看作双向有向图即可）\n\n```c\n\nint main() {\n\tALGraph G;\n\tinitGraph(G);\n\tcreateGraph(G, 4, 3);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"%c \",G.VerticesList[i]);\n\t\tEdgeNode *p = G.VerticesList[i].first;\n\t\twhile (p!= NULL)\n\t\t{\n\t\t\tprintf(\"%d \", p->dest);\n\t\t\tprintf(\"%d \",p->cost);\n\t\t\tp = p->link;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n/source/img/DataStructure/adjacency_list1.png\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp)\n","slug":"Data_Structure/2017-08-27-data-structure-adjacency-list","published":1,"date":"2020-02-29T02:45:08.988Z","updated":"2020-02-29T03:09:24.129Z","_id":"ck770ryg2000sisui1wnz82d9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-27</p>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><blockquote>\n<p>邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;</p>\n</blockquote>\n<p>/source/img/DataStructure/adjacency_list.jpg</p>\n<ul>\n<li>使用邻接表表示图的数据结构</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> &#123;</span>       <span class=\"comment\">//边结点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> dest;                   <span class=\"comment\">//边的另一个定点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cost;                   <span class=\"comment\">//边上的权重</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> *<span class=\"title\">link</span>;</span>      <span class=\"comment\">//下一条边链指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VertexNode</span> &#123;</span>       <span class=\"comment\">//顶点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">EdgeNode</span> *<span class=\"title\">first</span>;</span>     <span class=\"comment\">//边链表的头指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ALGraph</span> &#123;</span>          <span class=\"comment\">//图的定义</span></span><br><span class=\"line\">\tVertexNode VerticesList[maxVertices];     <span class=\"comment\">//顶点表（各边链表的头结点）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdge;      <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>初始化邻接表</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initGraph</span><span class=\"params\">(ALGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numEdge = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i].first = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取顶点在图的数组中的位置，如果不存在则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getVertices</span><span class=\"params\">(ALGraph G,<span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i].data==x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个带权的有向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createGraph</span><span class=\"params\">(ALGraph &amp;G, <span class=\"keyword\">int</span> numVertices, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息</span></span><br><span class=\"line\">\tG.numVertices = numVertices;</span><br><span class=\"line\">\tG.numEdge = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>,&amp;G.VerticesList[i].data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点和权重\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c %c %d\"</span>,&amp;e1,&amp;e2,&amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (getVertices(G,e1)!=<span class=\"number\">-1</span>&amp;&amp; getVertices(G, e2) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tEdgeNode *p, *q;</span><br><span class=\"line\">\t\t\tp = G.VerticesList[getVertices(G, e1)].first;</span><br><span class=\"line\">\t\t\tq = (EdgeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(EdgeNode));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (p-&gt;link != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tp-&gt;link= q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">\"顶点输入错误，请重新输入\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>测试代码（以上面的无向图为例，因为<code>createGraph</code>为构建有向图，只需将无向图看作双向有向图即可）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tALGraph G;</span><br><span class=\"line\">\tinitGraph(G);</span><br><span class=\"line\">\tcreateGraph(G, <span class=\"number\">4</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>,G.VerticesList[i]);</span><br><span class=\"line\">\t\tEdgeNode *p = G.VerticesList[i].first;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p!= <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, p-&gt;dest);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,p-&gt;cost);</span><br><span class=\"line\">\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br>/source/img/DataStructure/adjacency_list1.png</li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp\">源码下载</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-27</p>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><blockquote>\n<p>邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;</p>\n</blockquote>\n<p>/source/img/DataStructure/adjacency_list.jpg</p>\n<ul>\n<li>使用邻接表表示图的数据结构</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> &#123;</span>       <span class=\"comment\">//边结点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> dest;                   <span class=\"comment\">//边的另一个定点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cost;                   <span class=\"comment\">//边上的权重</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> *<span class=\"title\">link</span>;</span>      <span class=\"comment\">//下一条边链指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VertexNode</span> &#123;</span>       <span class=\"comment\">//顶点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">EdgeNode</span> *<span class=\"title\">first</span>;</span>     <span class=\"comment\">//边链表的头指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ALGraph</span> &#123;</span>          <span class=\"comment\">//图的定义</span></span><br><span class=\"line\">\tVertexNode VerticesList[maxVertices];     <span class=\"comment\">//顶点表（各边链表的头结点）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdge;      <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>初始化邻接表</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initGraph</span><span class=\"params\">(ALGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numEdge = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i].first = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取顶点在图的数组中的位置，如果不存在则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getVertices</span><span class=\"params\">(ALGraph G,<span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i].data==x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个带权的有向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createGraph</span><span class=\"params\">(ALGraph &amp;G, <span class=\"keyword\">int</span> numVertices, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息</span></span><br><span class=\"line\">\tG.numVertices = numVertices;</span><br><span class=\"line\">\tG.numEdge = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>,&amp;G.VerticesList[i].data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入顶点和权重\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c %c %d\"</span>,&amp;e1,&amp;e2,&amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (getVertices(G,e1)!=<span class=\"number\">-1</span>&amp;&amp; getVertices(G, e2) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tEdgeNode *p, *q;</span><br><span class=\"line\">\t\t\tp = G.VerticesList[getVertices(G, e1)].first;</span><br><span class=\"line\">\t\t\tq = (EdgeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(EdgeNode));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (p-&gt;link != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tp-&gt;link= q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">\"顶点输入错误，请重新输入\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>测试代码（以上面的无向图为例，因为<code>createGraph</code>为构建有向图，只需将无向图看作双向有向图即可）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tALGraph G;</span><br><span class=\"line\">\tinitGraph(G);</span><br><span class=\"line\">\tcreateGraph(G, <span class=\"number\">4</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>,G.VerticesList[i]);</span><br><span class=\"line\">\t\tEdgeNode *p = G.VerticesList[i].first;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p!= <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, p-&gt;dest);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,p-&gt;cost);</span><br><span class=\"line\">\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br>/source/img/DataStructure/adjacency_list1.png</li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp\">源码下载</a></p>\n"},{"title":"堆排序","description":"堆排序","_content":"modified: 2017-08-27\n\n### 堆排序原理\n\n在[建堆](https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html)完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。\n\n#### 使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\n\n* 采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素\n\n```c\nvoid shiftHeapSort(MaxHeapSort &H, int m,int n) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2 * m + 1; i <= n - 1; i = i * 2 + 1)\n\t{\n\t\tif (i<n - 1 && H.heap[i]<H.heap[i + 1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n```\n\n* 创建最大堆\n\n```c\nvoid createHeapSort(MaxHeapSort &H, int arr[], int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\tfor (int i = (n - 2) / 2; i >= 0; i--)\n\t{\n\t\tshiftHeapSort(H, i,H.n);\n\t}\n}\n```\n\n* 对最大堆进行排序\n\n```c\nint main(){\n\t \n\tint a[7] = {7,6,5,4,3,2,1};\n\t//首先构建最大堆\n\tMaxHeapSort H;\n\tcreateHeapSort(H, a, 7);\n\t//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆\n\tint tmp;\n\tfor (int i = H.n-1; i >=0; i--)\n\t{\n\t\ttmp = H.heap[0];\n\t\tH.heap[0] = H.heap[i];\n\t\tH.heap[i] = tmp;\n\t\t//将其再次调整为最大堆\n\t\tfor (int j = i/2; j >=0; j--)\n\t\t{\n\t\t\tshiftHeapSort(H,j,i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n* 运行结果\n/source/img/DataStructure/heap_sort.jpg\n","source":"_posts/Data_Structure/2017-08-27-data-structure-heap-sort.md","raw":"---\n\ntitle: \"堆排序\"\ndescription: \"堆排序\"\n\ntags: [数据结构]\n\n\n\n\n---\nmodified: 2017-08-27\n\n### 堆排序原理\n\n在[建堆](https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html)完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。\n\n#### 使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\n\n* 采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素\n\n```c\nvoid shiftHeapSort(MaxHeapSort &H, int m,int n) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2 * m + 1; i <= n - 1; i = i * 2 + 1)\n\t{\n\t\tif (i<n - 1 && H.heap[i]<H.heap[i + 1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n```\n\n* 创建最大堆\n\n```c\nvoid createHeapSort(MaxHeapSort &H, int arr[], int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\tfor (int i = (n - 2) / 2; i >= 0; i--)\n\t{\n\t\tshiftHeapSort(H, i,H.n);\n\t}\n}\n```\n\n* 对最大堆进行排序\n\n```c\nint main(){\n\t \n\tint a[7] = {7,6,5,4,3,2,1};\n\t//首先构建最大堆\n\tMaxHeapSort H;\n\tcreateHeapSort(H, a, 7);\n\t//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆\n\tint tmp;\n\tfor (int i = H.n-1; i >=0; i--)\n\t{\n\t\ttmp = H.heap[0];\n\t\tH.heap[0] = H.heap[i];\n\t\tH.heap[i] = tmp;\n\t\t//将其再次调整为最大堆\n\t\tfor (int j = i/2; j >=0; j--)\n\t\t{\n\t\t\tshiftHeapSort(H,j,i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n* 运行结果\n/source/img/DataStructure/heap_sort.jpg\n","slug":"Data_Structure/2017-08-27-data-structure-heap-sort","published":1,"date":"2020-02-29T02:45:09.000Z","updated":"2020-02-29T03:09:38.054Z","_id":"ck770ryg3000uisui6izg2sed","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-27</p>\n<h3 id=\"堆排序原理\"><a href=\"#堆排序原理\" class=\"headerlink\" title=\"堆排序原理\"></a>堆排序原理</h3><p>在<a href=\"https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html\">建堆</a>完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。</p>\n<h4 id=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"><a href=\"#使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\" class=\"headerlink\" title=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"></a>使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）</h4><ul>\n<li>采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;n - <span class=\"number\">1</span> &amp;&amp; H.heap[i]&lt;H.heap[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建最大堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeapSort(H, i,H.n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对最大堆进行排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//首先构建最大堆</span></span><br><span class=\"line\">\tMaxHeapSort H;</span><br><span class=\"line\">\tcreateHeapSort(H, a, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = H.n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tH.heap[<span class=\"number\">0</span>] = H.heap[i];</span><br><span class=\"line\">\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将其再次调整为最大堆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i/<span class=\"number\">2</span>; j &gt;=<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tshiftHeapSort(H,j,i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行结果<br>/source/img/DataStructure/heap_sort.jpg</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-27</p>\n<h3 id=\"堆排序原理\"><a href=\"#堆排序原理\" class=\"headerlink\" title=\"堆排序原理\"></a>堆排序原理</h3><p>在<a href=\"https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html\">建堆</a>完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。</p>\n<h4 id=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"><a href=\"#使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\" class=\"headerlink\" title=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"></a>使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）</h4><ul>\n<li>采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;n - <span class=\"number\">1</span> &amp;&amp; H.heap[i]&lt;H.heap[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建最大堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeapSort(H, i,H.n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对最大堆进行排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//首先构建最大堆</span></span><br><span class=\"line\">\tMaxHeapSort H;</span><br><span class=\"line\">\tcreateHeapSort(H, a, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = H.n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tH.heap[<span class=\"number\">0</span>] = H.heap[i];</span><br><span class=\"line\">\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将其再次调整为最大堆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i/<span class=\"number\">2</span>; j &gt;=<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tshiftHeapSort(H,j,i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行结果<br>/source/img/DataStructure/heap_sort.jpg</li>\n</ul>\n"},{"title":"Huffman树的算法实现","description":"Huffman树的算法实现","_content":"\nmodified  2017-08-27\n## Huffman树\n\nHuffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；\n\n### Huffman算法\n\n设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树\n/source/img/DataStructure/huffman_tree2.jpg\n\n\n### 构造Huffman树的算法实现\n* Huffman树的结点结构定义\n\n```c\ntypedef struct HuffmanNode {\n\tchar data;              //数据\n\tint weight;             //权重\n\tint lChild, rChild, parent; //指针\n};\n```\n* Huffman树的结构定义\n\n```c\ntypedef struct HuffmanTree {\n\tHuffmanNode elem[totalNumber];  //树的存储数组\n\tint n;                          //当前外结点的个数\n};\n```\n\n* 构造Huffman树\n\n```c\nvoid createHuffmanTree(HuffmanTree &HT,int weight[],int n) {\n\t//给出n个权重的数组，构造Huffman树HT\n\tint p1,p2, min1, min2;                   //p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值\n\tfor (int i = 0; i < n; i++)\n\t\tHT.elem[i].weight = weight[i];        //权重传到树中\n\tfor (int i = 0; i < 2*n-1; i++)            //元素初始化\n\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = -1;\n\tp1 = p2 = 0;\n\tfor ( int i = n; i <2*n-1; i++)          //逐个非叶节点构造\n\t{\n\t\tmin1 = min2 = 100;\n\t\tfor ( int j = 0; j < i; j++)          //寻找具有最小、次小值的根建树\n\t\t{\n\t\t\tif (HT.elem[j].parent== -1) {    //父指针为-1，则此时该节点没有父亲\n\t\t\t\tif (HT.elem[j].weight<min1)   //比原来最小的还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = p1;                   \n\t\t\t\t\tmin2 = min1;               //原来最小的变为最小\n\t\t\t\t\tp1 = j;\n\t\t\t\t\tmin1 = HT.elem[j].weight;   //记下新的最小值\n\t\t\t\t}\n\t\t\t\telse if (HT.elem[j].weight<min2) //比原来的次小还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tmin2 = HT.elem[j].weight;    //记下新的次小值\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHT.elem[i].lChild = p1;\n\t\tHT.elem[i].rChild = p2;        //左最小，右次小链接\n\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;\n\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          //链接父节点\n\t}\n\tHT.n = 2 * n - 1;\n}\n```\n##### 上图构建Huffman树之后的结果\n\n\n/source/img/DataStructure/huffman_tree.png\n/source/img/DataStructure/huffman_tree1.png\n\n\n* 上述代码运行\n\n```c\n\nint main() {\n\tint weight[5] = {7,5,2,4,6};\n\tHuffmanTree ht;\n    createHuffmanTree(ht,weight,5);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\"%d %d %d\\n\",ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n/source/img/DataStructure/huffman_tree3.png\n\n\n\n[源码地址](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp)","source":"_posts/Data_Structure/2017-08-28-data-structure-huffman-tree.md","raw":"---\n\ntitle: \"Huffman树的算法实现\"\ndescription: \"Huffman树的算法实现\"\n\ntags: [数据结构]\n\n\n\n---\n\nmodified  2017-08-27\n## Huffman树\n\nHuffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；\n\n### Huffman算法\n\n设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树\n/source/img/DataStructure/huffman_tree2.jpg\n\n\n### 构造Huffman树的算法实现\n* Huffman树的结点结构定义\n\n```c\ntypedef struct HuffmanNode {\n\tchar data;              //数据\n\tint weight;             //权重\n\tint lChild, rChild, parent; //指针\n};\n```\n* Huffman树的结构定义\n\n```c\ntypedef struct HuffmanTree {\n\tHuffmanNode elem[totalNumber];  //树的存储数组\n\tint n;                          //当前外结点的个数\n};\n```\n\n* 构造Huffman树\n\n```c\nvoid createHuffmanTree(HuffmanTree &HT,int weight[],int n) {\n\t//给出n个权重的数组，构造Huffman树HT\n\tint p1,p2, min1, min2;                   //p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值\n\tfor (int i = 0; i < n; i++)\n\t\tHT.elem[i].weight = weight[i];        //权重传到树中\n\tfor (int i = 0; i < 2*n-1; i++)            //元素初始化\n\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = -1;\n\tp1 = p2 = 0;\n\tfor ( int i = n; i <2*n-1; i++)          //逐个非叶节点构造\n\t{\n\t\tmin1 = min2 = 100;\n\t\tfor ( int j = 0; j < i; j++)          //寻找具有最小、次小值的根建树\n\t\t{\n\t\t\tif (HT.elem[j].parent== -1) {    //父指针为-1，则此时该节点没有父亲\n\t\t\t\tif (HT.elem[j].weight<min1)   //比原来最小的还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = p1;                   \n\t\t\t\t\tmin2 = min1;               //原来最小的变为最小\n\t\t\t\t\tp1 = j;\n\t\t\t\t\tmin1 = HT.elem[j].weight;   //记下新的最小值\n\t\t\t\t}\n\t\t\t\telse if (HT.elem[j].weight<min2) //比原来的次小还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tmin2 = HT.elem[j].weight;    //记下新的次小值\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHT.elem[i].lChild = p1;\n\t\tHT.elem[i].rChild = p2;        //左最小，右次小链接\n\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;\n\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          //链接父节点\n\t}\n\tHT.n = 2 * n - 1;\n}\n```\n##### 上图构建Huffman树之后的结果\n\n\n/source/img/DataStructure/huffman_tree.png\n/source/img/DataStructure/huffman_tree1.png\n\n\n* 上述代码运行\n\n```c\n\nint main() {\n\tint weight[5] = {7,5,2,4,6};\n\tHuffmanTree ht;\n    createHuffmanTree(ht,weight,5);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\"%d %d %d\\n\",ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n/source/img/DataStructure/huffman_tree3.png\n\n\n\n[源码地址](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp)","slug":"Data_Structure/2017-08-28-data-structure-huffman-tree","published":1,"date":"2020-02-29T02:45:09.033Z","updated":"2020-02-29T03:10:02.118Z","_id":"ck770ryg3000wisui6b9289dc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified  2017-08-27</p>\n<h2 id=\"Huffman树\"><a href=\"#Huffman树\" class=\"headerlink\" title=\"Huffman树\"></a>Huffman树</h2><p>Huffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；</p>\n<h3 id=\"Huffman算法\"><a href=\"#Huffman算法\" class=\"headerlink\" title=\"Huffman算法\"></a>Huffman算法</h3><p>设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树<br>/source/img/DataStructure/huffman_tree2.jpg</p>\n<h3 id=\"构造Huffman树的算法实现\"><a href=\"#构造Huffman树的算法实现\" class=\"headerlink\" title=\"构造Huffman树的算法实现\"></a>构造Huffman树的算法实现</h3><ul>\n<li>Huffman树的结点结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;             <span class=\"comment\">//权重</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lChild, rChild, parent; <span class=\"comment\">//指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Huffman树的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanTree</span> &#123;</span></span><br><span class=\"line\">\tHuffmanNode elem[totalNumber];  <span class=\"comment\">//树的存储数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;                          <span class=\"comment\">//当前外结点的个数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造Huffman树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHuffmanTree</span><span class=\"params\">(HuffmanTree &amp;HT,<span class=\"keyword\">int</span> weight[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//给出n个权重的数组，构造Huffman树HT</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p1,p2, min1, min2;                   <span class=\"comment\">//p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tHT.elem[i].weight = weight[i];        <span class=\"comment\">//权重传到树中</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)            <span class=\"comment\">//元素初始化</span></span><br><span class=\"line\">\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tp1 = p2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = n; i &lt;<span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)          <span class=\"comment\">//逐个非叶节点构造</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmin1 = min2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)          <span class=\"comment\">//寻找具有最小、次小值的根建树</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].parent== <span class=\"number\">-1</span>) &#123;    <span class=\"comment\">//父指针为-1，则此时该节点没有父亲</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min1)   <span class=\"comment\">//比原来最小的还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = p1;                   </span><br><span class=\"line\">\t\t\t\t\tmin2 = min1;               <span class=\"comment\">//原来最小的变为最小</span></span><br><span class=\"line\">\t\t\t\t\tp1 = j;</span><br><span class=\"line\">\t\t\t\t\tmin1 = HT.elem[j].weight;   <span class=\"comment\">//记下新的最小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min2) <span class=\"comment\">//比原来的次小还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = j;</span><br><span class=\"line\">\t\t\t\t\tmin2 = HT.elem[j].weight;    <span class=\"comment\">//记下新的次小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tHT.elem[i].lChild = p1;</span><br><span class=\"line\">\t\tHT.elem[i].rChild = p2;        <span class=\"comment\">//左最小，右次小链接</span></span><br><span class=\"line\">\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;</span><br><span class=\"line\">\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          <span class=\"comment\">//链接父节点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHT.n = <span class=\"number\">2</span> * n - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"上图构建Huffman树之后的结果\"><a href=\"#上图构建Huffman树之后的结果\" class=\"headerlink\" title=\"上图构建Huffman树之后的结果\"></a>上图构建Huffman树之后的结果</h5><p>/source/img/DataStructure/huffman_tree.png<br>/source/img/DataStructure/huffman_tree1.png</p>\n<ul>\n<li>上述代码运行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight[<span class=\"number\">5</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">\tHuffmanTree ht;</span><br><span class=\"line\">    createHuffmanTree(ht,weight,<span class=\"number\">5</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\\n\"</span>,ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br>/source/img/DataStructure/huffman_tree3.png</li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>modified  2017-08-27</p>\n<h2 id=\"Huffman树\"><a href=\"#Huffman树\" class=\"headerlink\" title=\"Huffman树\"></a>Huffman树</h2><p>Huffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；</p>\n<h3 id=\"Huffman算法\"><a href=\"#Huffman算法\" class=\"headerlink\" title=\"Huffman算法\"></a>Huffman算法</h3><p>设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树<br>/source/img/DataStructure/huffman_tree2.jpg</p>\n<h3 id=\"构造Huffman树的算法实现\"><a href=\"#构造Huffman树的算法实现\" class=\"headerlink\" title=\"构造Huffman树的算法实现\"></a>构造Huffman树的算法实现</h3><ul>\n<li>Huffman树的结点结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;             <span class=\"comment\">//权重</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lChild, rChild, parent; <span class=\"comment\">//指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Huffman树的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanTree</span> &#123;</span></span><br><span class=\"line\">\tHuffmanNode elem[totalNumber];  <span class=\"comment\">//树的存储数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;                          <span class=\"comment\">//当前外结点的个数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造Huffman树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHuffmanTree</span><span class=\"params\">(HuffmanTree &amp;HT,<span class=\"keyword\">int</span> weight[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//给出n个权重的数组，构造Huffman树HT</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p1,p2, min1, min2;                   <span class=\"comment\">//p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tHT.elem[i].weight = weight[i];        <span class=\"comment\">//权重传到树中</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)            <span class=\"comment\">//元素初始化</span></span><br><span class=\"line\">\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tp1 = p2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = n; i &lt;<span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)          <span class=\"comment\">//逐个非叶节点构造</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmin1 = min2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)          <span class=\"comment\">//寻找具有最小、次小值的根建树</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].parent== <span class=\"number\">-1</span>) &#123;    <span class=\"comment\">//父指针为-1，则此时该节点没有父亲</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min1)   <span class=\"comment\">//比原来最小的还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = p1;                   </span><br><span class=\"line\">\t\t\t\t\tmin2 = min1;               <span class=\"comment\">//原来最小的变为最小</span></span><br><span class=\"line\">\t\t\t\t\tp1 = j;</span><br><span class=\"line\">\t\t\t\t\tmin1 = HT.elem[j].weight;   <span class=\"comment\">//记下新的最小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min2) <span class=\"comment\">//比原来的次小还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = j;</span><br><span class=\"line\">\t\t\t\t\tmin2 = HT.elem[j].weight;    <span class=\"comment\">//记下新的次小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tHT.elem[i].lChild = p1;</span><br><span class=\"line\">\t\tHT.elem[i].rChild = p2;        <span class=\"comment\">//左最小，右次小链接</span></span><br><span class=\"line\">\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;</span><br><span class=\"line\">\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          <span class=\"comment\">//链接父节点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHT.n = <span class=\"number\">2</span> * n - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"上图构建Huffman树之后的结果\"><a href=\"#上图构建Huffman树之后的结果\" class=\"headerlink\" title=\"上图构建Huffman树之后的结果\"></a>上图构建Huffman树之后的结果</h5><p>/source/img/DataStructure/huffman_tree.png<br>/source/img/DataStructure/huffman_tree1.png</p>\n<ul>\n<li>上述代码运行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight[<span class=\"number\">5</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">\tHuffmanTree ht;</span><br><span class=\"line\">    createHuffmanTree(ht,weight,<span class=\"number\">5</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\\n\"</span>,ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br>/source/img/DataStructure/huffman_tree3.png</li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp\">源码地址</a></p>\n"},{"_content":"# Java文章目录\n","source":"_posts/Directory/Java Directory.md","raw":"# Java文章目录\n","slug":"Directory/Java Directory","published":1,"date":"2019-09-11T01:29:47.698Z","updated":"2019-09-30T08:28:42.967Z","title":"Directory/Java Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg4000yisui3yfj87e8","content":"<h1 id=\"Java文章目录\"><a href=\"#Java文章目录\" class=\"headerlink\" title=\"Java文章目录\"></a>Java文章目录</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java文章目录\"><a href=\"#Java文章目录\" class=\"headerlink\" title=\"Java文章目录\"></a>Java文章目录</h1>"},{"_content":"\n# 其他文章目录\n\n","source":"_posts/Directory/Other Directory.md","raw":"\n# 其他文章目录\n\n","slug":"Directory/Other Directory","published":1,"date":"2019-09-11T11:02:43.459Z","updated":"2019-09-30T08:28:42.968Z","title":"Directory/Other Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg40010isui8bzl1tji","content":"<h1 id=\"其他文章目录\"><a href=\"#其他文章目录\" class=\"headerlink\" title=\"其他文章目录\"></a>其他文章目录</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"其他文章目录\"><a href=\"#其他文章目录\" class=\"headerlink\" title=\"其他文章目录\"></a>其他文章目录</h1>"},{"_content":"# Java目录\n\n* [Java基础](Java基础/README.md)\n* [Java多线程](Java多线程/README.md)\n* [Java虚拟机](Java虚拟机/README.md)\n* [Java设计模式](设计模式/README.md)","source":"_posts/Java/README.md","raw":"# Java目录\n\n* [Java基础](Java基础/README.md)\n* [Java多线程](Java多线程/README.md)\n* [Java虚拟机](Java虚拟机/README.md)\n* [Java设计模式](设计模式/README.md)","slug":"Java/README","published":1,"date":"2019-09-11T01:29:47.705Z","updated":"2019-09-30T08:28:42.977Z","title":"Java/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg50012isuifoz941uu","content":"<h1 id=\"Java目录\"><a href=\"#Java目录\" class=\"headerlink\" title=\"Java目录\"></a>Java目录</h1><ul>\n<li><a href=\"Java基础/README.md\">Java基础</a></li>\n<li><a href=\"Java多线程/README.md\">Java多线程</a></li>\n<li><a href=\"Java虚拟机/README.md\">Java虚拟机</a></li>\n<li><a href=\"设计模式/README.md\">Java设计模式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java目录\"><a href=\"#Java目录\" class=\"headerlink\" title=\"Java目录\"></a>Java目录</h1><ul>\n<li><a href=\"Java基础/README.md\">Java基础</a></li>\n<li><a href=\"Java多线程/README.md\">Java多线程</a></li>\n<li><a href=\"Java虚拟机/README.md\">Java虚拟机</a></li>\n<li><a href=\"设计模式/README.md\">Java设计模式</a></li>\n</ul>\n"},{"_content":"\n## Other目录\n\n* [Git基础](Git/Git.html)","source":"_posts/Other/README.md","raw":"\n## Other目录\n\n* [Git基础](Git/Git.html)","slug":"Other/README","published":1,"date":"2019-09-11T08:04:40.931Z","updated":"2019-10-08T06:19:41.311Z","title":"Other/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg60014isuid14ggobg","content":"<h2 id=\"Other目录\"><a href=\"#Other目录\" class=\"headerlink\" title=\"Other目录\"></a>Other目录</h2><ul>\n<li><a href=\"Git/Git.html\">Git基础</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Other目录\"><a href=\"#Other目录\" class=\"headerlink\" title=\"Other目录\"></a>Other目录</h2><ul>\n<li><a href=\"Git/Git.html\">Git基础</a></li>\n</ul>\n"},{"_content":"## 函数式编程（FP）\n\n\"函数式编程\", 又称泛函编程, 是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。\n函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","source":"_posts/Other/函数式编程.md","raw":"## 函数式编程（FP）\n\n\"函数式编程\", 又称泛函编程, 是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。\n函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","slug":"Other/函数式编程","published":1,"date":"2019-09-19T09:34:08.500Z","updated":"2019-09-19T09:41:14.781Z","title":"Other/函数式编程","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg60016isui27kzelic","content":"<h2 id=\"函数式编程（FP）\"><a href=\"#函数式编程（FP）\" class=\"headerlink\" title=\"函数式编程（FP）\"></a>函数式编程（FP）</h2><p>“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。<br>函数式编程关心数据的映射，命令式编程关心解决问题的步骤；</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数式编程（FP）\"><a href=\"#函数式编程（FP）\" class=\"headerlink\" title=\"函数式编程（FP）\"></a>函数式编程（FP）</h2><p>“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。<br>函数式编程关心数据的映射，命令式编程关心解决问题的步骤；</p>\n"},{"title":"PAT甲级1001. A+B Format","description":"Calculate a + b and output the sum in standard format.","_content":"\nmodified: 2017-07-27\n\n* A+B Format (20)\n\nCalculate a + b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\n\nInput\n\nEach input file contains one test case. Each case contains a pair of integers a and b where -1000000 <= a, b <= 1000000. The numbers are separated by a space.\n\nOutput\n\nFor each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.\n\nSample Input\n-1000000 9\n\nSample Output\n-999,991\n\n### 题目要求：\n\n计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；\n\n输入：输入两个在[-1000000,1000000]的a,b两个数\n\n输出：应该在一行格式化输出\n\n### 解题思路：\n\na,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\nint main() {\n\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint num = 0;\n\tint tmp[3];\n\n\tscanf(\"%d%d\", &a, &b);\n\tc = a + b;\n\n\tif (c < 0)\n\t{\n\t\tprintf(\"%c\", '-');\n\t\tc = -c;\n\t}\n\n\twhile (c/1000>=1)\n\t{\n\t\ttmp[num] = c % 1000;\n\t\tnum++;\n\t\tc = c / 1000;\n\t\t\n\t}\n\ttmp[num] = c;\n\n\tfor (int  i = num; i >=0; i--)\n\t{\n\t\tif (i==num)\n\t\t{\n\t\t\tprintf(\"%d\", tmp[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tmp[i]<10)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",00\", tmp[i]);\n\t\t\t}\n\t\t\telse if (tmp[i]<100)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",0\", tmp[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",\", tmp[i]);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n","source":"_posts/PAT/2017-07-27-pat-advanced-1001.md","raw":"---\ntitle: \"PAT甲级1001. A+B Format\"\ndescription: \"Calculate a + b and output the sum in standard format.\"\ntags: [pat]\n\n\n---\n\nmodified: 2017-07-27\n\n* A+B Format (20)\n\nCalculate a + b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\n\nInput\n\nEach input file contains one test case. Each case contains a pair of integers a and b where -1000000 <= a, b <= 1000000. The numbers are separated by a space.\n\nOutput\n\nFor each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.\n\nSample Input\n-1000000 9\n\nSample Output\n-999,991\n\n### 题目要求：\n\n计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；\n\n输入：输入两个在[-1000000,1000000]的a,b两个数\n\n输出：应该在一行格式化输出\n\n### 解题思路：\n\na,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\nint main() {\n\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint num = 0;\n\tint tmp[3];\n\n\tscanf(\"%d%d\", &a, &b);\n\tc = a + b;\n\n\tif (c < 0)\n\t{\n\t\tprintf(\"%c\", '-');\n\t\tc = -c;\n\t}\n\n\twhile (c/1000>=1)\n\t{\n\t\ttmp[num] = c % 1000;\n\t\tnum++;\n\t\tc = c / 1000;\n\t\t\n\t}\n\ttmp[num] = c;\n\n\tfor (int  i = num; i >=0; i--)\n\t{\n\t\tif (i==num)\n\t\t{\n\t\t\tprintf(\"%d\", tmp[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tmp[i]<10)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",00\", tmp[i]);\n\t\t\t}\n\t\t\telse if (tmp[i]<100)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",0\", tmp[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",\", tmp[i]);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n","slug":"PAT/2017-07-27-pat-advanced-1001","published":1,"date":"2020-02-29T02:44:34.831Z","updated":"2020-02-29T02:53:05.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg70017isui72c986yj","content":"<p>modified: 2017-07-27</p>\n<ul>\n<li>A+B Format (20)</li>\n</ul>\n<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p>\n<p>Output</p>\n<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>\n<p>Sample Input<br>-1000000 9</p>\n<p>Sample Output<br>-999,991</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；</p>\n<p>输入：输入两个在[-1000000,1000000]的a,b两个数</p>\n<p>输出：应该在一行格式化输出</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>a,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">\tc = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, <span class=\"string\">'-'</span>);</span><br><span class=\"line\">\t\tc = -c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (c/<span class=\"number\">1000</span>&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[num] = c % <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t\tc = c / <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttmp[num] = c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = num; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i==num)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%d\"</span>, <span class=\"string\">\",00\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">100</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%d\"</span>, <span class=\"string\">\",0\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%d\"</span>, <span class=\"string\">\",\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-27</p>\n<ul>\n<li>A+B Format (20)</li>\n</ul>\n<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p>\n<p>Output</p>\n<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>\n<p>Sample Input<br>-1000000 9</p>\n<p>Sample Output<br>-999,991</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；</p>\n<p>输入：输入两个在[-1000000,1000000]的a,b两个数</p>\n<p>输出：应该在一行格式化输出</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>a,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">\tc = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, <span class=\"string\">'-'</span>);</span><br><span class=\"line\">\t\tc = -c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (c/<span class=\"number\">1000</span>&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[num] = c % <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t\tc = c / <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttmp[num] = c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = num; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i==num)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%d\"</span>, <span class=\"string\">\",00\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">100</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%d\"</span>, <span class=\"string\">\",0\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%d\"</span>, <span class=\"string\">\",\"</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"PAT甲级1002. A+B for Polynomials","description":"This time, you are supposed to find A+B where A and B are two polynomials. ","_content":"\nmodified: 2017-07-27\n\nThis time, you are supposed to find A+B where A and B are two polynomials.\n\nInput\n\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively. It is given that 1 <= K <= 10，0 <= NK < ... < N2 < N1 <=1000.\n\nOutput\n\nFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.\n\nSample Input\n\n2 1 2.4 0 3.2\n\n2 2 1.5 1 0.5\n\nSample Output\n\n3 2 1.5 1 2.9 0 3.2\n\n### 题目要求：\n\n两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 ... 其中K代表项数，N1...代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；\n\n### 解题思路：\n\n定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；\n\n* 本题目采用C语言进行编写\n\n```c\n\nint main() {\n\n\tint k1, k2, k3, count1 = 0, count2 = 0, count3 = 0;\n\tfloat NA1[20] = { 0 };\n\tfloat NA2[20] = { 0 };\n\tfloat NA3[40] = { 0 };\n\tchar ch;\n\n\tscanf(\"%d\", &k1);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA1[count1++]);\n\t}\n\n\tscanf(\"%d\", &k2);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA2[count2++]);\n\t}\n\n\tcount1 = count2 = 0;\n\n\twhile (count1 < 2 * k1  && count2 < 2 * k2)\n\t{\n\t\tif (NA1[count1] == NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tcount2 += 1;\n\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];\n\t\t}\n\t\telse if (NA1[count1] > NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t}\n\t}\n\twhile (count1 < 2 * k1) {\n\t\tNA3[count3++] = NA1[count1++];\n\t\tNA3[count3++] = NA1[count1++];\n\t}\n\n\twhile (count2 < 2 * k2)\n\t{\n\t\tNA3[count3++] = NA2[count2++];\n\t\tNA3[count3++] = NA2[count2++];\n\t}\n\n\tk3 = (count3 + 1) / 2;\n\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tk3--;\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\", k3);\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\" \");\n\t\t\t\tprintf(\"%d\", (int)NA3[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(\" \");\n\t\t\tprintf(\"%.1f\", NA3[i]);\n\t\t}\n\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 总结：\n\n在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；\n","source":"_posts/PAT/2017-07-27-pat-advanced-1002.md","raw":"---\ntitle: \"PAT甲级1002. A+B for Polynomials\"\ndescription: \"This time, you are supposed to find A+B where A and B are two polynomials. \"\ntags: [pat]\n\n\n\n\n---\n\nmodified: 2017-07-27\n\nThis time, you are supposed to find A+B where A and B are two polynomials.\n\nInput\n\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively. It is given that 1 <= K <= 10，0 <= NK < ... < N2 < N1 <=1000.\n\nOutput\n\nFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.\n\nSample Input\n\n2 1 2.4 0 3.2\n\n2 2 1.5 1 0.5\n\nSample Output\n\n3 2 1.5 1 2.9 0 3.2\n\n### 题目要求：\n\n两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 ... 其中K代表项数，N1...代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；\n\n### 解题思路：\n\n定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；\n\n* 本题目采用C语言进行编写\n\n```c\n\nint main() {\n\n\tint k1, k2, k3, count1 = 0, count2 = 0, count3 = 0;\n\tfloat NA1[20] = { 0 };\n\tfloat NA2[20] = { 0 };\n\tfloat NA3[40] = { 0 };\n\tchar ch;\n\n\tscanf(\"%d\", &k1);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA1[count1++]);\n\t}\n\n\tscanf(\"%d\", &k2);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA2[count2++]);\n\t}\n\n\tcount1 = count2 = 0;\n\n\twhile (count1 < 2 * k1  && count2 < 2 * k2)\n\t{\n\t\tif (NA1[count1] == NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tcount2 += 1;\n\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];\n\t\t}\n\t\telse if (NA1[count1] > NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t}\n\t}\n\twhile (count1 < 2 * k1) {\n\t\tNA3[count3++] = NA1[count1++];\n\t\tNA3[count3++] = NA1[count1++];\n\t}\n\n\twhile (count2 < 2 * k2)\n\t{\n\t\tNA3[count3++] = NA2[count2++];\n\t\tNA3[count3++] = NA2[count2++];\n\t}\n\n\tk3 = (count3 + 1) / 2;\n\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tk3--;\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\", k3);\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\" \");\n\t\t\t\tprintf(\"%d\", (int)NA3[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(\" \");\n\t\t\tprintf(\"%.1f\", NA3[i]);\n\t\t}\n\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 总结：\n\n在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；\n","slug":"PAT/2017-07-27-pat-advanced-1002","published":1,"date":"2020-02-29T02:44:34.886Z","updated":"2020-02-29T02:52:55.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg80018isuiaereglz4","content":"<p>modified: 2017-07-27</p>\n<p>This time, you are supposed to find A+B where A and B are two polynomials.</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>\n<p>Output</p>\n<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>\n<p>Sample Input</p>\n<p>2 1 2.4 0 3.2</p>\n<p>2 2 1.5 1 0.5</p>\n<p>Sample Output</p>\n<p>3 2 1.5 1 2.9 0 3.2</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 … 其中K代表项数，N1…代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；</p>\n<ul>\n<li>本题目采用C语言进行编写</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1, k2, k3, count1 = <span class=\"number\">0</span>, count2 = <span class=\"number\">0</span>, count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA1[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA2[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA3[<span class=\"number\">40</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k1);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%f\"</span>, &amp;NA1[count1++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k2);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%f\"</span>, &amp;NA2[count2++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcount1 = count2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1  &amp;&amp; count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (NA1[count1] == NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tcount2 += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (NA1[count1] &gt; NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1) &#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tk3 = (count3 + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t\tk3--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, k3);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, (<span class=\"keyword\">int</span>)NA3[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%.1f\"</span>, NA3[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；</p>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-27</p>\n<p>This time, you are supposed to find A+B where A and B are two polynomials.</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>\n<p>Output</p>\n<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>\n<p>Sample Input</p>\n<p>2 1 2.4 0 3.2</p>\n<p>2 2 1.5 1 0.5</p>\n<p>Sample Output</p>\n<p>3 2 1.5 1 2.9 0 3.2</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 … 其中K代表项数，N1…代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；</p>\n<ul>\n<li>本题目采用C语言进行编写</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1, k2, k3, count1 = <span class=\"number\">0</span>, count2 = <span class=\"number\">0</span>, count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA1[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA2[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA3[<span class=\"number\">40</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k1);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%f\"</span>, &amp;NA1[count1++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;k2);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%f\"</span>, &amp;NA2[count2++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcount1 = count2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1  &amp;&amp; count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (NA1[count1] == NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tcount2 += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (NA1[count1] &gt; NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1) &#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tk3 = (count3 + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t\tk3--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, k3);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, (<span class=\"keyword\">int</span>)NA3[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%.1f\"</span>, NA3[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；</p>\n"},{"title":"PAT甲级1005. Spell It Right","description":"Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.","_content":"\nmodified: 2017-07-27\nGiven a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\n\nInput Specification:\n\nEach input file contains one test case. Each case occupies one line which contains an N (<= 10100).\n\nOutput Specification:\n\nFor each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\n\nSample Input:\n12345\n\nSample Output:\none five\n\n### 题目要求：\n\n任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；\n\n输入：输入的N<=10100\n\n输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格\n\n### 解题思路：\n\n首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\nint main() {\n\tchar ch;\n\tint count = 0;\n\tint words[4];\n\tint sum = 0;\n\tch = getchar();\n\twhile (ch != '\\n')\n\t{\n\t\tsum += ch - '0';\n\t\tch = getchar();\n\t}\n\twhile (sum / 10 > 0)\n\t{\n\t\twords[count++] = sum % 10;\n\t\tsum = sum / 10;\n\t}\n\twords[count++] = sum % 10;\n\tfor (int i = count - 1; i >= 0; i--)\n\t{\n\t\tswitch (words[i])\n\t\t{\n\t\tcase 0:\n\t\t\tprintf(\"zero\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"one\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"two\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"three\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"four\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"five\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"six\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tprintf(\"seven\");\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf(\"eight\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tprintf(\"nine\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (i!=0)\n\t\t{\n\t\t\tprintf(\" \");\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n```","source":"_posts/PAT/2017-07-27-pat-advanced-1005.md","raw":"---\n\ntitle: \"PAT甲级1005. Spell It Right\"\ndescription: \"Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\"\ntags: [pat]\n\n\n\n---\n\nmodified: 2017-07-27\nGiven a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\n\nInput Specification:\n\nEach input file contains one test case. Each case occupies one line which contains an N (<= 10100).\n\nOutput Specification:\n\nFor each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\n\nSample Input:\n12345\n\nSample Output:\none five\n\n### 题目要求：\n\n任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；\n\n输入：输入的N<=10100\n\n输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格\n\n### 解题思路：\n\n首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\nint main() {\n\tchar ch;\n\tint count = 0;\n\tint words[4];\n\tint sum = 0;\n\tch = getchar();\n\twhile (ch != '\\n')\n\t{\n\t\tsum += ch - '0';\n\t\tch = getchar();\n\t}\n\twhile (sum / 10 > 0)\n\t{\n\t\twords[count++] = sum % 10;\n\t\tsum = sum / 10;\n\t}\n\twords[count++] = sum % 10;\n\tfor (int i = count - 1; i >= 0; i--)\n\t{\n\t\tswitch (words[i])\n\t\t{\n\t\tcase 0:\n\t\t\tprintf(\"zero\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"one\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"two\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"three\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"four\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"five\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"six\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tprintf(\"seven\");\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf(\"eight\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tprintf(\"nine\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (i!=0)\n\t\t{\n\t\t\tprintf(\" \");\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n```","slug":"PAT/2017-07-27-pat-advanced-1005","published":1,"date":"2020-02-29T02:44:34.908Z","updated":"2020-02-29T02:52:41.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg8001aisuiftwv8bey","content":"<p>modified: 2017-07-27<br>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100).</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>\n<p>Sample Input:<br>12345</p>\n<p>Sample Output:<br>one five</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；</p>\n<p>输入：输入的N&lt;=10100</p>\n<p>输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> words[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += ch - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sum / <span class=\"number\">10</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tsum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (words[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"zero\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"five\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"six\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"seven\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"eight\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"nine\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i!=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-27<br>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100).</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>\n<p>Sample Input:<br>12345</p>\n<p>Sample Output:<br>one five</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；</p>\n<p>输入：输入的N&lt;=10100</p>\n<p>输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> words[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += ch - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sum / <span class=\"number\">10</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tsum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (words[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"zero\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"five\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"six\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"seven\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"eight\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"nine\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i!=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1007. Maximum Subsequence Sum","description":"you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence","_content":"\nmodified: 2017-07-27\nGiven a sequence of K integers { N1, N2, ..., NK }. A continuous subsequence is defined to be { Ni, Ni+1, ..., Nj } where 1 <= i <= j <= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\n\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\n\nInput Specification:\n\nEach input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (<= 10000). The second line contains K numbers, separated by a space.\n\nOutput Specification:\n\nFor each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\n\nSample Input:\n\n10\n\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:\n\n10 1 4\n\n### 题目要求：\n\n给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；\n\n### 解题思路：\n\nsum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp<0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp<0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；\n\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <stdbool.h>\n\nint main() {\n\n\tint count, sum = -1, sumTmp = 0, left = 0, leftTmp = 0, right = 0, input, first, last;\n\t\n\tint num[10000];\n\n\tbool positive = false, half_positive = false;\n\n\n\tscanf(\"%d\", &count);\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\n\t\tscanf(\"%d\", &input);\n\t\tnum[i] = input;\n\t\tif (input >= 0)\n\t\t{\n\t\t\tpositive = true;\n\t\t}\n\n\t\tsumTmp = sumTmp + input;\n\t\tif (sum < sumTmp)\n\t\t{\n\t\t\tleft = leftTmp;\n\t\t\tright = i;\n\t\t\tsum = sumTmp;\n\t\t}\n\t\telse if (sumTmp < 0)\n\t\t{\n\t\t\tleftTmp=i+1;\n\t\t\tsumTmp = 0;\n\t\t}\n\n\t}\n\n\tif (positive)\n\t{\n\t\tprintf(\"%d %d %d\", sum, num[left], num[right]);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d %d %d\", 0, num[0], num[count-1]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 总结：\n\n又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；\n\n本题中容易被忽略的数列类型有如下：\n\n* 连续0\n\n  5\n \n  0 0 -1 -1 0\n\n* 前面都为负、最后一位为0\n\n  5\n\n  -1 -1 -1 -1 0\n\n   \n\n","source":"_posts/PAT/2017-07-27-pat-advanced-1007.md","raw":"---\n\ntitle: \"PAT甲级1007. Maximum Subsequence Sum\"\ndescription: \"you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence\"\ntags: [pat]\n\n\n\n---\n\nmodified: 2017-07-27\nGiven a sequence of K integers { N1, N2, ..., NK }. A continuous subsequence is defined to be { Ni, Ni+1, ..., Nj } where 1 <= i <= j <= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\n\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\n\nInput Specification:\n\nEach input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (<= 10000). The second line contains K numbers, separated by a space.\n\nOutput Specification:\n\nFor each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\n\nSample Input:\n\n10\n\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:\n\n10 1 4\n\n### 题目要求：\n\n给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；\n\n### 解题思路：\n\nsum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp<0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp<0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；\n\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <stdbool.h>\n\nint main() {\n\n\tint count, sum = -1, sumTmp = 0, left = 0, leftTmp = 0, right = 0, input, first, last;\n\t\n\tint num[10000];\n\n\tbool positive = false, half_positive = false;\n\n\n\tscanf(\"%d\", &count);\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\n\t\tscanf(\"%d\", &input);\n\t\tnum[i] = input;\n\t\tif (input >= 0)\n\t\t{\n\t\t\tpositive = true;\n\t\t}\n\n\t\tsumTmp = sumTmp + input;\n\t\tif (sum < sumTmp)\n\t\t{\n\t\t\tleft = leftTmp;\n\t\t\tright = i;\n\t\t\tsum = sumTmp;\n\t\t}\n\t\telse if (sumTmp < 0)\n\t\t{\n\t\t\tleftTmp=i+1;\n\t\t\tsumTmp = 0;\n\t\t}\n\n\t}\n\n\tif (positive)\n\t{\n\t\tprintf(\"%d %d %d\", sum, num[left], num[right]);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d %d %d\", 0, num[0], num[count-1]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 总结：\n\n又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；\n\n本题中容易被忽略的数列类型有如下：\n\n* 连续0\n\n  5\n \n  0 0 -1 -1 0\n\n* 前面都为负、最后一位为0\n\n  5\n\n  -1 -1 -1 -1 0\n\n   \n\n","slug":"PAT/2017-07-27-pat-advanced-1007","published":1,"date":"2020-02-29T02:44:34.914Z","updated":"2020-02-29T02:52:32.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryg9001bisui1p9abdjn","content":"<p>modified: 2017-07-27<br>Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>\n<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>\n<p>Sample Input:</p>\n<p>10</p>\n<p>-10 1 2 3 4 -5 -23 3 7 -21</p>\n<p>Sample Output:</p>\n<p>10 1 4</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>sum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp&lt;0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp&lt;0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count, sum = <span class=\"number\">-1</span>, sumTmp = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>, leftTmp = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>, input, first, last;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> positive = <span class=\"literal\">false</span>, half_positive = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;input);</span><br><span class=\"line\">\t\tnum[i] = input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (input &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpositive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsumTmp = sumTmp + input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sum &lt; sumTmp)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleft = leftTmp;</span><br><span class=\"line\">\t\t\tright = i;</span><br><span class=\"line\">\t\t\tsum = sumTmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sumTmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleftTmp=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tsumTmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (positive)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\"</span>, sum, num[left], num[right]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\"</span>, <span class=\"number\">0</span>, num[<span class=\"number\">0</span>], num[count<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；</p>\n<p>本题中容易被忽略的数列类型有如下：</p>\n<ul>\n<li><p>连续0</p>\n<p>5</p>\n<p>0 0 -1 -1 0</p>\n</li>\n<li><p>前面都为负、最后一位为0</p>\n<p>5</p>\n<p>-1 -1 -1 -1 0</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-27<br>Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>\n<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>\n<p>Sample Input:</p>\n<p>10</p>\n<p>-10 1 2 3 4 -5 -23 3 7 -21</p>\n<p>Sample Output:</p>\n<p>10 1 4</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>sum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp&lt;0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp&lt;0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count, sum = <span class=\"number\">-1</span>, sumTmp = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>, leftTmp = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>, input, first, last;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> positive = <span class=\"literal\">false</span>, half_positive = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;input);</span><br><span class=\"line\">\t\tnum[i] = input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (input &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpositive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsumTmp = sumTmp + input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sum &lt; sumTmp)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleft = leftTmp;</span><br><span class=\"line\">\t\t\tright = i;</span><br><span class=\"line\">\t\t\tsum = sumTmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sumTmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleftTmp=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tsumTmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (positive)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\"</span>, sum, num[left], num[right]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d %d\"</span>, <span class=\"number\">0</span>, num[<span class=\"number\">0</span>], num[count<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；</p>\n<p>本题中容易被忽略的数列类型有如下：</p>\n<ul>\n<li><p>连续0</p>\n<p>5</p>\n<p>0 0 -1 -1 0</p>\n</li>\n<li><p>前面都为负、最后一位为0</p>\n<p>5</p>\n<p>-1 -1 -1 -1 0</p>\n</li>\n</ul>\n"},{"title":"PAT甲级1008. Elevator","description":"The highest building in our city has only one elevator. A request list is made up with N positive numbers. ","_content":"\nmodified: 2017-07-27\nThe highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\n\nFor a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\n\nInput Specification:\n\nEach input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\n\nOutput Specification:\n\nFor each test case, print the total time on a single line.\n\nSample Input:\n3 2 3 1\n\nSample Output:\n41\n\n### 题目要求：\n\n一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；\n\n给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；\n\n每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；\n\n### 解题思路：\n\n首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n\n\nint main() {\n\n\tchar ch;\n\tint floor[101];\n\t//用于对输入的楼层数进行计数\n\tint count = 0;\n\tint time =0 ;\n\tscanf(\"%d\", &floor[count++]);\n\twhile (ch=getchar()!='\\n')\n\t{\n\t\tscanf(\"%d\", &floor[count++]);\n\t}\n\ttime += 6 * floor[1]+5;\n\n\tfor (int i = 2; i < count; i++)\n\t{\n\t\tif (floor[i]>floor[i-1])\n\t\t{\n\t\t\ttime += 6 * (floor[i] - floor[i - 1])+5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttime += 4 * (floor[i-1] - floor[i])+5;\n\t\t}\n\t}\n\n\tprintf(\"%d\",time);\n\treturn 0;\n}\n\n```","source":"_posts/PAT/2017-07-27-pat-advanced-1008.md","raw":"---\ntitle: \"PAT甲级1008. Elevator\"\ndescription: \"The highest building in our city has only one elevator. A request list is made up with N positive numbers. \"\ntags: [pat]\n\n\n\n---\n\nmodified: 2017-07-27\nThe highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\n\nFor a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\n\nInput Specification:\n\nEach input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\n\nOutput Specification:\n\nFor each test case, print the total time on a single line.\n\nSample Input:\n3 2 3 1\n\nSample Output:\n41\n\n### 题目要求：\n\n一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；\n\n给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；\n\n每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；\n\n### 解题思路：\n\n首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n\n\nint main() {\n\n\tchar ch;\n\tint floor[101];\n\t//用于对输入的楼层数进行计数\n\tint count = 0;\n\tint time =0 ;\n\tscanf(\"%d\", &floor[count++]);\n\twhile (ch=getchar()!='\\n')\n\t{\n\t\tscanf(\"%d\", &floor[count++]);\n\t}\n\ttime += 6 * floor[1]+5;\n\n\tfor (int i = 2; i < count; i++)\n\t{\n\t\tif (floor[i]>floor[i-1])\n\t\t{\n\t\t\ttime += 6 * (floor[i] - floor[i - 1])+5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttime += 4 * (floor[i-1] - floor[i])+5;\n\t\t}\n\t}\n\n\tprintf(\"%d\",time);\n\treturn 0;\n}\n\n```","slug":"PAT/2017-07-27-pat-advanced-1008","published":1,"date":"2020-02-29T02:44:34.934Z","updated":"2020-02-29T02:52:21.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryga001cisui9x8hdm1k","content":"<p>modified: 2017-07-27<br>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>\n<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print the total time on a single line.</p>\n<p>Sample Input:<br>3 2 3 1</p>\n<p>Sample Output:<br>41</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；</p>\n<p>给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；</p>\n<p>每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">floor</span>[<span class=\"number\">101</span>];</span><br><span class=\"line\">\t<span class=\"comment\">//用于对输入的楼层数进行计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> time =<span class=\"number\">0</span> ;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch=getchar()!=<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime += <span class=\"number\">6</span> * <span class=\"built_in\">floor</span>[<span class=\"number\">1</span>]+<span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">floor</span>[i]&gt;<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">6</span> * (<span class=\"built_in\">floor</span>[i] - <span class=\"built_in\">floor</span>[i - <span class=\"number\">1</span>])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">4</span> * (<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>] - <span class=\"built_in\">floor</span>[i])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,time);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-27<br>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>\n<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print the total time on a single line.</p>\n<p>Sample Input:<br>3 2 3 1</p>\n<p>Sample Output:<br>41</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；</p>\n<p>给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；</p>\n<p>每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">floor</span>[<span class=\"number\">101</span>];</span><br><span class=\"line\">\t<span class=\"comment\">//用于对输入的楼层数进行计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> time =<span class=\"number\">0</span> ;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch=getchar()!=<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime += <span class=\"number\">6</span> * <span class=\"built_in\">floor</span>[<span class=\"number\">1</span>]+<span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">floor</span>[i]&gt;<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">6</span> * (<span class=\"built_in\">floor</span>[i] - <span class=\"built_in\">floor</span>[i - <span class=\"number\">1</span>])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">4</span> * (<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>] - <span class=\"built_in\">floor</span>[i])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,time);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1006. Sign In and Sign Out","description":"At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.","_content":"\nmodified: 2017-07-31\nAt the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\n\nInput Specification:\n\nEach input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n\nID_number Sign_in_time Sign_out_time\n\nwhere times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.\n\nOutput Specification:\n\nFor each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.\n\nNote: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\n\nSample Input:\n\n3\n\nCS301111 15:30:28 17:00:10\n\nSC3021234 08:00:00 11:25:25\n\nCS301133 21:45:00 21:58:40\n\nSample Output:\n\nSC3021234 CS301133\n\n### 题目要求：\n\n每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；\n\n输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；\n\n输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；\n\n题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；\n\n### 解题思路\n\n方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"stdbool.h\"\ntypedef struct user {\n\tchar name[20];\n\tchar inTime[20];\n\tchar outTime[20];\n}user;\nint main() {\n\n\tuser user[100];\n\tint num;\n\tint unLockedIndex;\n\tint lockedIndex;\n\tchar inTimeTmp[20];\n\tstrcpy(inTimeTmp,\"23:59:59\");\n\tchar outTimeTmp[20];\n\tstrcpy(outTimeTmp, \"00:00:00\");\n\tunLockedIndex = 0;\n\tlockedIndex = 0;\n\tscanf(\"%d\",&num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",&user[i].name);\n\t\tscanf(\"%s\", &user[i].inTime);\n\t\t//大于零表示第二个字符串小于第一个\n\t\tif (strcmp(inTimeTmp, user[i].inTime)>0)\n\t\t{\n\t\t\tstrcpy(inTimeTmp, user[i].inTime);\n\t\t\tunLockedIndex = i;\n\t\t}\n\n\t\tscanf(\"%s\", &user[i].outTime);\n\t\t//表示第二个字符串大于第一个\n\t\tif (strcmp(outTimeTmp, user[i].outTime)<0)\n\t\t\t{\n\t\t\t\tstrcpy(outTimeTmp, user[i].outTime);\n\t\t\t\tlockedIndex = i;\n\t\t\t}\n\t\t\n\t}\n\tprintf(\"%s %s\",user[unLockedIndex].name,user[lockedIndex].name);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 方法二：将输入的时间转换为秒，然后再比较大小\n","source":"_posts/PAT/2017-07-31-pat-advanced-1006.md","raw":"---\ntitle: \"PAT甲级1006. Sign In and Sign Out\"\ndescription: \"At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\"\ntags: [pat]\n\n\n---\n\nmodified: 2017-07-31\nAt the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\n\nInput Specification:\n\nEach input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n\nID_number Sign_in_time Sign_out_time\n\nwhere times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.\n\nOutput Specification:\n\nFor each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.\n\nNote: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\n\nSample Input:\n\n3\n\nCS301111 15:30:28 17:00:10\n\nSC3021234 08:00:00 11:25:25\n\nCS301133 21:45:00 21:58:40\n\nSample Output:\n\nSC3021234 CS301133\n\n### 题目要求：\n\n每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；\n\n输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；\n\n输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；\n\n题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；\n\n### 解题思路\n\n方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"stdbool.h\"\ntypedef struct user {\n\tchar name[20];\n\tchar inTime[20];\n\tchar outTime[20];\n}user;\nint main() {\n\n\tuser user[100];\n\tint num;\n\tint unLockedIndex;\n\tint lockedIndex;\n\tchar inTimeTmp[20];\n\tstrcpy(inTimeTmp,\"23:59:59\");\n\tchar outTimeTmp[20];\n\tstrcpy(outTimeTmp, \"00:00:00\");\n\tunLockedIndex = 0;\n\tlockedIndex = 0;\n\tscanf(\"%d\",&num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",&user[i].name);\n\t\tscanf(\"%s\", &user[i].inTime);\n\t\t//大于零表示第二个字符串小于第一个\n\t\tif (strcmp(inTimeTmp, user[i].inTime)>0)\n\t\t{\n\t\t\tstrcpy(inTimeTmp, user[i].inTime);\n\t\t\tunLockedIndex = i;\n\t\t}\n\n\t\tscanf(\"%s\", &user[i].outTime);\n\t\t//表示第二个字符串大于第一个\n\t\tif (strcmp(outTimeTmp, user[i].outTime)<0)\n\t\t\t{\n\t\t\t\tstrcpy(outTimeTmp, user[i].outTime);\n\t\t\t\tlockedIndex = i;\n\t\t\t}\n\t\t\n\t}\n\tprintf(\"%s %s\",user[unLockedIndex].name,user[lockedIndex].name);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 方法二：将输入的时间转换为秒，然后再比较大小\n","slug":"PAT/2017-07-31-pat-advanced-1006","published":1,"date":"2020-02-29T02:44:34.944Z","updated":"2020-02-29T02:52:07.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygd001fisuieo0i0p5i","content":"<p>modified: 2017-07-31<br>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p>\n<p>ID_number Sign_in_time Sign_out_time</p>\n<p>where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>\n<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>\n<p>Sample Input:</p>\n<p>3</p>\n<p>CS301111 15:30:28 17:00:10</p>\n<p>SC3021234 08:00:00 11:25:25</p>\n<p>CS301133 21:45:00 21:58:40</p>\n<p>Sample Output:</p>\n<p>SC3021234 CS301133</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；</p>\n<p>输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；</p>\n<p>输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；</p>\n<p>题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"string.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdbool.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;user;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuser user[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> unLockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(inTimeTmp,<span class=\"string\">\"23:59:59\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(outTimeTmp, <span class=\"string\">\"00:00:00\"</span>);</span><br><span class=\"line\">\tunLockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tlockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,&amp;user[i].name);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, &amp;user[i].inTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//大于零表示第二个字符串小于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(inTimeTmp, user[i].inTime)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(inTimeTmp, user[i].inTime);</span><br><span class=\"line\">\t\t\tunLockedIndex = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, &amp;user[i].outTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//表示第二个字符串大于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(outTimeTmp, user[i].outTime)&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">strcpy</span>(outTimeTmp, user[i].outTime);</span><br><span class=\"line\">\t\t\t\tlockedIndex = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\"</span>,user[unLockedIndex].name,user[lockedIndex].name);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法二：将输入的时间转换为秒，然后再比较大小\"><a href=\"#方法二：将输入的时间转换为秒，然后再比较大小\" class=\"headerlink\" title=\"方法二：将输入的时间转换为秒，然后再比较大小\"></a>方法二：将输入的时间转换为秒，然后再比较大小</h3>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-31<br>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p>\n<p>ID_number Sign_in_time Sign_out_time</p>\n<p>where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>\n<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>\n<p>Sample Input:</p>\n<p>3</p>\n<p>CS301111 15:30:28 17:00:10</p>\n<p>SC3021234 08:00:00 11:25:25</p>\n<p>CS301133 21:45:00 21:58:40</p>\n<p>Sample Output:</p>\n<p>SC3021234 CS301133</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；</p>\n<p>输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；</p>\n<p>输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；</p>\n<p>题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"string.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdbool.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;user;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuser user[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> unLockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(inTimeTmp,<span class=\"string\">\"23:59:59\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(outTimeTmp, <span class=\"string\">\"00:00:00\"</span>);</span><br><span class=\"line\">\tunLockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tlockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,&amp;user[i].name);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, &amp;user[i].inTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//大于零表示第二个字符串小于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(inTimeTmp, user[i].inTime)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(inTimeTmp, user[i].inTime);</span><br><span class=\"line\">\t\t\tunLockedIndex = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, &amp;user[i].outTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//表示第二个字符串大于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(outTimeTmp, user[i].outTime)&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">strcpy</span>(outTimeTmp, user[i].outTime);</span><br><span class=\"line\">\t\t\t\tlockedIndex = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %s\"</span>,user[unLockedIndex].name,user[lockedIndex].name);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法二：将输入的时间转换为秒，然后再比较大小\"><a href=\"#方法二：将输入的时间转换为秒，然后再比较大小\" class=\"headerlink\" title=\"方法二：将输入的时间转换为秒，然后再比较大小\"></a>方法二：将输入的时间转换为秒，然后再比较大小</h3>"},{"title":"PAT甲级1011. World Cup Betting ","description":"The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result.","_content":"\nmodified: 2017-08-01\nWith the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.\n\nChinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%.\n\nFor example, 3 games' odds are given as the following:\n\n W    T    L\n\n1.1  2.5  1.7\n\n1.2  3.0  1.6\n\n4.1  1.2  1.1\n\nTo obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1*3.0*2.5*65%-1)*2 = 37.98 yuans (accurate up to 2 decimal places).\n\nInput\n\nEach input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.\n\nOutput\n\nFor each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.\n\nSample Input\n\n1.1 2.5 1.7\n\n1.2 3.0 1.6\n\n4.1 1.2 1.1\n\nSample Output\n\nT T W 37.98\n\n### 题目要求\n\n题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；\n\n### 解题思路\n\n设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n\nint main()\n{\n\tchar line[3] = {'W','T','L'};\n\tchar outChar[3];\n\n\tint index;\n\tfloat in,tmp;\n\tfloat result=1;\n\n\n\tfor (int  i = 0; i < 3; i++)\n\t{\n\t\tindex = 0;\n\t\ttmp = 0;\n\t\tfor (int j = 0; j <3; j++)\n\t\t{\n\t\t\tscanf(\"%f\",&in);\n\t\t\tif (tmp<in)\n\t\t\t{\n\t\t\t\ttmp = in;\n\t\t\t\tindex = j;\n\t\t\t}\n\n\t\t}\n\t\tresult *= tmp;\n\t\toutChar[i]=line[index];\n\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%c \",outChar[i]);\n\t}\n\t\n\tprintf(\"%.2f\", (result*0.65 - 1) * 2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```","source":"_posts/PAT/2017-08-01-pat-advanced-1011.md","raw":"---\n\ntitle: \"PAT甲级1011. World Cup Betting \"\ndescription: \"The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result.\"\ntags: [pat]\n\n\n---\n\nmodified: 2017-08-01\nWith the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.\n\nChinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%.\n\nFor example, 3 games' odds are given as the following:\n\n W    T    L\n\n1.1  2.5  1.7\n\n1.2  3.0  1.6\n\n4.1  1.2  1.1\n\nTo obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1*3.0*2.5*65%-1)*2 = 37.98 yuans (accurate up to 2 decimal places).\n\nInput\n\nEach input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.\n\nOutput\n\nFor each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.\n\nSample Input\n\n1.1 2.5 1.7\n\n1.2 3.0 1.6\n\n4.1 1.2 1.1\n\nSample Output\n\nT T W 37.98\n\n### 题目要求\n\n题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；\n\n### 解题思路\n\n设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n\nint main()\n{\n\tchar line[3] = {'W','T','L'};\n\tchar outChar[3];\n\n\tint index;\n\tfloat in,tmp;\n\tfloat result=1;\n\n\n\tfor (int  i = 0; i < 3; i++)\n\t{\n\t\tindex = 0;\n\t\ttmp = 0;\n\t\tfor (int j = 0; j <3; j++)\n\t\t{\n\t\t\tscanf(\"%f\",&in);\n\t\t\tif (tmp<in)\n\t\t\t{\n\t\t\t\ttmp = in;\n\t\t\t\tindex = j;\n\t\t\t}\n\n\t\t}\n\t\tresult *= tmp;\n\t\toutChar[i]=line[index];\n\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%c \",outChar[i]);\n\t}\n\t\n\tprintf(\"%.2f\", (result*0.65 - 1) * 2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```","slug":"PAT/2017-08-01-pat-advanced-1011","published":1,"date":"2020-02-29T02:44:34.950Z","updated":"2020-02-29T02:51:53.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygd001hisui8s1w5cjf","content":"<p>modified: 2017-08-01<br>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>\n<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>\n<p>For example, 3 games’ odds are given as the following:</p>\n<p> W    T    L</p>\n<p>1.1  2.5  1.7</p>\n<p>1.2  3.0  1.6</p>\n<p>4.1  1.2  1.1</p>\n<p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1<em>3.0</em>2.5<em>65%-1)</em>2 = 37.98 yuans (accurate up to 2 decimal places).</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p>\n<p>Output</p>\n<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>\n<p>Sample Input</p>\n<p>1.1 2.5 1.7</p>\n<p>1.2 3.0 1.6</p>\n<p>4.1 1.2 1.1</p>\n<p>Sample Output</p>\n<p>T T W 37.98</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> <span class=\"built_in\">line</span>[<span class=\"number\">3</span>] = &#123;<span class=\"string\">'W'</span>,<span class=\"string\">'T'</span>,<span class=\"string\">'L'</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outChar[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> in,tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> result=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;<span class=\"number\">3</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%f\"</span>,&amp;in);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&lt;in)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttmp = in;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tresult *= tmp;</span><br><span class=\"line\">\t\toutChar[i]=<span class=\"built_in\">line</span>[index];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>,outChar[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2f\"</span>, (result*<span class=\"number\">0.65</span> - <span class=\"number\">1</span>) * <span class=\"number\">2</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-01<br>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>\n<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>\n<p>For example, 3 games’ odds are given as the following:</p>\n<p> W    T    L</p>\n<p>1.1  2.5  1.7</p>\n<p>1.2  3.0  1.6</p>\n<p>4.1  1.2  1.1</p>\n<p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1<em>3.0</em>2.5<em>65%-1)</em>2 = 37.98 yuans (accurate up to 2 decimal places).</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p>\n<p>Output</p>\n<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>\n<p>Sample Input</p>\n<p>1.1 2.5 1.7</p>\n<p>1.2 3.0 1.6</p>\n<p>4.1 1.2 1.1</p>\n<p>Sample Output</p>\n<p>T T W 37.98</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdlib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> <span class=\"built_in\">line</span>[<span class=\"number\">3</span>] = &#123;<span class=\"string\">'W'</span>,<span class=\"string\">'T'</span>,<span class=\"string\">'L'</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outChar[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> in,tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> result=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;<span class=\"number\">3</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%f\"</span>,&amp;in);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&lt;in)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttmp = in;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tresult *= tmp;</span><br><span class=\"line\">\t\toutChar[i]=<span class=\"built_in\">line</span>[index];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c \"</span>,outChar[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%.2f\"</span>, (result*<span class=\"number\">0.65</span> - <span class=\"number\">1</span>) * <span class=\"number\">2</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1060. Are They Equal","description":"Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.","_content":"\nmodified: 2017-08-01\nIf a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\n\nInput Specification:\n\nEach input file contains one test case which gives three numbers N, A and B, where N (<100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.\n\nOutput Specification:\n\nFor each test case, print in a line \"YES\" if the two numbers are treated equal, and then the number in the standard form \"0.d1...dN*10^k\" (d1>0 unless the number is 0); or \"NO\" if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\n\nNote: Simple chopping is assumed without rounding.\n\nSample Input 1:\n\n3 12300 12358.9\n\nSample Output 1:\n\nYES 0.123*10^5\n\n\nSample Input 2:\n\n3 120 128\n\nSample Output 2:\n\nNO 0.120*10^3 0.128*10^3\n\n### 题目要求\n\n将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；\n\n### 解题思路\n\n题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;\n\nvoid getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；\n\nvoid formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index>=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index<=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；\n\n对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；\n\n数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；\n\n需要注意的要点：结尾需要使用0进行补足\n\n\n### C语言代码\n\n```c\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中\nvoid getRidZero(char  num[10000], int *index, int *decimalPoint, char  pNum[10000])\n{\n\t//做一个循环除去开头的零和小数点\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] != '0'&&num[i] != '.'&&num[i] != '\\0')\n\t\t{\n\t\t\t*index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n    //用于获取小数点的位置\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] == '.')\n\t\t{\n\t\t\t*decimalPoint = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint j = 0;\n\n\tfor (int i = *index; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] < 0)\n\t\t{\n\t\t\tpNum[j] = '0';\n\t\t\tj++;\n\t\t}\n\t\telse if (num[i] == '.')\n\t\t{\n\n\t\t\tcontinue;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tpNum[j] = num[i];\n\t\t\tj++;\n\t\t}\n\n\t}\n\n}\n\n//用于将pNum[]中保存的数按照科学计数法输出\nvoid formatPrint(int accuracy, char  pNum[10000], int decimalPoint, int index)\n{\n\tprintf(\"0.\");\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tprintf(\"%C\", pNum[i]);\n\t}\n\tif (decimalPoint - index >= 0)\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index);\n\t}\n\telse\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index + 1);\n\t}\n}\n\nint main() {\n\n\tint  accuracy;\n\tchar num1[10000];\n\tchar num2[10000];\n\n\tchar pNum1[10000];\n\tchar pNum2[10000];\n\n\t//用于记录小数点的位置\n\tint decimalPoint1 = 0;\n\tint decimalPoint2 = 0;\n\n\t//用于记录数字开始的位置\n\tint index1 = 0;\n\tint index2 = 0;\n\n\tbool equal = true;\n\n\tscanf(\"%d %s %s\", &accuracy, num1, num2);\n\tgetRidZero(num1, &index1, &decimalPoint1, pNum1);\n\tgetRidZero(num2, &index2, &decimalPoint2, pNum2);\n\n\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tif (pNum1[i] != pNum2[i])\n\t\t{\n\t\t\tequal = false;\n\t\t}\n\t}\n\n\tif ((index1 - decimalPoint1) != (index2 - decimalPoint2))\n\t{\n\t\tequal = false;\n\t}\n\n\tbool notZero = false;\n\t//判断00000000 和000000.000000000\n\tfor (int i = 0; i < 5000; i++)\n\t{\n\t\tif (pNum1[i] != '0' || pNum2[i] != '0')\n\t\t{\n\t\t\t//证明不是0\n\t\t\tnotZero = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tif (!notZero)  //证明都是0   然后输出 0.0000*10^0 ，是第六个测试点\n\t{\n\t\tprintf(\"YES 0.\");\n\t\tfor (int i = 0; i < accuracy; i++)\n\t\t{\n\t\t\tprintf(\"%C\", '0');\n\t\t}\n\t\tprintf(\"*10^%d\", 0);\n\n\t}\n\telse if (equal)    //如果两个数相等\n\t{\n\t\tprintf(\"YES \");\n\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t}\n\telse          //如果两个数不想等\n\t{\n\t\tprintf(\"NO \");\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t\t//输出第二个数\n\t\tprintf(\" \");\n\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n\n### 测试用例\n\n* 5　0000.0000123　0.0000123\n* 4　000123　　　　　00123.005\n* 4　00000　　　　　000.000001\n* 4　00.000　　　　　00000\n* 4　0.01　　　　　　0.01000005\n\n","source":"_posts/PAT/2017-08-01-pat-advanced-1060.md","raw":"---\ntitle: \"PAT甲级1060. Are They Equal\"\ndescription: \"Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\"\ntags: [pat]\n\n\n---\n\nmodified: 2017-08-01\nIf a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\n\nInput Specification:\n\nEach input file contains one test case which gives three numbers N, A and B, where N (<100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.\n\nOutput Specification:\n\nFor each test case, print in a line \"YES\" if the two numbers are treated equal, and then the number in the standard form \"0.d1...dN*10^k\" (d1>0 unless the number is 0); or \"NO\" if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\n\nNote: Simple chopping is assumed without rounding.\n\nSample Input 1:\n\n3 12300 12358.9\n\nSample Output 1:\n\nYES 0.123*10^5\n\n\nSample Input 2:\n\n3 120 128\n\nSample Output 2:\n\nNO 0.120*10^3 0.128*10^3\n\n### 题目要求\n\n将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；\n\n### 解题思路\n\n题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;\n\nvoid getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；\n\nvoid formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index>=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index<=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；\n\n对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；\n\n数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；\n\n需要注意的要点：结尾需要使用0进行补足\n\n\n### C语言代码\n\n```c\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中\nvoid getRidZero(char  num[10000], int *index, int *decimalPoint, char  pNum[10000])\n{\n\t//做一个循环除去开头的零和小数点\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] != '0'&&num[i] != '.'&&num[i] != '\\0')\n\t\t{\n\t\t\t*index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n    //用于获取小数点的位置\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] == '.')\n\t\t{\n\t\t\t*decimalPoint = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint j = 0;\n\n\tfor (int i = *index; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] < 0)\n\t\t{\n\t\t\tpNum[j] = '0';\n\t\t\tj++;\n\t\t}\n\t\telse if (num[i] == '.')\n\t\t{\n\n\t\t\tcontinue;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tpNum[j] = num[i];\n\t\t\tj++;\n\t\t}\n\n\t}\n\n}\n\n//用于将pNum[]中保存的数按照科学计数法输出\nvoid formatPrint(int accuracy, char  pNum[10000], int decimalPoint, int index)\n{\n\tprintf(\"0.\");\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tprintf(\"%C\", pNum[i]);\n\t}\n\tif (decimalPoint - index >= 0)\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index);\n\t}\n\telse\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index + 1);\n\t}\n}\n\nint main() {\n\n\tint  accuracy;\n\tchar num1[10000];\n\tchar num2[10000];\n\n\tchar pNum1[10000];\n\tchar pNum2[10000];\n\n\t//用于记录小数点的位置\n\tint decimalPoint1 = 0;\n\tint decimalPoint2 = 0;\n\n\t//用于记录数字开始的位置\n\tint index1 = 0;\n\tint index2 = 0;\n\n\tbool equal = true;\n\n\tscanf(\"%d %s %s\", &accuracy, num1, num2);\n\tgetRidZero(num1, &index1, &decimalPoint1, pNum1);\n\tgetRidZero(num2, &index2, &decimalPoint2, pNum2);\n\n\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tif (pNum1[i] != pNum2[i])\n\t\t{\n\t\t\tequal = false;\n\t\t}\n\t}\n\n\tif ((index1 - decimalPoint1) != (index2 - decimalPoint2))\n\t{\n\t\tequal = false;\n\t}\n\n\tbool notZero = false;\n\t//判断00000000 和000000.000000000\n\tfor (int i = 0; i < 5000; i++)\n\t{\n\t\tif (pNum1[i] != '0' || pNum2[i] != '0')\n\t\t{\n\t\t\t//证明不是0\n\t\t\tnotZero = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tif (!notZero)  //证明都是0   然后输出 0.0000*10^0 ，是第六个测试点\n\t{\n\t\tprintf(\"YES 0.\");\n\t\tfor (int i = 0; i < accuracy; i++)\n\t\t{\n\t\t\tprintf(\"%C\", '0');\n\t\t}\n\t\tprintf(\"*10^%d\", 0);\n\n\t}\n\telse if (equal)    //如果两个数相等\n\t{\n\t\tprintf(\"YES \");\n\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t}\n\telse          //如果两个数不想等\n\t{\n\t\tprintf(\"NO \");\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t\t//输出第二个数\n\t\tprintf(\" \");\n\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n\n### 测试用例\n\n* 5　0000.0000123　0.0000123\n* 4　000123　　　　　00123.005\n* 4　00000　　　　　000.000001\n* 4　00.000　　　　　00000\n* 4　0.01　　　　　　0.01000005\n\n","slug":"PAT/2017-08-01-pat-advanced-1060","published":1,"date":"2020-02-29T02:44:34.997Z","updated":"2020-02-29T02:51:29.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryge001kisui4nf7dp3s","content":"<p>modified: 2017-08-01<br>If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.</p>\n<p>Note: Simple chopping is assumed without rounding.</p>\n<p>Sample Input 1:</p>\n<p>3 12300 12358.9</p>\n<p>Sample Output 1:</p>\n<p>YES 0.123*10^5</p>\n<p>Sample Input 2:</p>\n<p>3 120 128</p>\n<p>Sample Output 2:</p>\n<p>NO 0.120<em>10^3 0.128</em>10^3</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;</p>\n<p>void getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；</p>\n<p>void formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index&gt;=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index&lt;=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；</p>\n<p>对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；</p>\n<p>数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；</p>\n<p>需要注意的要点：结尾需要使用0进行补足</p>\n<h3 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getRidZero</span><span class=\"params\">(<span class=\"keyword\">char</span>  num[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> *index, <span class=\"keyword\">int</span> *decimalPoint, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//做一个循环除去开头的零和小数点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] != <span class=\"string\">'0'</span>&amp;&amp;num[i] != <span class=\"string\">'.'</span>&amp;&amp;num[i] != <span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*index = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于获取小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">'\\0'</span> || num[i] == <span class=\"string\">'.'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*decimalPoint = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = *index; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">'\\0'</span> || num[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num[i] == <span class=\"string\">'.'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = num[i];</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将pNum[]中保存的数按照科学计数法输出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">formatPrint</span><span class=\"params\">(<span class=\"keyword\">int</span> accuracy, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> decimalPoint, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"0.\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%C\"</span>, pNum[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (decimalPoint - index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*10^%d\"</span>, decimalPoint - index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*10^%d\"</span>, decimalPoint - index + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>  accuracy;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录数字开始的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> equal = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %s %s\"</span>, &amp;accuracy, num1, num2);</span><br><span class=\"line\">\tgetRidZero(num1, &amp;index1, &amp;decimalPoint1, pNum1);</span><br><span class=\"line\">\tgetRidZero(num2, &amp;index2, &amp;decimalPoint2, pNum2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != pNum2[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((index1 - decimalPoint1) != (index2 - decimalPoint2))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> notZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断00000000 和000000.000000000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != <span class=\"string\">'0'</span> || pNum2[i] != <span class=\"string\">'0'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//证明不是0</span></span><br><span class=\"line\">\t\t\tnotZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!notZero)  <span class=\"comment\">//证明都是0   然后输出 0.0000*10^0 ，是第六个测试点</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"YES 0.\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%C\"</span>, <span class=\"string\">'0'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*10^%d\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (equal)    <span class=\"comment\">//如果两个数相等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"YES \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>          <span class=\"comment\">//如果两个数不想等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"NO \"</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//输出第二个数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><ul>\n<li>5　0000.0000123　0.0000123</li>\n<li>4　000123　　　　　00123.005</li>\n<li>4　00000　　　　　000.000001</li>\n<li>4　00.000　　　　　00000</li>\n<li>4　0.01　　　　　　0.01000005</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-01<br>If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.</p>\n<p>Note: Simple chopping is assumed without rounding.</p>\n<p>Sample Input 1:</p>\n<p>3 12300 12358.9</p>\n<p>Sample Output 1:</p>\n<p>YES 0.123*10^5</p>\n<p>Sample Input 2:</p>\n<p>3 120 128</p>\n<p>Sample Output 2:</p>\n<p>NO 0.120<em>10^3 0.128</em>10^3</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;</p>\n<p>void getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；</p>\n<p>void formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index&gt;=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index&lt;=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；</p>\n<p>对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；</p>\n<p>数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；</p>\n<p>需要注意的要点：结尾需要使用0进行补足</p>\n<h3 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getRidZero</span><span class=\"params\">(<span class=\"keyword\">char</span>  num[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> *index, <span class=\"keyword\">int</span> *decimalPoint, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//做一个循环除去开头的零和小数点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] != <span class=\"string\">'0'</span>&amp;&amp;num[i] != <span class=\"string\">'.'</span>&amp;&amp;num[i] != <span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*index = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于获取小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">'\\0'</span> || num[i] == <span class=\"string\">'.'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*decimalPoint = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = *index; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">'\\0'</span> || num[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num[i] == <span class=\"string\">'.'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = num[i];</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将pNum[]中保存的数按照科学计数法输出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">formatPrint</span><span class=\"params\">(<span class=\"keyword\">int</span> accuracy, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> decimalPoint, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"0.\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%C\"</span>, pNum[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (decimalPoint - index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*10^%d\"</span>, decimalPoint - index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*10^%d\"</span>, decimalPoint - index + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>  accuracy;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录数字开始的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> equal = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %s %s\"</span>, &amp;accuracy, num1, num2);</span><br><span class=\"line\">\tgetRidZero(num1, &amp;index1, &amp;decimalPoint1, pNum1);</span><br><span class=\"line\">\tgetRidZero(num2, &amp;index2, &amp;decimalPoint2, pNum2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != pNum2[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((index1 - decimalPoint1) != (index2 - decimalPoint2))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> notZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断00000000 和000000.000000000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != <span class=\"string\">'0'</span> || pNum2[i] != <span class=\"string\">'0'</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//证明不是0</span></span><br><span class=\"line\">\t\t\tnotZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!notZero)  <span class=\"comment\">//证明都是0   然后输出 0.0000*10^0 ，是第六个测试点</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"YES 0.\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%C\"</span>, <span class=\"string\">'0'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"*10^%d\"</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (equal)    <span class=\"comment\">//如果两个数相等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"YES \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>          <span class=\"comment\">//如果两个数不想等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"NO \"</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//输出第二个数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><ul>\n<li>5　0000.0000123　0.0000123</li>\n<li>4　000123　　　　　00123.005</li>\n<li>4　00000　　　　　000.000001</li>\n<li>4　00.000　　　　　00000</li>\n<li>4　0.01　　　　　　0.01000005</li>\n</ul>\n"},{"title":"线索化二叉树","description":"","_content":"\nmodified: 2017-08-04\n使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；\n\n在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。\n\n/source/img/DataStructure/threaded_binary_tree.jpg\n\n以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）\n\n根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。\n\n为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：[二叉线索树源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp)\n\n如果二叉树的构造、以及遍历不熟悉的可以先看[二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)；\n\n\n### 线索二叉树的结构体\n\n```c\n\n//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继\ntypedef enum {\n\tLink = 0, Thread = 1     //Link==0:指针，Thread==1,线索\n}PointerTag;\ntypedef struct BinaryTree {\n\tchar item;\n\tBinaryTree *lChild;\n\tBinaryTree *rChild;\n\tPointerTag lTag, rTag;\n}BinaryTree, *pBinaryTree;\n\n```\n\n### 二叉树的先序构造\n\n要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为'#'，第一个被遍历的结点不需要加上'#'\n\n如图：先序遍历的结果为：cba###d#e#f##\n/source/img/DataStructure/binary_tree.jpg\n\n```c\npBinaryTree createBinaryTree() {\n\tpBinaryTree treeNode=NULL;\n\tchar tmp = '0';\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\ttreeNode = (BinaryTree *)malloc(sizeof(BinaryTree));\n\t\ttreeNode->item = tmp;\n\t\t\n\t\ttreeNode->lChild=createBinaryTree();\n\t\tif (treeNode->lChild)\n\t\t\ttreeNode->lTag = Link;\n\t\ttreeNode->rChild=createBinaryTree();\n\t\tif (treeNode->rChild)\n\t\t\ttreeNode->rTag = Link;\n\t}\n\treturn treeNode;\n}\n```\n\n### 二叉树的线索化，代码过程说明：\n\n将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；\n\n<font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font>\n\n\n+ [二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)的中序遍历\n\n```c\nvoid inVisitBiTree(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tinVisitBiTree(biTree->lChild);\n\t\tprintf(\"%c\",biTree->item);\n\t\tinVisitBiTree(biTree->rChild);\n\t}\n}\n```\n\n\n+ 二叉树线索化函数的整体框架\n\n二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块；\n         }\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n\n+ 对访问结点记录，即对前驱的记录\n\n在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n         }\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n<font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font>\n\n如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n\t       \tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n         }\n        pre->biTree;\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n+ 对后继的记录\n\n如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；\n\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (binaryTree)\n\t{\n\t\tInThreading(binaryTree->lChild);\n\t\t//如果没有左孩子时前驱线索\n\t\tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n\t\t//当没有右孩子，后继线索\n\t\tif (!pre->rChild)\n\t\t{\n\t\t\tpre->rTag = Thread;\n\t\t\tpre->rChild = binaryTree;\n\t\t}\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n\n<font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font>\n<font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre->biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font>\n\n### 为已经线索化的二叉树添加头结点\n\n/source/img/DataStructure/thread_binary_tree.jpg\n\n\n\n```c\nvoid InOrderThreading(pBinaryTree &binarytree,pBinaryTree &head) {\n\thead = (pBinaryTree )malloc(sizeof(BinaryTree));\n\n\t//初始化头结点\n\thead->lTag = Link;\n\thead->rTag = Thread;\n\thead->rChild = head;  //头指针回指\n\tif (!binarytree) {\n\t\t head->lChild =head;\n\t}\n\telse\n\t{\n\t\thead->lChild = binarytree;  //当binaryTree非空时，指向二叉树的根结点\n\t\tpre = head;   //定义的全局变量第一次赋值使用\n\t\tInThreading(binarytree);\n\t\t//对最后一个结点线索化\n\t\tpre->rTag = Thread;\n\t\tpre->rChild = head;\n\t\thead->rChild = pre;   //头结点指向中序遍历的最后一个结点\n\t}\n}\n\n```\n\n### 对于中序线索树的中序遍历\n\n先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继\n\n一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。\n\n\n\t/source/img/DataStructure/thread_binary_tree.jpg\n\n\n```c\nvoid InVisitThreadTree(pBinaryTree binarytree) {\n\tpBinaryTree pBTree;\n\tpBTree = binarytree->lChild;\n\n\t//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree\n\twhile (pBTree != binarytree)\n\t{\n\t\t//找到最左元素\n\t\twhile (pBTree->lTag == Link)\n\t\t{\n\t\t\tpBTree = pBTree->lChild;\n\t\t}\n\t\tprintf(\"%c\", pBTree->item);\n\n\t\t//如果右孩子是线索，则其指向的是下一个访问的结点\n\t\twhile ((pBTree->rChild != binarytree) && (pBTree->rTag == Thread))\n\t\t{\n\t\t\tpBTree = pBTree->rChild;\n\t\t\tprintf(\"%c\", pBTree->item);\n\t\t}\n\t\tpBTree = pBTree->rChild;\n\n\t}\n}\n\n```\n\n### 测试:cba###d#e#f##\n\n<font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font>\n```c\n//定义全局变量\npBinaryTree pre;\n\n```\n\n```c\nint main() {\n\tpBinaryTree TbinaryTree, Head;\n\tTbinaryTree = createBinaryTree();\n\tprintf(\"二叉树的先序遍历\\n\");\n\tpreVisitBiTree(TbinaryTree);\n\tprintf(\"\\n二叉树的中序遍历\\n\");\n\tinVisitBiTree(TbinaryTree);\n\tInOrderThreading(TbinaryTree, Head);\n\tprintf(\"\\n中序线索二叉树的中序遍历\\n\");\n\tInVisitThreadTree(Head);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n测试结果：\n\n\n/source/img/DataStructure/binary_tree_result.png\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Data_Structure/2017-08-08-data-structure-threaded-binary-tree.md","raw":"---\ntitle: \"线索化二叉树\"\ndescription: \"\"\ntags: [数据结构]\n\n\n\n---\n\nmodified: 2017-08-04\n使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；\n\n在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。\n\n/source/img/DataStructure/threaded_binary_tree.jpg\n\n以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）\n\n根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。\n\n为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：[二叉线索树源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp)\n\n如果二叉树的构造、以及遍历不熟悉的可以先看[二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)；\n\n\n### 线索二叉树的结构体\n\n```c\n\n//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继\ntypedef enum {\n\tLink = 0, Thread = 1     //Link==0:指针，Thread==1,线索\n}PointerTag;\ntypedef struct BinaryTree {\n\tchar item;\n\tBinaryTree *lChild;\n\tBinaryTree *rChild;\n\tPointerTag lTag, rTag;\n}BinaryTree, *pBinaryTree;\n\n```\n\n### 二叉树的先序构造\n\n要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为'#'，第一个被遍历的结点不需要加上'#'\n\n如图：先序遍历的结果为：cba###d#e#f##\n/source/img/DataStructure/binary_tree.jpg\n\n```c\npBinaryTree createBinaryTree() {\n\tpBinaryTree treeNode=NULL;\n\tchar tmp = '0';\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\ttreeNode = (BinaryTree *)malloc(sizeof(BinaryTree));\n\t\ttreeNode->item = tmp;\n\t\t\n\t\ttreeNode->lChild=createBinaryTree();\n\t\tif (treeNode->lChild)\n\t\t\ttreeNode->lTag = Link;\n\t\ttreeNode->rChild=createBinaryTree();\n\t\tif (treeNode->rChild)\n\t\t\ttreeNode->rTag = Link;\n\t}\n\treturn treeNode;\n}\n```\n\n### 二叉树的线索化，代码过程说明：\n\n将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；\n\n<font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font>\n\n\n+ [二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)的中序遍历\n\n```c\nvoid inVisitBiTree(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tinVisitBiTree(biTree->lChild);\n\t\tprintf(\"%c\",biTree->item);\n\t\tinVisitBiTree(biTree->rChild);\n\t}\n}\n```\n\n\n+ 二叉树线索化函数的整体框架\n\n二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块；\n         }\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n\n+ 对访问结点记录，即对前驱的记录\n\n在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n         }\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n<font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font>\n\n如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n\t       \tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n         }\n        pre->biTree;\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n+ 对后继的记录\n\n如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；\n\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (binaryTree)\n\t{\n\t\tInThreading(binaryTree->lChild);\n\t\t//如果没有左孩子时前驱线索\n\t\tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n\t\t//当没有右孩子，后继线索\n\t\tif (!pre->rChild)\n\t\t{\n\t\t\tpre->rTag = Thread;\n\t\t\tpre->rChild = binaryTree;\n\t\t}\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n\n<font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font>\n<font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre->biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font>\n\n### 为已经线索化的二叉树添加头结点\n\n/source/img/DataStructure/thread_binary_tree.jpg\n\n\n\n```c\nvoid InOrderThreading(pBinaryTree &binarytree,pBinaryTree &head) {\n\thead = (pBinaryTree )malloc(sizeof(BinaryTree));\n\n\t//初始化头结点\n\thead->lTag = Link;\n\thead->rTag = Thread;\n\thead->rChild = head;  //头指针回指\n\tif (!binarytree) {\n\t\t head->lChild =head;\n\t}\n\telse\n\t{\n\t\thead->lChild = binarytree;  //当binaryTree非空时，指向二叉树的根结点\n\t\tpre = head;   //定义的全局变量第一次赋值使用\n\t\tInThreading(binarytree);\n\t\t//对最后一个结点线索化\n\t\tpre->rTag = Thread;\n\t\tpre->rChild = head;\n\t\thead->rChild = pre;   //头结点指向中序遍历的最后一个结点\n\t}\n}\n\n```\n\n### 对于中序线索树的中序遍历\n\n先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继\n\n一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。\n\n\n\t/source/img/DataStructure/thread_binary_tree.jpg\n\n\n```c\nvoid InVisitThreadTree(pBinaryTree binarytree) {\n\tpBinaryTree pBTree;\n\tpBTree = binarytree->lChild;\n\n\t//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree\n\twhile (pBTree != binarytree)\n\t{\n\t\t//找到最左元素\n\t\twhile (pBTree->lTag == Link)\n\t\t{\n\t\t\tpBTree = pBTree->lChild;\n\t\t}\n\t\tprintf(\"%c\", pBTree->item);\n\n\t\t//如果右孩子是线索，则其指向的是下一个访问的结点\n\t\twhile ((pBTree->rChild != binarytree) && (pBTree->rTag == Thread))\n\t\t{\n\t\t\tpBTree = pBTree->rChild;\n\t\t\tprintf(\"%c\", pBTree->item);\n\t\t}\n\t\tpBTree = pBTree->rChild;\n\n\t}\n}\n\n```\n\n### 测试:cba###d#e#f##\n\n<font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font>\n```c\n//定义全局变量\npBinaryTree pre;\n\n```\n\n```c\nint main() {\n\tpBinaryTree TbinaryTree, Head;\n\tTbinaryTree = createBinaryTree();\n\tprintf(\"二叉树的先序遍历\\n\");\n\tpreVisitBiTree(TbinaryTree);\n\tprintf(\"\\n二叉树的中序遍历\\n\");\n\tinVisitBiTree(TbinaryTree);\n\tInOrderThreading(TbinaryTree, Head);\n\tprintf(\"\\n中序线索二叉树的中序遍历\\n\");\n\tInVisitThreadTree(Head);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n测试结果：\n\n\n/source/img/DataStructure/binary_tree_result.png\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Data_Structure/2017-08-08-data-structure-threaded-binary-tree","published":1,"date":"2020-02-29T02:45:08.951Z","updated":"2020-02-29T03:15:56.111Z","_id":"ck770rygp001qisui3lhqfm4y","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-04<br>使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；</p>\n<p>在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。</p>\n<p>/source/img/DataStructure/threaded_binary_tree.jpg</p>\n<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）</p>\n<p>根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。</p>\n<p>为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp\">二叉线索树源码</a></p>\n<p>如果二叉树的构造、以及遍历不熟悉的可以先看<a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>；</p>\n<h3 id=\"线索二叉树的结构体\"><a href=\"#线索二叉树的结构体\" class=\"headerlink\" title=\"线索二叉树的结构体\"></a>线索二叉树的结构体</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">\tLink = <span class=\"number\">0</span>, Thread = <span class=\"number\">1</span>     <span class=\"comment\">//Link==0:指针，Thread==1,线索</span></span><br><span class=\"line\">&#125;PointerTag;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\tBinaryTree *lChild;</span><br><span class=\"line\">\tBinaryTree *rChild;</span><br><span class=\"line\">\tPointerTag lTag, rTag;</span><br><span class=\"line\">&#125;BinaryTree, *pBinaryTree;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的先序构造\"><a href=\"#二叉树的先序构造\" class=\"headerlink\" title=\"二叉树的先序构造\"></a>二叉树的先序构造</h3><p>要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为’#’，第一个被遍历的结点不需要加上’#’</p>\n<p>如图：先序遍历的结果为：cba###d#e#f##<br>/source/img/DataStructure/binary_tree.jpg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree treeNode=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">'#'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = (BinaryTree *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttreeNode-&gt;lChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;lChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;lTag = Link;</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;rChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;rTag = Link;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的线索化，代码过程说明：\"><a href=\"#二叉树的线索化，代码过程说明：\" class=\"headerlink\" title=\"二叉树的线索化，代码过程说明：\"></a>二叉树的线索化，代码过程说明：</h3><p>将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；</p>\n<p><font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font></p>\n<ul>\n<li><a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>的中序遍历</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,biTree-&gt;item);</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>二叉树线索化函数的整体框架</li>\n</ul>\n<p>二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%c\",biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>对访问结点记录，即对前驱的记录</li>\n</ul>\n<p>在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%c\",biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font></p>\n<p>如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%c\",biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">\t       \t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        pre-&gt;biTree;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对后继的记录</li>\n</ul>\n<p>如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (binaryTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果没有左孩子时前驱线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当没有右孩子，后继线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pre-&gt;rChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\t\tpre-&gt;rChild = binaryTree;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font><br><font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre-&gt;biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font></p>\n<h3 id=\"为已经线索化的二叉树添加头结点\"><a href=\"#为已经线索化的二叉树添加头结点\" class=\"headerlink\" title=\"为已经线索化的二叉树添加头结点\"></a>为已经线索化的二叉树添加头结点</h3><p>/source/img/DataStructure/thread_binary_tree.jpg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderThreading</span><span class=\"params\">(pBinaryTree &amp;binarytree,pBinaryTree &amp;head)</span> </span>&#123;</span><br><span class=\"line\">\thead = (pBinaryTree )<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化头结点</span></span><br><span class=\"line\">\thead-&gt;lTag = Link;</span><br><span class=\"line\">\thead-&gt;rTag = Thread;</span><br><span class=\"line\">\thead-&gt;rChild = head;  <span class=\"comment\">//头指针回指</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!binarytree) &#123;</span><br><span class=\"line\">\t\t head-&gt;lChild =head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thead-&gt;lChild = binarytree;  <span class=\"comment\">//当binaryTree非空时，指向二叉树的根结点</span></span><br><span class=\"line\">\t\tpre = head;   <span class=\"comment\">//定义的全局变量第一次赋值使用</span></span><br><span class=\"line\">\t\tInThreading(binarytree);</span><br><span class=\"line\">\t\t<span class=\"comment\">//对最后一个结点线索化</span></span><br><span class=\"line\">\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\tpre-&gt;rChild = head;</span><br><span class=\"line\">\t\thead-&gt;rChild = pre;   <span class=\"comment\">//头结点指向中序遍历的最后一个结点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对于中序线索树的中序遍历\"><a href=\"#对于中序线索树的中序遍历\" class=\"headerlink\" title=\"对于中序线索树的中序遍历\"></a>对于中序线索树的中序遍历</h3><p>先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继</p>\n<p>一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。</p>\n<pre><code>/source/img/DataStructure/thread_binary_tree.jpg</code></pre><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InVisitThreadTree</span><span class=\"params\">(pBinaryTree binarytree)</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree pBTree;</span><br><span class=\"line\">\tpBTree = binarytree-&gt;lChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pBTree != binarytree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到最左元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (pBTree-&gt;lTag == Link)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, pBTree-&gt;item);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果右孩子是线索，则其指向的是下一个访问的结点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((pBTree-&gt;rChild != binarytree) &amp;&amp; (pBTree-&gt;rTag == Thread))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, pBTree-&gt;item);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试-cba-d-e-f\"><a href=\"#测试-cba-d-e-f\" class=\"headerlink\" title=\"测试:cba###d#e#f##\"></a>测试:cba###d#e#f##</h3><p><font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义全局变量</span></span><br><span class=\"line\">pBinaryTree pre;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree TbinaryTree, Head;</span><br><span class=\"line\">\tTbinaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"二叉树的先序遍历\\n\"</span>);</span><br><span class=\"line\">\tpreVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n二叉树的中序遍历\\n\"</span>);</span><br><span class=\"line\">\tinVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\tInOrderThreading(TbinaryTree, Head);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n中序线索二叉树的中序遍历\\n\"</span>);</span><br><span class=\"line\">\tInVisitThreadTree(Head);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试结果：</p>\n<p>/source/img/DataStructure/binary_tree_result.png</p>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-08-04<br>使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；</p>\n<p>在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。</p>\n<p>/source/img/DataStructure/threaded_binary_tree.jpg</p>\n<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）</p>\n<p>根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。</p>\n<p>为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp\">二叉线索树源码</a></p>\n<p>如果二叉树的构造、以及遍历不熟悉的可以先看<a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>；</p>\n<h3 id=\"线索二叉树的结构体\"><a href=\"#线索二叉树的结构体\" class=\"headerlink\" title=\"线索二叉树的结构体\"></a>线索二叉树的结构体</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">\tLink = <span class=\"number\">0</span>, Thread = <span class=\"number\">1</span>     <span class=\"comment\">//Link==0:指针，Thread==1,线索</span></span><br><span class=\"line\">&#125;PointerTag;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\tBinaryTree *lChild;</span><br><span class=\"line\">\tBinaryTree *rChild;</span><br><span class=\"line\">\tPointerTag lTag, rTag;</span><br><span class=\"line\">&#125;BinaryTree, *pBinaryTree;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的先序构造\"><a href=\"#二叉树的先序构造\" class=\"headerlink\" title=\"二叉树的先序构造\"></a>二叉树的先序构造</h3><p>要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为’#’，第一个被遍历的结点不需要加上’#’</p>\n<p>如图：先序遍历的结果为：cba###d#e#f##<br>/source/img/DataStructure/binary_tree.jpg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree treeNode=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">'#'</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = (BinaryTree *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttreeNode-&gt;lChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;lChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;lTag = Link;</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;rChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;rTag = Link;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的线索化，代码过程说明：\"><a href=\"#二叉树的线索化，代码过程说明：\" class=\"headerlink\" title=\"二叉树的线索化，代码过程说明：\"></a>二叉树的线索化，代码过程说明：</h3><p>将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；</p>\n<p><font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font></p>\n<ul>\n<li><a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>的中序遍历</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>,biTree-&gt;item);</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>二叉树线索化函数的整体框架</li>\n</ul>\n<p>二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%c\",biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>对访问结点记录，即对前驱的记录</li>\n</ul>\n<p>在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%c\",biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font></p>\n<p>如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(\"%c\",biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">\t       \t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        pre-&gt;biTree;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对后继的记录</li>\n</ul>\n<p>如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (binaryTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果没有左孩子时前驱线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当没有右孩子，后继线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pre-&gt;rChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\t\tpre-&gt;rChild = binaryTree;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font><br><font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre-&gt;biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font></p>\n<h3 id=\"为已经线索化的二叉树添加头结点\"><a href=\"#为已经线索化的二叉树添加头结点\" class=\"headerlink\" title=\"为已经线索化的二叉树添加头结点\"></a>为已经线索化的二叉树添加头结点</h3><p>/source/img/DataStructure/thread_binary_tree.jpg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderThreading</span><span class=\"params\">(pBinaryTree &amp;binarytree,pBinaryTree &amp;head)</span> </span>&#123;</span><br><span class=\"line\">\thead = (pBinaryTree )<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化头结点</span></span><br><span class=\"line\">\thead-&gt;lTag = Link;</span><br><span class=\"line\">\thead-&gt;rTag = Thread;</span><br><span class=\"line\">\thead-&gt;rChild = head;  <span class=\"comment\">//头指针回指</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!binarytree) &#123;</span><br><span class=\"line\">\t\t head-&gt;lChild =head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thead-&gt;lChild = binarytree;  <span class=\"comment\">//当binaryTree非空时，指向二叉树的根结点</span></span><br><span class=\"line\">\t\tpre = head;   <span class=\"comment\">//定义的全局变量第一次赋值使用</span></span><br><span class=\"line\">\t\tInThreading(binarytree);</span><br><span class=\"line\">\t\t<span class=\"comment\">//对最后一个结点线索化</span></span><br><span class=\"line\">\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\tpre-&gt;rChild = head;</span><br><span class=\"line\">\t\thead-&gt;rChild = pre;   <span class=\"comment\">//头结点指向中序遍历的最后一个结点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对于中序线索树的中序遍历\"><a href=\"#对于中序线索树的中序遍历\" class=\"headerlink\" title=\"对于中序线索树的中序遍历\"></a>对于中序线索树的中序遍历</h3><p>先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继</p>\n<p>一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。</p>\n<pre><code>/source/img/DataStructure/thread_binary_tree.jpg</code></pre><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InVisitThreadTree</span><span class=\"params\">(pBinaryTree binarytree)</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree pBTree;</span><br><span class=\"line\">\tpBTree = binarytree-&gt;lChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pBTree != binarytree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到最左元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (pBTree-&gt;lTag == Link)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, pBTree-&gt;item);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果右孩子是线索，则其指向的是下一个访问的结点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((pBTree-&gt;rChild != binarytree) &amp;&amp; (pBTree-&gt;rTag == Thread))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, pBTree-&gt;item);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试-cba-d-e-f\"><a href=\"#测试-cba-d-e-f\" class=\"headerlink\" title=\"测试:cba###d#e#f##\"></a>测试:cba###d#e#f##</h3><p><font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义全局变量</span></span><br><span class=\"line\">pBinaryTree pre;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree TbinaryTree, Head;</span><br><span class=\"line\">\tTbinaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"二叉树的先序遍历\\n\"</span>);</span><br><span class=\"line\">\tpreVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n二叉树的中序遍历\\n\"</span>);</span><br><span class=\"line\">\tinVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\tInOrderThreading(TbinaryTree, Head);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n中序线索二叉树的中序遍历\\n\"</span>);</span><br><span class=\"line\">\tInVisitThreadTree(Head);</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试结果：</p>\n<p>/source/img/DataStructure/binary_tree_result.png</p>\n"},{"_content":"","source":"_posts/Android/Other/Groovy介绍.md","raw":"","slug":"Android/Other/Groovy介绍","published":1,"date":"2019-09-30T08:28:42.958Z","updated":"2019-09-30T08:28:42.958Z","title":"Android/Other/Groovy介绍","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygq001risui4wj430qp","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android/框架/RxJava2.0.md","raw":"","slug":"Android/框架/RxJava2.0","published":1,"date":"2019-09-19T09:34:08.488Z","updated":"2019-09-19T09:41:14.750Z","title":"Android/框架/RxJava2.0","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygq001tisuihg6lh4hz","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android/View/ActionBar和ToolBar的使用.md","raw":"","slug":"Android/View/ActionBar和ToolBar的使用","published":1,"date":"2019-09-30T07:19:02.841Z","updated":"2019-09-30T08:28:42.961Z","title":"Android/View/ActionBar和ToolBar的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygr001uisui3c5db6fr","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/Java多线程/Java锁机制.md","raw":"","slug":"Java/Java多线程/Java锁机制","published":1,"date":"2019-09-19T09:41:14.777Z","updated":"2019-09-19T09:41:14.777Z","title":"Java/Java多线程/Java锁机制","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygs001visui9tbcheht","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/Java基础/Java 输入输出操作.md","raw":"","slug":"Java/Java基础/Java 输入输出操作","published":1,"date":"2019-09-19T09:41:14.768Z","updated":"2019-09-19T09:41:14.768Z","title":"Java/Java基础/Java 输入输出操作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygs001wisuiaggdemse","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/Java虚拟机/README.md","raw":"","slug":"Java/Java虚拟机/README","published":1,"date":"2019-09-19T09:41:14.778Z","updated":"2019-09-19T09:41:14.778Z","title":"Java/Java虚拟机/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygt001xisui49r1b13l","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Kotlin/Kotlin基础/README.md","raw":"","slug":"Kotlin/Kotlin基础/README","published":1,"date":"2019-11-28T12:20:23.104Z","updated":"2019-11-28T12:20:23.104Z","title":"Kotlin/Kotlin基础/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygt001yisui5uord8oi","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Other/Git/README.md","raw":"","slug":"Other/Git/README","published":1,"date":"2019-09-19T09:41:14.780Z","updated":"2019-09-19T09:41:14.780Z","title":"Other/Git/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygv001zisuia5a11dha","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Other/Img/README.md","raw":"","slug":"Other/Img/README","published":1,"date":"2019-09-11T08:04:40.930Z","updated":"2019-09-11T08:04:40.930Z","title":"Other/Img/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770rygv0020isui9v3pa449","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。\n2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。\n3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。\n4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。\n5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。\n6、AMS通知淘宝绑定Application并启动MainActivity。\n7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。\n\n\n## Android应用启动从Zygote到Activity.onCreate\n\n本文从点击Android应用图标开始介绍Android应用的启动过程\n\n### Android应用有两个方面的特点\n\n**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。\n\n**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;\n\n\n任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。\n\n在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 \n\n\n### Zygote：创建新的进程\n\nAndroid操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。\n\n**init进程会启动Zygote进程**\n\n**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。\n\n**在Zygote之后，init启动运行时的进程？**\n\n紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**\n\n### 用户点击图标通过Launcher启动应用的过程\n\n点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。\n\n* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。\n* 2、目标信心会被存储至intent对象中，避免重复第一步工作；\n* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；\n* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；\n* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。\n\n\n### 在该应用启动流程中有三个不同的阶段\n* 1、进程创建\n* 2、绑定应用\n* 3、启动Activity/Service/调用intent receiver\n\n#### 进程创建\n\nActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id\n\n在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。\n\n#### 应用绑定\n\n下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。\n\n\n#### 启动Activity","source":"_posts/Android/Advanced/应用启动流程.md","raw":"1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。\n2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。\n3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。\n4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。\n5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。\n6、AMS通知淘宝绑定Application并启动MainActivity。\n7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。\n\n\n## Android应用启动从Zygote到Activity.onCreate\n\n本文从点击Android应用图标开始介绍Android应用的启动过程\n\n### Android应用有两个方面的特点\n\n**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。\n\n**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;\n\n\n任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。\n\n在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 \n\n\n### Zygote：创建新的进程\n\nAndroid操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。\n\n**init进程会启动Zygote进程**\n\n**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。\n\n**在Zygote之后，init启动运行时的进程？**\n\n紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**\n\n### 用户点击图标通过Launcher启动应用的过程\n\n点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。\n\n* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。\n* 2、目标信心会被存储至intent对象中，避免重复第一步工作；\n* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；\n* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；\n* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。\n\n\n### 在该应用启动流程中有三个不同的阶段\n* 1、进程创建\n* 2、绑定应用\n* 3、启动Activity/Service/调用intent receiver\n\n#### 进程创建\n\nActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id\n\n在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。\n\n#### 应用绑定\n\n下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。\n\n\n#### 启动Activity","slug":"Android/Advanced/应用启动流程","published":1,"date":"2019-09-30T08:28:42.948Z","updated":"2019-09-30T08:28:42.949Z","title":"Android/Advanced/应用启动流程","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryh60021isuihl9h7e41","content":"<p>1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。<br>2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br>3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。<br>4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。<br>5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。<br>6、AMS通知淘宝绑定Application并启动MainActivity。<br>7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</p>\n<h2 id=\"Android应用启动从Zygote到Activity-onCreate\"><a href=\"#Android应用启动从Zygote到Activity-onCreate\" class=\"headerlink\" title=\"Android应用启动从Zygote到Activity.onCreate\"></a>Android应用启动从Zygote到Activity.onCreate</h2><p>本文从点击Android应用图标开始介绍Android应用的启动过程</p>\n<h3 id=\"Android应用有两个方面的特点\"><a href=\"#Android应用有两个方面的特点\" class=\"headerlink\" title=\"Android应用有两个方面的特点\"></a>Android应用有两个方面的特点</h3><p><strong>特点一：</strong>具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。</p>\n<p><strong>特点二：</strong>自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;</p>\n<p>任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。</p>\n<p>在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 </p>\n<h3 id=\"Zygote：创建新的进程\"><a href=\"#Zygote：创建新的进程\" class=\"headerlink\" title=\"Zygote：创建新的进程\"></a>Zygote：创建新的进程</h3><p>Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。</p>\n<p><strong>init进程会启动Zygote进程</strong></p>\n<p><strong>Zygote</strong>进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。</p>\n<p><strong>在Zygote之后，init启动运行时的进程？</strong></p>\n<p>紧接着Zygote fork并启动一个称为system server的进程，<strong>system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。</strong></p>\n<h3 id=\"用户点击图标通过Launcher启动应用的过程\"><a href=\"#用户点击图标通过Launcher启动应用的过程\" class=\"headerlink\" title=\"用户点击图标通过Launcher启动应用的过程\"></a>用户点击图标通过Launcher启动应用的过程</h3><p>点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。</p>\n<ul>\n<li>1、收集intent的目标的信息，通过调用<code>PackageManager</code>对象中的<code>resolveIntent()</code>方法，默认使用<code>PackageManager.MATCH_DEFAULT_ONLY</code> 和     <code>PackageManager.GET_SHARED_LIBRARY_FILES</code>标志。</li>\n<li>2、目标信心会被存储至intent对象中，避免重复第一步工作；</li>\n<li>3、判断用户是否有权限调用intent中的组件，通过<code>grantUriPermissionLocked()</code>方法执行；</li>\n<li>4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：<code>FLAG_ACTIVITY_NEW_TASK</code> 或者其他flags<code>FLAG_ACTIVITY_CLEAR_TOP</code>；</li>\n<li>5、检查进程的<code>ProcessRecord</code>是否已经存在，如果<code>ProcessRecord</code>为空，ActivityManager需要创建一个新的进程来实例化目标组件。</li>\n</ul>\n<h3 id=\"在该应用启动流程中有三个不同的阶段\"><a href=\"#在该应用启动流程中有三个不同的阶段\" class=\"headerlink\" title=\"在该应用启动流程中有三个不同的阶段\"></a>在该应用启动流程中有三个不同的阶段</h3><ul>\n<li>1、进程创建</li>\n<li>2、绑定应用</li>\n<li>3、启动Activity/Service/调用intent receiver</li>\n</ul>\n<h4 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h4><p>ActivityManagerService通过调用<code>startProcessLocked()</code>方法来创建一个新的进程，<code>startProcessLocked</code>方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用<code>ZygoteInit.main()</code>方法，该方法会创建一个ActivityThread对象，并返回新建进程的id</p>\n<p>在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用<code>Looper.loop()</code>方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用<code>Looper.prepareLoop()</code>再掉用<code>Looper.loop()</code>方法启动message loop。</p>\n<h4 id=\"应用绑定\"><a href=\"#应用绑定\" class=\"headerlink\" title=\"应用绑定\"></a>应用绑定</h4><p>下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的<code>bindApplication()</code>方法来实现。该方法将<code>BIND_APPLICATION</code>信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——<code>handleBindApplication()</code>，该方法调用<code>makeApplication()</code>方法，<code>makeApplication()</code>方法将应用中特定的类加载到内存中执行。</p>\n<h4 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h4>","site":{"data":{}},"excerpt":"","more":"<p>1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。<br>2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br>3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。<br>4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。<br>5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。<br>6、AMS通知淘宝绑定Application并启动MainActivity。<br>7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</p>\n<h2 id=\"Android应用启动从Zygote到Activity-onCreate\"><a href=\"#Android应用启动从Zygote到Activity-onCreate\" class=\"headerlink\" title=\"Android应用启动从Zygote到Activity.onCreate\"></a>Android应用启动从Zygote到Activity.onCreate</h2><p>本文从点击Android应用图标开始介绍Android应用的启动过程</p>\n<h3 id=\"Android应用有两个方面的特点\"><a href=\"#Android应用有两个方面的特点\" class=\"headerlink\" title=\"Android应用有两个方面的特点\"></a>Android应用有两个方面的特点</h3><p><strong>特点一：</strong>具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。</p>\n<p><strong>特点二：</strong>自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;</p>\n<p>任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。</p>\n<p>在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 </p>\n<h3 id=\"Zygote：创建新的进程\"><a href=\"#Zygote：创建新的进程\" class=\"headerlink\" title=\"Zygote：创建新的进程\"></a>Zygote：创建新的进程</h3><p>Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。</p>\n<p><strong>init进程会启动Zygote进程</strong></p>\n<p><strong>Zygote</strong>进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。</p>\n<p><strong>在Zygote之后，init启动运行时的进程？</strong></p>\n<p>紧接着Zygote fork并启动一个称为system server的进程，<strong>system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。</strong></p>\n<h3 id=\"用户点击图标通过Launcher启动应用的过程\"><a href=\"#用户点击图标通过Launcher启动应用的过程\" class=\"headerlink\" title=\"用户点击图标通过Launcher启动应用的过程\"></a>用户点击图标通过Launcher启动应用的过程</h3><p>点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。</p>\n<ul>\n<li>1、收集intent的目标的信息，通过调用<code>PackageManager</code>对象中的<code>resolveIntent()</code>方法，默认使用<code>PackageManager.MATCH_DEFAULT_ONLY</code> 和     <code>PackageManager.GET_SHARED_LIBRARY_FILES</code>标志。</li>\n<li>2、目标信心会被存储至intent对象中，避免重复第一步工作；</li>\n<li>3、判断用户是否有权限调用intent中的组件，通过<code>grantUriPermissionLocked()</code>方法执行；</li>\n<li>4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：<code>FLAG_ACTIVITY_NEW_TASK</code> 或者其他flags<code>FLAG_ACTIVITY_CLEAR_TOP</code>；</li>\n<li>5、检查进程的<code>ProcessRecord</code>是否已经存在，如果<code>ProcessRecord</code>为空，ActivityManager需要创建一个新的进程来实例化目标组件。</li>\n</ul>\n<h3 id=\"在该应用启动流程中有三个不同的阶段\"><a href=\"#在该应用启动流程中有三个不同的阶段\" class=\"headerlink\" title=\"在该应用启动流程中有三个不同的阶段\"></a>在该应用启动流程中有三个不同的阶段</h3><ul>\n<li>1、进程创建</li>\n<li>2、绑定应用</li>\n<li>3、启动Activity/Service/调用intent receiver</li>\n</ul>\n<h4 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h4><p>ActivityManagerService通过调用<code>startProcessLocked()</code>方法来创建一个新的进程，<code>startProcessLocked</code>方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用<code>ZygoteInit.main()</code>方法，该方法会创建一个ActivityThread对象，并返回新建进程的id</p>\n<p>在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用<code>Looper.loop()</code>方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用<code>Looper.prepareLoop()</code>再掉用<code>Looper.loop()</code>方法启动message loop。</p>\n<h4 id=\"应用绑定\"><a href=\"#应用绑定\" class=\"headerlink\" title=\"应用绑定\"></a>应用绑定</h4><p>下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的<code>bindApplication()</code>方法来实现。该方法将<code>BIND_APPLICATION</code>信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——<code>handleBindApplication()</code>，该方法调用<code>makeApplication()</code>方法，<code>makeApplication()</code>方法将应用中特定的类加载到内存中执行。</p>\n<h4 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h4>"},{"_content":"\n\n\n# Android JNI对敏感信息进行保护\n\n## Android反编译\n\n在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。\n\n## 将敏感信息保存使用native代码实现\n\n相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。\n\n\n\n\n\n\n\n","source":"_posts/Android/Android JNI/Android JNI敏感信息保护.md","raw":"\n\n\n# Android JNI对敏感信息进行保护\n\n## Android反编译\n\n在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。\n\n## 将敏感信息保存使用native代码实现\n\n相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。\n\n\n\n\n\n\n\n","slug":"Android/Android JNI/Android JNI敏感信息保护","published":1,"date":"2019-09-21T00:52:10.110Z","updated":"2019-09-21T00:52:10.111Z","title":"Android/Android JNI/Android JNI敏感信息保护","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryh60022isuic6ou9f7z","content":"<h1 id=\"Android-JNI对敏感信息进行保护\"><a href=\"#Android-JNI对敏感信息进行保护\" class=\"headerlink\" title=\"Android JNI对敏感信息进行保护\"></a>Android JNI对敏感信息进行保护</h1><h2 id=\"Android反编译\"><a href=\"#Android反编译\" class=\"headerlink\" title=\"Android反编译\"></a>Android反编译</h2><p>在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。</p>\n<h2 id=\"将敏感信息保存使用native代码实现\"><a href=\"#将敏感信息保存使用native代码实现\" class=\"headerlink\" title=\"将敏感信息保存使用native代码实现\"></a>将敏感信息保存使用native代码实现</h2><p>相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-JNI对敏感信息进行保护\"><a href=\"#Android-JNI对敏感信息进行保护\" class=\"headerlink\" title=\"Android JNI对敏感信息进行保护\"></a>Android JNI对敏感信息进行保护</h1><h2 id=\"Android反编译\"><a href=\"#Android反编译\" class=\"headerlink\" title=\"Android反编译\"></a>Android反编译</h2><p>在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。</p>\n<h2 id=\"将敏感信息保存使用native代码实现\"><a href=\"#将敏感信息保存使用native代码实现\" class=\"headerlink\" title=\"将敏感信息保存使用native代码实现\"></a>将敏感信息保存使用native代码实现</h2><p>相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。</p>\n"},{"_content":"\nAndroid防止二次打包主要通过对签名文件的验证来进行\n\n### 应用签名文件介绍\n\n在Android Studio2.2之后多了对签名版本的选择`V1(Jar Signature)`和`V2(Full APK Signature)`V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。\n\n#### 签名文件在gradle中配置\n\n    signingConfigs {      \n      debug {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"         \n        keyAlias \"**\"          \n        keyPassword \"******\"          \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }      \n      release {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"          \n        keyAlias \"**\"          \n        keyPassword \"******\"         \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }\n    }\n\n### 应用签名文件查看\n\n* 已有.jks文件\n\n在cmd中输入\n```xml\n\nkeytool -list -v -keystore path/android.jks -storepass password\n\n```\n![](/assets/Android safe.png)\n\n\n* 只有.apk文件\n\n使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入\n```xml\nkeytool -printcert -file path/android.jks\n```\n![](/assets/Android safe1.png)\n\n**两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码**\n\n### 在Java代码中进行验证，通过PackageManager获取签名信息。\n\n使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解\n\n\n### 在native层进行签名验证\n使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。\n\n因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。\n\n### 在服务端对签名文件进行验证\n服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）\n\n\n","source":"_posts/Android/Android反编译/Android应用防止二次打包.md","raw":"\nAndroid防止二次打包主要通过对签名文件的验证来进行\n\n### 应用签名文件介绍\n\n在Android Studio2.2之后多了对签名版本的选择`V1(Jar Signature)`和`V2(Full APK Signature)`V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。\n\n#### 签名文件在gradle中配置\n\n    signingConfigs {      \n      debug {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"         \n        keyAlias \"**\"          \n        keyPassword \"******\"          \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }      \n      release {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"          \n        keyAlias \"**\"          \n        keyPassword \"******\"         \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }\n    }\n\n### 应用签名文件查看\n\n* 已有.jks文件\n\n在cmd中输入\n```xml\n\nkeytool -list -v -keystore path/android.jks -storepass password\n\n```\n![](/assets/Android safe.png)\n\n\n* 只有.apk文件\n\n使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入\n```xml\nkeytool -printcert -file path/android.jks\n```\n![](/assets/Android safe1.png)\n\n**两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码**\n\n### 在Java代码中进行验证，通过PackageManager获取签名信息。\n\n使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解\n\n\n### 在native层进行签名验证\n使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。\n\n因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。\n\n### 在服务端对签名文件进行验证\n服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）\n\n\n","slug":"Android/Android反编译/Android应用防止二次打包","published":1,"date":"2019-09-30T08:28:42.950Z","updated":"2019-11-30T11:14:32.181Z","title":"Android/Android反编译/Android应用防止二次打包","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryh70023isuif5r02oyn","content":"<p>Android防止二次打包主要通过对签名文件的验证来进行</p>\n<h3 id=\"应用签名文件介绍\"><a href=\"#应用签名文件介绍\" class=\"headerlink\" title=\"应用签名文件介绍\"></a>应用签名文件介绍</h3><p>在Android Studio2.2之后多了对签名版本的选择<code>V1(Jar Signature)</code>和<code>V2(Full APK Signature)</code>V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。</p>\n<h4 id=\"签名文件在gradle中配置\"><a href=\"#签名文件在gradle中配置\" class=\"headerlink\" title=\"签名文件在gradle中配置\"></a>签名文件在gradle中配置</h4><pre><code>signingConfigs {      \n  debug {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;         \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;          \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }      \n  release {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;          \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;         \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }\n}</code></pre><h3 id=\"应用签名文件查看\"><a href=\"#应用签名文件查看\" class=\"headerlink\" title=\"应用签名文件查看\"></a>应用签名文件查看</h3><ul>\n<li>已有.jks文件</li>\n</ul>\n<p>在cmd中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">keytool -list -v -keystore path/android.jks -storepass password</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe.png)</p>\n<ul>\n<li>只有.apk文件</li>\n</ul>\n<p>使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file path/android.jks</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe1.png)</p>\n<p><strong>两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码</strong></p>\n<h3 id=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"><a href=\"#在Java代码中进行验证，通过PackageManager获取签名信息。\" class=\"headerlink\" title=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"></a>在Java代码中进行验证，通过PackageManager获取签名信息。</h3><p>使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解</p>\n<h3 id=\"在native层进行签名验证\"><a href=\"#在native层进行签名验证\" class=\"headerlink\" title=\"在native层进行签名验证\"></a>在native层进行签名验证</h3><p>使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。</p>\n<p>因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。</p>\n<h3 id=\"在服务端对签名文件进行验证\"><a href=\"#在服务端对签名文件进行验证\" class=\"headerlink\" title=\"在服务端对签名文件进行验证\"></a>在服务端对签名文件进行验证</h3><p>服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android防止二次打包主要通过对签名文件的验证来进行</p>\n<h3 id=\"应用签名文件介绍\"><a href=\"#应用签名文件介绍\" class=\"headerlink\" title=\"应用签名文件介绍\"></a>应用签名文件介绍</h3><p>在Android Studio2.2之后多了对签名版本的选择<code>V1(Jar Signature)</code>和<code>V2(Full APK Signature)</code>V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。</p>\n<h4 id=\"签名文件在gradle中配置\"><a href=\"#签名文件在gradle中配置\" class=\"headerlink\" title=\"签名文件在gradle中配置\"></a>签名文件在gradle中配置</h4><pre><code>signingConfigs {      \n  debug {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;         \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;          \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }      \n  release {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;          \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;         \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }\n}</code></pre><h3 id=\"应用签名文件查看\"><a href=\"#应用签名文件查看\" class=\"headerlink\" title=\"应用签名文件查看\"></a>应用签名文件查看</h3><ul>\n<li>已有.jks文件</li>\n</ul>\n<p>在cmd中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">keytool -list -v -keystore path/android.jks -storepass password</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe.png)</p>\n<ul>\n<li>只有.apk文件</li>\n</ul>\n<p>使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file path/android.jks</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe1.png)</p>\n<p><strong>两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码</strong></p>\n<h3 id=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"><a href=\"#在Java代码中进行验证，通过PackageManager获取签名信息。\" class=\"headerlink\" title=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"></a>在Java代码中进行验证，通过PackageManager获取签名信息。</h3><p>使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解</p>\n<h3 id=\"在native层进行签名验证\"><a href=\"#在native层进行签名验证\" class=\"headerlink\" title=\"在native层进行签名验证\"></a>在native层进行签名验证</h3><p>使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。</p>\n<p>因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。</p>\n<h3 id=\"在服务端对签名文件进行验证\"><a href=\"#在服务端对签名文件进行验证\" class=\"headerlink\" title=\"在服务端对签名文件进行验证\"></a>在服务端对签名文件进行验证</h3><p>服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）</p>\n"},{"title":"Android lifecycle-aware components","description":"Android生命周期感知组件介绍","_content":"\nmodified: 2018-08-09\n# Android生命周期感知组件介绍(Android lifecycle-aware components)\n\n## lifecycle-aware组件介绍\n\n* **ViewModel：**为绑定在特定生命周期的对象提供创建以及恢复的方法，`ViewModel`通常保存`View`的数据或者用于与其他组件进行通信，例如data repository\n* **LifecycleOwner/LifecycleRegisterOwner：**`LifecycleOwner`以及`LifecycleRegisterOwner`都是需要在`AppCompatActivity`或者`Support Fragment`类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。\n* **LiveData:**通过`LiveData`可以通过多个组件来观察到数据的变化。`LiveData`不会影响应用中的组件如：Activity、Service、Fragment或者其他`LifecycleOwner`的生命周期。`LiveData`可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。\n\n## 布局文件中添加计时器\n\n```xml\n    <Chronometer\n        android:id=\"@+id/chronometer\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n```\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);\n        chronometer.start();\n    }\n}\n\n\n```\n\n**当旋转屏幕时，由于Activity重建，使得计时器被重置**\n\n## 添加ViewMedel\n\n添加`ViewModel`来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用`ViewModel`也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。\n\n### 使用ViewModel来留存计时器（`Chronometer`）的状态\n\nChronometerViewModel中的代码\n\n```java\npublic class ChronometerViewModel extends ViewModel {\n    \n    private MutableLiveData<Long>mElapsedTime=new MutableLiveData<>();\n\n    private long mInitialTime;\n\n    public ChronometerViewModel(){\n        mInitialTime= SystemClock.elapsedRealtime();\n\n        Timer timer=new Timer();\n\n        timer.scheduleAtFixedRate(new TimerTask() {\n            @Override\n            public void run() {\n                 final long newValue=(SystemClock.elapsedRealtime()-mInitialTime)/1000;\n                 mElapsedTime.postValue(newValue);\n            }\n        },1000,1000);\n    }\n\n    public LiveData<Long>getElapsedTime(){\n\n        return mElapsedTime;\n    }\n}\n\n\n```\n\n在MainActivity中添加代码\n```java\n     chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n\n```\n\n`this`指代的是`LifecycleOwner`的一个实例，`ViewModel`与`LifecycleOwner`保活时间一样长，当`ViewModel`的所有者的配置信息（如：屏幕旋转）发生变化时，`ViewModel`不会被销毁，当其所有者重新被实例化时，会与已经存在的`ViewModel`重新建立联系。其生命周期如图所示：\n\n/source/img/201807/view_model.png\n\n\n## 将Activity中使用的数据使用LiveData进行封装\n\n将计时控件`chronometer`使用`Timer`来设置，每隔一秒钟更新一次UI，将相应的代码放在`ChronometerViewModel`中，而让Activity只保持用户与UI之间的交流操作。\n\n\nMainActivity中的完整代码\n```java\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ChronometerViewModel chronometerViewModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n         chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n         subscribe();\n\n    }\n    \n    private void subscribe(){\n        final Observer<Long>elapseTimeObserver=new Observer<Long>() {\n            @Override\n            public void onChanged(@Nullable Long aLong) {\n\n                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+\"秒\");\n            }\n        };\n        chronometerViewModel.getElapsedTime().observe(this,elapseTimeObserver);\n    }\n}\n\n\n```\n\n当`timer`每隔一秒***通知***`MainActivity`时，`MainActivity`将会更新一下UI，为避免内存泄漏，`ViewModel`中没有指向Activity的引用。\n\n`ViewModel`并不直接改变View，在使用`ViewModel`中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。\n\n**注：为了将数据暴露给观察者，需要使用`LiveData`对数据进行封装**\n\n`LiveData`是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。\n\n**运行结果：**\n\n/source/img/201807/view_model1.png\n/source/img/201807/view_model2.png\n\n\n在旋转屏幕后计时器继续未重置。\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/2018-08-09-android-ViewModel-introduction.md","raw":"---\n\ntitle: \"Android lifecycle-aware components\"\ndescription: \"Android生命周期感知组件介绍\"\ntags: [Android]\n\n---\n\nmodified: 2018-08-09\n# Android生命周期感知组件介绍(Android lifecycle-aware components)\n\n## lifecycle-aware组件介绍\n\n* **ViewModel：**为绑定在特定生命周期的对象提供创建以及恢复的方法，`ViewModel`通常保存`View`的数据或者用于与其他组件进行通信，例如data repository\n* **LifecycleOwner/LifecycleRegisterOwner：**`LifecycleOwner`以及`LifecycleRegisterOwner`都是需要在`AppCompatActivity`或者`Support Fragment`类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。\n* **LiveData:**通过`LiveData`可以通过多个组件来观察到数据的变化。`LiveData`不会影响应用中的组件如：Activity、Service、Fragment或者其他`LifecycleOwner`的生命周期。`LiveData`可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。\n\n## 布局文件中添加计时器\n\n```xml\n    <Chronometer\n        android:id=\"@+id/chronometer\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n```\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);\n        chronometer.start();\n    }\n}\n\n\n```\n\n**当旋转屏幕时，由于Activity重建，使得计时器被重置**\n\n## 添加ViewMedel\n\n添加`ViewModel`来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用`ViewModel`也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。\n\n### 使用ViewModel来留存计时器（`Chronometer`）的状态\n\nChronometerViewModel中的代码\n\n```java\npublic class ChronometerViewModel extends ViewModel {\n    \n    private MutableLiveData<Long>mElapsedTime=new MutableLiveData<>();\n\n    private long mInitialTime;\n\n    public ChronometerViewModel(){\n        mInitialTime= SystemClock.elapsedRealtime();\n\n        Timer timer=new Timer();\n\n        timer.scheduleAtFixedRate(new TimerTask() {\n            @Override\n            public void run() {\n                 final long newValue=(SystemClock.elapsedRealtime()-mInitialTime)/1000;\n                 mElapsedTime.postValue(newValue);\n            }\n        },1000,1000);\n    }\n\n    public LiveData<Long>getElapsedTime(){\n\n        return mElapsedTime;\n    }\n}\n\n\n```\n\n在MainActivity中添加代码\n```java\n     chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n\n```\n\n`this`指代的是`LifecycleOwner`的一个实例，`ViewModel`与`LifecycleOwner`保活时间一样长，当`ViewModel`的所有者的配置信息（如：屏幕旋转）发生变化时，`ViewModel`不会被销毁，当其所有者重新被实例化时，会与已经存在的`ViewModel`重新建立联系。其生命周期如图所示：\n\n/source/img/201807/view_model.png\n\n\n## 将Activity中使用的数据使用LiveData进行封装\n\n将计时控件`chronometer`使用`Timer`来设置，每隔一秒钟更新一次UI，将相应的代码放在`ChronometerViewModel`中，而让Activity只保持用户与UI之间的交流操作。\n\n\nMainActivity中的完整代码\n```java\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ChronometerViewModel chronometerViewModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n         chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n         subscribe();\n\n    }\n    \n    private void subscribe(){\n        final Observer<Long>elapseTimeObserver=new Observer<Long>() {\n            @Override\n            public void onChanged(@Nullable Long aLong) {\n\n                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+\"秒\");\n            }\n        };\n        chronometerViewModel.getElapsedTime().observe(this,elapseTimeObserver);\n    }\n}\n\n\n```\n\n当`timer`每隔一秒***通知***`MainActivity`时，`MainActivity`将会更新一下UI，为避免内存泄漏，`ViewModel`中没有指向Activity的引用。\n\n`ViewModel`并不直接改变View，在使用`ViewModel`中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。\n\n**注：为了将数据暴露给观察者，需要使用`LiveData`对数据进行封装**\n\n`LiveData`是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。\n\n**运行结果：**\n\n/source/img/201807/view_model1.png\n/source/img/201807/view_model2.png\n\n\n在旋转屏幕后计时器继续未重置。\n\n\n\n\n\n\n","slug":"Android/Android基础/2018-08-09-android-ViewModel-introduction","published":1,"date":"2020-02-29T02:45:21.663Z","updated":"2020-02-29T03:16:43.550Z","_id":"ck770ryh70024isuiapjh8kvs","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2018-08-09</p>\n<h1 id=\"Android生命周期感知组件介绍-Android-lifecycle-aware-components\"><a href=\"#Android生命周期感知组件介绍-Android-lifecycle-aware-components\" class=\"headerlink\" title=\"Android生命周期感知组件介绍(Android lifecycle-aware components)\"></a>Android生命周期感知组件介绍(Android lifecycle-aware components)</h1><h2 id=\"lifecycle-aware组件介绍\"><a href=\"#lifecycle-aware组件介绍\" class=\"headerlink\" title=\"lifecycle-aware组件介绍\"></a>lifecycle-aware组件介绍</h2><ul>\n<li><strong>ViewModel：</strong>为绑定在特定生命周期的对象提供创建以及恢复的方法，<code>ViewModel</code>通常保存<code>View</code>的数据或者用于与其他组件进行通信，例如data repository</li>\n<li><strong>LifecycleOwner/LifecycleRegisterOwner：</strong><code>LifecycleOwner</code>以及<code>LifecycleRegisterOwner</code>都是需要在<code>AppCompatActivity</code>或者<code>Support Fragment</code>类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。</li>\n<li><strong>LiveData:</strong>通过<code>LiveData</code>可以通过多个组件来观察到数据的变化。<code>LiveData</code>不会影响应用中的组件如：Activity、Service、Fragment或者其他<code>LifecycleOwner</code>的生命周期。<code>LiveData</code>可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。</li>\n</ul>\n<h2 id=\"布局文件中添加计时器\"><a href=\"#布局文件中添加计时器\" class=\"headerlink\" title=\"布局文件中添加计时器\"></a>布局文件中添加计时器</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Chronometer</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/chronometer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:text</span>=<span class=\"string\">\"Hello World!\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">\"parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintLeft_toLeftOf</span>=<span class=\"string\">\"parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintRight_toRightOf</span>=<span class=\"string\">\"parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">\"parent\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);</span><br><span class=\"line\">        chronometer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当旋转屏幕时，由于Activity重建，使得计时器被重置</strong></p>\n<h2 id=\"添加ViewMedel\"><a href=\"#添加ViewMedel\" class=\"headerlink\" title=\"添加ViewMedel\"></a>添加ViewMedel</h2><p>添加<code>ViewModel</code>来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用<code>ViewModel</code>也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。</p>\n<h3 id=\"使用ViewModel来留存计时器（Chronometer）的状态\"><a href=\"#使用ViewModel来留存计时器（Chronometer）的状态\" class=\"headerlink\" title=\"使用ViewModel来留存计时器（Chronometer）的状态\"></a>使用ViewModel来留存计时器（<code>Chronometer</code>）的状态</h3><p>ChronometerViewModel中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChronometerViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Long&gt;mElapsedTime=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mInitialTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChronometerViewModel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        mInitialTime= SystemClock.elapsedRealtime();</span><br><span class=\"line\"></span><br><span class=\"line\">        Timer timer=<span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">        timer.scheduleAtFixedRate(<span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newValue=(SystemClock.elapsedRealtime()-mInitialTime)/<span class=\"number\">1000</span>;</span><br><span class=\"line\">                 mElapsedTime.postValue(newValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;Long&gt;getElapsedTime()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mElapsedTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在MainActivity中添加代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>this</code>指代的是<code>LifecycleOwner</code>的一个实例，<code>ViewModel</code>与<code>LifecycleOwner</code>保活时间一样长，当<code>ViewModel</code>的所有者的配置信息（如：屏幕旋转）发生变化时，<code>ViewModel</code>不会被销毁，当其所有者重新被实例化时，会与已经存在的<code>ViewModel</code>重新建立联系。其生命周期如图所示：</p>\n<p>/source/img/201807/view_model.png</p>\n<h2 id=\"将Activity中使用的数据使用LiveData进行封装\"><a href=\"#将Activity中使用的数据使用LiveData进行封装\" class=\"headerlink\" title=\"将Activity中使用的数据使用LiveData进行封装\"></a>将Activity中使用的数据使用LiveData进行封装</h2><p>将计时控件<code>chronometer</code>使用<code>Timer</code>来设置，每隔一秒钟更新一次UI，将相应的代码放在<code>ChronometerViewModel</code>中，而让Activity只保持用户与UI之间的交流操作。</p>\n<p>MainActivity中的完整代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ChronometerViewModel chronometerViewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">         chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">         subscribe();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;Long&gt;elapseTimeObserver=<span class=\"keyword\">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Long aLong)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+<span class=\"string\">\"秒\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        chronometerViewModel.getElapsedTime().observe(<span class=\"keyword\">this</span>,elapseTimeObserver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>timer</code>每隔一秒<strong><em>通知</em></strong><code>MainActivity</code>时，<code>MainActivity</code>将会更新一下UI，为避免内存泄漏，<code>ViewModel</code>中没有指向Activity的引用。</p>\n<p><code>ViewModel</code>并不直接改变View，在使用<code>ViewModel</code>中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。</p>\n<p><strong>注：为了将数据暴露给观察者，需要使用<code>LiveData</code>对数据进行封装</strong></p>\n<p><code>LiveData</code>是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。</p>\n<p><strong>运行结果：</strong></p>\n<p>/source/img/201807/view_model1.png<br>/source/img/201807/view_model2.png</p>\n<p>在旋转屏幕后计时器继续未重置。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>modified: 2018-08-09</p>\n<h1 id=\"Android生命周期感知组件介绍-Android-lifecycle-aware-components\"><a href=\"#Android生命周期感知组件介绍-Android-lifecycle-aware-components\" class=\"headerlink\" title=\"Android生命周期感知组件介绍(Android lifecycle-aware components)\"></a>Android生命周期感知组件介绍(Android lifecycle-aware components)</h1><h2 id=\"lifecycle-aware组件介绍\"><a href=\"#lifecycle-aware组件介绍\" class=\"headerlink\" title=\"lifecycle-aware组件介绍\"></a>lifecycle-aware组件介绍</h2><ul>\n<li><strong>ViewModel：</strong>为绑定在特定生命周期的对象提供创建以及恢复的方法，<code>ViewModel</code>通常保存<code>View</code>的数据或者用于与其他组件进行通信，例如data repository</li>\n<li><strong>LifecycleOwner/LifecycleRegisterOwner：</strong><code>LifecycleOwner</code>以及<code>LifecycleRegisterOwner</code>都是需要在<code>AppCompatActivity</code>或者<code>Support Fragment</code>类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。</li>\n<li><strong>LiveData:</strong>通过<code>LiveData</code>可以通过多个组件来观察到数据的变化。<code>LiveData</code>不会影响应用中的组件如：Activity、Service、Fragment或者其他<code>LifecycleOwner</code>的生命周期。<code>LiveData</code>可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。</li>\n</ul>\n<h2 id=\"布局文件中添加计时器\"><a href=\"#布局文件中添加计时器\" class=\"headerlink\" title=\"布局文件中添加计时器\"></a>布局文件中添加计时器</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Chronometer</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/chronometer\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:text</span>=<span class=\"string\">\"Hello World!\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintBottom_toBottomOf</span>=<span class=\"string\">\"parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintLeft_toLeftOf</span>=<span class=\"string\">\"parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintRight_toRightOf</span>=<span class=\"string\">\"parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:layout_constraintTop_toTopOf</span>=<span class=\"string\">\"parent\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);</span><br><span class=\"line\">        chronometer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当旋转屏幕时，由于Activity重建，使得计时器被重置</strong></p>\n<h2 id=\"添加ViewMedel\"><a href=\"#添加ViewMedel\" class=\"headerlink\" title=\"添加ViewMedel\"></a>添加ViewMedel</h2><p>添加<code>ViewModel</code>来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用<code>ViewModel</code>也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。</p>\n<h3 id=\"使用ViewModel来留存计时器（Chronometer）的状态\"><a href=\"#使用ViewModel来留存计时器（Chronometer）的状态\" class=\"headerlink\" title=\"使用ViewModel来留存计时器（Chronometer）的状态\"></a>使用ViewModel来留存计时器（<code>Chronometer</code>）的状态</h3><p>ChronometerViewModel中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChronometerViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Long&gt;mElapsedTime=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mInitialTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChronometerViewModel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        mInitialTime= SystemClock.elapsedRealtime();</span><br><span class=\"line\"></span><br><span class=\"line\">        Timer timer=<span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">        timer.scheduleAtFixedRate(<span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newValue=(SystemClock.elapsedRealtime()-mInitialTime)/<span class=\"number\">1000</span>;</span><br><span class=\"line\">                 mElapsedTime.postValue(newValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;Long&gt;getElapsedTime()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mElapsedTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在MainActivity中添加代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>this</code>指代的是<code>LifecycleOwner</code>的一个实例，<code>ViewModel</code>与<code>LifecycleOwner</code>保活时间一样长，当<code>ViewModel</code>的所有者的配置信息（如：屏幕旋转）发生变化时，<code>ViewModel</code>不会被销毁，当其所有者重新被实例化时，会与已经存在的<code>ViewModel</code>重新建立联系。其生命周期如图所示：</p>\n<p>/source/img/201807/view_model.png</p>\n<h2 id=\"将Activity中使用的数据使用LiveData进行封装\"><a href=\"#将Activity中使用的数据使用LiveData进行封装\" class=\"headerlink\" title=\"将Activity中使用的数据使用LiveData进行封装\"></a>将Activity中使用的数据使用LiveData进行封装</h2><p>将计时控件<code>chronometer</code>使用<code>Timer</code>来设置，每隔一秒钟更新一次UI，将相应的代码放在<code>ChronometerViewModel</code>中，而让Activity只保持用户与UI之间的交流操作。</p>\n<p>MainActivity中的完整代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ChronometerViewModel chronometerViewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">         chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">         subscribe();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;Long&gt;elapseTimeObserver=<span class=\"keyword\">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Long aLong)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+<span class=\"string\">\"秒\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        chronometerViewModel.getElapsedTime().observe(<span class=\"keyword\">this</span>,elapseTimeObserver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>timer</code>每隔一秒<strong><em>通知</em></strong><code>MainActivity</code>时，<code>MainActivity</code>将会更新一下UI，为避免内存泄漏，<code>ViewModel</code>中没有指向Activity的引用。</p>\n<p><code>ViewModel</code>并不直接改变View，在使用<code>ViewModel</code>中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。</p>\n<p><strong>注：为了将数据暴露给观察者，需要使用<code>LiveData</code>对数据进行封装</strong></p>\n<p><code>LiveData</code>是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。</p>\n<p><strong>运行结果：</strong></p>\n<p>/source/img/201807/view_model1.png<br>/source/img/201807/view_model2.png</p>\n<p>在旋转屏幕后计时器继续未重置。</p>\n"},{"title":"Android 6.0及以上手机权限进行动态获取","thumbnail":"/assets/android_basis_permission.png","toc":true,"_content":"\n\n## 在Android 6.0及以上需要对手机权限进行动态获取\n\n如果手机版本为Android 6.0(API 23)或更高版本，以及app的`targetSdkVersion`为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。\n\n<!--more-->\n\n**同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。** *同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如`Manifest.permission.BLUETOOTH`在动态申请时同样不会出现权限申请对话框，但会回调*\n< !--more-->\nAndroid动态权限的申请仅对下图中的9大权限组进行申请\n![](/assets/android_basis_permission.png)\n\n### 一、对于可选硬件功能权限的获取\n\n使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加`<uses-feature> `\n```html\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n```\n当声明为`android:required=\"false\"`时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要`PackageManager.hasSystemFeature()`来确定该设备是否存在；当声明为`android:required=\"true\"`时，需要手机上具有该设备，否则不能进行安装操作。\n\n### 二、代码实现\n\n```java\n\n    String[] permissions = {Manifest.permission.BLUETOOTH};\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //只有系统API大于23时，才需要判断权限是否需要获取\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            //用于判断权限是否已经获取\n            int i = ContextCompat.checkSelfPermission(this, permissions[0]);\n            //权限是否已经获取 GRANTED--授权 DINED--拒绝\n            if (i != PackageManager.PERMISSION_GRANTED) {\n                //如果没有被授予该权限，提示用户请求该权限\n                ActivityCompat.requestPermissions(this, permissions, 1);\n            }else {\n                Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                           @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode==1){\n            //未获取到权限\n            if (grantResults[0] != PackageManager.PERMISSION_GRANTED) {\n                //判断用户是否点击了不再提醒；检测该权限是否还可以再申请\n                boolean result = this.shouldShowRequestPermissionRationale(permissions[0]);\n                //如果不可以再申请\n                if (!result) {\n                    //用户需要继续使用App\n                    //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示\n                    LogUtils.printInfo(\"请到设置界面开启相应权限\");\n                }else {\n                    //如果可以再申请\n                    Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show();\n                }\n            }\n        }\n    }\n```\n\n### 三、连续多次申请权限出现问题\n在进行连续多次申请时，在回调函数`onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)`的`permissions`数组会返回长度为零的数组，因为在Activity的`requestPermissions()`方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行`onRequestPermissionsResult`方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；\n\n```java\n    //Activity源码\n    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {\n        //省略部分代码\n        if (mHasCurrentPermissionsRequest) {\n            Log.w(TAG, \"Can request only one set of permissions at a time\");\n            // Dispatch the callback with empty arrays which means a cancellation.\n            onRequestPermissionsResult(requestCode, new String[0], new int[0]);\n            return;\n        }\n        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);\n        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);\n        mHasCurrentPermissionsRequest = true;\n    }\n```\n\n\n### 四、其他\n\n有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。\n```xml\n\n```\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Android 6.0动态权限获取.md","raw":"---\ntitle: Android 6.0及以上手机权限进行动态获取\nthumbnail: /assets/android_basis_permission.png\ntoc: true\n\ncategories: Android\ntags: [Android]\n---\n\n\n## 在Android 6.0及以上需要对手机权限进行动态获取\n\n如果手机版本为Android 6.0(API 23)或更高版本，以及app的`targetSdkVersion`为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。\n\n<!--more-->\n\n**同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。** *同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如`Manifest.permission.BLUETOOTH`在动态申请时同样不会出现权限申请对话框，但会回调*\n< !--more-->\nAndroid动态权限的申请仅对下图中的9大权限组进行申请\n![](/assets/android_basis_permission.png)\n\n### 一、对于可选硬件功能权限的获取\n\n使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加`<uses-feature> `\n```html\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n```\n当声明为`android:required=\"false\"`时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要`PackageManager.hasSystemFeature()`来确定该设备是否存在；当声明为`android:required=\"true\"`时，需要手机上具有该设备，否则不能进行安装操作。\n\n### 二、代码实现\n\n```java\n\n    String[] permissions = {Manifest.permission.BLUETOOTH};\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //只有系统API大于23时，才需要判断权限是否需要获取\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            //用于判断权限是否已经获取\n            int i = ContextCompat.checkSelfPermission(this, permissions[0]);\n            //权限是否已经获取 GRANTED--授权 DINED--拒绝\n            if (i != PackageManager.PERMISSION_GRANTED) {\n                //如果没有被授予该权限，提示用户请求该权限\n                ActivityCompat.requestPermissions(this, permissions, 1);\n            }else {\n                Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                           @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode==1){\n            //未获取到权限\n            if (grantResults[0] != PackageManager.PERMISSION_GRANTED) {\n                //判断用户是否点击了不再提醒；检测该权限是否还可以再申请\n                boolean result = this.shouldShowRequestPermissionRationale(permissions[0]);\n                //如果不可以再申请\n                if (!result) {\n                    //用户需要继续使用App\n                    //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示\n                    LogUtils.printInfo(\"请到设置界面开启相应权限\");\n                }else {\n                    //如果可以再申请\n                    Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show();\n                }\n            }\n        }\n    }\n```\n\n### 三、连续多次申请权限出现问题\n在进行连续多次申请时，在回调函数`onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)`的`permissions`数组会返回长度为零的数组，因为在Activity的`requestPermissions()`方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行`onRequestPermissionsResult`方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；\n\n```java\n    //Activity源码\n    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {\n        //省略部分代码\n        if (mHasCurrentPermissionsRequest) {\n            Log.w(TAG, \"Can request only one set of permissions at a time\");\n            // Dispatch the callback with empty arrays which means a cancellation.\n            onRequestPermissionsResult(requestCode, new String[0], new int[0]);\n            return;\n        }\n        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);\n        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);\n        mHasCurrentPermissionsRequest = true;\n    }\n```\n\n\n### 四、其他\n\n有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。\n```xml\n\n```\n\n\n\n\n\n\n\n\n","slug":"Android/Android基础/Android 6.0动态权限获取","published":1,"date":"2019-09-19T09:34:08.480Z","updated":"2020-02-29T02:07:06.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryh80025isui466416rx","content":"<h2 id=\"在Android-6-0及以上需要对手机权限进行动态获取\"><a href=\"#在Android-6-0及以上需要对手机权限进行动态获取\" class=\"headerlink\" title=\"在Android 6.0及以上需要对手机权限进行动态获取\"></a>在Android 6.0及以上需要对手机权限进行动态获取</h2><p>如果手机版本为Android 6.0(API 23)或更高版本，以及app的<code>targetSdkVersion</code>为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。</p>\n<a id=\"more\"></a>\n\n<p><strong>同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。</strong> <em>同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如<code>Manifest.permission.BLUETOOTH</code>在动态申请时同样不会出现权限申请对话框，但会回调</em><br>&lt; !–more–&gt;<br>Android动态权限的申请仅对下图中的9大权限组进行申请<br><img src=\"/assets/android_basis_permission.png\" alt=\"\"></p>\n<h3 id=\"一、对于可选硬件功能权限的获取\"><a href=\"#一、对于可选硬件功能权限的获取\" class=\"headerlink\" title=\"一、对于可选硬件功能权限的获取\"></a>一、对于可选硬件功能权限的获取</h3><p>使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加<code>&lt;uses-feature&gt;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-feature</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.hardware.camera\"</span> <span class=\"attr\">android:required</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当声明为<code>android:required=&quot;false&quot;</code>时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要<code>PackageManager.hasSystemFeature()</code>来确定该设备是否存在；当声明为<code>android:required=&quot;true&quot;</code>时，需要手机上具有该设备，否则不能进行安装操作。</p>\n<h3 id=\"二、代码实现\"><a href=\"#二、代码实现\" class=\"headerlink\" title=\"二、代码实现\"></a>二、代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String[] permissions = &#123;Manifest.permission.BLUETOOTH&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    <span class=\"comment\">//只有系统API大于23时，才需要判断权限是否需要获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断权限是否已经获取</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = ContextCompat.checkSelfPermission(<span class=\"keyword\">this</span>, permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//权限是否已经获取 GRANTED--授权 DINED--拒绝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有被授予该权限，提示用户请求该权限</span></span><br><span class=\"line\">            ActivityCompat.requestPermissions(<span class=\"keyword\">this</span>, permissions, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"权限已获取\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, @NonNull String[] permissions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//未获取到权限</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grantResults[<span class=\"number\">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断用户是否点击了不再提醒；检测该权限是否还可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.shouldShowRequestPermissionRationale(permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//如果不可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用户需要继续使用App</span></span><br><span class=\"line\">                <span class=\"comment\">//提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示</span></span><br><span class=\"line\">                LogUtils.printInfo(<span class=\"string\">\"请到设置界面开启相应权限\"</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果可以再申请</span></span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"请开启权限权限\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、连续多次申请权限出现问题\"><a href=\"#三、连续多次申请权限出现问题\" class=\"headerlink\" title=\"三、连续多次申请权限出现问题\"></a>三、连续多次申请权限出现问题</h3><p>在进行连续多次申请时，在回调函数<code>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)</code>的<code>permissions</code>数组会返回长度为零的数组，因为在Activity的<code>requestPermissions()</code>方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行<code>onRequestPermissionsResult</code>方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">requestPermissions</span><span class=\"params\">(@NonNull String[] permissions, <span class=\"keyword\">int</span> requestCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">\"Can request only one set of permissions at a time\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class=\"line\">        onRequestPermissionsResult(requestCode, <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class=\"line\">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mHasCurrentPermissionsRequest = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"四、其他\"><a href=\"#四、其他\" class=\"headerlink\" title=\"四、其他\"></a>四、其他</h3><p>有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"在Android-6-0及以上需要对手机权限进行动态获取\"><a href=\"#在Android-6-0及以上需要对手机权限进行动态获取\" class=\"headerlink\" title=\"在Android 6.0及以上需要对手机权限进行动态获取\"></a>在Android 6.0及以上需要对手机权限进行动态获取</h2><p>如果手机版本为Android 6.0(API 23)或更高版本，以及app的<code>targetSdkVersion</code>为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。</p>","more":"<p><strong>同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。</strong> <em>同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如<code>Manifest.permission.BLUETOOTH</code>在动态申请时同样不会出现权限申请对话框，但会回调</em><br>&lt; !–more–&gt;<br>Android动态权限的申请仅对下图中的9大权限组进行申请<br><img src=\"/assets/android_basis_permission.png\" alt=\"\"></p>\n<h3 id=\"一、对于可选硬件功能权限的获取\"><a href=\"#一、对于可选硬件功能权限的获取\" class=\"headerlink\" title=\"一、对于可选硬件功能权限的获取\"></a>一、对于可选硬件功能权限的获取</h3><p>使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加<code>&lt;uses-feature&gt;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-feature</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.hardware.camera\"</span> <span class=\"attr\">android:required</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当声明为<code>android:required=&quot;false&quot;</code>时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要<code>PackageManager.hasSystemFeature()</code>来确定该设备是否存在；当声明为<code>android:required=&quot;true&quot;</code>时，需要手机上具有该设备，否则不能进行安装操作。</p>\n<h3 id=\"二、代码实现\"><a href=\"#二、代码实现\" class=\"headerlink\" title=\"二、代码实现\"></a>二、代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String[] permissions = &#123;Manifest.permission.BLUETOOTH&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    <span class=\"comment\">//只有系统API大于23时，才需要判断权限是否需要获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断权限是否已经获取</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = ContextCompat.checkSelfPermission(<span class=\"keyword\">this</span>, permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//权限是否已经获取 GRANTED--授权 DINED--拒绝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有被授予该权限，提示用户请求该权限</span></span><br><span class=\"line\">            ActivityCompat.requestPermissions(<span class=\"keyword\">this</span>, permissions, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"权限已获取\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, @NonNull String[] permissions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//未获取到权限</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grantResults[<span class=\"number\">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断用户是否点击了不再提醒；检测该权限是否还可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.shouldShowRequestPermissionRationale(permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//如果不可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用户需要继续使用App</span></span><br><span class=\"line\">                <span class=\"comment\">//提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示</span></span><br><span class=\"line\">                LogUtils.printInfo(<span class=\"string\">\"请到设置界面开启相应权限\"</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果可以再申请</span></span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"请开启权限权限\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、连续多次申请权限出现问题\"><a href=\"#三、连续多次申请权限出现问题\" class=\"headerlink\" title=\"三、连续多次申请权限出现问题\"></a>三、连续多次申请权限出现问题</h3><p>在进行连续多次申请时，在回调函数<code>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)</code>的<code>permissions</code>数组会返回长度为零的数组，因为在Activity的<code>requestPermissions()</code>方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行<code>onRequestPermissionsResult</code>方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">requestPermissions</span><span class=\"params\">(@NonNull String[] permissions, <span class=\"keyword\">int</span> requestCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">\"Can request only one set of permissions at a time\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class=\"line\">        onRequestPermissionsResult(requestCode, <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class=\"line\">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mHasCurrentPermissionsRequest = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"四、其他\"><a href=\"#四、其他\" class=\"headerlink\" title=\"四、其他\"></a>四、其他</h3><p>有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"_content":"# Android后台处理介绍\n\nAndroid手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。\n\n## 推荐在后台进行处理的三种情况\n\n### App处理操作是否可以滞后进行，或者需要实时处理\n\n例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行\n\n### App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\n\n例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。\n\n### App操作处理是否是由系统进行触发\n\n系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。\n\n#### 加一个选择策略图片\n\n## 线程池\n\n对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。\n\n* 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁\n\n## Foreground Service操作\n\n对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。\n\n## Workmanager\n\n对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0\\(API 23\\)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。\n\n## 后台进程操作的限制\n\n为了最大化利用电池以及更好的App使用体验，Android会限制App\\(或者一个forceground service notification\\)，当其对用户不可见时。\n\n* Android 6.0\\(Api 23\\)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。\n* Android 7.0\\(Api 24\\)限制隐式广播。\n* Android 8.0\\(Api 26\\)限制更多的后台操作，包括后台获取地址信息以及释放缓存。\n\n","source":"_posts/Android/Android基础/Android后台任务.md","raw":"# Android后台处理介绍\n\nAndroid手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。\n\n## 推荐在后台进行处理的三种情况\n\n### App处理操作是否可以滞后进行，或者需要实时处理\n\n例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行\n\n### App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\n\n例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。\n\n### App操作处理是否是由系统进行触发\n\n系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。\n\n#### 加一个选择策略图片\n\n## 线程池\n\n对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。\n\n* 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁\n\n## Foreground Service操作\n\n对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。\n\n## Workmanager\n\n对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0\\(API 23\\)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。\n\n## 后台进程操作的限制\n\n为了最大化利用电池以及更好的App使用体验，Android会限制App\\(或者一个forceground service notification\\)，当其对用户不可见时。\n\n* Android 6.0\\(Api 23\\)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。\n* Android 7.0\\(Api 24\\)限制隐式广播。\n* Android 8.0\\(Api 26\\)限制更多的后台操作，包括后台获取地址信息以及释放缓存。\n\n","slug":"Android/Android基础/Android后台任务","published":1,"date":"2019-09-30T08:26:59.176Z","updated":"2019-09-30T08:28:42.954Z","title":"Android/Android基础/Android后台任务","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryh90027isui9z27hnv4","content":"<h1 id=\"Android后台处理介绍\"><a href=\"#Android后台处理介绍\" class=\"headerlink\" title=\"Android后台处理介绍\"></a>Android后台处理介绍</h1><p>Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。</p>\n<h2 id=\"推荐在后台进行处理的三种情况\"><a href=\"#推荐在后台进行处理的三种情况\" class=\"headerlink\" title=\"推荐在后台进行处理的三种情况\"></a>推荐在后台进行处理的三种情况</h2><h3 id=\"App处理操作是否可以滞后进行，或者需要实时处理\"><a href=\"#App处理操作是否可以滞后进行，或者需要实时处理\" class=\"headerlink\" title=\"App处理操作是否可以滞后进行，或者需要实时处理\"></a>App处理操作是否可以滞后进行，或者需要实时处理</h3><p>例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行</p>\n<h3 id=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\"><a href=\"#App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\" class=\"headerlink\" title=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\"></a>App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理</h3><p>例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。</p>\n<h3 id=\"App操作处理是否是由系统进行触发\"><a href=\"#App操作处理是否是由系统进行触发\" class=\"headerlink\" title=\"App操作处理是否是由系统进行触发\"></a>App操作处理是否是由系统进行触发</h3><p>系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。</p>\n<h4 id=\"加一个选择策略图片\"><a href=\"#加一个选择策略图片\" class=\"headerlink\" title=\"加一个选择策略图片\"></a>加一个选择策略图片</h4><h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。</p>\n<ul>\n<li>注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁</li>\n</ul>\n<h2 id=\"Foreground-Service操作\"><a href=\"#Foreground-Service操作\" class=\"headerlink\" title=\"Foreground Service操作\"></a>Foreground Service操作</h2><p>对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。</p>\n<h2 id=\"Workmanager\"><a href=\"#Workmanager\" class=\"headerlink\" title=\"Workmanager\"></a>Workmanager</h2><p>对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。</p>\n<h2 id=\"后台进程操作的限制\"><a href=\"#后台进程操作的限制\" class=\"headerlink\" title=\"后台进程操作的限制\"></a>后台进程操作的限制</h2><p>为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。</p>\n<ul>\n<li>Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。</li>\n<li>Android 7.0(Api 24)限制隐式广播。</li>\n<li>Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android后台处理介绍\"><a href=\"#Android后台处理介绍\" class=\"headerlink\" title=\"Android后台处理介绍\"></a>Android后台处理介绍</h1><p>Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。</p>\n<h2 id=\"推荐在后台进行处理的三种情况\"><a href=\"#推荐在后台进行处理的三种情况\" class=\"headerlink\" title=\"推荐在后台进行处理的三种情况\"></a>推荐在后台进行处理的三种情况</h2><h3 id=\"App处理操作是否可以滞后进行，或者需要实时处理\"><a href=\"#App处理操作是否可以滞后进行，或者需要实时处理\" class=\"headerlink\" title=\"App处理操作是否可以滞后进行，或者需要实时处理\"></a>App处理操作是否可以滞后进行，或者需要实时处理</h3><p>例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行</p>\n<h3 id=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\"><a href=\"#App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\" class=\"headerlink\" title=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\"></a>App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理</h3><p>例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。</p>\n<h3 id=\"App操作处理是否是由系统进行触发\"><a href=\"#App操作处理是否是由系统进行触发\" class=\"headerlink\" title=\"App操作处理是否是由系统进行触发\"></a>App操作处理是否是由系统进行触发</h3><p>系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。</p>\n<h4 id=\"加一个选择策略图片\"><a href=\"#加一个选择策略图片\" class=\"headerlink\" title=\"加一个选择策略图片\"></a>加一个选择策略图片</h4><h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。</p>\n<ul>\n<li>注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁</li>\n</ul>\n<h2 id=\"Foreground-Service操作\"><a href=\"#Foreground-Service操作\" class=\"headerlink\" title=\"Foreground Service操作\"></a>Foreground Service操作</h2><p>对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。</p>\n<h2 id=\"Workmanager\"><a href=\"#Workmanager\" class=\"headerlink\" title=\"Workmanager\"></a>Workmanager</h2><p>对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。</p>\n<h2 id=\"后台进程操作的限制\"><a href=\"#后台进程操作的限制\" class=\"headerlink\" title=\"后台进程操作的限制\"></a>后台进程操作的限制</h2><p>为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。</p>\n<ul>\n<li>Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。</li>\n<li>Android 7.0(Api 24)限制隐式广播。</li>\n<li>Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。</li>\n</ul>\n"},{"_content":"\n## Android序列化\n\nAndroid序列化对象的方法有两种：\n\n* 实现Serializable接口，Java自带\n* 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）","source":"_posts/Android/Android基础/Android序列化.md","raw":"\n## Android序列化\n\nAndroid序列化对象的方法有两种：\n\n* 实现Serializable接口，Java自带\n* 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）","slug":"Android/Android基础/Android序列化","published":1,"date":"2019-11-28T12:20:15.894Z","updated":"2019-11-30T11:14:32.183Z","title":"Android/Android基础/Android序列化","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhb0029isuie7kgd8tr","content":"<h2 id=\"Android序列化\"><a href=\"#Android序列化\" class=\"headerlink\" title=\"Android序列化\"></a>Android序列化</h2><p>Android序列化对象的方法有两种：</p>\n<ul>\n<li>实现Serializable接口，Java自带</li>\n<li>实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android序列化\"><a href=\"#Android序列化\" class=\"headerlink\" title=\"Android序列化\"></a>Android序列化</h2><p>Android序列化对象的方法有两种：</p>\n<ul>\n<li>实现Serializable接口，Java自带</li>\n<li>实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）</li>\n</ul>\n"},{"_content":"## Android文件的读和写\n\n1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；\n2、SD卡中的文件；\n3、数据区(/data/data/..)的文件；\n\n### 资源文件的读写\n\nraw使用InputStream in = getResources().openRawResource(R.raw.test);\nasset使用InputStream in = getResources().getAssets().open(fileName);\n\n### Android应用数据私有目录存储（位于应用功能安装目录下）\n\n该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。\n\n文件类型：\n/data/data/包名/cache ：存放的是APP的缓存信息\n/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码\n/data/data/包名/files ： 存放APP的文件信息\n\n还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。\n\n私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录\n\n`context.getCacheDir()`用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间\n\n\n#### 文件读操作\n\n#### 文件写操作\n\n\n### Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\n\n该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。\n\n\n\n* 首先需要获取权限\n\n```xml\n\n     <!--用于获取文件操作的权限-->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n* 需要确定写入文件目录是否存在，如果不存在，则需要新建目录\n\n\n\n### Android存储公有目录\nAndorid开发公有目录与Context无关，使用Environment进行获取\n\n* Environment.DIRECTORY_PICTURES 图片目录\n* Environment.DIRECTORY_DCIM 相册目录\n* Environment.DIRECTORY_DOCUMENTS 文档目录\n* Environment.DIRECTORY_DOWNLOADS 下载目录\n* Environment.DIRECTORY_MOVIES 视频\n\n```java\n    //有参\n    Environment.getExternalStoragePublicDirectory(String type) ;\n    //无参\n    Environment.getExternalStoragePublicDirectory();\n\n```\n\n\n### Android本地文件选择\n","source":"_posts/Android/Android基础/Android文件操作.md","raw":"## Android文件的读和写\n\n1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；\n2、SD卡中的文件；\n3、数据区(/data/data/..)的文件；\n\n### 资源文件的读写\n\nraw使用InputStream in = getResources().openRawResource(R.raw.test);\nasset使用InputStream in = getResources().getAssets().open(fileName);\n\n### Android应用数据私有目录存储（位于应用功能安装目录下）\n\n该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。\n\n文件类型：\n/data/data/包名/cache ：存放的是APP的缓存信息\n/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码\n/data/data/包名/files ： 存放APP的文件信息\n\n还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。\n\n私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录\n\n`context.getCacheDir()`用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间\n\n\n#### 文件读操作\n\n#### 文件写操作\n\n\n### Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\n\n该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。\n\n\n\n* 首先需要获取权限\n\n```xml\n\n     <!--用于获取文件操作的权限-->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n* 需要确定写入文件目录是否存在，如果不存在，则需要新建目录\n\n\n\n### Android存储公有目录\nAndorid开发公有目录与Context无关，使用Environment进行获取\n\n* Environment.DIRECTORY_PICTURES 图片目录\n* Environment.DIRECTORY_DCIM 相册目录\n* Environment.DIRECTORY_DOCUMENTS 文档目录\n* Environment.DIRECTORY_DOWNLOADS 下载目录\n* Environment.DIRECTORY_MOVIES 视频\n\n```java\n    //有参\n    Environment.getExternalStoragePublicDirectory(String type) ;\n    //无参\n    Environment.getExternalStoragePublicDirectory();\n\n```\n\n\n### Android本地文件选择\n","slug":"Android/Android基础/Android文件操作","published":1,"date":"2019-09-19T09:34:08.482Z","updated":"2019-09-30T08:28:42.954Z","title":"Android/Android基础/Android文件操作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhb002aisuid9nm7zyw","content":"<h2 id=\"Android文件的读和写\"><a href=\"#Android文件的读和写\" class=\"headerlink\" title=\"Android文件的读和写\"></a>Android文件的读和写</h2><p>1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；<br>2、SD卡中的文件；<br>3、数据区(/data/data/..)的文件；</p>\n<h3 id=\"资源文件的读写\"><a href=\"#资源文件的读写\" class=\"headerlink\" title=\"资源文件的读写\"></a>资源文件的读写</h3><p>raw使用InputStream in = getResources().openRawResource(R.raw.test);<br>asset使用InputStream in = getResources().getAssets().open(fileName);</p>\n<h3 id=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"><a href=\"#Android应用数据私有目录存储（位于应用功能安装目录下）\" class=\"headerlink\" title=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"></a>Android应用数据私有目录存储（位于应用功能安装目录下）</h3><p>该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。</p>\n<p>文件类型：<br>/data/data/包名/cache ：存放的是APP的缓存信息<br>/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码<br>/data/data/包名/files ： 存放APP的文件信息</p>\n<p>还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。</p>\n<p>私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录</p>\n<p><code>context.getCacheDir()</code>用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间</p>\n<h4 id=\"文件读操作\"><a href=\"#文件读操作\" class=\"headerlink\" title=\"文件读操作\"></a>文件读操作</h4><h4 id=\"文件写操作\"><a href=\"#文件写操作\" class=\"headerlink\" title=\"文件写操作\"></a>文件写操作</h4><h3 id=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"><a href=\"#Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\" class=\"headerlink\" title=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"></a>Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）</h3><p>该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。</p>\n<ul>\n<li>首先需要获取权限</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--用于获取文件操作的权限--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.READ_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.WRITE_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要确定写入文件目录是否存在，如果不存在，则需要新建目录</li>\n</ul>\n<h3 id=\"Android存储公有目录\"><a href=\"#Android存储公有目录\" class=\"headerlink\" title=\"Android存储公有目录\"></a>Android存储公有目录</h3><p>Andorid开发公有目录与Context无关，使用Environment进行获取</p>\n<ul>\n<li>Environment.DIRECTORY_PICTURES 图片目录</li>\n<li>Environment.DIRECTORY_DCIM 相册目录</li>\n<li>Environment.DIRECTORY_DOCUMENTS 文档目录</li>\n<li>Environment.DIRECTORY_DOWNLOADS 下载目录</li>\n<li>Environment.DIRECTORY_MOVIES 视频</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory(String type) ;</span><br><span class=\"line\"><span class=\"comment\">//无参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory();</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Android本地文件选择\"><a href=\"#Android本地文件选择\" class=\"headerlink\" title=\"Android本地文件选择\"></a>Android本地文件选择</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android文件的读和写\"><a href=\"#Android文件的读和写\" class=\"headerlink\" title=\"Android文件的读和写\"></a>Android文件的读和写</h2><p>1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；<br>2、SD卡中的文件；<br>3、数据区(/data/data/..)的文件；</p>\n<h3 id=\"资源文件的读写\"><a href=\"#资源文件的读写\" class=\"headerlink\" title=\"资源文件的读写\"></a>资源文件的读写</h3><p>raw使用InputStream in = getResources().openRawResource(R.raw.test);<br>asset使用InputStream in = getResources().getAssets().open(fileName);</p>\n<h3 id=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"><a href=\"#Android应用数据私有目录存储（位于应用功能安装目录下）\" class=\"headerlink\" title=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"></a>Android应用数据私有目录存储（位于应用功能安装目录下）</h3><p>该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。</p>\n<p>文件类型：<br>/data/data/包名/cache ：存放的是APP的缓存信息<br>/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码<br>/data/data/包名/files ： 存放APP的文件信息</p>\n<p>还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。</p>\n<p>私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录</p>\n<p><code>context.getCacheDir()</code>用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间</p>\n<h4 id=\"文件读操作\"><a href=\"#文件读操作\" class=\"headerlink\" title=\"文件读操作\"></a>文件读操作</h4><h4 id=\"文件写操作\"><a href=\"#文件写操作\" class=\"headerlink\" title=\"文件写操作\"></a>文件写操作</h4><h3 id=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"><a href=\"#Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\" class=\"headerlink\" title=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"></a>Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）</h3><p>该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。</p>\n<ul>\n<li>首先需要获取权限</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--用于获取文件操作的权限--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.READ_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.WRITE_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要确定写入文件目录是否存在，如果不存在，则需要新建目录</li>\n</ul>\n<h3 id=\"Android存储公有目录\"><a href=\"#Android存储公有目录\" class=\"headerlink\" title=\"Android存储公有目录\"></a>Android存储公有目录</h3><p>Andorid开发公有目录与Context无关，使用Environment进行获取</p>\n<ul>\n<li>Environment.DIRECTORY_PICTURES 图片目录</li>\n<li>Environment.DIRECTORY_DCIM 相册目录</li>\n<li>Environment.DIRECTORY_DOCUMENTS 文档目录</li>\n<li>Environment.DIRECTORY_DOWNLOADS 下载目录</li>\n<li>Environment.DIRECTORY_MOVIES 视频</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory(String type) ;</span><br><span class=\"line\"><span class=\"comment\">//无参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory();</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Android本地文件选择\"><a href=\"#Android本地文件选择\" class=\"headerlink\" title=\"Android本地文件选择\"></a>Android本地文件选择</h3>"},{"_content":"# Handler介绍\n\nHandler直接继承于Object类\n\nHandler与一个线程的`MessageQueue`进行绑定，可以用于`Message`的发送与处理以及`Runnable`对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的`Message Queue`相绑定，它可以将messages以及runnables对象传递到`Message Queue`，并对`Message Queue`中的messages以及runnables对象进行处理。\n\nHandler使用的两个主要方面：\n1、对messages以及runnables在将来某一个节点执行进行调度；\n2、在非当前线程执行其他操作\n\nHandler对Message的调度通过`post(Runnable)`, `postAtTime(Runnable, long)`, `postDelayed(Runnable, Object, long)`, `sendEmptyMessage(int)`, `sendMessage(Message)`, `sendMessageAtTime(Message, long)`, 以及·、`sendMessageDelayed(Message, long) `等方法进行，`post`方法可以将`Runnable`对象插入到队列中，当消息队列收到`Runnable`对象时，可以执行。`sendMessage`方法可以将`Message`对象（其中包含大量数据）插入到队列中，通过`HandlerMessage`方法进行处理。\n\n当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。\n\n当应用程序创建一个进程之后，它的主线程用于持有的`Message Queue`用于管理“顶级”的应用对象(`Activity` `Broadcast Receiver`等)和他们创建的窗口。当创建自己的线程时，可以通过`Handler`与应用的主线程进行信息交换。\n\n# Looper介绍\n\nLooper直接继承于Object\n\nLooper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的`prepare()`方法来运行一个loop，`loop()`方法用来处理message。\n\n与message loop进行大部分交互都是通过`Handler`类来进行。\n\n下列代码是实现一个`Looper`线程的方式，通过分离开的`prepare()`以及`loop()`方法初始化一个Handler与Looper进行交互。\n\n\n```java\n\n class LooperThread extends Thread {\n  \n      public Handler mHandler;\n\n      public void run() {\n          Looper.prepare();\n\n          mHandler = new Handler() {\n              public void handleMessage(Message msg) {\n                  // process incoming messages here\n              }\n          };\n\n          Looper.loop();\n      }\n  }\n\n```\n\n# MessageQueue介绍\n\nMessageQueue直接继承于Object\n\nMessage不能直接添加至`Message Queue`中，需要通过与`Looper`相关联的`Handler`对象来实现。通过`Looper.myQueue`方法可以从当前线程中获取`MessageQueue`\n\n\n### 从源码角度分析Handler、Looper、MessageQueue三者之间的关系\n\n`Handler`默认构造函数`Handler()`，将自己与当前线程的`Looper`进行绑定，如果当前线程中没有`Looper`对象，会报出异常。\n\n```\n  \n    //Handler源码117行\n    public Handler() {\n        this(null, false);\n    }\n    \n    //Handler源码131行\n      public Handler(Callback callback) {\n        this(callback, false);\n    }\n    \n    \n```\n\n通过`Looper.prepare();`为当前线程设置一个`Looper`\n具体流程：\n其中`prepare()`方法是`Looper`类中的静态方法；在`prepare(boolean quitAllowed)`方法中调用`sThreadLocal.set(new Looper(quitAllowed));`当前线程设置一个新的`Looper`在构造函数`Looper(boolean quitAllowed)`中，该`Looper`创建了一个新的`MessageQueue`(mQueue = new MessageQueue(quitAllowed););\n\n```\n\n    //Looper源码97行\n       public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n    \n    \n    //Looper源码267行\n        private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n```\n\n\n在Handler源码的192行中，通过`mLooper = Looper.myLooper();`来获取当前线程中的`Looper`\n\n```\n\n     //Handler源码192行\n  public Handler(Callback callback, boolean async) {\n      \n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n\n   //Looper71行\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n\n   //Looper97行\n\n   //Looper源码254行\n     public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n\n## Handler发送消息机制\n\nHandler调用` sendMessage(Message msg)`方法最终会一步一步调用`sendMessageAtTime(Message msg, long uptimeMillis)`在该方法中通过`MessageQueue queue = mQueue;`获取到MessageQueue，调用  用`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`方法将`Message`加入到消息队列中\n\n```\n   //Handler源码中的689行\n       public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n## Handler消息处理机制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Handler Looper介绍.md","raw":"# Handler介绍\n\nHandler直接继承于Object类\n\nHandler与一个线程的`MessageQueue`进行绑定，可以用于`Message`的发送与处理以及`Runnable`对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的`Message Queue`相绑定，它可以将messages以及runnables对象传递到`Message Queue`，并对`Message Queue`中的messages以及runnables对象进行处理。\n\nHandler使用的两个主要方面：\n1、对messages以及runnables在将来某一个节点执行进行调度；\n2、在非当前线程执行其他操作\n\nHandler对Message的调度通过`post(Runnable)`, `postAtTime(Runnable, long)`, `postDelayed(Runnable, Object, long)`, `sendEmptyMessage(int)`, `sendMessage(Message)`, `sendMessageAtTime(Message, long)`, 以及·、`sendMessageDelayed(Message, long) `等方法进行，`post`方法可以将`Runnable`对象插入到队列中，当消息队列收到`Runnable`对象时，可以执行。`sendMessage`方法可以将`Message`对象（其中包含大量数据）插入到队列中，通过`HandlerMessage`方法进行处理。\n\n当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。\n\n当应用程序创建一个进程之后，它的主线程用于持有的`Message Queue`用于管理“顶级”的应用对象(`Activity` `Broadcast Receiver`等)和他们创建的窗口。当创建自己的线程时，可以通过`Handler`与应用的主线程进行信息交换。\n\n# Looper介绍\n\nLooper直接继承于Object\n\nLooper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的`prepare()`方法来运行一个loop，`loop()`方法用来处理message。\n\n与message loop进行大部分交互都是通过`Handler`类来进行。\n\n下列代码是实现一个`Looper`线程的方式，通过分离开的`prepare()`以及`loop()`方法初始化一个Handler与Looper进行交互。\n\n\n```java\n\n class LooperThread extends Thread {\n  \n      public Handler mHandler;\n\n      public void run() {\n          Looper.prepare();\n\n          mHandler = new Handler() {\n              public void handleMessage(Message msg) {\n                  // process incoming messages here\n              }\n          };\n\n          Looper.loop();\n      }\n  }\n\n```\n\n# MessageQueue介绍\n\nMessageQueue直接继承于Object\n\nMessage不能直接添加至`Message Queue`中，需要通过与`Looper`相关联的`Handler`对象来实现。通过`Looper.myQueue`方法可以从当前线程中获取`MessageQueue`\n\n\n### 从源码角度分析Handler、Looper、MessageQueue三者之间的关系\n\n`Handler`默认构造函数`Handler()`，将自己与当前线程的`Looper`进行绑定，如果当前线程中没有`Looper`对象，会报出异常。\n\n```\n  \n    //Handler源码117行\n    public Handler() {\n        this(null, false);\n    }\n    \n    //Handler源码131行\n      public Handler(Callback callback) {\n        this(callback, false);\n    }\n    \n    \n```\n\n通过`Looper.prepare();`为当前线程设置一个`Looper`\n具体流程：\n其中`prepare()`方法是`Looper`类中的静态方法；在`prepare(boolean quitAllowed)`方法中调用`sThreadLocal.set(new Looper(quitAllowed));`当前线程设置一个新的`Looper`在构造函数`Looper(boolean quitAllowed)`中，该`Looper`创建了一个新的`MessageQueue`(mQueue = new MessageQueue(quitAllowed););\n\n```\n\n    //Looper源码97行\n       public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n    \n    \n    //Looper源码267行\n        private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n```\n\n\n在Handler源码的192行中，通过`mLooper = Looper.myLooper();`来获取当前线程中的`Looper`\n\n```\n\n     //Handler源码192行\n  public Handler(Callback callback, boolean async) {\n      \n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n\n   //Looper71行\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n\n   //Looper97行\n\n   //Looper源码254行\n     public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n\n## Handler发送消息机制\n\nHandler调用` sendMessage(Message msg)`方法最终会一步一步调用`sendMessageAtTime(Message msg, long uptimeMillis)`在该方法中通过`MessageQueue queue = mQueue;`获取到MessageQueue，调用  用`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`方法将`Message`加入到消息队列中\n\n```\n   //Handler源码中的689行\n       public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n## Handler消息处理机制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android基础/Handler Looper介绍","published":1,"date":"2019-09-30T07:19:02.820Z","updated":"2019-09-30T08:28:42.955Z","title":"Android/Android基础/Handler Looper介绍","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhc002disui0cdi94bt","content":"<h1 id=\"Handler介绍\"><a href=\"#Handler介绍\" class=\"headerlink\" title=\"Handler介绍\"></a>Handler介绍</h1><p>Handler直接继承于Object类</p>\n<p>Handler与一个线程的<code>MessageQueue</code>进行绑定，可以用于<code>Message</code>的发送与处理以及<code>Runnable</code>对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的<code>Message Queue</code>相绑定，它可以将messages以及runnables对象传递到<code>Message Queue</code>，并对<code>Message Queue</code>中的messages以及runnables对象进行处理。</p>\n<p>Handler使用的两个主要方面：<br>1、对messages以及runnables在将来某一个节点执行进行调度；<br>2、在非当前线程执行其他操作</p>\n<p>Handler对Message的调度通过<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, 以及·、<code>sendMessageDelayed(Message, long)</code>等方法进行，<code>post</code>方法可以将<code>Runnable</code>对象插入到队列中，当消息队列收到<code>Runnable</code>对象时，可以执行。<code>sendMessage</code>方法可以将<code>Message</code>对象（其中包含大量数据）插入到队列中，通过<code>HandlerMessage</code>方法进行处理。</p>\n<p>当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。</p>\n<p>当应用程序创建一个进程之后，它的主线程用于持有的<code>Message Queue</code>用于管理“顶级”的应用对象(<code>Activity</code> <code>Broadcast Receiver</code>等)和他们创建的窗口。当创建自己的线程时，可以通过<code>Handler</code>与应用的主线程进行信息交换。</p>\n<h1 id=\"Looper介绍\"><a href=\"#Looper介绍\" class=\"headerlink\" title=\"Looper介绍\"></a>Looper介绍</h1><p>Looper直接继承于Object</p>\n<p>Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的<code>prepare()</code>方法来运行一个loop，<code>loop()</code>方法用来处理message。</p>\n<p>与message loop进行大部分交互都是通过<code>Handler</code>类来进行。</p>\n<p>下列代码是实现一个<code>Looper</code>线程的方式，通过分离开的<code>prepare()</code>以及<code>loop()</code>方法初始化一个Handler与Looper进行交互。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         Looper.prepare();</span><br><span class=\"line\"></span><br><span class=\"line\">         mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         Looper.loop();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"MessageQueue介绍\"><a href=\"#MessageQueue介绍\" class=\"headerlink\" title=\"MessageQueue介绍\"></a>MessageQueue介绍</h1><p>MessageQueue直接继承于Object</p>\n<p>Message不能直接添加至<code>Message Queue</code>中，需要通过与<code>Looper</code>相关联的<code>Handler</code>对象来实现。通过<code>Looper.myQueue</code>方法可以从当前线程中获取<code>MessageQueue</code></p>\n<h3 id=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"><a href=\"#从源码角度分析Handler、Looper、MessageQueue三者之间的关系\" class=\"headerlink\" title=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"></a>从源码角度分析Handler、Looper、MessageQueue三者之间的关系</h3><p><code>Handler</code>默认构造函数<code>Handler()</code>，将自己与当前线程的<code>Looper</code>进行绑定，如果当前线程中没有<code>Looper</code>对象，会报出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">&#x2F;&#x2F;Handler源码117行</span><br><span class=\"line\">public Handler() &#123;</span><br><span class=\"line\">    this(null, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Handler源码131行</span><br><span class=\"line\">  public Handler(Callback callback) &#123;</span><br><span class=\"line\">    this(callback, false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>Looper.prepare();</code>为当前线程设置一个<code>Looper</code><br>具体流程：<br>其中<code>prepare()</code>方法是<code>Looper</code>类中的静态方法；在<code>prepare(boolean quitAllowed)</code>方法中调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>当前线程设置一个新的<code>Looper</code>在构造函数<code>Looper(boolean quitAllowed)</code>中，该<code>Looper</code>创建了一个新的<code>MessageQueue</code>(mQueue = new MessageQueue(quitAllowed););</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码97行</span><br><span class=\"line\">   public static void prepare() &#123;</span><br><span class=\"line\">    prepare(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void prepare(boolean quitAllowed) &#123;</span><br><span class=\"line\">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class=\"line\">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码267行</span><br><span class=\"line\">    private Looper(boolean quitAllowed) &#123;</span><br><span class=\"line\">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread &#x3D; Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在Handler源码的192行中，通过<code>mLooper = Looper.myLooper();</code>来获取当前线程中的<code>Looper</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;Handler源码192行</span><br><span class=\"line\">public Handler(Callback callback, boolean async) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      mLooper &#x3D; Looper.myLooper();</span><br><span class=\"line\">      if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(</span><br><span class=\"line\">              &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class=\"line\">                      + &quot; that has not called Looper.prepare()&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mQueue &#x3D; mLooper.mQueue;</span><br><span class=\"line\">      mCallback &#x3D; callback;</span><br><span class=\"line\">      mAsynchronous &#x3D; async;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper71行</span><br><span class=\"line\">  static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper97行</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper源码254行</span><br><span class=\"line\">   public static @Nullable Looper myLooper() &#123;</span><br><span class=\"line\">      return sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Handler发送消息机制\"><a href=\"#Handler发送消息机制\" class=\"headerlink\" title=\"Handler发送消息机制\"></a>Handler发送消息机制</h2><p>Handler调用<code>sendMessage(Message msg)</code>方法最终会一步一步调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>在该方法中通过<code>MessageQueue queue = mQueue;</code>获取到MessageQueue，调用  用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>方法将<code>Message</code>加入到消息队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Handler源码中的689行</span><br><span class=\"line\">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">     MessageQueue queue &#x3D; mQueue;</span><br><span class=\"line\">     if (queue &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">         RuntimeException e &#x3D; new RuntimeException(</span><br><span class=\"line\">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Handler消息处理机制\"><a href=\"#Handler消息处理机制\" class=\"headerlink\" title=\"Handler消息处理机制\"></a>Handler消息处理机制</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Handler介绍\"><a href=\"#Handler介绍\" class=\"headerlink\" title=\"Handler介绍\"></a>Handler介绍</h1><p>Handler直接继承于Object类</p>\n<p>Handler与一个线程的<code>MessageQueue</code>进行绑定，可以用于<code>Message</code>的发送与处理以及<code>Runnable</code>对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的<code>Message Queue</code>相绑定，它可以将messages以及runnables对象传递到<code>Message Queue</code>，并对<code>Message Queue</code>中的messages以及runnables对象进行处理。</p>\n<p>Handler使用的两个主要方面：<br>1、对messages以及runnables在将来某一个节点执行进行调度；<br>2、在非当前线程执行其他操作</p>\n<p>Handler对Message的调度通过<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, 以及·、<code>sendMessageDelayed(Message, long)</code>等方法进行，<code>post</code>方法可以将<code>Runnable</code>对象插入到队列中，当消息队列收到<code>Runnable</code>对象时，可以执行。<code>sendMessage</code>方法可以将<code>Message</code>对象（其中包含大量数据）插入到队列中，通过<code>HandlerMessage</code>方法进行处理。</p>\n<p>当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。</p>\n<p>当应用程序创建一个进程之后，它的主线程用于持有的<code>Message Queue</code>用于管理“顶级”的应用对象(<code>Activity</code> <code>Broadcast Receiver</code>等)和他们创建的窗口。当创建自己的线程时，可以通过<code>Handler</code>与应用的主线程进行信息交换。</p>\n<h1 id=\"Looper介绍\"><a href=\"#Looper介绍\" class=\"headerlink\" title=\"Looper介绍\"></a>Looper介绍</h1><p>Looper直接继承于Object</p>\n<p>Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的<code>prepare()</code>方法来运行一个loop，<code>loop()</code>方法用来处理message。</p>\n<p>与message loop进行大部分交互都是通过<code>Handler</code>类来进行。</p>\n<p>下列代码是实现一个<code>Looper</code>线程的方式，通过分离开的<code>prepare()</code>以及<code>loop()</code>方法初始化一个Handler与Looper进行交互。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         Looper.prepare();</span><br><span class=\"line\"></span><br><span class=\"line\">         mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         Looper.loop();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"MessageQueue介绍\"><a href=\"#MessageQueue介绍\" class=\"headerlink\" title=\"MessageQueue介绍\"></a>MessageQueue介绍</h1><p>MessageQueue直接继承于Object</p>\n<p>Message不能直接添加至<code>Message Queue</code>中，需要通过与<code>Looper</code>相关联的<code>Handler</code>对象来实现。通过<code>Looper.myQueue</code>方法可以从当前线程中获取<code>MessageQueue</code></p>\n<h3 id=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"><a href=\"#从源码角度分析Handler、Looper、MessageQueue三者之间的关系\" class=\"headerlink\" title=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"></a>从源码角度分析Handler、Looper、MessageQueue三者之间的关系</h3><p><code>Handler</code>默认构造函数<code>Handler()</code>，将自己与当前线程的<code>Looper</code>进行绑定，如果当前线程中没有<code>Looper</code>对象，会报出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">&#x2F;&#x2F;Handler源码117行</span><br><span class=\"line\">public Handler() &#123;</span><br><span class=\"line\">    this(null, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Handler源码131行</span><br><span class=\"line\">  public Handler(Callback callback) &#123;</span><br><span class=\"line\">    this(callback, false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>Looper.prepare();</code>为当前线程设置一个<code>Looper</code><br>具体流程：<br>其中<code>prepare()</code>方法是<code>Looper</code>类中的静态方法；在<code>prepare(boolean quitAllowed)</code>方法中调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>当前线程设置一个新的<code>Looper</code>在构造函数<code>Looper(boolean quitAllowed)</code>中，该<code>Looper</code>创建了一个新的<code>MessageQueue</code>(mQueue = new MessageQueue(quitAllowed););</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码97行</span><br><span class=\"line\">   public static void prepare() &#123;</span><br><span class=\"line\">    prepare(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void prepare(boolean quitAllowed) &#123;</span><br><span class=\"line\">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class=\"line\">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码267行</span><br><span class=\"line\">    private Looper(boolean quitAllowed) &#123;</span><br><span class=\"line\">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread &#x3D; Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在Handler源码的192行中，通过<code>mLooper = Looper.myLooper();</code>来获取当前线程中的<code>Looper</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;Handler源码192行</span><br><span class=\"line\">public Handler(Callback callback, boolean async) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      mLooper &#x3D; Looper.myLooper();</span><br><span class=\"line\">      if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(</span><br><span class=\"line\">              &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class=\"line\">                      + &quot; that has not called Looper.prepare()&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mQueue &#x3D; mLooper.mQueue;</span><br><span class=\"line\">      mCallback &#x3D; callback;</span><br><span class=\"line\">      mAsynchronous &#x3D; async;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper71行</span><br><span class=\"line\">  static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper97行</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper源码254行</span><br><span class=\"line\">   public static @Nullable Looper myLooper() &#123;</span><br><span class=\"line\">      return sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Handler发送消息机制\"><a href=\"#Handler发送消息机制\" class=\"headerlink\" title=\"Handler发送消息机制\"></a>Handler发送消息机制</h2><p>Handler调用<code>sendMessage(Message msg)</code>方法最终会一步一步调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>在该方法中通过<code>MessageQueue queue = mQueue;</code>获取到MessageQueue，调用  用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>方法将<code>Message</code>加入到消息队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Handler源码中的689行</span><br><span class=\"line\">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">     MessageQueue queue &#x3D; mQueue;</span><br><span class=\"line\">     if (queue &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">         RuntimeException e &#x3D; new RuntimeException(</span><br><span class=\"line\">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Handler消息处理机制\"><a href=\"#Handler消息处理机制\" class=\"headerlink\" title=\"Handler消息处理机制\"></a>Handler消息处理机制</h2>"},{"_content":"\n\n## SharedPreference的使用\n\n### 保存数据\n\n### 读取数据","source":"_posts/Android/Android基础/数据储存.md","raw":"\n\n## SharedPreference的使用\n\n### 保存数据\n\n### 读取数据","slug":"Android/Android基础/数据储存","published":1,"date":"2019-11-28T12:20:15.895Z","updated":"2019-11-30T11:14:32.183Z","title":"Android/Android基础/数据储存","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhd002eisui61yj2hsr","content":"<h2 id=\"SharedPreference的使用\"><a href=\"#SharedPreference的使用\" class=\"headerlink\" title=\"SharedPreference的使用\"></a>SharedPreference的使用</h2><h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><h3 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SharedPreference的使用\"><a href=\"#SharedPreference的使用\" class=\"headerlink\" title=\"SharedPreference的使用\"></a>SharedPreference的使用</h2><h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><h3 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h3>"},{"_content":"getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；\n\n|传入的Name|返回的对象|说明|\n|------|------|------|\n|WINDOW_SERVICE|WindowManager|管理打开的窗口程序|\n|LAYOUT_INFLATER_SERVICE|\tLayoutInflater\t|取得xml里定义的view\n|ACTIVITY_SERVICE\t|ActivityManager\t|管理应用程序的系统状态\n|POWER_SERVICE\t|PowerManger\t|电源的服务\n|ALARM_SERVICE\t|AlarmManager|\t闹钟的服务\n|NOTIFICATION_SERVICE\t|NotificationManager\t|状态栏的服务\n|KEYGUARD_SERVICE\t|KeyguardManager\t|键盘锁的服务\n|LOCATION_SERVICE\t|LocationManager\t|位置的服务，如GPS\n|SEARCH_SERVICE\t|SearchManager\t|搜索的服务\n|VEBRATOR_SERVICE|\tVebrator|\t手机震动的服务\n|CONNECTIVITY_SERVICE\t|Connectivity\t|网络连接的服务\n|WIFI_SERVICE\t|WifiManager\t|Wi-Fi服务\n|TELEPHONY_SERVICE\t|TeleponyManager\t|电话服务","source":"_posts/Android/Android基础/getSystemService的使用.md","raw":"getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；\n\n|传入的Name|返回的对象|说明|\n|------|------|------|\n|WINDOW_SERVICE|WindowManager|管理打开的窗口程序|\n|LAYOUT_INFLATER_SERVICE|\tLayoutInflater\t|取得xml里定义的view\n|ACTIVITY_SERVICE\t|ActivityManager\t|管理应用程序的系统状态\n|POWER_SERVICE\t|PowerManger\t|电源的服务\n|ALARM_SERVICE\t|AlarmManager|\t闹钟的服务\n|NOTIFICATION_SERVICE\t|NotificationManager\t|状态栏的服务\n|KEYGUARD_SERVICE\t|KeyguardManager\t|键盘锁的服务\n|LOCATION_SERVICE\t|LocationManager\t|位置的服务，如GPS\n|SEARCH_SERVICE\t|SearchManager\t|搜索的服务\n|VEBRATOR_SERVICE|\tVebrator|\t手机震动的服务\n|CONNECTIVITY_SERVICE\t|Connectivity\t|网络连接的服务\n|WIFI_SERVICE\t|WifiManager\t|Wi-Fi服务\n|TELEPHONY_SERVICE\t|TeleponyManager\t|电话服务","slug":"Android/Android基础/getSystemService的使用","published":1,"date":"2019-09-30T07:19:02.815Z","updated":"2019-09-30T08:28:42.956Z","title":"Android/Android基础/getSystemService的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhd002gisui9bcv4u8o","content":"<p>getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；</p>\n<table>\n<thead>\n<tr>\n<th>传入的Name</th>\n<th>返回的对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WINDOW_SERVICE</td>\n<td>WindowManager</td>\n<td>管理打开的窗口程序</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td>LayoutInflater</td>\n<td>取得xml里定义的view</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td>ActivityManager</td>\n<td>管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td>PowerManger</td>\n<td>电源的服务</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td>AlarmManager</td>\n<td>闹钟的服务</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td>NotificationManager</td>\n<td>状态栏的服务</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td>KeyguardManager</td>\n<td>键盘锁的服务</td>\n</tr>\n<tr>\n<td>LOCATION_SERVICE</td>\n<td>LocationManager</td>\n<td>位置的服务，如GPS</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td>SearchManager</td>\n<td>搜索的服务</td>\n</tr>\n<tr>\n<td>VEBRATOR_SERVICE</td>\n<td>Vebrator</td>\n<td>手机震动的服务</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td>Connectivity</td>\n<td>网络连接的服务</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td>WifiManager</td>\n<td>Wi-Fi服务</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td>TeleponyManager</td>\n<td>电话服务</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；</p>\n<table>\n<thead>\n<tr>\n<th>传入的Name</th>\n<th>返回的对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WINDOW_SERVICE</td>\n<td>WindowManager</td>\n<td>管理打开的窗口程序</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td>LayoutInflater</td>\n<td>取得xml里定义的view</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td>ActivityManager</td>\n<td>管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td>PowerManger</td>\n<td>电源的服务</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td>AlarmManager</td>\n<td>闹钟的服务</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td>NotificationManager</td>\n<td>状态栏的服务</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td>KeyguardManager</td>\n<td>键盘锁的服务</td>\n</tr>\n<tr>\n<td>LOCATION_SERVICE</td>\n<td>LocationManager</td>\n<td>位置的服务，如GPS</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td>SearchManager</td>\n<td>搜索的服务</td>\n</tr>\n<tr>\n<td>VEBRATOR_SERVICE</td>\n<td>Vebrator</td>\n<td>手机震动的服务</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td>Connectivity</td>\n<td>网络连接的服务</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td>WifiManager</td>\n<td>Wi-Fi服务</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td>TeleponyManager</td>\n<td>电话服务</td>\n</tr>\n</tbody></table>\n"},{"_content":"\n\n**知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor**\n\n一个AsyncTask对象被创建出来后,就只能执行一个异步任务。\n\n\nAsyncTask<Params,Progress,Result>是一个抽象类，继承AsyncTask需要指定三个泛型参数\n* Params：启动任务时输入的参数类型\n* Progress：后台任务执行中返回进度值的类型\n* Result：后台任务执行完成后返回结果类型\n\nAsyncTask中三个重要函数\n\n* doInBackground：异步执行后台线程要完成的任务在此方法中进行\n* onPreExecute：执行后台耗时操作前调用，通常用于初始化操作\n* onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI\n* onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。\n","source":"_posts/Android/Android基础/异步操作Asynctask.md","raw":"\n\n**知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor**\n\n一个AsyncTask对象被创建出来后,就只能执行一个异步任务。\n\n\nAsyncTask<Params,Progress,Result>是一个抽象类，继承AsyncTask需要指定三个泛型参数\n* Params：启动任务时输入的参数类型\n* Progress：后台任务执行中返回进度值的类型\n* Result：后台任务执行完成后返回结果类型\n\nAsyncTask中三个重要函数\n\n* doInBackground：异步执行后台线程要完成的任务在此方法中进行\n* onPreExecute：执行后台耗时操作前调用，通常用于初始化操作\n* onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI\n* onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。\n","slug":"Android/Android基础/异步操作Asynctask","published":1,"date":"2019-09-30T07:19:02.827Z","updated":"2019-09-30T08:28:42.957Z","title":"Android/Android基础/异步操作Asynctask","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhe002iisuiazkqcon6","content":"<p><strong>知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor</strong></p>\n<p>一个AsyncTask对象被创建出来后,就只能执行一个异步任务。</p>\n<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数</p>\n<ul>\n<li>Params：启动任务时输入的参数类型</li>\n<li>Progress：后台任务执行中返回进度值的类型</li>\n<li>Result：后台任务执行完成后返回结果类型</li>\n</ul>\n<p>AsyncTask中三个重要函数</p>\n<ul>\n<li>doInBackground：异步执行后台线程要完成的任务在此方法中进行</li>\n<li>onPreExecute：执行后台耗时操作前调用，通常用于初始化操作</li>\n<li>onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI</li>\n<li>onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor</strong></p>\n<p>一个AsyncTask对象被创建出来后,就只能执行一个异步任务。</p>\n<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数</p>\n<ul>\n<li>Params：启动任务时输入的参数类型</li>\n<li>Progress：后台任务执行中返回进度值的类型</li>\n<li>Result：后台任务执行完成后返回结果类型</li>\n</ul>\n<p>AsyncTask中三个重要函数</p>\n<ul>\n<li>doInBackground：异步执行后台线程要完成的任务在此方法中进行</li>\n<li>onPreExecute：执行后台耗时操作前调用，通常用于初始化操作</li>\n<li>onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI</li>\n<li>onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。</li>\n</ul>\n"},{"_content":"# Android 蓝牙4.0开发\n\n这是一条优雅的分割线\n\n### 写在前面：\n\n本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0\n\n尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。\n\n\n### 首先对蓝牙进行非专业的介绍，\n\n蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！\n\n### 对GATT的介绍\n\n\n\n\n\n按照惯例先上代码\n\n优雅的代码\n\n##3 权限的获取\n\n蓝牙4.0有一个坑爹的权限是位置信息的获取\n\n\n### 蓝牙搜索\n蓝牙的搜索有三种方式\n* 方法一：`BluetoothAdapter.startDiscovery()`是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；\n蓝牙扫描广播接收器\n\n```java\n\n//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果\nprivate class DeviceReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if(BluetoothDevice.ACTION_FOUND.equals(action)){\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  \n        }\n    }\n}\n```\n\n* 方法二：`BluetoothAdapter.startScan(ScanCallback callback)`在`ScanCallback`的`onScanResult(int callbackType, ScanResult result)`方法中，通过`result.getDevice()`可获取扫描到的Ble设备\n* 方法三：`BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)`\n  该方法已经被舍弃\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Ble/Android ble 4.0.md","raw":"# Android 蓝牙4.0开发\n\n这是一条优雅的分割线\n\n### 写在前面：\n\n本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0\n\n尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。\n\n\n### 首先对蓝牙进行非专业的介绍，\n\n蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！\n\n### 对GATT的介绍\n\n\n\n\n\n按照惯例先上代码\n\n优雅的代码\n\n##3 权限的获取\n\n蓝牙4.0有一个坑爹的权限是位置信息的获取\n\n\n### 蓝牙搜索\n蓝牙的搜索有三种方式\n* 方法一：`BluetoothAdapter.startDiscovery()`是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；\n蓝牙扫描广播接收器\n\n```java\n\n//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果\nprivate class DeviceReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if(BluetoothDevice.ACTION_FOUND.equals(action)){\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  \n        }\n    }\n}\n```\n\n* 方法二：`BluetoothAdapter.startScan(ScanCallback callback)`在`ScanCallback`的`onScanResult(int callbackType, ScanResult result)`方法中，通过`result.getDevice()`可获取扫描到的Ble设备\n* 方法三：`BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)`\n  该方法已经被舍弃\n\n\n\n\n\n\n\n\n\n","slug":"Android/Ble/Android ble 4.0","published":1,"date":"2019-09-19T09:41:14.744Z","updated":"2019-09-19T09:41:14.745Z","title":"Android/Ble/Android ble 4.0","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhe002jisuid2743vwq","content":"<h1 id=\"Android-蓝牙4-0开发\"><a href=\"#Android-蓝牙4-0开发\" class=\"headerlink\" title=\"Android 蓝牙4.0开发\"></a>Android 蓝牙4.0开发</h1><p>这是一条优雅的分割线</p>\n<h3 id=\"写在前面：\"><a href=\"#写在前面：\" class=\"headerlink\" title=\"写在前面：\"></a>写在前面：</h3><p>本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0</p>\n<p>尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。</p>\n<h3 id=\"首先对蓝牙进行非专业的介绍，\"><a href=\"#首先对蓝牙进行非专业的介绍，\" class=\"headerlink\" title=\"首先对蓝牙进行非专业的介绍，\"></a>首先对蓝牙进行非专业的介绍，</h3><p>蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！</p>\n<h3 id=\"对GATT的介绍\"><a href=\"#对GATT的介绍\" class=\"headerlink\" title=\"对GATT的介绍\"></a>对GATT的介绍</h3><p>按照惯例先上代码</p>\n<p>优雅的代码</p>\n<p>##3 权限的获取</p>\n<p>蓝牙4.0有一个坑爹的权限是位置信息的获取</p>\n<h3 id=\"蓝牙搜索\"><a href=\"#蓝牙搜索\" class=\"headerlink\" title=\"蓝牙搜索\"></a>蓝牙搜索</h3><p>蓝牙的搜索有三种方式</p>\n<ul>\n<li>方法一：<code>BluetoothAdapter.startDiscovery()</code>是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；<br>蓝牙扫描广播接收器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeviceReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BluetoothDevice.ACTION_FOUND.equals(action))&#123;</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法二：<code>BluetoothAdapter.startScan(ScanCallback callback)</code>在<code>ScanCallback</code>的<code>onScanResult(int callbackType, ScanResult result)</code>方法中，通过<code>result.getDevice()</code>可获取扫描到的Ble设备</li>\n<li>方法三：<code>BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)</code><br>该方法已经被舍弃</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-蓝牙4-0开发\"><a href=\"#Android-蓝牙4-0开发\" class=\"headerlink\" title=\"Android 蓝牙4.0开发\"></a>Android 蓝牙4.0开发</h1><p>这是一条优雅的分割线</p>\n<h3 id=\"写在前面：\"><a href=\"#写在前面：\" class=\"headerlink\" title=\"写在前面：\"></a>写在前面：</h3><p>本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0</p>\n<p>尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。</p>\n<h3 id=\"首先对蓝牙进行非专业的介绍，\"><a href=\"#首先对蓝牙进行非专业的介绍，\" class=\"headerlink\" title=\"首先对蓝牙进行非专业的介绍，\"></a>首先对蓝牙进行非专业的介绍，</h3><p>蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！</p>\n<h3 id=\"对GATT的介绍\"><a href=\"#对GATT的介绍\" class=\"headerlink\" title=\"对GATT的介绍\"></a>对GATT的介绍</h3><p>按照惯例先上代码</p>\n<p>优雅的代码</p>\n<p>##3 权限的获取</p>\n<p>蓝牙4.0有一个坑爹的权限是位置信息的获取</p>\n<h3 id=\"蓝牙搜索\"><a href=\"#蓝牙搜索\" class=\"headerlink\" title=\"蓝牙搜索\"></a>蓝牙搜索</h3><p>蓝牙的搜索有三种方式</p>\n<ul>\n<li>方法一：<code>BluetoothAdapter.startDiscovery()</code>是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；<br>蓝牙扫描广播接收器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeviceReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BluetoothDevice.ACTION_FOUND.equals(action))&#123;</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法二：<code>BluetoothAdapter.startScan(ScanCallback callback)</code>在<code>ScanCallback</code>的<code>onScanResult(int callbackType, ScanResult result)</code>方法中，通过<code>result.getDevice()</code>可获取扫描到的Ble设备</li>\n<li>方法三：<code>BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)</code><br>该方法已经被舍弃</li>\n</ul>\n"},{"_content":"### 查看签名文件信息\n\n密码是password\n\n```\n    keytool -list -v -keystore application.jks -storepass password\n```","source":"_posts/Android/Other/常用操作.md","raw":"### 查看签名文件信息\n\n密码是password\n\n```\n    keytool -list -v -keystore application.jks -storepass password\n```","slug":"Android/Other/常用操作","published":1,"date":"2019-09-30T08:28:42.959Z","updated":"2019-09-30T08:28:42.960Z","title":"Android/Other/常用操作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhf002kisuifed5fs53","content":"<h3 id=\"查看签名文件信息\"><a href=\"#查看签名文件信息\" class=\"headerlink\" title=\"查看签名文件信息\"></a>查看签名文件信息</h3><p>密码是password</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -v -keystore application.jks -storepass password</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"查看签名文件信息\"><a href=\"#查看签名文件信息\" class=\"headerlink\" title=\"查看签名文件信息\"></a>查看签名文件信息</h3><p>密码是password</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -v -keystore application.jks -storepass password</span><br></pre></td></tr></table></figure>"},{"_content":"# 使用自定义View实现倒计时功能\n\n当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。\n\n## 倒计时控件实现的功能\n\n* 显示时间进度\n* 计时结束后将会自动跳转到下一个Activity中\n\n实现效果如图所示\n\n在本篇博客中的代码会有部分缺省，源码链接\n\n## 对自定义View的尺寸进行测量并绘制中间的大圆\n\nView在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。\n\n```text\npublic class CountDownView extends android.support.v7.widget.AppCompatTextView {\n\n    private int circleRadius;\n\n    private int circleColor=0xff33b5e5;\n\n    private Paint circlePaint;\n    private Rect bounds;\n\n    private int centerX;\n    private int centerY;\n\n    public CountDownView(Context context) {\n        super(context);\n        init();\n    }\n\n    public void init(){\n        circlePaint=new Paint();\n        bounds=new Rect();\n\n    }\n\n    public CountDownView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n\n        circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;\n        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        getDrawingRect(bounds);      //获取控件的边界\n\n        centerX=bounds.centerX();\n        centerY=bounds.centerY();\n\n        //绘制中间的大圆的背景\n        circlePaint.setAntiAlias(true);\n        circlePaint.setStyle(Paint.Style.FILL);\n        circlePaint.setColor(circleColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);\n\n    }\n}\n```\n\n在activity\\_main.xml中添加自定义控件\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    tools:context=\".MainActivity\">\n\n    <com.example.wyw.countdowndemo.CountDownView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        />\n\n</LinearLayout>\n```\n\n运行结果\n\n## 绘制进度边框\n\n```text\n    private int cirlceBoundColor=0xff00ddff;\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setStyle(Paint.Style.STROKE);\n        circlePaint.setStrokeWidth(5);\n        circlePaint.setColor(cirlceBoundColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);\n\n    }\n```\n\n## 绘制进度条的一条弧线\n\n进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线\n\n```text\n    private RectF arcRectF;\n    private int processColor=0xff99cc00;\n\n    public void init(){\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setColor(processColor);\n        //设置线冒样式\n        circlePaint.setStrokeCap(Paint.Cap.ROUND);\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,40,false,circlePaint);\n\n    }\n```\n\n## 进度条按照通过Timer不断控制绘制角度的增加\n\n```text\n    private int currentDrawTime;    //已经绘制的次数\n    private Timer timer;\n\n    public void init(){\n        timer=new Timer();\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);\n\n    }\n\n    public void drawProcess(){\n\n        currentDrawTime=0;\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n               postInvalidate();\n               currentDrawTime++;\n               if (currentDrawTime==8)\n                   timer.cancel();\n            }\n        },500,500);\n\n    }\n```\n\n## 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\n\n```text\n    @Override\n    protected void onDraw(Canvas canvas) {\n     Paint paint = getPaint();\n        float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;\n        paint.setAntiAlias(true);  //防锯齿\n        paint.setColor(Color.WHITE);\n        paint.setTextAlign(Paint.Align.CENTER);\n        canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint);\n\n    }\n```\n\n","source":"_posts/Android/View/CountDownView.md","raw":"# 使用自定义View实现倒计时功能\n\n当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。\n\n## 倒计时控件实现的功能\n\n* 显示时间进度\n* 计时结束后将会自动跳转到下一个Activity中\n\n实现效果如图所示\n\n在本篇博客中的代码会有部分缺省，源码链接\n\n## 对自定义View的尺寸进行测量并绘制中间的大圆\n\nView在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。\n\n```text\npublic class CountDownView extends android.support.v7.widget.AppCompatTextView {\n\n    private int circleRadius;\n\n    private int circleColor=0xff33b5e5;\n\n    private Paint circlePaint;\n    private Rect bounds;\n\n    private int centerX;\n    private int centerY;\n\n    public CountDownView(Context context) {\n        super(context);\n        init();\n    }\n\n    public void init(){\n        circlePaint=new Paint();\n        bounds=new Rect();\n\n    }\n\n    public CountDownView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n\n        circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;\n        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        getDrawingRect(bounds);      //获取控件的边界\n\n        centerX=bounds.centerX();\n        centerY=bounds.centerY();\n\n        //绘制中间的大圆的背景\n        circlePaint.setAntiAlias(true);\n        circlePaint.setStyle(Paint.Style.FILL);\n        circlePaint.setColor(circleColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);\n\n    }\n}\n```\n\n在activity\\_main.xml中添加自定义控件\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    tools:context=\".MainActivity\">\n\n    <com.example.wyw.countdowndemo.CountDownView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        />\n\n</LinearLayout>\n```\n\n运行结果\n\n## 绘制进度边框\n\n```text\n    private int cirlceBoundColor=0xff00ddff;\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setStyle(Paint.Style.STROKE);\n        circlePaint.setStrokeWidth(5);\n        circlePaint.setColor(cirlceBoundColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);\n\n    }\n```\n\n## 绘制进度条的一条弧线\n\n进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线\n\n```text\n    private RectF arcRectF;\n    private int processColor=0xff99cc00;\n\n    public void init(){\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setColor(processColor);\n        //设置线冒样式\n        circlePaint.setStrokeCap(Paint.Cap.ROUND);\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,40,false,circlePaint);\n\n    }\n```\n\n## 进度条按照通过Timer不断控制绘制角度的增加\n\n```text\n    private int currentDrawTime;    //已经绘制的次数\n    private Timer timer;\n\n    public void init(){\n        timer=new Timer();\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);\n\n    }\n\n    public void drawProcess(){\n\n        currentDrawTime=0;\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n               postInvalidate();\n               currentDrawTime++;\n               if (currentDrawTime==8)\n                   timer.cancel();\n            }\n        },500,500);\n\n    }\n```\n\n## 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\n\n```text\n    @Override\n    protected void onDraw(Canvas canvas) {\n     Paint paint = getPaint();\n        float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;\n        paint.setAntiAlias(true);  //防锯齿\n        paint.setColor(Color.WHITE);\n        paint.setTextAlign(Paint.Align.CENTER);\n        canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint);\n\n    }\n```\n\n","slug":"Android/View/CountDownView","published":1,"date":"2019-09-19T09:41:14.745Z","updated":"2019-09-19T09:41:14.746Z","title":"Android/View/CountDownView","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhf002lisui72488ciu","content":"<h1 id=\"使用自定义View实现倒计时功能\"><a href=\"#使用自定义View实现倒计时功能\" class=\"headerlink\" title=\"使用自定义View实现倒计时功能\"></a>使用自定义View实现倒计时功能</h1><p>当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。</p>\n<h2 id=\"倒计时控件实现的功能\"><a href=\"#倒计时控件实现的功能\" class=\"headerlink\" title=\"倒计时控件实现的功能\"></a>倒计时控件实现的功能</h2><ul>\n<li>显示时间进度</li>\n<li>计时结束后将会自动跳转到下一个Activity中</li>\n</ul>\n<p>实现效果如图所示</p>\n<p>在本篇博客中的代码会有部分缺省，源码链接</p>\n<h2 id=\"对自定义View的尺寸进行测量并绘制中间的大圆\"><a href=\"#对自定义View的尺寸进行测量并绘制中间的大圆\" class=\"headerlink\" title=\"对自定义View的尺寸进行测量并绘制中间的大圆\"></a>对自定义View的尺寸进行测量并绘制中间的大圆</h2><p>View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CountDownView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleColor&#x3D;0xff33b5e5;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Paint circlePaint;</span><br><span class=\"line\">    private Rect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int centerX;</span><br><span class=\"line\">    private int centerY;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        circlePaint&#x3D;new Paint();</span><br><span class=\"line\">        bounds&#x3D;new Rect();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        super.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        circleRadius&#x3D;getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()&#x2F;2:getMeasuredWidth()&#x2F;2;</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\">        getDrawingRect(bounds);      &#x2F;&#x2F;获取控件的边界</span><br><span class=\"line\"></span><br><span class=\"line\">        centerX&#x3D;bounds.centerX();</span><br><span class=\"line\">        centerY&#x3D;bounds.centerY();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;绘制中间的大圆的背景</span><br><span class=\"line\">        circlePaint.setAntiAlias(true);</span><br><span class=\"line\">        circlePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        circlePaint.setColor(circleColor);</span><br><span class=\"line\">        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在activity_main.xml中添加自定义控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.example.wyw.countdowndemo.CountDownView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<h2 id=\"绘制进度边框\"><a href=\"#绘制进度边框\" class=\"headerlink\" title=\"绘制进度边框\"></a>绘制进度边框</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int cirlceBoundColor&#x3D;0xff00ddff;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">    circlePaint.setStrokeWidth(5);</span><br><span class=\"line\">    circlePaint.setColor(cirlceBoundColor);</span><br><span class=\"line\">    canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绘制进度条的一条弧线\"><a href=\"#绘制进度条的一条弧线\" class=\"headerlink\" title=\"绘制进度条的一条弧线\"></a>绘制进度条的一条弧线</h2><p>进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private RectF arcRectF;</span><br><span class=\"line\">private int processColor&#x3D;0xff99cc00;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setColor(processColor);</span><br><span class=\"line\">    &#x2F;&#x2F;设置线冒样式</span><br><span class=\"line\">    circlePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,40,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进度条按照通过Timer不断控制绘制角度的增加\"><a href=\"#进度条按照通过Timer不断控制绘制角度的增加\" class=\"headerlink\" title=\"进度条按照通过Timer不断控制绘制角度的增加\"></a>进度条按照通过Timer不断控制绘制角度的增加</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int currentDrawTime;    &#x2F;&#x2F;已经绘制的次数</span><br><span class=\"line\">private Timer timer;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    timer&#x3D;new Timer();</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void drawProcess()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentDrawTime&#x3D;0;</span><br><span class=\"line\">    timer.schedule(new TimerTask() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">           currentDrawTime++;</span><br><span class=\"line\">           if (currentDrawTime&#x3D;&#x3D;8)</span><br><span class=\"line\">               timer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,500,500);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"><a href=\"#倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\" class=\"headerlink\" title=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"></a>倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"> Paint paint &#x3D; getPaint();</span><br><span class=\"line\">    float textY &#x3D; centerY - (circlePaint.descent() + circlePaint.ascent()) &#x2F; 2;</span><br><span class=\"line\">    paint.setAntiAlias(true);  &#x2F;&#x2F;防锯齿</span><br><span class=\"line\">    paint.setColor(Color.WHITE);</span><br><span class=\"line\">    paint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\">    canvas.drawText((4000-500*currentDrawTime)&#x2F;500+&quot;s&quot;,centerY,textY,paint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用自定义View实现倒计时功能\"><a href=\"#使用自定义View实现倒计时功能\" class=\"headerlink\" title=\"使用自定义View实现倒计时功能\"></a>使用自定义View实现倒计时功能</h1><p>当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。</p>\n<h2 id=\"倒计时控件实现的功能\"><a href=\"#倒计时控件实现的功能\" class=\"headerlink\" title=\"倒计时控件实现的功能\"></a>倒计时控件实现的功能</h2><ul>\n<li>显示时间进度</li>\n<li>计时结束后将会自动跳转到下一个Activity中</li>\n</ul>\n<p>实现效果如图所示</p>\n<p>在本篇博客中的代码会有部分缺省，源码链接</p>\n<h2 id=\"对自定义View的尺寸进行测量并绘制中间的大圆\"><a href=\"#对自定义View的尺寸进行测量并绘制中间的大圆\" class=\"headerlink\" title=\"对自定义View的尺寸进行测量并绘制中间的大圆\"></a>对自定义View的尺寸进行测量并绘制中间的大圆</h2><p>View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CountDownView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleColor&#x3D;0xff33b5e5;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Paint circlePaint;</span><br><span class=\"line\">    private Rect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int centerX;</span><br><span class=\"line\">    private int centerY;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        circlePaint&#x3D;new Paint();</span><br><span class=\"line\">        bounds&#x3D;new Rect();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        super.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        circleRadius&#x3D;getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()&#x2F;2:getMeasuredWidth()&#x2F;2;</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\">        getDrawingRect(bounds);      &#x2F;&#x2F;获取控件的边界</span><br><span class=\"line\"></span><br><span class=\"line\">        centerX&#x3D;bounds.centerX();</span><br><span class=\"line\">        centerY&#x3D;bounds.centerY();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;绘制中间的大圆的背景</span><br><span class=\"line\">        circlePaint.setAntiAlias(true);</span><br><span class=\"line\">        circlePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        circlePaint.setColor(circleColor);</span><br><span class=\"line\">        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在activity_main.xml中添加自定义控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.example.wyw.countdowndemo.CountDownView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<h2 id=\"绘制进度边框\"><a href=\"#绘制进度边框\" class=\"headerlink\" title=\"绘制进度边框\"></a>绘制进度边框</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int cirlceBoundColor&#x3D;0xff00ddff;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">    circlePaint.setStrokeWidth(5);</span><br><span class=\"line\">    circlePaint.setColor(cirlceBoundColor);</span><br><span class=\"line\">    canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绘制进度条的一条弧线\"><a href=\"#绘制进度条的一条弧线\" class=\"headerlink\" title=\"绘制进度条的一条弧线\"></a>绘制进度条的一条弧线</h2><p>进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private RectF arcRectF;</span><br><span class=\"line\">private int processColor&#x3D;0xff99cc00;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setColor(processColor);</span><br><span class=\"line\">    &#x2F;&#x2F;设置线冒样式</span><br><span class=\"line\">    circlePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,40,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进度条按照通过Timer不断控制绘制角度的增加\"><a href=\"#进度条按照通过Timer不断控制绘制角度的增加\" class=\"headerlink\" title=\"进度条按照通过Timer不断控制绘制角度的增加\"></a>进度条按照通过Timer不断控制绘制角度的增加</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int currentDrawTime;    &#x2F;&#x2F;已经绘制的次数</span><br><span class=\"line\">private Timer timer;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    timer&#x3D;new Timer();</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void drawProcess()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentDrawTime&#x3D;0;</span><br><span class=\"line\">    timer.schedule(new TimerTask() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">           currentDrawTime++;</span><br><span class=\"line\">           if (currentDrawTime&#x3D;&#x3D;8)</span><br><span class=\"line\">               timer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,500,500);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"><a href=\"#倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\" class=\"headerlink\" title=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"></a>倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"> Paint paint &#x3D; getPaint();</span><br><span class=\"line\">    float textY &#x3D; centerY - (circlePaint.descent() + circlePaint.ascent()) &#x2F; 2;</span><br><span class=\"line\">    paint.setAntiAlias(true);  &#x2F;&#x2F;防锯齿</span><br><span class=\"line\">    paint.setColor(Color.WHITE);</span><br><span class=\"line\">    paint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\">    canvas.drawText((4000-500*currentDrawTime)&#x2F;500+&quot;s&quot;,centerY,textY,paint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"\nLayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。\n\n* LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。\n\n* findViewById用于已载入的界面，使用findViewById来获取其中的界面元素\n\n\n## 获取LayoutInflater实例的方法\n\n* 1、通过系统服务获取布局加载器\n```\n    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n```\n* 2、通过activity中的getLayoutInflater()方法\n```\n    LayoutInflater inflater = getLayoutInflater();\n```\n\n* 3、通过LayoutInflater的from静态方法\n\n```\n    LayoutInflater inflater = LayoutInflater.from(this)\n```\n\n**这三种方式本质都是调用Context.getSystemService()**\n\n## 使用inflate方法加载布局\n\nLayoutInflater提供四种加载布局的方法\n\n* public View inflate (int resource, ViewGroup root)\n* public View inflate (int resource, ViewGroup root, boolean attachToRoot)\n* public View inflate (XmlPullParser parser, ViewGroup root)\n* public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)\n\n\n**ViewGroup root：指实例的布局所要放入的根视图**\n**boolean attachToToot：指是否附加到传入的根视图**\n\n\n1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。\n2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。\n3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。\n\n**即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View**\n\n### 示例：将button布局添加到LinearLayout上\n\n```\n    <Button xmlns:android=”http://schemas.android.com/apk/res/android\"\n     android:layout_width=”match_parent”\n     android:layout_height=”wrap_content”\n     android:text=”@string/action_attach_to_root_true”\n     android:id=”@+id/button_ok”>\n    </Button>\n```\nButton的layout params类型是LinearLayout.LayoutParams\n\n**将attachRoot设置为true**\n\n```\n    inflater.inflate(R.layout.view_button, mLinearLayout, true);\n```\n**将attachRoot设置为false**\n当attachRoot设置为false后，\n\n```\n    Button btn = (Button)inflater.inflate\n                    (R.layout.view_button,parent,false);\n    parent.addView(btn);\n```\n\n同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    \n\n**在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可**\n\n\n\n\n\n","source":"_posts/Android/View/LayoutInflater使用.md","raw":"\nLayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。\n\n* LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。\n\n* findViewById用于已载入的界面，使用findViewById来获取其中的界面元素\n\n\n## 获取LayoutInflater实例的方法\n\n* 1、通过系统服务获取布局加载器\n```\n    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n```\n* 2、通过activity中的getLayoutInflater()方法\n```\n    LayoutInflater inflater = getLayoutInflater();\n```\n\n* 3、通过LayoutInflater的from静态方法\n\n```\n    LayoutInflater inflater = LayoutInflater.from(this)\n```\n\n**这三种方式本质都是调用Context.getSystemService()**\n\n## 使用inflate方法加载布局\n\nLayoutInflater提供四种加载布局的方法\n\n* public View inflate (int resource, ViewGroup root)\n* public View inflate (int resource, ViewGroup root, boolean attachToRoot)\n* public View inflate (XmlPullParser parser, ViewGroup root)\n* public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)\n\n\n**ViewGroup root：指实例的布局所要放入的根视图**\n**boolean attachToToot：指是否附加到传入的根视图**\n\n\n1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。\n2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。\n3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。\n\n**即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View**\n\n### 示例：将button布局添加到LinearLayout上\n\n```\n    <Button xmlns:android=”http://schemas.android.com/apk/res/android\"\n     android:layout_width=”match_parent”\n     android:layout_height=”wrap_content”\n     android:text=”@string/action_attach_to_root_true”\n     android:id=”@+id/button_ok”>\n    </Button>\n```\nButton的layout params类型是LinearLayout.LayoutParams\n\n**将attachRoot设置为true**\n\n```\n    inflater.inflate(R.layout.view_button, mLinearLayout, true);\n```\n**将attachRoot设置为false**\n当attachRoot设置为false后，\n\n```\n    Button btn = (Button)inflater.inflate\n                    (R.layout.view_button,parent,false);\n    parent.addView(btn);\n```\n\n同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    \n\n**在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可**\n\n\n\n\n\n","slug":"Android/View/LayoutInflater使用","published":1,"date":"2019-09-30T07:19:02.841Z","updated":"2019-09-30T08:28:42.961Z","title":"Android/View/LayoutInflater使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhg002misuifd87bq2m","content":"<p>LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。</p>\n<ul>\n<li><p>LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。</p>\n</li>\n<li><p>findViewById用于已载入的界面，使用findViewById来获取其中的界面元素</p>\n</li>\n</ul>\n<h2 id=\"获取LayoutInflater实例的方法\"><a href=\"#获取LayoutInflater实例的方法\" class=\"headerlink\" title=\"获取LayoutInflater实例的方法\"></a>获取LayoutInflater实例的方法</h2><ul>\n<li><p>1、通过系统服务获取布局加载器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li>\n<li><p>2、通过activity中的getLayoutInflater()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; getLayoutInflater();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3、通过LayoutInflater的from静态方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; LayoutInflater.from(this)</span><br></pre></td></tr></table></figure>\n\n<p><strong>这三种方式本质都是调用Context.getSystemService()</strong></p>\n<h2 id=\"使用inflate方法加载布局\"><a href=\"#使用inflate方法加载布局\" class=\"headerlink\" title=\"使用inflate方法加载布局\"></a>使用inflate方法加载布局</h2><p>LayoutInflater提供四种加载布局的方法</p>\n<ul>\n<li>public View inflate (int resource, ViewGroup root)</li>\n<li>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)</li>\n</ul>\n<p><strong>ViewGroup root：指实例的布局所要放入的根视图</strong><br><strong>boolean attachToToot：指是否附加到传入的根视图</strong></p>\n<p>1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。<br>2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。<br>3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。</p>\n<p><strong>即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View</strong></p>\n<h3 id=\"示例：将button布局添加到LinearLayout上\"><a href=\"#示例：将button布局添加到LinearLayout上\" class=\"headerlink\" title=\"示例：将button布局添加到LinearLayout上\"></a>示例：将button布局添加到LinearLayout上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button xmlns:android&#x3D;”http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\"> android:layout_width&#x3D;”match_parent”</span><br><span class=\"line\"> android:layout_height&#x3D;”wrap_content”</span><br><span class=\"line\"> android:text&#x3D;”@string&#x2F;action_attach_to_root_true”</span><br><span class=\"line\"> android:id&#x3D;”@+id&#x2F;button_ok”&gt;</span><br><span class=\"line\">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>\n<p>Button的layout params类型是LinearLayout.LayoutParams</p>\n<p><strong>将attachRoot设置为true</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.view_button, mLinearLayout, true);</span><br></pre></td></tr></table></figure>\n<p><strong>将attachRoot设置为false</strong><br>当attachRoot设置为false后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button btn &#x3D; (Button)inflater.inflate</span><br><span class=\"line\">                (R.layout.view_button,parent,false);</span><br><span class=\"line\">parent.addView(btn);</span><br></pre></td></tr></table></figure>\n\n<p>同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    </p>\n<p><strong>在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。</p>\n<ul>\n<li><p>LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。</p>\n</li>\n<li><p>findViewById用于已载入的界面，使用findViewById来获取其中的界面元素</p>\n</li>\n</ul>\n<h2 id=\"获取LayoutInflater实例的方法\"><a href=\"#获取LayoutInflater实例的方法\" class=\"headerlink\" title=\"获取LayoutInflater实例的方法\"></a>获取LayoutInflater实例的方法</h2><ul>\n<li><p>1、通过系统服务获取布局加载器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li>\n<li><p>2、通过activity中的getLayoutInflater()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; getLayoutInflater();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3、通过LayoutInflater的from静态方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; LayoutInflater.from(this)</span><br></pre></td></tr></table></figure>\n\n<p><strong>这三种方式本质都是调用Context.getSystemService()</strong></p>\n<h2 id=\"使用inflate方法加载布局\"><a href=\"#使用inflate方法加载布局\" class=\"headerlink\" title=\"使用inflate方法加载布局\"></a>使用inflate方法加载布局</h2><p>LayoutInflater提供四种加载布局的方法</p>\n<ul>\n<li>public View inflate (int resource, ViewGroup root)</li>\n<li>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)</li>\n</ul>\n<p><strong>ViewGroup root：指实例的布局所要放入的根视图</strong><br><strong>boolean attachToToot：指是否附加到传入的根视图</strong></p>\n<p>1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。<br>2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。<br>3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。</p>\n<p><strong>即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View</strong></p>\n<h3 id=\"示例：将button布局添加到LinearLayout上\"><a href=\"#示例：将button布局添加到LinearLayout上\" class=\"headerlink\" title=\"示例：将button布局添加到LinearLayout上\"></a>示例：将button布局添加到LinearLayout上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button xmlns:android&#x3D;”http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\"> android:layout_width&#x3D;”match_parent”</span><br><span class=\"line\"> android:layout_height&#x3D;”wrap_content”</span><br><span class=\"line\"> android:text&#x3D;”@string&#x2F;action_attach_to_root_true”</span><br><span class=\"line\"> android:id&#x3D;”@+id&#x2F;button_ok”&gt;</span><br><span class=\"line\">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>\n<p>Button的layout params类型是LinearLayout.LayoutParams</p>\n<p><strong>将attachRoot设置为true</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.view_button, mLinearLayout, true);</span><br></pre></td></tr></table></figure>\n<p><strong>将attachRoot设置为false</strong><br>当attachRoot设置为false后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button btn &#x3D; (Button)inflater.inflate</span><br><span class=\"line\">                (R.layout.view_button,parent,false);</span><br><span class=\"line\">parent.addView(btn);</span><br></pre></td></tr></table></figure>\n\n<p>同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    </p>\n<p><strong>在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可</strong></p>\n"},{"_content":" ## CoordinatorLayout\n CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。\n \n CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar\n \n **CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用**\n \n ## AppBarLayout\n \n AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。\n \n AppBarLayout有五种滚动标识：\n * scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部\n * enterAlways：让任意向下的滚动都会导致该view变为可见\n * enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。\n * exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠\n * snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开\n \n ## CollapsingToolbarLayout\n CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，\n \n ## Behavior\n \n Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。\n \n \n# SnackBar\nSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。\n\n如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；\n\n###SnackBar的使用方式\n```\n\n```\n\n\n# Toast\nToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，\n\n\n### SnackBar和Toast之间的对比\n\n|不同|Toast|SnackBar|\n|---|-----|-----|\n|1|Toast从API1就存在|SnackBar在API23添加|\n|2|不需要Activity，可以显示在Android Home或者其他应用才|只能显示在某一个Activity中|\n|3|不能根据用户的操作执行Action|可以根据用户的操作执行Action|\n|4|在用户滑动时不能消失|在用户滑动时可以消失| ","source":"_posts/Android/View/Materials Design.md","raw":" ## CoordinatorLayout\n CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。\n \n CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar\n \n **CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用**\n \n ## AppBarLayout\n \n AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。\n \n AppBarLayout有五种滚动标识：\n * scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部\n * enterAlways：让任意向下的滚动都会导致该view变为可见\n * enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。\n * exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠\n * snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开\n \n ## CollapsingToolbarLayout\n CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，\n \n ## Behavior\n \n Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。\n \n \n# SnackBar\nSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。\n\n如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；\n\n###SnackBar的使用方式\n```\n\n```\n\n\n# Toast\nToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，\n\n\n### SnackBar和Toast之间的对比\n\n|不同|Toast|SnackBar|\n|---|-----|-----|\n|1|Toast从API1就存在|SnackBar在API23添加|\n|2|不需要Activity，可以显示在Android Home或者其他应用才|只能显示在某一个Activity中|\n|3|不能根据用户的操作执行Action|可以根据用户的操作执行Action|\n|4|在用户滑动时不能消失|在用户滑动时可以消失| ","slug":"Android/View/Materials Design","published":1,"date":"2019-09-30T07:19:02.847Z","updated":"2019-09-30T08:28:42.962Z","title":"Android/View/Materials Design","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhg002nisuidfytazsk","content":"<h2 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h2><p> CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。</p>\n<p> CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar</p>\n<p> <strong>CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用</strong></p>\n<h2 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h2><p> AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。</p>\n<p> AppBarLayout有五种滚动标识：</p>\n<ul>\n<li><p>scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部</p>\n</li>\n<li><p>enterAlways：让任意向下的滚动都会导致该view变为可见</p>\n</li>\n<li><p>enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。</p>\n</li>\n<li><p>exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠</p>\n</li>\n<li><p>snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开</p>\n<h2 id=\"CollapsingToolbarLayout\"><a href=\"#CollapsingToolbarLayout\" class=\"headerlink\" title=\"CollapsingToolbarLayout\"></a>CollapsingToolbarLayout</h2><p>CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，</p>\n<h2 id=\"Behavior\"><a href=\"#Behavior\" class=\"headerlink\" title=\"Behavior\"></a>Behavior</h2><p>Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。</p>\n</li>\n</ul>\n<h1 id=\"SnackBar\"><a href=\"#SnackBar\" class=\"headerlink\" title=\"SnackBar\"></a>SnackBar</h1><p>SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。</p>\n<p>如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；</p>\n<p>###SnackBar的使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Toast\"><a href=\"#Toast\" class=\"headerlink\" title=\"Toast\"></a>Toast</h1><p>Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，</p>\n<h3 id=\"SnackBar和Toast之间的对比\"><a href=\"#SnackBar和Toast之间的对比\" class=\"headerlink\" title=\"SnackBar和Toast之间的对比\"></a>SnackBar和Toast之间的对比</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>Toast</th>\n<th>SnackBar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Toast从API1就存在</td>\n<td>SnackBar在API23添加</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不需要Activity，可以显示在Android Home或者其他应用才</td>\n<td>只能显示在某一个Activity中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不能根据用户的操作执行Action</td>\n<td>可以根据用户的操作执行Action</td>\n</tr>\n<tr>\n<td>4</td>\n<td>在用户滑动时不能消失</td>\n<td>在用户滑动时可以消失</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h2><p> CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。</p>\n<p> CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar</p>\n<p> <strong>CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用</strong></p>\n<h2 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h2><p> AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。</p>\n<p> AppBarLayout有五种滚动标识：</p>\n<ul>\n<li><p>scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部</p>\n</li>\n<li><p>enterAlways：让任意向下的滚动都会导致该view变为可见</p>\n</li>\n<li><p>enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。</p>\n</li>\n<li><p>exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠</p>\n</li>\n<li><p>snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开</p>\n<h2 id=\"CollapsingToolbarLayout\"><a href=\"#CollapsingToolbarLayout\" class=\"headerlink\" title=\"CollapsingToolbarLayout\"></a>CollapsingToolbarLayout</h2><p>CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，</p>\n<h2 id=\"Behavior\"><a href=\"#Behavior\" class=\"headerlink\" title=\"Behavior\"></a>Behavior</h2><p>Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。</p>\n</li>\n</ul>\n<h1 id=\"SnackBar\"><a href=\"#SnackBar\" class=\"headerlink\" title=\"SnackBar\"></a>SnackBar</h1><p>SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。</p>\n<p>如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；</p>\n<p>###SnackBar的使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Toast\"><a href=\"#Toast\" class=\"headerlink\" title=\"Toast\"></a>Toast</h1><p>Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，</p>\n<h3 id=\"SnackBar和Toast之间的对比\"><a href=\"#SnackBar和Toast之间的对比\" class=\"headerlink\" title=\"SnackBar和Toast之间的对比\"></a>SnackBar和Toast之间的对比</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>Toast</th>\n<th>SnackBar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Toast从API1就存在</td>\n<td>SnackBar在API23添加</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不需要Activity，可以显示在Android Home或者其他应用才</td>\n<td>只能显示在某一个Activity中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不能根据用户的操作执行Action</td>\n<td>可以根据用户的操作执行Action</td>\n</tr>\n<tr>\n<td>4</td>\n<td>在用户滑动时不能消失</td>\n<td>在用户滑动时可以消失</td>\n</tr>\n</tbody></table>\n"},{"_content":"# 使用SearchView以及RecyclerView实现条目删选\n\n\\#\\# 使用SearchView以及RecyclerView实现条目删选\n\n## SearchView介绍\n\nSearchView继承图 ![SearchView&#x7EE7;&#x627F;&#x56FE;](https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表\n\n## RecyclerView介绍\n\nRecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。\n\n## 代码实现\n\n### 搜索框的添加\n\n1、在res/menu文件夹下添加menu\\_main，即MainActivity的菜单栏\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_search\"\n        android:icon=\"@android:drawable/ic_menu_search\"\n        android:title=\"@string/action_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always|collapseActionView\" />\n\n</menu>\n```\n\n2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件\n\n注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView\n\n```text\n java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView\n```\n\nMainActivity中的代码\n\n```java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.menu_main,menu);\n        MenuItem menuItem=menu.findItem(R.id.action_search);\n        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);\n        searchView.setOnQueryTextListener(this);\n        return true;\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        return false;\n    }\n}\n```\n\n显示效果如图所示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### RecylerViewAdapter编写\n\n1、在build.gradle\\(Module:app\\)中添加依赖\n\n```text\ndependencies {\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n}\n```\n\n2、RecyclerView列表中每一个item布局文件item\\_recyclerview的编写\n\n```markup\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <android.support.v7.widget.CardView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:cardCornerRadius=\"5dp\">\n\n        <TextView\n            android:id=\"@+id/word_tv\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:layout_gravity=\"center\"\n            android:text=\"word\"\n            android:textSize=\"25sp\" />\n    </android.support.v7.widget.CardView>\n</LinearLayout>\n```\n\n3、RecylerViewAdapter编写\n\n```text\npublic class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder>{\n\n    private List<String>strings;\n\n    public RecyclerViewAdapter(List<String>strings) {\n        this.strings=strings;\n    }\n\n\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);\n        ViewHolder viewHolder=new ViewHolder(view);\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        ((ViewHolder)holder).words.setText(strings.get(position));\n    }\n\n    @Override\n    public int getItemCount() {\n        return strings.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder{\n\n        TextView words;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            words=(TextView)itemView.findViewById(R.id.word_tv);\n        }\n    }\n\n}\n```\n\n### 在MainActivity中添加RecyclerView布局\n\n1、在布局文件activity\\_main中添加RecyclerView布局\n\n```text\n<android.support.v7.widget.RecyclerView\n    android:id=\"@+id/main_recyclerview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n</android.support.v7.widget.RecyclerView>\n```\n\n2、在MainActivity中为RecyclerView添加适配器\n\n```text\n    //省略部分代码\n\n    private RecyclerView recyclerView;\n    private RecyclerViewAdapter recyclerViewAdapter;\n\n    private List<String>words;\n\n    private RecyclerView.LayoutManager layoutManager;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        recyclerView=findViewById(R.id.main_recyclerview);\n        layoutManager=new LinearLayoutManager(MainActivity.this);\n        words=new ArrayList<>();\n        words.add(\"abc\");\n        words.add(\"abc\");\n        words.add(\"abc\");\n        recyclerViewAdapter=new RecyclerViewAdapter(words);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setAdapter(recyclerViewAdapter);\n\n    }\n```\n\n结果显示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### 在MainActivity中添加筛选方法\n\n```text\n    private List<String>filter(List<String>strings,String text){\n        filterString=new ArrayList<>();\n\n        for (String word:words){\n            if (word.contains(text))\n                filterString.add(word);\n        }\n        return filterString;\n    }\n```\n\n### 在RecyclerViewAdapter中设置筛选后的单词的显示\n\n```text\n   //省略部分代码\n public void setFilter(List<String>filterWords){\n        words=filterWords;\n        notifyDataSetChanged();\n    }\n```\n\n### 当检测到SearchView中输入变化时进行单词筛选\n\n```text\n    @Override\n    public boolean onQueryTextChange(String newText) {\n\n        filterString=filter(words,newText);\n        recyclerViewAdapter.setFilter(filterString);\n        return true;\n    }\n```\n\n## 运行结果\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n[源码地址](https://download.csdn.net/download/qq_36422743/10468538%20源码地址)\n\n","source":"_posts/Android/View/使用RecyclerView和SearchView实现查找删除.md","raw":"# 使用SearchView以及RecyclerView实现条目删选\n\n\\#\\# 使用SearchView以及RecyclerView实现条目删选\n\n## SearchView介绍\n\nSearchView继承图 ![SearchView&#x7EE7;&#x627F;&#x56FE;](https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表\n\n## RecyclerView介绍\n\nRecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。\n\n## 代码实现\n\n### 搜索框的添加\n\n1、在res/menu文件夹下添加menu\\_main，即MainActivity的菜单栏\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_search\"\n        android:icon=\"@android:drawable/ic_menu_search\"\n        android:title=\"@string/action_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always|collapseActionView\" />\n\n</menu>\n```\n\n2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件\n\n注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView\n\n```text\n java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView\n```\n\nMainActivity中的代码\n\n```java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.menu_main,menu);\n        MenuItem menuItem=menu.findItem(R.id.action_search);\n        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);\n        searchView.setOnQueryTextListener(this);\n        return true;\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        return false;\n    }\n}\n```\n\n显示效果如图所示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### RecylerViewAdapter编写\n\n1、在build.gradle\\(Module:app\\)中添加依赖\n\n```text\ndependencies {\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n}\n```\n\n2、RecyclerView列表中每一个item布局文件item\\_recyclerview的编写\n\n```markup\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <android.support.v7.widget.CardView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:cardCornerRadius=\"5dp\">\n\n        <TextView\n            android:id=\"@+id/word_tv\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:layout_gravity=\"center\"\n            android:text=\"word\"\n            android:textSize=\"25sp\" />\n    </android.support.v7.widget.CardView>\n</LinearLayout>\n```\n\n3、RecylerViewAdapter编写\n\n```text\npublic class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder>{\n\n    private List<String>strings;\n\n    public RecyclerViewAdapter(List<String>strings) {\n        this.strings=strings;\n    }\n\n\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);\n        ViewHolder viewHolder=new ViewHolder(view);\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        ((ViewHolder)holder).words.setText(strings.get(position));\n    }\n\n    @Override\n    public int getItemCount() {\n        return strings.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder{\n\n        TextView words;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            words=(TextView)itemView.findViewById(R.id.word_tv);\n        }\n    }\n\n}\n```\n\n### 在MainActivity中添加RecyclerView布局\n\n1、在布局文件activity\\_main中添加RecyclerView布局\n\n```text\n<android.support.v7.widget.RecyclerView\n    android:id=\"@+id/main_recyclerview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n</android.support.v7.widget.RecyclerView>\n```\n\n2、在MainActivity中为RecyclerView添加适配器\n\n```text\n    //省略部分代码\n\n    private RecyclerView recyclerView;\n    private RecyclerViewAdapter recyclerViewAdapter;\n\n    private List<String>words;\n\n    private RecyclerView.LayoutManager layoutManager;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        recyclerView=findViewById(R.id.main_recyclerview);\n        layoutManager=new LinearLayoutManager(MainActivity.this);\n        words=new ArrayList<>();\n        words.add(\"abc\");\n        words.add(\"abc\");\n        words.add(\"abc\");\n        recyclerViewAdapter=new RecyclerViewAdapter(words);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setAdapter(recyclerViewAdapter);\n\n    }\n```\n\n结果显示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### 在MainActivity中添加筛选方法\n\n```text\n    private List<String>filter(List<String>strings,String text){\n        filterString=new ArrayList<>();\n\n        for (String word:words){\n            if (word.contains(text))\n                filterString.add(word);\n        }\n        return filterString;\n    }\n```\n\n### 在RecyclerViewAdapter中设置筛选后的单词的显示\n\n```text\n   //省略部分代码\n public void setFilter(List<String>filterWords){\n        words=filterWords;\n        notifyDataSetChanged();\n    }\n```\n\n### 当检测到SearchView中输入变化时进行单词筛选\n\n```text\n    @Override\n    public boolean onQueryTextChange(String newText) {\n\n        filterString=filter(words,newText);\n        recyclerViewAdapter.setFilter(filterString);\n        return true;\n    }\n```\n\n## 运行结果\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n[源码地址](https://download.csdn.net/download/qq_36422743/10468538%20源码地址)\n\n","slug":"Android/View/使用RecyclerView和SearchView实现查找删除","published":1,"date":"2019-09-19T09:41:14.746Z","updated":"2019-09-19T09:41:14.746Z","title":"Android/View/使用RecyclerView和SearchView实现查找删除","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhh002oisui6e1k05qd","content":"<h1 id=\"使用SearchView以及RecyclerView实现条目删选\"><a href=\"#使用SearchView以及RecyclerView实现条目删选\" class=\"headerlink\" title=\"使用SearchView以及RecyclerView实现条目删选\"></a>使用SearchView以及RecyclerView实现条目删选</h1><p>## 使用SearchView以及RecyclerView实现条目删选</p>\n<h2 id=\"SearchView介绍\"><a href=\"#SearchView介绍\" class=\"headerlink\" title=\"SearchView介绍\"></a>SearchView介绍</h2><p>SearchView继承图 <img src=\"https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"SearchView&#x7EE7;&#x627F;&#x56FE;\"> SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表</p>\n<h2 id=\"RecyclerView介绍\"><a href=\"#RecyclerView介绍\" class=\"headerlink\" title=\"RecyclerView介绍\"></a>RecyclerView介绍</h2><p>RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"搜索框的添加\"><a href=\"#搜索框的添加\" class=\"headerlink\" title=\"搜索框的添加\"></a>搜索框的添加</h3><p>1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id&#x3D;&quot;@+id&#x2F;action_search&quot;</span><br><span class=\"line\">        android:icon&#x3D;&quot;@android:drawable&#x2F;ic_menu_search&quot;</span><br><span class=\"line\">        android:title&#x3D;&quot;@string&#x2F;action_search&quot;</span><br><span class=\"line\">        app:actionViewClass&#x3D;&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction&#x3D;&quot;always|collapseActionView&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件</p>\n<p>注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView</span><br></pre></td></tr></table></figure>\n\n<p>MainActivity中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SearchView</span>.<span class=\"title\">OnQueryTextListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        getMenuInflater().inflate(R.menu.menu_main,menu);</span><br><span class=\"line\">        MenuItem menuItem=menu.findItem(R.id.action_search);</span><br><span class=\"line\">        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);</span><br><span class=\"line\">        searchView.setOnQueryTextListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextSubmit</span><span class=\"params\">(String query)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextChange</span><span class=\"params\">(String newText)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如图所示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"RecylerViewAdapter编写\"><a href=\"#RecylerViewAdapter编写\" class=\"headerlink\" title=\"RecylerViewAdapter编写\"></a>RecylerViewAdapter编写</h3><p>1、在build.gradle(Module:app)中添加依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、RecyclerView列表中每一个item布局文件item_recyclerview的编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v7.widget.CardView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class=\"line\">        app:cardCornerRadius&#x3D;&quot;5dp&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:id&#x3D;&quot;@+id&#x2F;word_tv&quot;</span><br><span class=\"line\">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">            android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:text&#x3D;&quot;word&quot;</span><br><span class=\"line\">            android:textSize&#x3D;&quot;25sp&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3、RecylerViewAdapter编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt;strings;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RecyclerViewAdapter(List&lt;String&gt;strings) &#123;</span><br><span class=\"line\">        this.strings&#x3D;strings;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">        View view &#x3D; LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);</span><br><span class=\"line\">        ViewHolder viewHolder&#x3D;new ViewHolder(view);</span><br><span class=\"line\">        return viewHolder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;</span><br><span class=\"line\">        ((ViewHolder)holder).words.setText(strings.get(position));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemCount() &#123;</span><br><span class=\"line\">        return strings.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        TextView words;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ViewHolder(View itemView) &#123;</span><br><span class=\"line\">            super(itemView);</span><br><span class=\"line\">            words&#x3D;(TextView)itemView.findViewById(R.id.word_tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在MainActivity中添加RecyclerView布局\"><a href=\"#在MainActivity中添加RecyclerView布局\" class=\"headerlink\" title=\"在MainActivity中添加RecyclerView布局\"></a>在MainActivity中添加RecyclerView布局</h3><p>1、在布局文件activity_main中添加RecyclerView布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;main_recyclerview&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;android.support.v7.widget.RecyclerView&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中为RecyclerView添加适配器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;省略部分代码</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView recyclerView;</span><br><span class=\"line\">private RecyclerViewAdapter recyclerViewAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">private List&lt;String&gt;words;</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView.LayoutManager layoutManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    recyclerView&#x3D;findViewById(R.id.main_recyclerview);</span><br><span class=\"line\">    layoutManager&#x3D;new LinearLayoutManager(MainActivity.this);</span><br><span class=\"line\">    words&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    recyclerViewAdapter&#x3D;new RecyclerViewAdapter(words);</span><br><span class=\"line\">    recyclerView.setLayoutManager(layoutManager);</span><br><span class=\"line\">    recyclerView.setAdapter(recyclerViewAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果显示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"在MainActivity中添加筛选方法\"><a href=\"#在MainActivity中添加筛选方法\" class=\"headerlink\" title=\"在MainActivity中添加筛选方法\"></a>在MainActivity中添加筛选方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;String&gt;filter(List&lt;String&gt;strings,String text)&#123;</span><br><span class=\"line\">    filterString&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (String word:words)&#123;</span><br><span class=\"line\">        if (word.contains(text))</span><br><span class=\"line\">            filterString.add(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return filterString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"><a href=\"#在RecyclerViewAdapter中设置筛选后的单词的显示\" class=\"headerlink\" title=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"></a>在RecyclerViewAdapter中设置筛选后的单词的显示</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &#x2F;&#x2F;省略部分代码</span><br><span class=\"line\">public void setFilter(List&lt;String&gt;filterWords)&#123;</span><br><span class=\"line\">       words&#x3D;filterWords;</span><br><span class=\"line\">       notifyDataSetChanged();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"当检测到SearchView中输入变化时进行单词筛选\"><a href=\"#当检测到SearchView中输入变化时进行单词筛选\" class=\"headerlink\" title=\"当检测到SearchView中输入变化时进行单词筛选\"></a>当检测到SearchView中输入变化时进行单词筛选</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onQueryTextChange(String newText) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    filterString&#x3D;filter(words,newText);</span><br><span class=\"line\">    recyclerViewAdapter.setFilter(filterString);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<p><a href=\"https://download.csdn.net/download/qq_36422743/10468538%20源码地址\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用SearchView以及RecyclerView实现条目删选\"><a href=\"#使用SearchView以及RecyclerView实现条目删选\" class=\"headerlink\" title=\"使用SearchView以及RecyclerView实现条目删选\"></a>使用SearchView以及RecyclerView实现条目删选</h1><p>## 使用SearchView以及RecyclerView实现条目删选</p>\n<h2 id=\"SearchView介绍\"><a href=\"#SearchView介绍\" class=\"headerlink\" title=\"SearchView介绍\"></a>SearchView介绍</h2><p>SearchView继承图 <img src=\"https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"SearchView&#x7EE7;&#x627F;&#x56FE;\"> SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表</p>\n<h2 id=\"RecyclerView介绍\"><a href=\"#RecyclerView介绍\" class=\"headerlink\" title=\"RecyclerView介绍\"></a>RecyclerView介绍</h2><p>RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"搜索框的添加\"><a href=\"#搜索框的添加\" class=\"headerlink\" title=\"搜索框的添加\"></a>搜索框的添加</h3><p>1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id&#x3D;&quot;@+id&#x2F;action_search&quot;</span><br><span class=\"line\">        android:icon&#x3D;&quot;@android:drawable&#x2F;ic_menu_search&quot;</span><br><span class=\"line\">        android:title&#x3D;&quot;@string&#x2F;action_search&quot;</span><br><span class=\"line\">        app:actionViewClass&#x3D;&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction&#x3D;&quot;always|collapseActionView&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件</p>\n<p>注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView</span><br></pre></td></tr></table></figure>\n\n<p>MainActivity中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SearchView</span>.<span class=\"title\">OnQueryTextListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        getMenuInflater().inflate(R.menu.menu_main,menu);</span><br><span class=\"line\">        MenuItem menuItem=menu.findItem(R.id.action_search);</span><br><span class=\"line\">        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);</span><br><span class=\"line\">        searchView.setOnQueryTextListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextSubmit</span><span class=\"params\">(String query)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextChange</span><span class=\"params\">(String newText)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如图所示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"RecylerViewAdapter编写\"><a href=\"#RecylerViewAdapter编写\" class=\"headerlink\" title=\"RecylerViewAdapter编写\"></a>RecylerViewAdapter编写</h3><p>1、在build.gradle(Module:app)中添加依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、RecyclerView列表中每一个item布局文件item_recyclerview的编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v7.widget.CardView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class=\"line\">        app:cardCornerRadius&#x3D;&quot;5dp&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:id&#x3D;&quot;@+id&#x2F;word_tv&quot;</span><br><span class=\"line\">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">            android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:text&#x3D;&quot;word&quot;</span><br><span class=\"line\">            android:textSize&#x3D;&quot;25sp&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3、RecylerViewAdapter编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt;strings;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RecyclerViewAdapter(List&lt;String&gt;strings) &#123;</span><br><span class=\"line\">        this.strings&#x3D;strings;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">        View view &#x3D; LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);</span><br><span class=\"line\">        ViewHolder viewHolder&#x3D;new ViewHolder(view);</span><br><span class=\"line\">        return viewHolder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;</span><br><span class=\"line\">        ((ViewHolder)holder).words.setText(strings.get(position));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemCount() &#123;</span><br><span class=\"line\">        return strings.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        TextView words;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ViewHolder(View itemView) &#123;</span><br><span class=\"line\">            super(itemView);</span><br><span class=\"line\">            words&#x3D;(TextView)itemView.findViewById(R.id.word_tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在MainActivity中添加RecyclerView布局\"><a href=\"#在MainActivity中添加RecyclerView布局\" class=\"headerlink\" title=\"在MainActivity中添加RecyclerView布局\"></a>在MainActivity中添加RecyclerView布局</h3><p>1、在布局文件activity_main中添加RecyclerView布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;main_recyclerview&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;android.support.v7.widget.RecyclerView&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中为RecyclerView添加适配器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;省略部分代码</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView recyclerView;</span><br><span class=\"line\">private RecyclerViewAdapter recyclerViewAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">private List&lt;String&gt;words;</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView.LayoutManager layoutManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    recyclerView&#x3D;findViewById(R.id.main_recyclerview);</span><br><span class=\"line\">    layoutManager&#x3D;new LinearLayoutManager(MainActivity.this);</span><br><span class=\"line\">    words&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    recyclerViewAdapter&#x3D;new RecyclerViewAdapter(words);</span><br><span class=\"line\">    recyclerView.setLayoutManager(layoutManager);</span><br><span class=\"line\">    recyclerView.setAdapter(recyclerViewAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果显示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"在MainActivity中添加筛选方法\"><a href=\"#在MainActivity中添加筛选方法\" class=\"headerlink\" title=\"在MainActivity中添加筛选方法\"></a>在MainActivity中添加筛选方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;String&gt;filter(List&lt;String&gt;strings,String text)&#123;</span><br><span class=\"line\">    filterString&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (String word:words)&#123;</span><br><span class=\"line\">        if (word.contains(text))</span><br><span class=\"line\">            filterString.add(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return filterString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"><a href=\"#在RecyclerViewAdapter中设置筛选后的单词的显示\" class=\"headerlink\" title=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"></a>在RecyclerViewAdapter中设置筛选后的单词的显示</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &#x2F;&#x2F;省略部分代码</span><br><span class=\"line\">public void setFilter(List&lt;String&gt;filterWords)&#123;</span><br><span class=\"line\">       words&#x3D;filterWords;</span><br><span class=\"line\">       notifyDataSetChanged();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"当检测到SearchView中输入变化时进行单词筛选\"><a href=\"#当检测到SearchView中输入变化时进行单词筛选\" class=\"headerlink\" title=\"当检测到SearchView中输入变化时进行单词筛选\"></a>当检测到SearchView中输入变化时进行单词筛选</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onQueryTextChange(String newText) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    filterString&#x3D;filter(words,newText);</span><br><span class=\"line\">    recyclerViewAdapter.setFilter(filterString);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<p><a href=\"https://download.csdn.net/download/qq_36422743/10468538%20源码地址\">源码地址</a></p>\n"},{"_content":"# 在Android中使用Dagger2\n\n## Dagger2介绍\n\n### 为什么我们需要注解依赖注入？\n\nDependency Injection\\(注解依赖\\)是在IOC\\(Inversion of cnontrol\\)的基础上实现的，为了将类的实例的实现与类进行分离。\n\n如果一个类使用`new`操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。\n\n### 注入模式\n\n* 构造函数注入：以传递参数的方式\n* 字段注入：以变量的方式\n* 方法注入：\n\n“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”\n\n* Dependency provider:使用注解`@Module`表示的类，用于提供可以进行注入的对象。类中的方法使用注解`@Providers`表示该方法的返回对象可以被依赖注入。`@Moudle`可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用`@Inject`即可\n* Dependency consumer：注解`@Inject`用于定义一个依赖。\n* Connection consumer and producer：使用注解`@Component`的接口定义module对象中`provider`与依赖对象之间的连接，接口的实现类由Dagger自动生成。\n\n## Dagger2的局限性\n\n* Dagger2不能自动注入域\n* Dagger2不能注入private类型\n* Dagger2\n\n## 工程结构图\n\n假装有图\n\n","source":"_posts/Android/框架/Dagger2.md","raw":"# 在Android中使用Dagger2\n\n## Dagger2介绍\n\n### 为什么我们需要注解依赖注入？\n\nDependency Injection\\(注解依赖\\)是在IOC\\(Inversion of cnontrol\\)的基础上实现的，为了将类的实例的实现与类进行分离。\n\n如果一个类使用`new`操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。\n\n### 注入模式\n\n* 构造函数注入：以传递参数的方式\n* 字段注入：以变量的方式\n* 方法注入：\n\n“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”\n\n* Dependency provider:使用注解`@Module`表示的类，用于提供可以进行注入的对象。类中的方法使用注解`@Providers`表示该方法的返回对象可以被依赖注入。`@Moudle`可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用`@Inject`即可\n* Dependency consumer：注解`@Inject`用于定义一个依赖。\n* Connection consumer and producer：使用注解`@Component`的接口定义module对象中`provider`与依赖对象之间的连接，接口的实现类由Dagger自动生成。\n\n## Dagger2的局限性\n\n* Dagger2不能自动注入域\n* Dagger2不能注入private类型\n* Dagger2\n\n## 工程结构图\n\n假装有图\n\n","slug":"Android/框架/Dagger2","published":1,"date":"2019-09-19T09:34:08.488Z","updated":"2020-02-26T06:12:59.620Z","title":"Android/框架/Dagger2","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhh002pisui8s056syc","content":"<h1 id=\"在Android中使用Dagger2\"><a href=\"#在Android中使用Dagger2\" class=\"headerlink\" title=\"在Android中使用Dagger2\"></a>在Android中使用Dagger2</h1><h2 id=\"Dagger2介绍\"><a href=\"#Dagger2介绍\" class=\"headerlink\" title=\"Dagger2介绍\"></a>Dagger2介绍</h2><h3 id=\"为什么我们需要注解依赖注入？\"><a href=\"#为什么我们需要注解依赖注入？\" class=\"headerlink\" title=\"为什么我们需要注解依赖注入？\"></a>为什么我们需要注解依赖注入？</h3><p>Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。</p>\n<p>如果一个类使用<code>new</code>操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。</p>\n<h3 id=\"注入模式\"><a href=\"#注入模式\" class=\"headerlink\" title=\"注入模式\"></a>注入模式</h3><ul>\n<li>构造函数注入：以传递参数的方式</li>\n<li>字段注入：以变量的方式</li>\n<li>方法注入：</li>\n</ul>\n<p>“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”</p>\n<ul>\n<li>Dependency provider:使用注解<code>@Module</code>表示的类，用于提供可以进行注入的对象。类中的方法使用注解<code>@Providers</code>表示该方法的返回对象可以被依赖注入。<code>@Moudle</code>可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用<code>@Inject</code>即可</li>\n<li>Dependency consumer：注解<code>@Inject</code>用于定义一个依赖。</li>\n<li>Connection consumer and producer：使用注解<code>@Component</code>的接口定义module对象中<code>provider</code>与依赖对象之间的连接，接口的实现类由Dagger自动生成。</li>\n</ul>\n<h2 id=\"Dagger2的局限性\"><a href=\"#Dagger2的局限性\" class=\"headerlink\" title=\"Dagger2的局限性\"></a>Dagger2的局限性</h2><ul>\n<li>Dagger2不能自动注入域</li>\n<li>Dagger2不能注入private类型</li>\n<li>Dagger2</li>\n</ul>\n<h2 id=\"工程结构图\"><a href=\"#工程结构图\" class=\"headerlink\" title=\"工程结构图\"></a>工程结构图</h2><p>假装有图</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在Android中使用Dagger2\"><a href=\"#在Android中使用Dagger2\" class=\"headerlink\" title=\"在Android中使用Dagger2\"></a>在Android中使用Dagger2</h1><h2 id=\"Dagger2介绍\"><a href=\"#Dagger2介绍\" class=\"headerlink\" title=\"Dagger2介绍\"></a>Dagger2介绍</h2><h3 id=\"为什么我们需要注解依赖注入？\"><a href=\"#为什么我们需要注解依赖注入？\" class=\"headerlink\" title=\"为什么我们需要注解依赖注入？\"></a>为什么我们需要注解依赖注入？</h3><p>Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。</p>\n<p>如果一个类使用<code>new</code>操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。</p>\n<h3 id=\"注入模式\"><a href=\"#注入模式\" class=\"headerlink\" title=\"注入模式\"></a>注入模式</h3><ul>\n<li>构造函数注入：以传递参数的方式</li>\n<li>字段注入：以变量的方式</li>\n<li>方法注入：</li>\n</ul>\n<p>“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”</p>\n<ul>\n<li>Dependency provider:使用注解<code>@Module</code>表示的类，用于提供可以进行注入的对象。类中的方法使用注解<code>@Providers</code>表示该方法的返回对象可以被依赖注入。<code>@Moudle</code>可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用<code>@Inject</code>即可</li>\n<li>Dependency consumer：注解<code>@Inject</code>用于定义一个依赖。</li>\n<li>Connection consumer and producer：使用注解<code>@Component</code>的接口定义module对象中<code>provider</code>与依赖对象之间的连接，接口的实现类由Dagger自动生成。</li>\n</ul>\n<h2 id=\"Dagger2的局限性\"><a href=\"#Dagger2的局限性\" class=\"headerlink\" title=\"Dagger2的局限性\"></a>Dagger2的局限性</h2><ul>\n<li>Dagger2不能自动注入域</li>\n<li>Dagger2不能注入private类型</li>\n<li>Dagger2</li>\n</ul>\n<h2 id=\"工程结构图\"><a href=\"#工程结构图\" class=\"headerlink\" title=\"工程结构图\"></a>工程结构图</h2><p>假装有图</p>\n"},{"_content":"\n\n#### JSONString与HashMap之间的转换\n\n* HashMap转换为JsonString\n\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    String JSONString=JSON.toJSONString(hashMap);\n```\n\n\n* JsonString转换为HashMap\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap= JSON.parseObject(JSONString, Map.class);\n    \n    //错误方式\n    hashMap= (Map<String, String>) JSON.parse(JSONString);\n```\n\n**注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**\n\n\n#### 知识点\n\n* 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败\n","source":"_posts/Android/框架/fastjson的使用.md","raw":"\n\n#### JSONString与HashMap之间的转换\n\n* HashMap转换为JsonString\n\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    String JSONString=JSON.toJSONString(hashMap);\n```\n\n\n* JsonString转换为HashMap\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap= JSON.parseObject(JSONString, Map.class);\n    \n    //错误方式\n    hashMap= (Map<String, String>) JSON.parse(JSONString);\n```\n\n**注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**\n\n\n#### 知识点\n\n* 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败\n","slug":"Android/框架/fastjson的使用","published":1,"date":"2019-09-27T08:23:54.030Z","updated":"2019-11-30T11:14:32.191Z","title":"Android/框架/fastjson的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhj002qisui3s1jfogt","content":"<h4 id=\"JSONString与HashMap之间的转换\"><a href=\"#JSONString与HashMap之间的转换\" class=\"headerlink\" title=\"JSONString与HashMap之间的转换\"></a>JSONString与HashMap之间的转换</h4><ul>\n<li>HashMap转换为JsonString</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String JSONString=JSON.toJSONString(hashMap);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>JsonString转换为HashMap<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap= JSON.parseObject(JSONString, Map<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误方式</span></span><br><span class=\"line\">hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据</strong></p>\n<h4 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h4><ul>\n<li>在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JSONString与HashMap之间的转换\"><a href=\"#JSONString与HashMap之间的转换\" class=\"headerlink\" title=\"JSONString与HashMap之间的转换\"></a>JSONString与HashMap之间的转换</h4><ul>\n<li>HashMap转换为JsonString</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String JSONString=JSON.toJSONString(hashMap);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>JsonString转换为HashMap<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap= JSON.parseObject(JSONString, Map<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误方式</span></span><br><span class=\"line\">hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据</strong></p>\n<h4 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h4><ul>\n<li>在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败</li>\n</ul>\n"},{"_content":"## Java关键字介绍\n\n### static\n\n### volatile\n\n\n\n\n### final\nfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；\n\n#### 在数据中使用final\n一个数据不可改变有两种原因：\n* 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。\n* 在运行时赋初值后不可改变；\n\n当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。\n\n\n#### 在方法中使用final\n final作为方法参数使用时，表示该引用不能被修改；\n \n final直接修饰方法时，有两个原因\n * 防止子类修改该方法，避免该方法被重写(overridden)\n * 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）\n \n\n\n#### 在类中使用final\n\n禁止该类被继承\n\n### transient\n\n### long关键字\n\n在Java开发过程中，如果需要long类型的变量，需要在变量后加`l`\n\n```\n     long a=1000000000000l;\n     //long b=1000000000000;        //会报出Integer number too large\n     //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large\n     //long b1=100*1000*1000*1000;  //b1会输出一个奇怪的值 1215752192\n     //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围\n     //long b1=(long)(100*1000*1000*1000);;  //使用功强制类型转换，b1会输出一个奇怪的值 1215752192\n     long b1=100l*1000l*1000l*1000l;   //正确写法\n     //long b1=100*1000*1000l*1000l;     //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果\n   \n\n```","source":"_posts/Java/Java基础/Java关键字.md","raw":"## Java关键字介绍\n\n### static\n\n### volatile\n\n\n\n\n### final\nfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；\n\n#### 在数据中使用final\n一个数据不可改变有两种原因：\n* 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。\n* 在运行时赋初值后不可改变；\n\n当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。\n\n\n#### 在方法中使用final\n final作为方法参数使用时，表示该引用不能被修改；\n \n final直接修饰方法时，有两个原因\n * 防止子类修改该方法，避免该方法被重写(overridden)\n * 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）\n \n\n\n#### 在类中使用final\n\n禁止该类被继承\n\n### transient\n\n### long关键字\n\n在Java开发过程中，如果需要long类型的变量，需要在变量后加`l`\n\n```\n     long a=1000000000000l;\n     //long b=1000000000000;        //会报出Integer number too large\n     //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large\n     //long b1=100*1000*1000*1000;  //b1会输出一个奇怪的值 1215752192\n     //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围\n     //long b1=(long)(100*1000*1000*1000);;  //使用功强制类型转换，b1会输出一个奇怪的值 1215752192\n     long b1=100l*1000l*1000l*1000l;   //正确写法\n     //long b1=100*1000*1000l*1000l;     //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果\n   \n\n```","slug":"Java/Java基础/Java关键字","published":1,"date":"2019-09-19T09:41:14.769Z","updated":"2019-11-30T11:14:32.244Z","title":"Java/Java基础/Java关键字","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhj002risuidp496lx2","content":"<h2 id=\"Java关键字介绍\"><a href=\"#Java关键字介绍\" class=\"headerlink\" title=\"Java关键字介绍\"></a>Java关键字介绍</h2><h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；</p>\n<h4 id=\"在数据中使用final\"><a href=\"#在数据中使用final\" class=\"headerlink\" title=\"在数据中使用final\"></a>在数据中使用final</h4><p>一个数据不可改变有两种原因：</p>\n<ul>\n<li>在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。</li>\n<li>在运行时赋初值后不可改变；</li>\n</ul>\n<p>当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。</p>\n<h4 id=\"在方法中使用final\"><a href=\"#在方法中使用final\" class=\"headerlink\" title=\"在方法中使用final\"></a>在方法中使用final</h4><p> final作为方法参数使用时，表示该引用不能被修改；</p>\n<p> final直接修饰方法时，有两个原因</p>\n<ul>\n<li>防止子类修改该方法，避免该方法被重写(overridden)</li>\n<li>在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）</li>\n</ul>\n<h4 id=\"在类中使用final\"><a href=\"#在类中使用final\" class=\"headerlink\" title=\"在类中使用final\"></a>在类中使用final</h4><p>禁止该类被继承</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><h3 id=\"long关键字\"><a href=\"#long关键字\" class=\"headerlink\" title=\"long关键字\"></a>long关键字</h3><p>在Java开发过程中，如果需要long类型的变量，需要在变量后加<code>l</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a&#x3D;1000000000000l;</span><br><span class=\"line\">&#x2F;&#x2F;long b&#x3D;1000000000000;        &#x2F;&#x2F;会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b &#x3D; (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000*1000;  &#x2F;&#x2F;b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">&#x2F;&#x2F;这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;(long)(100*1000*1000*1000);;  &#x2F;&#x2F;使用功强制类型转换，b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">long b1&#x3D;100l*1000l*1000l*1000l;   &#x2F;&#x2F;正确写法</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000l*1000l;     &#x2F;&#x2F;可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java关键字介绍\"><a href=\"#Java关键字介绍\" class=\"headerlink\" title=\"Java关键字介绍\"></a>Java关键字介绍</h2><h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；</p>\n<h4 id=\"在数据中使用final\"><a href=\"#在数据中使用final\" class=\"headerlink\" title=\"在数据中使用final\"></a>在数据中使用final</h4><p>一个数据不可改变有两种原因：</p>\n<ul>\n<li>在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。</li>\n<li>在运行时赋初值后不可改变；</li>\n</ul>\n<p>当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。</p>\n<h4 id=\"在方法中使用final\"><a href=\"#在方法中使用final\" class=\"headerlink\" title=\"在方法中使用final\"></a>在方法中使用final</h4><p> final作为方法参数使用时，表示该引用不能被修改；</p>\n<p> final直接修饰方法时，有两个原因</p>\n<ul>\n<li>防止子类修改该方法，避免该方法被重写(overridden)</li>\n<li>在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）</li>\n</ul>\n<h4 id=\"在类中使用final\"><a href=\"#在类中使用final\" class=\"headerlink\" title=\"在类中使用final\"></a>在类中使用final</h4><p>禁止该类被继承</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><h3 id=\"long关键字\"><a href=\"#long关键字\" class=\"headerlink\" title=\"long关键字\"></a>long关键字</h3><p>在Java开发过程中，如果需要long类型的变量，需要在变量后加<code>l</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a&#x3D;1000000000000l;</span><br><span class=\"line\">&#x2F;&#x2F;long b&#x3D;1000000000000;        &#x2F;&#x2F;会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b &#x3D; (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000*1000;  &#x2F;&#x2F;b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">&#x2F;&#x2F;这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;(long)(100*1000*1000*1000);;  &#x2F;&#x2F;使用功强制类型转换，b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">long b1&#x3D;100l*1000l*1000l*1000l;   &#x2F;&#x2F;正确写法</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000l*1000l;     &#x2F;&#x2F;可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果</span><br></pre></td></tr></table></figure>"},{"_content":"### java 内部类\n\n内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。\n\n\n### 内部类的作用\n\n实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。\n\n内部类可以同时用多个实例，每个实例都有自己的状态信息；\n\n内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；\n\n\n### 内部类分类\n\n#### 局部内部类\n\n嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。\n\n#### 静态内部类\n\n静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式\n\n \n```java\n    public class Singleton {  \n        private static class SingletonHolder {  \n            private static final Singleton INSTANCE = new Singleton();  \n        }  \n        private Singleton (){}  \n        public static final Singleton getInstance() {  \n            return SingletonHolder.INSTANCE; \n        }  \n    }\n \n```   \n\n#### 匿名内部类\n\n匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型\n\n```java\n\n    new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello\");\n            }\n        }).start();\n\n\n```\n\n\n#### 内部类与闭包\n\n内部类会包含对外部类的引用，形成闭包\n\n```java\n        \n    public class Outer{\n        private int a=1;\n        \n        public class Inner{\n            private int b=2;\n            public int multi(){\n            return a*b;\n        }\n    }\n        \n\n```\n\n\n","source":"_posts/Java/Java基础/Java内部类.md","raw":"### java 内部类\n\n内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。\n\n\n### 内部类的作用\n\n实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。\n\n内部类可以同时用多个实例，每个实例都有自己的状态信息；\n\n内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；\n\n\n### 内部类分类\n\n#### 局部内部类\n\n嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。\n\n#### 静态内部类\n\n静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式\n\n \n```java\n    public class Singleton {  \n        private static class SingletonHolder {  \n            private static final Singleton INSTANCE = new Singleton();  \n        }  \n        private Singleton (){}  \n        public static final Singleton getInstance() {  \n            return SingletonHolder.INSTANCE; \n        }  \n    }\n \n```   \n\n#### 匿名内部类\n\n匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型\n\n```java\n\n    new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello\");\n            }\n        }).start();\n\n\n```\n\n\n#### 内部类与闭包\n\n内部类会包含对外部类的引用，形成闭包\n\n```java\n        \n    public class Outer{\n        private int a=1;\n        \n        public class Inner{\n            private int b=2;\n            public int multi(){\n            return a*b;\n        }\n    }\n        \n\n```\n\n\n","slug":"Java/Java基础/Java内部类","published":1,"date":"2019-11-28T12:18:36.245Z","updated":"2019-11-30T11:14:32.244Z","title":"Java/Java基础/Java内部类","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhk002sisui8w910f8r","content":"<h3 id=\"java-内部类\"><a href=\"#java-内部类\" class=\"headerlink\" title=\"java 内部类\"></a>java 内部类</h3><p>内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。</p>\n<h3 id=\"内部类的作用\"><a href=\"#内部类的作用\" class=\"headerlink\" title=\"内部类的作用\"></a>内部类的作用</h3><p>实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。</p>\n<p>内部类可以同时用多个实例，每个实例都有自己的状态信息；</p>\n<p>内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；</p>\n<h3 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h3><h4 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h4><p>嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">#### 匿名内部类</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为<span class=\"keyword\">final</span>类型</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"内部类与闭包\"><a href=\"#内部类与闭包\" class=\"headerlink\" title=\"内部类与闭包\"></a>内部类与闭包</h4><p>内部类会包含对外部类的引用，形成闭包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"java-内部类\"><a href=\"#java-内部类\" class=\"headerlink\" title=\"java 内部类\"></a>java 内部类</h3><p>内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。</p>\n<h3 id=\"内部类的作用\"><a href=\"#内部类的作用\" class=\"headerlink\" title=\"内部类的作用\"></a>内部类的作用</h3><p>实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。</p>\n<p>内部类可以同时用多个实例，每个实例都有自己的状态信息；</p>\n<p>内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；</p>\n<h3 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h3><h4 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h4><p>嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">#### 匿名内部类</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为<span class=\"keyword\">final</span>类型</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"内部类与闭包\"><a href=\"#内部类与闭包\" class=\"headerlink\" title=\"内部类与闭包\"></a>内部类与闭包</h4><p>内部类会包含对外部类的引用，形成闭包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"\n\n\n## Java引用\n\n在`java.lang.ref`包中有一系列可以辅助GC灵活进行处理的类；抽象类`Reference`有三个子类`SoftReference`(软引用),`WeakReference`(弱引用),和`PhantomReference`(虚引用)，三个子类的可达性依次减弱。\n\n当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用`Reference`，如果GC发现一个Object是可达的，那么不会回收该对象。\n\n\n|引用类型 |GC回收时间 |用途 |生存时间|\n|-|-|-|-|\n|HardReference|从不|对象的一般状态|JVM停止运行时|\n|SoftReference|内存不足时|对象缓存|内存不足时停止|\n|WeakReference|GC时|对象缓存|GC后终止|\n|PhantomReference|unknown|unknown|unknown|\n\n`SoftReference`和`WeakReference`可以选择是否将其放入`ReferenceQueue`，而`PhantomReference`必须放入`ReferenceQueue`中。\n\n注：`ReferenceQueue`用于`PhantomReference`的清理\n\n\n\n### Java基本类型与引用类型\n\n注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。","source":"_posts/Java/Java基础/Java引用.md","raw":"\n\n\n## Java引用\n\n在`java.lang.ref`包中有一系列可以辅助GC灵活进行处理的类；抽象类`Reference`有三个子类`SoftReference`(软引用),`WeakReference`(弱引用),和`PhantomReference`(虚引用)，三个子类的可达性依次减弱。\n\n当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用`Reference`，如果GC发现一个Object是可达的，那么不会回收该对象。\n\n\n|引用类型 |GC回收时间 |用途 |生存时间|\n|-|-|-|-|\n|HardReference|从不|对象的一般状态|JVM停止运行时|\n|SoftReference|内存不足时|对象缓存|内存不足时停止|\n|WeakReference|GC时|对象缓存|GC后终止|\n|PhantomReference|unknown|unknown|unknown|\n\n`SoftReference`和`WeakReference`可以选择是否将其放入`ReferenceQueue`，而`PhantomReference`必须放入`ReferenceQueue`中。\n\n注：`ReferenceQueue`用于`PhantomReference`的清理\n\n\n\n### Java基本类型与引用类型\n\n注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。","slug":"Java/Java基础/Java引用","published":1,"date":"2019-11-28T12:20:15.918Z","updated":"2019-11-30T11:14:32.244Z","title":"Java/Java基础/Java引用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhk002tisui499y5nxg","content":"<h2 id=\"Java引用\"><a href=\"#Java引用\" class=\"headerlink\" title=\"Java引用\"></a>Java引用</h2><p>在<code>java.lang.ref</code>包中有一系列可以辅助GC灵活进行处理的类；抽象类<code>Reference</code>有三个子类<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),和<code>PhantomReference</code>(虚引用)，三个子类的可达性依次减弱。</p>\n<p>当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用<code>Reference</code>，如果GC发现一个Object是可达的，那么不会回收该对象。</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>GC回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HardReference</td>\n<td>从不</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时停止</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>GC时</td>\n<td>对象缓存</td>\n<td>GC后终止</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>unknown</td>\n<td>unknown</td>\n<td>unknown</td>\n</tr>\n</tbody></table>\n<p><code>SoftReference</code>和<code>WeakReference</code>可以选择是否将其放入<code>ReferenceQueue</code>，而<code>PhantomReference</code>必须放入<code>ReferenceQueue</code>中。</p>\n<p>注：<code>ReferenceQueue</code>用于<code>PhantomReference</code>的清理</p>\n<h3 id=\"Java基本类型与引用类型\"><a href=\"#Java基本类型与引用类型\" class=\"headerlink\" title=\"Java基本类型与引用类型\"></a>Java基本类型与引用类型</h3><p>注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java引用\"><a href=\"#Java引用\" class=\"headerlink\" title=\"Java引用\"></a>Java引用</h2><p>在<code>java.lang.ref</code>包中有一系列可以辅助GC灵活进行处理的类；抽象类<code>Reference</code>有三个子类<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),和<code>PhantomReference</code>(虚引用)，三个子类的可达性依次减弱。</p>\n<p>当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用<code>Reference</code>，如果GC发现一个Object是可达的，那么不会回收该对象。</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>GC回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HardReference</td>\n<td>从不</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时停止</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>GC时</td>\n<td>对象缓存</td>\n<td>GC后终止</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>unknown</td>\n<td>unknown</td>\n<td>unknown</td>\n</tr>\n</tbody></table>\n<p><code>SoftReference</code>和<code>WeakReference</code>可以选择是否将其放入<code>ReferenceQueue</code>，而<code>PhantomReference</code>必须放入<code>ReferenceQueue</code>中。</p>\n<p>注：<code>ReferenceQueue</code>用于<code>PhantomReference</code>的清理</p>\n<h3 id=\"Java基本类型与引用类型\"><a href=\"#Java基本类型与引用类型\" class=\"headerlink\" title=\"Java基本类型与引用类型\"></a>Java基本类型与引用类型</h3><p>注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。</p>\n"},{"_content":"## Queue 接口\n\n# Collection的使用方法\n\n接口`Collection`继承自`Iterable`接口    \n\n用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。\n\n### BlockingQueue接口\n实现类 \n* ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小\n* DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口\n* LinkedBlockingQueue 内部以链表的形式实现\n* PriorityBlockingQueue 无界并发队列\n* SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；\n\n方法\n* add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常\n* remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* offer  添加一个元素并返回true，如果队列已满，则返回false\n* poll  移除并返问队列头部的元素，，如果队列为空，则返回null\n* peek  返回队列头部的元素，如果队列为空，则返回null\n* put  添加一个元素，如果队列满，则阻塞\n* take 移除并返回队列头部的元素，如果队列为空，则阻塞\n\n \n\n## List接口：实现类 ArrayList LinkedList Vector\n### ArrayList\n\nArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；\n\nArrayList在循环中删除元素可能会出现问题：\n1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏\n2、使用for-each进行删除，实际是调用它的迭代器来实现，\n\n### LinkedList\nLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） \n\n### Vector\n\nVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；\n\n    \n    \n**Java Doc里建议用Deque替代Stack接口完成栈的功能**\n\n\n## Set接口：实现类 Hashset、TreeSet\n\n*  Hashset：按照哈希算法存取集合中的对象，存取速度快\n*  TreeSet：实现Sorted接口，能够对集合中的对象进行排序\n\n## Map接口\n\n\n\n### HashMap遍历\n\n\n\n##  Iterable和Iterator(迭代器)\n\n\n\n\n\n\n","source":"_posts/Java/Java基础/Java集合.md","raw":"## Queue 接口\n\n# Collection的使用方法\n\n接口`Collection`继承自`Iterable`接口    \n\n用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。\n\n### BlockingQueue接口\n实现类 \n* ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小\n* DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口\n* LinkedBlockingQueue 内部以链表的形式实现\n* PriorityBlockingQueue 无界并发队列\n* SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；\n\n方法\n* add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常\n* remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* offer  添加一个元素并返回true，如果队列已满，则返回false\n* poll  移除并返问队列头部的元素，，如果队列为空，则返回null\n* peek  返回队列头部的元素，如果队列为空，则返回null\n* put  添加一个元素，如果队列满，则阻塞\n* take 移除并返回队列头部的元素，如果队列为空，则阻塞\n\n \n\n## List接口：实现类 ArrayList LinkedList Vector\n### ArrayList\n\nArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；\n\nArrayList在循环中删除元素可能会出现问题：\n1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏\n2、使用for-each进行删除，实际是调用它的迭代器来实现，\n\n### LinkedList\nLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） \n\n### Vector\n\nVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；\n\n    \n    \n**Java Doc里建议用Deque替代Stack接口完成栈的功能**\n\n\n## Set接口：实现类 Hashset、TreeSet\n\n*  Hashset：按照哈希算法存取集合中的对象，存取速度快\n*  TreeSet：实现Sorted接口，能够对集合中的对象进行排序\n\n## Map接口\n\n\n\n### HashMap遍历\n\n\n\n##  Iterable和Iterator(迭代器)\n\n\n\n\n\n\n","slug":"Java/Java基础/Java集合","published":1,"date":"2019-09-27T08:23:54.079Z","updated":"2019-09-30T08:28:42.971Z","title":"Java/Java基础/Java集合","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhl002uisui0urubitd","content":"<h2 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h2><h1 id=\"Collection的使用方法\"><a href=\"#Collection的使用方法\" class=\"headerlink\" title=\"Collection的使用方法\"></a>Collection的使用方法</h1><p>接口<code>Collection</code>继承自<code>Iterable</code>接口    </p>\n<p>用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。</p>\n<h3 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h3><p>实现类 </p>\n<ul>\n<li>ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小</li>\n<li>DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口</li>\n<li>LinkedBlockingQueue 内部以链表的形式实现</li>\n<li>PriorityBlockingQueue 无界并发队列</li>\n<li>SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li>\n<li>remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>offer  添加一个元素并返回true，如果队列已满，则返回false</li>\n<li>poll  移除并返问队列头部的元素，，如果队列为空，则返回null</li>\n<li>peek  返回队列头部的元素，如果队列为空，则返回null</li>\n<li>put  添加一个元素，如果队列满，则阻塞</li>\n<li>take 移除并返回队列头部的元素，如果队列为空，则阻塞</li>\n</ul>\n<h2 id=\"List接口：实现类-ArrayList-LinkedList-Vector\"><a href=\"#List接口：实现类-ArrayList-LinkedList-Vector\" class=\"headerlink\" title=\"List接口：实现类 ArrayList LinkedList Vector\"></a>List接口：实现类 ArrayList LinkedList Vector</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；</p>\n<p>ArrayList在循环中删除元素可能会出现问题：<br>1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏<br>2、使用for-each进行删除，实际是调用它的迭代器来实现，</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） </p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；</p>\n<p><strong>Java Doc里建议用Deque替代Stack接口完成栈的功能</strong></p>\n<h2 id=\"Set接口：实现类-Hashset、TreeSet\"><a href=\"#Set接口：实现类-Hashset、TreeSet\" class=\"headerlink\" title=\"Set接口：实现类 Hashset、TreeSet\"></a>Set接口：实现类 Hashset、TreeSet</h2><ul>\n<li>Hashset：按照哈希算法存取集合中的对象，存取速度快</li>\n<li>TreeSet：实现Sorted接口，能够对集合中的对象进行排序</li>\n</ul>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap遍历\"><a href=\"#HashMap遍历\" class=\"headerlink\" title=\"HashMap遍历\"></a>HashMap遍历</h3><h2 id=\"Iterable和Iterator-迭代器\"><a href=\"#Iterable和Iterator-迭代器\" class=\"headerlink\" title=\"Iterable和Iterator(迭代器)\"></a>Iterable和Iterator(迭代器)</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h2><h1 id=\"Collection的使用方法\"><a href=\"#Collection的使用方法\" class=\"headerlink\" title=\"Collection的使用方法\"></a>Collection的使用方法</h1><p>接口<code>Collection</code>继承自<code>Iterable</code>接口    </p>\n<p>用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。</p>\n<h3 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h3><p>实现类 </p>\n<ul>\n<li>ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小</li>\n<li>DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口</li>\n<li>LinkedBlockingQueue 内部以链表的形式实现</li>\n<li>PriorityBlockingQueue 无界并发队列</li>\n<li>SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li>\n<li>remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>offer  添加一个元素并返回true，如果队列已满，则返回false</li>\n<li>poll  移除并返问队列头部的元素，，如果队列为空，则返回null</li>\n<li>peek  返回队列头部的元素，如果队列为空，则返回null</li>\n<li>put  添加一个元素，如果队列满，则阻塞</li>\n<li>take 移除并返回队列头部的元素，如果队列为空，则阻塞</li>\n</ul>\n<h2 id=\"List接口：实现类-ArrayList-LinkedList-Vector\"><a href=\"#List接口：实现类-ArrayList-LinkedList-Vector\" class=\"headerlink\" title=\"List接口：实现类 ArrayList LinkedList Vector\"></a>List接口：实现类 ArrayList LinkedList Vector</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；</p>\n<p>ArrayList在循环中删除元素可能会出现问题：<br>1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏<br>2、使用for-each进行删除，实际是调用它的迭代器来实现，</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） </p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；</p>\n<p><strong>Java Doc里建议用Deque替代Stack接口完成栈的功能</strong></p>\n<h2 id=\"Set接口：实现类-Hashset、TreeSet\"><a href=\"#Set接口：实现类-Hashset、TreeSet\" class=\"headerlink\" title=\"Set接口：实现类 Hashset、TreeSet\"></a>Set接口：实现类 Hashset、TreeSet</h2><ul>\n<li>Hashset：按照哈希算法存取集合中的对象，存取速度快</li>\n<li>TreeSet：实现Sorted接口，能够对集合中的对象进行排序</li>\n</ul>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap遍历\"><a href=\"#HashMap遍历\" class=\"headerlink\" title=\"HashMap遍历\"></a>HashMap遍历</h3><h2 id=\"Iterable和Iterator-迭代器\"><a href=\"#Iterable和Iterator-迭代器\" class=\"headerlink\" title=\"Iterable和Iterator(迭代器)\"></a>Iterable和Iterator(迭代器)</h2>"},{"_content":"\n\n### Lambda介绍\nLambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的**；\n\n\n\n### Java Lambda表达式的写法\n\nJava中的Lambda表达式通常用`(argument)->(body)`的语法表示\n\n```java\n    (arg1, arg2...) -> { body }\n    (type1 arg1, type2 arg2...) -> { body }\n```\n\n* 一个Lambda表达式可以有零个或多个参数；\n* Lambda表达式的主体可以包括零条或多条语句；\n* 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。\n\n\n### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface），`java.lang.Runnable`接口是只有一个`run()`方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建`Runnable`接口引用如下：\n\n```java\n    Runnable r=()->Log.i(\"测试\",\"Hello Word\");\n    //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口\n    new Thread(()->Log.i(\"测试\",\"Hello Word\")).start();\n \n```\n\n###  Lambda表达式与匿名类的区别\n\n* 对于关键字的使用：对于匿名类，关键字`this`解读为匿名类，而对于Lambda表达式，关键字`this`解读为Lambda的外部类\n\n* Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。\n\n\n### 使用Lambda表达式将List中的元素按照长度进行排序\n\n```java\n    \n    //采用匿名内部类写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, new Comparator<String>(){\n        @Override\n        public int compare(String s1, String s2){\n            return s1.length()-s2.length();\n        }\n    });\n    \n    //采用Lambda写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, (s1, s2) ->{\n        return s1.length()-s2.length();\n    });\n            \n```\n\n### 使用Lambda将List中的每个值平方，并计算和\n\n`java.util.stream.Stream`接口，在Java8引入，必须使用Lambda表达式作为参数，`map()`将input stream的元素，映射成out stream；`reduce()`方法用于将stream元素组合起来。\n\n```java\n    \n    //常用写法\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = 0;\n    for(Integer tmp : list) {\n        int x = tmp +tmp;\n        sum = sum + x;\n    }\n    System.out.println(sum);\n\n    // 使用Lambda写法，\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();\n    System.out.println(sum);\n\n\n```\n\n\n\n\n\n\n<<<<<<< HEAD\n=======\n#### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface）\n\n\n#### Lambda表达式使用注意事项\n\n在Lambda表达式中不能有指向其自己的引用，关键字`this`指向的是闭包，而在匿名内部类中`this`关键字指向的是匿名函数自己，\n\n\n### Lambda表达式的常用方法\n\n#### 使用lambda表达式替换匿名类\n使用lambda表达式替换匿名类，需要用到函数式接口,如`Runnable接口`；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。\n\n``` java\n    //使用匿名内部类表达式方法\n    new Thread(new Runnable(){\n        @Override\n        public void run() {\n        System.out.println(\"Test Runnable 1\");\n    }\n    \n    ).start();\n    \n    //使用匿名内部类的方式\n    new Thread( () -> System.out.println(\"Test Runnable 2\") ).start();\n\n```\n\n在使用lambda表达式进行排序时，`Comparator<String>`中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    \n\n\n```java\n    //使用匿名内部类方式对list进行排序\n    Collections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n        }\n    });\n    //使用lambda表达式方式对list进行排序\n    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n\n```\n\n\n\n#### 使用Lambda表达式进行点击事件处理\n\n```java\n    //非lambda表达式方法\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n        Log.i(\"info\",\"点击\");\n        }\n    });\n\n    //使用lambda表达式方式\n    button.setOnClickListener((e)->{\n        Log.i(\"info\",\"点击\");\n    });\n\n\n```\n\n但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，`setOnClickListener()`方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式\n\n```\n        hello.setOnClickListener(object : View.OnClickListener {\n            override fun onClick(v: View?) {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n        })\n        \n        //或者\n       hello.setOnClickListener{\n          Log.i(\"info\",\"点击\");\n        }\n\n\n```\n\n\n#### 在Java中使用lambda表达式和函数式接口Predicate\n\n在`java.util.function`包中，包含多个类用于支持Java的函数式编程，使用`java.util.function.Predicate`函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为\n\n\n\n\n\n\n\n>>>>>>> EditBranch\n","source":"_posts/Java/Java基础/Lambda表达式.md","raw":"\n\n### Lambda介绍\nLambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的**；\n\n\n\n### Java Lambda表达式的写法\n\nJava中的Lambda表达式通常用`(argument)->(body)`的语法表示\n\n```java\n    (arg1, arg2...) -> { body }\n    (type1 arg1, type2 arg2...) -> { body }\n```\n\n* 一个Lambda表达式可以有零个或多个参数；\n* Lambda表达式的主体可以包括零条或多条语句；\n* 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。\n\n\n### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface），`java.lang.Runnable`接口是只有一个`run()`方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建`Runnable`接口引用如下：\n\n```java\n    Runnable r=()->Log.i(\"测试\",\"Hello Word\");\n    //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口\n    new Thread(()->Log.i(\"测试\",\"Hello Word\")).start();\n \n```\n\n###  Lambda表达式与匿名类的区别\n\n* 对于关键字的使用：对于匿名类，关键字`this`解读为匿名类，而对于Lambda表达式，关键字`this`解读为Lambda的外部类\n\n* Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。\n\n\n### 使用Lambda表达式将List中的元素按照长度进行排序\n\n```java\n    \n    //采用匿名内部类写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, new Comparator<String>(){\n        @Override\n        public int compare(String s1, String s2){\n            return s1.length()-s2.length();\n        }\n    });\n    \n    //采用Lambda写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, (s1, s2) ->{\n        return s1.length()-s2.length();\n    });\n            \n```\n\n### 使用Lambda将List中的每个值平方，并计算和\n\n`java.util.stream.Stream`接口，在Java8引入，必须使用Lambda表达式作为参数，`map()`将input stream的元素，映射成out stream；`reduce()`方法用于将stream元素组合起来。\n\n```java\n    \n    //常用写法\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = 0;\n    for(Integer tmp : list) {\n        int x = tmp +tmp;\n        sum = sum + x;\n    }\n    System.out.println(sum);\n\n    // 使用Lambda写法，\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();\n    System.out.println(sum);\n\n\n```\n\n\n\n\n\n\n<<<<<<< HEAD\n=======\n#### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface）\n\n\n#### Lambda表达式使用注意事项\n\n在Lambda表达式中不能有指向其自己的引用，关键字`this`指向的是闭包，而在匿名内部类中`this`关键字指向的是匿名函数自己，\n\n\n### Lambda表达式的常用方法\n\n#### 使用lambda表达式替换匿名类\n使用lambda表达式替换匿名类，需要用到函数式接口,如`Runnable接口`；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。\n\n``` java\n    //使用匿名内部类表达式方法\n    new Thread(new Runnable(){\n        @Override\n        public void run() {\n        System.out.println(\"Test Runnable 1\");\n    }\n    \n    ).start();\n    \n    //使用匿名内部类的方式\n    new Thread( () -> System.out.println(\"Test Runnable 2\") ).start();\n\n```\n\n在使用lambda表达式进行排序时，`Comparator<String>`中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    \n\n\n```java\n    //使用匿名内部类方式对list进行排序\n    Collections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n        }\n    });\n    //使用lambda表达式方式对list进行排序\n    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n\n```\n\n\n\n#### 使用Lambda表达式进行点击事件处理\n\n```java\n    //非lambda表达式方法\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n        Log.i(\"info\",\"点击\");\n        }\n    });\n\n    //使用lambda表达式方式\n    button.setOnClickListener((e)->{\n        Log.i(\"info\",\"点击\");\n    });\n\n\n```\n\n但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，`setOnClickListener()`方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式\n\n```\n        hello.setOnClickListener(object : View.OnClickListener {\n            override fun onClick(v: View?) {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n        })\n        \n        //或者\n       hello.setOnClickListener{\n          Log.i(\"info\",\"点击\");\n        }\n\n\n```\n\n\n#### 在Java中使用lambda表达式和函数式接口Predicate\n\n在`java.util.function`包中，包含多个类用于支持Java的函数式编程，使用`java.util.function.Predicate`函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为\n\n\n\n\n\n\n\n>>>>>>> EditBranch\n","slug":"Java/Java基础/Lambda表达式","published":1,"date":"2019-09-19T09:41:14.773Z","updated":"2019-11-30T11:14:32.245Z","title":"Java/Java基础/Lambda表达式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhl002visuicvvxg8cx","content":"<h3 id=\"Lambda介绍\"><a href=\"#Lambda介绍\" class=\"headerlink\" title=\"Lambda介绍\"></a>Lambda介绍</h3><p>Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<strong>在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的</strong>；</p>\n<h3 id=\"Java-Lambda表达式的写法\"><a href=\"#Java-Lambda表达式的写法\" class=\"headerlink\" title=\"Java Lambda表达式的写法\"></a>Java Lambda表达式的写法</h3><p>Java中的Lambda表达式通常用<code>(argument)-&gt;(body)</code>的语法表示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class=\"line\">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个Lambda表达式可以有零个或多个参数；</li>\n<li>Lambda表达式的主体可以包括零条或多条语句；</li>\n<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。</li>\n</ul>\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>把只有一个抽象方法的接口叫做函数式接口（functional interface），<code>java.lang.Runnable</code>接口是只有一个<code>run()</code>方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建<code>Runnable</code>接口引用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r=()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>)).start();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lambda表达式与匿名类的区别\"><a href=\"#Lambda表达式与匿名类的区别\" class=\"headerlink\" title=\"Lambda表达式与匿名类的区别\"></a>Lambda表达式与匿名类的区别</h3><ul>\n<li><p>对于关键字的使用：对于匿名类，关键字<code>this</code>解读为匿名类，而对于Lambda表达式，关键字<code>this</code>解读为Lambda的外部类</p>\n</li>\n<li><p>Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。</p>\n</li>\n</ul>\n<h3 id=\"使用Lambda表达式将List中的元素按照长度进行排序\"><a href=\"#使用Lambda表达式将List中的元素按照长度进行排序\" class=\"headerlink\" title=\"使用Lambda表达式将List中的元素按照长度进行排序\"></a>使用Lambda表达式将List中的元素按照长度进行排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用Lambda写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Lambda将List中的每个值平方，并计算和\"><a href=\"#使用Lambda将List中的每个值平方，并计算和\" class=\"headerlink\" title=\"使用Lambda将List中的每个值平方，并计算和\"></a>使用Lambda将List中的每个值平方，并计算和</h3><p><code>java.util.stream.Stream</code>接口，在Java8引入，必须使用Lambda表达式作为参数，<code>map()</code>将input stream的元素，映射成out stream；<code>reduce()</code>方法用于将stream元素组合起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常用写法</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer tmp : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = tmp +tmp;</span><br><span class=\"line\">    sum = sum + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Lambda写法，</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h4 id=\"函数式接口-1\"><a href=\"#函数式接口-1\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h4><p>把只有一个抽象方法的接口叫做函数式接口（functional interface）</p>\n<h4 id=\"Lambda表达式使用注意事项\"><a href=\"#Lambda表达式使用注意事项\" class=\"headerlink\" title=\"Lambda表达式使用注意事项\"></a>Lambda表达式使用注意事项</h4><p>在Lambda表达式中不能有指向其自己的引用，关键字<code>this</code>指向的是闭包，而在匿名内部类中<code>this</code>关键字指向的是匿名函数自己，</p>\n<h3 id=\"Lambda表达式的常用方法\"><a href=\"#Lambda表达式的常用方法\" class=\"headerlink\" title=\"Lambda表达式的常用方法\"></a>Lambda表达式的常用方法</h3><h4 id=\"使用lambda表达式替换匿名类\"><a href=\"#使用lambda表达式替换匿名类\" class=\"headerlink\" title=\"使用lambda表达式替换匿名类\"></a>使用lambda表达式替换匿名类</h4><p>使用lambda表达式替换匿名类，需要用到函数式接口,如<code>Runnable接口</code>；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类表达式方法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Test Runnable 1\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用匿名内部类的方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread( () -&gt; System.out.println(<span class=\"string\">\"Test Runnable 2\"</span>) ).start();</span><br></pre></td></tr></table></figure>\n\n<p>在使用lambda表达式进行排序时，<code>Comparator&lt;String&gt;</code>中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"使用Lambda表达式进行点击事件处理\"><a href=\"#使用Lambda表达式进行点击事件处理\" class=\"headerlink\" title=\"使用Lambda表达式进行点击事件处理\"></a>使用Lambda表达式进行点击事件处理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非lambda表达式方法</span></span><br><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式</span></span><br><span class=\"line\">button.setOnClickListener((e)-&gt;&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，<code>setOnClickListener()</code>方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> hello.setOnClickListener(object : View.OnClickListener &#123;</span><br><span class=\"line\">     override fun onClick(v: View?) &#123;</span><br><span class=\"line\">         TODO(&quot;not implemented&quot;) &#x2F;&#x2F;To change body of created functions use File | Settings | File Templates.</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> &#x2F;&#x2F;或者</span><br><span class=\"line\">hello.setOnClickListener&#123;</span><br><span class=\"line\">   Log.i(&quot;info&quot;,&quot;点击&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"在Java中使用lambda表达式和函数式接口Predicate\"><a href=\"#在Java中使用lambda表达式和函数式接口Predicate\" class=\"headerlink\" title=\"在Java中使用lambda表达式和函数式接口Predicate\"></a>在Java中使用lambda表达式和函数式接口Predicate</h4><p>在<code>java.util.function</code>包中，包含多个类用于支持Java的函数式编程，使用<code>java.util.function.Predicate</code>函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>EditBranch</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Lambda介绍\"><a href=\"#Lambda介绍\" class=\"headerlink\" title=\"Lambda介绍\"></a>Lambda介绍</h3><p>Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<strong>在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的</strong>；</p>\n<h3 id=\"Java-Lambda表达式的写法\"><a href=\"#Java-Lambda表达式的写法\" class=\"headerlink\" title=\"Java Lambda表达式的写法\"></a>Java Lambda表达式的写法</h3><p>Java中的Lambda表达式通常用<code>(argument)-&gt;(body)</code>的语法表示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class=\"line\">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个Lambda表达式可以有零个或多个参数；</li>\n<li>Lambda表达式的主体可以包括零条或多条语句；</li>\n<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。</li>\n</ul>\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>把只有一个抽象方法的接口叫做函数式接口（functional interface），<code>java.lang.Runnable</code>接口是只有一个<code>run()</code>方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建<code>Runnable</code>接口引用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r=()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>)).start();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lambda表达式与匿名类的区别\"><a href=\"#Lambda表达式与匿名类的区别\" class=\"headerlink\" title=\"Lambda表达式与匿名类的区别\"></a>Lambda表达式与匿名类的区别</h3><ul>\n<li><p>对于关键字的使用：对于匿名类，关键字<code>this</code>解读为匿名类，而对于Lambda表达式，关键字<code>this</code>解读为Lambda的外部类</p>\n</li>\n<li><p>Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。</p>\n</li>\n</ul>\n<h3 id=\"使用Lambda表达式将List中的元素按照长度进行排序\"><a href=\"#使用Lambda表达式将List中的元素按照长度进行排序\" class=\"headerlink\" title=\"使用Lambda表达式将List中的元素按照长度进行排序\"></a>使用Lambda表达式将List中的元素按照长度进行排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用Lambda写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Lambda将List中的每个值平方，并计算和\"><a href=\"#使用Lambda将List中的每个值平方，并计算和\" class=\"headerlink\" title=\"使用Lambda将List中的每个值平方，并计算和\"></a>使用Lambda将List中的每个值平方，并计算和</h3><p><code>java.util.stream.Stream</code>接口，在Java8引入，必须使用Lambda表达式作为参数，<code>map()</code>将input stream的元素，映射成out stream；<code>reduce()</code>方法用于将stream元素组合起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常用写法</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer tmp : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = tmp +tmp;</span><br><span class=\"line\">    sum = sum + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Lambda写法，</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h4 id=\"函数式接口-1\"><a href=\"#函数式接口-1\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h4><p>把只有一个抽象方法的接口叫做函数式接口（functional interface）</p>\n<h4 id=\"Lambda表达式使用注意事项\"><a href=\"#Lambda表达式使用注意事项\" class=\"headerlink\" title=\"Lambda表达式使用注意事项\"></a>Lambda表达式使用注意事项</h4><p>在Lambda表达式中不能有指向其自己的引用，关键字<code>this</code>指向的是闭包，而在匿名内部类中<code>this</code>关键字指向的是匿名函数自己，</p>\n<h3 id=\"Lambda表达式的常用方法\"><a href=\"#Lambda表达式的常用方法\" class=\"headerlink\" title=\"Lambda表达式的常用方法\"></a>Lambda表达式的常用方法</h3><h4 id=\"使用lambda表达式替换匿名类\"><a href=\"#使用lambda表达式替换匿名类\" class=\"headerlink\" title=\"使用lambda表达式替换匿名类\"></a>使用lambda表达式替换匿名类</h4><p>使用lambda表达式替换匿名类，需要用到函数式接口,如<code>Runnable接口</code>；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类表达式方法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Test Runnable 1\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用匿名内部类的方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread( () -&gt; System.out.println(<span class=\"string\">\"Test Runnable 2\"</span>) ).start();</span><br></pre></td></tr></table></figure>\n\n<p>在使用lambda表达式进行排序时，<code>Comparator&lt;String&gt;</code>中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"使用Lambda表达式进行点击事件处理\"><a href=\"#使用Lambda表达式进行点击事件处理\" class=\"headerlink\" title=\"使用Lambda表达式进行点击事件处理\"></a>使用Lambda表达式进行点击事件处理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非lambda表达式方法</span></span><br><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式</span></span><br><span class=\"line\">button.setOnClickListener((e)-&gt;&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，<code>setOnClickListener()</code>方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> hello.setOnClickListener(object : View.OnClickListener &#123;</span><br><span class=\"line\">     override fun onClick(v: View?) &#123;</span><br><span class=\"line\">         TODO(&quot;not implemented&quot;) &#x2F;&#x2F;To change body of created functions use File | Settings | File Templates.</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> &#x2F;&#x2F;或者</span><br><span class=\"line\">hello.setOnClickListener&#123;</span><br><span class=\"line\">   Log.i(&quot;info&quot;,&quot;点击&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"在Java中使用lambda表达式和函数式接口Predicate\"><a href=\"#在Java中使用lambda表达式和函数式接口Predicate\" class=\"headerlink\" title=\"在Java中使用lambda表达式和函数式接口Predicate\"></a>在Java中使用lambda表达式和函数式接口Predicate</h4><p>在<code>java.util.function</code>包中，包含多个类用于支持Java的函数式编程，使用<code>java.util.function.Predicate</code>函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>EditBranch</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n"},{"_content":"\n## Java基础目录\n\n* [Java输入输出操作](Java输入输出操作.html)\n* [Java关键字](Java关键字.html)\n* [Java泛型](Java泛型.html)\n* [Java集合](Java集合.html)\n* [Java Lambda表达式](Lambda表达式.html)\n* [String、StringBuffer、StringBuilder的区别](String、StringBuffer、StringBuilder区别.html)\n","source":"_posts/Java/Java基础/README.md","raw":"\n## Java基础目录\n\n* [Java输入输出操作](Java输入输出操作.html)\n* [Java关键字](Java关键字.html)\n* [Java泛型](Java泛型.html)\n* [Java集合](Java集合.html)\n* [Java Lambda表达式](Lambda表达式.html)\n* [String、StringBuffer、StringBuilder的区别](String、StringBuffer、StringBuilder区别.html)\n","slug":"Java/Java基础/README","published":1,"date":"2019-09-19T09:41:14.774Z","updated":"2020-02-26T06:13:01.241Z","title":"Java/Java基础/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhm002wisuiek20gx7m","content":"<h2 id=\"Java基础目录\"><a href=\"#Java基础目录\" class=\"headerlink\" title=\"Java基础目录\"></a>Java基础目录</h2><ul>\n<li><a href=\"Java输入输出操作.html\">Java输入输出操作</a></li>\n<li><a href=\"Java关键字.html\">Java关键字</a></li>\n<li><a href=\"Java泛型.html\">Java泛型</a></li>\n<li><a href=\"Java集合.html\">Java集合</a></li>\n<li><a href=\"Lambda表达式.html\">Java Lambda表达式</a></li>\n<li><a href=\"String、StringBuffer、StringBuilder区别.html\">String、StringBuffer、StringBuilder的区别</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java基础目录\"><a href=\"#Java基础目录\" class=\"headerlink\" title=\"Java基础目录\"></a>Java基础目录</h2><ul>\n<li><a href=\"Java输入输出操作.html\">Java输入输出操作</a></li>\n<li><a href=\"Java关键字.html\">Java关键字</a></li>\n<li><a href=\"Java泛型.html\">Java泛型</a></li>\n<li><a href=\"Java集合.html\">Java集合</a></li>\n<li><a href=\"Lambda表达式.html\">Java Lambda表达式</a></li>\n<li><a href=\"String、StringBuffer、StringBuilder区别.html\">String、StringBuffer、StringBuilder的区别</a></li>\n</ul>\n"},{"_content":"### String、StringBuffer、StringBuilder\n\n`String`类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的`String`对象；\n\n`StringBuffer`和`StringBuilder`对象是可以改变的，变化时基于原来的对象基础上机型改变。\n\n### StringBuffer VS. String Builder\n\nStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。\n\n### '+' VS. StringBuilder\n\n\n\n### byte[]和String类型相互转化\n\nbyte[]转换为String,如果是非法值，可能转换不成功\n\n```\n    //用于测试String和byte之间的相互转化\n    String testString=\"1234566789\";\n    byte[] testByte=testString.getBytes();\n    try {\n        String string=new String(testByte, \"UTF-8\");\n        System.out.println(string);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n```","source":"_posts/Java/Java基础/String、StringBuffer、StringBuilder区别.md","raw":"### String、StringBuffer、StringBuilder\n\n`String`类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的`String`对象；\n\n`StringBuffer`和`StringBuilder`对象是可以改变的，变化时基于原来的对象基础上机型改变。\n\n### StringBuffer VS. String Builder\n\nStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。\n\n### '+' VS. StringBuilder\n\n\n\n### byte[]和String类型相互转化\n\nbyte[]转换为String,如果是非法值，可能转换不成功\n\n```\n    //用于测试String和byte之间的相互转化\n    String testString=\"1234566789\";\n    byte[] testByte=testString.getBytes();\n    try {\n        String string=new String(testByte, \"UTF-8\");\n        System.out.println(string);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n```","slug":"Java/Java基础/String、StringBuffer、StringBuilder区别","published":1,"date":"2019-09-19T09:41:14.774Z","updated":"2019-11-30T11:14:32.245Z","title":"Java/Java基础/String、StringBuffer、StringBuilder区别","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhm002xisuig8s47yoh","content":"<h3 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h3><p><code>String</code>类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的<code>String</code>对象；</p>\n<p><code>StringBuffer</code>和<code>StringBuilder</code>对象是可以改变的，变化时基于原来的对象基础上机型改变。</p>\n<h3 id=\"StringBuffer-VS-String-Builder\"><a href=\"#StringBuffer-VS-String-Builder\" class=\"headerlink\" title=\"StringBuffer VS. String Builder\"></a>StringBuffer VS. String Builder</h3><p>StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。</p>\n<h3 id=\"‘-’-VS-StringBuilder\"><a href=\"#‘-’-VS-StringBuilder\" class=\"headerlink\" title=\"‘+’ VS. StringBuilder\"></a>‘+’ VS. StringBuilder</h3><h3 id=\"byte-和String类型相互转化\"><a href=\"#byte-和String类型相互转化\" class=\"headerlink\" title=\"byte[]和String类型相互转化\"></a>byte[]和String类型相互转化</h3><p>byte[]转换为String,如果是非法值，可能转换不成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用于测试String和byte之间的相互转化</span><br><span class=\"line\">String testString&#x3D;&quot;1234566789&quot;;</span><br><span class=\"line\">byte[] testByte&#x3D;testString.getBytes();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    String string&#x3D;new String(testByte, &quot;UTF-8&quot;);</span><br><span class=\"line\">    System.out.println(string);</span><br><span class=\"line\">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h3><p><code>String</code>类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的<code>String</code>对象；</p>\n<p><code>StringBuffer</code>和<code>StringBuilder</code>对象是可以改变的，变化时基于原来的对象基础上机型改变。</p>\n<h3 id=\"StringBuffer-VS-String-Builder\"><a href=\"#StringBuffer-VS-String-Builder\" class=\"headerlink\" title=\"StringBuffer VS. String Builder\"></a>StringBuffer VS. String Builder</h3><p>StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。</p>\n<h3 id=\"‘-’-VS-StringBuilder\"><a href=\"#‘-’-VS-StringBuilder\" class=\"headerlink\" title=\"‘+’ VS. StringBuilder\"></a>‘+’ VS. StringBuilder</h3><h3 id=\"byte-和String类型相互转化\"><a href=\"#byte-和String类型相互转化\" class=\"headerlink\" title=\"byte[]和String类型相互转化\"></a>byte[]和String类型相互转化</h3><p>byte[]转换为String,如果是非法值，可能转换不成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用于测试String和byte之间的相互转化</span><br><span class=\"line\">String testString&#x3D;&quot;1234566789&quot;;</span><br><span class=\"line\">byte[] testByte&#x3D;testString.getBytes();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    String string&#x3D;new String(testByte, &quot;UTF-8&quot;);</span><br><span class=\"line\">    System.out.println(string);</span><br><span class=\"line\">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"\n\n## AES加密\n\n AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，\n \n  \n### AES在Java中的使用\n\n JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。\n Java中的加解密由Cipher组件提供。\n \n**注：**\n* Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding \n* Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)\n\n#### 生成秘钥\n\n```\n     KeyGenerator generator=KeyGenerator.getInstance(\"AES/ECB/PKCS5PADDING\");\n     //用于指定秘钥长度\n     generator.init(Secret_Key_Size);\n\n     SecretKey secretKey=generator.generateKey();\n\n```","source":"_posts/Java/Java基础/加密算法.md","raw":"\n\n## AES加密\n\n AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，\n \n  \n### AES在Java中的使用\n\n JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。\n Java中的加解密由Cipher组件提供。\n \n**注：**\n* Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding \n* Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)\n\n#### 生成秘钥\n\n```\n     KeyGenerator generator=KeyGenerator.getInstance(\"AES/ECB/PKCS5PADDING\");\n     //用于指定秘钥长度\n     generator.init(Secret_Key_Size);\n\n     SecretKey secretKey=generator.generateKey();\n\n```","slug":"Java/Java基础/加密算法","published":1,"date":"2019-11-28T12:20:15.919Z","updated":"2019-11-30T11:14:32.246Z","title":"Java/Java基础/加密算法","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhn002yisui70lp4gyg","content":"<h2 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h2><p> AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，</p>\n<h3 id=\"AES在Java中的使用\"><a href=\"#AES在Java中的使用\" class=\"headerlink\" title=\"AES在Java中的使用\"></a>AES在Java中的使用</h3><p> JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。<br> Java中的加解密由Cipher组件提供。</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding </li>\n<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)</li>\n</ul>\n<h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeyGenerator generator&#x3D;KeyGenerator.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5PADDING&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;用于指定秘钥长度</span><br><span class=\"line\">generator.init(Secret_Key_Size);</span><br><span class=\"line\"></span><br><span class=\"line\">SecretKey secretKey&#x3D;generator.generateKey();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h2><p> AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，</p>\n<h3 id=\"AES在Java中的使用\"><a href=\"#AES在Java中的使用\" class=\"headerlink\" title=\"AES在Java中的使用\"></a>AES在Java中的使用</h3><p> JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。<br> Java中的加解密由Cipher组件提供。</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding </li>\n<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)</li>\n</ul>\n<h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeyGenerator generator&#x3D;KeyGenerator.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5PADDING&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;用于指定秘钥长度</span><br><span class=\"line\">generator.init(Secret_Key_Size);</span><br><span class=\"line\"></span><br><span class=\"line\">SecretKey secretKey&#x3D;generator.generateKey();</span><br></pre></td></tr></table></figure>"},{"_content":"### 不同单例模式在多线程下的特点\n\n* 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；\n\n```java\n\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton (){}\n\n    public static Singleton getInstance() {\n     if (instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n    }\n}\n```\n\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。\n\n```java\n\npublic static synchronized Singleton getInstance() {\n    if (instance == null) {\n        instance = new Singleton();\n    }\n    return instance;\n}\n\n```\n* 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。\n\n```java\npublic static Singleton getSingleton() {\n    if (instance == null) {                         //Single Checked\n        synchronized (Singleton.class) {\n            if (instance == null) {                 //Double Checked\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance ;\n}\n\n```\n**在使用`synchronized`关键字之后，每次只有一个线程可以进入到该方法中，但是使用`synchronized`关键字会造成开销过大**\n\n于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。\n\n1、给 instance 分配内存\n2、调用 Singleton 的构造函数来初始化成员变量\n3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。\n\n```java\n\npublic class Singleton {\n    private volatile static Singleton instance; //声明成 volatile\n    private Singleton (){}\n\n    public static Singleton getSingleton() {\n        if (instance == null) {                         \n            synchronized (Singleton.class) {\n                if (instance == null) {       \n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n   \n}\n\n```\n`volatile`具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）\n\n\n* 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\n\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n* 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n\n```\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java多线程/Java多线程与单例模式.md","raw":"### 不同单例模式在多线程下的特点\n\n* 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；\n\n```java\n\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton (){}\n\n    public static Singleton getInstance() {\n     if (instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n    }\n}\n```\n\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。\n\n```java\n\npublic static synchronized Singleton getInstance() {\n    if (instance == null) {\n        instance = new Singleton();\n    }\n    return instance;\n}\n\n```\n* 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。\n\n```java\npublic static Singleton getSingleton() {\n    if (instance == null) {                         //Single Checked\n        synchronized (Singleton.class) {\n            if (instance == null) {                 //Double Checked\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance ;\n}\n\n```\n**在使用`synchronized`关键字之后，每次只有一个线程可以进入到该方法中，但是使用`synchronized`关键字会造成开销过大**\n\n于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。\n\n1、给 instance 分配内存\n2、调用 Singleton 的构造函数来初始化成员变量\n3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。\n\n```java\n\npublic class Singleton {\n    private volatile static Singleton instance; //声明成 volatile\n    private Singleton (){}\n\n    public static Singleton getSingleton() {\n        if (instance == null) {                         \n            synchronized (Singleton.class) {\n                if (instance == null) {       \n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n   \n}\n\n```\n`volatile`具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）\n\n\n* 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\n\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n* 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n\n```\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/Java多线程/Java多线程与单例模式","published":1,"date":"2019-09-19T09:41:14.775Z","updated":"2019-09-30T08:28:42.973Z","title":"Java/Java多线程/Java多线程与单例模式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhn002zisuiecym0wns","content":"<h3 id=\"不同单例模式在多线程下的特点\"><a href=\"#不同单例模式在多线程下的特点\" class=\"headerlink\" title=\"不同单例模式在多线程下的特点\"></a>不同单例模式在多线程下的特点</h3><ul>\n<li>懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         <span class=\"comment\">//Single Checked</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                 <span class=\"comment\">//Double Checked</span></span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>synchronized</code>关键字之后，每次只有一个线程可以进入到该方法中，但是使用<code>synchronized</code>关键字会造成开销过大</strong></p>\n<p>于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。</p>\n<p>1、给 instance 分配内存<br>2、调用 Singleton 的构造函数来初始化成员变量<br>3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance; <span class=\"comment\">//声明成 volatile</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;       </span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）</p>\n<ul>\n<li>饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<ul>\n<li>静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"不同单例模式在多线程下的特点\"><a href=\"#不同单例模式在多线程下的特点\" class=\"headerlink\" title=\"不同单例模式在多线程下的特点\"></a>不同单例模式在多线程下的特点</h3><ul>\n<li>懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         <span class=\"comment\">//Single Checked</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                 <span class=\"comment\">//Double Checked</span></span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>synchronized</code>关键字之后，每次只有一个线程可以进入到该方法中，但是使用<code>synchronized</code>关键字会造成开销过大</strong></p>\n<p>于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。</p>\n<p>1、给 instance 分配内存<br>2、调用 Singleton 的构造函数来初始化成员变量<br>3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance; <span class=\"comment\">//声明成 volatile</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;       </span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）</p>\n<ul>\n<li>饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<ul>\n<li>静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n"},{"_content":"## Java多线程协作\n\nJava多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在`Object`对象中有`wait()`和`notifyAll()`方法，在Java  SE 5多任务库中添加`Condition`类，其中有`await()`和`singal()`方法。\n\n\n### join\n\n当一个在线程**m**中调用`t.join()`，**m**线程会被挂起，直至**t**执行结束(`t.isAlive`为false)；如果**t**线程调用`t.interrupt()`(在**m**线程之外)，则线程**m**中会继续执行任务。\n\n\n","source":"_posts/Java/Java多线程/Java多线程之间的协作.md","raw":"## Java多线程协作\n\nJava多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在`Object`对象中有`wait()`和`notifyAll()`方法，在Java  SE 5多任务库中添加`Condition`类，其中有`await()`和`singal()`方法。\n\n\n### join\n\n当一个在线程**m**中调用`t.join()`，**m**线程会被挂起，直至**t**执行结束(`t.isAlive`为false)；如果**t**线程调用`t.interrupt()`(在**m**线程之外)，则线程**m**中会继续执行任务。\n\n\n","slug":"Java/Java多线程/Java多线程之间的协作","published":1,"date":"2019-09-19T09:41:14.776Z","updated":"2019-09-19T09:41:14.776Z","title":"Java/Java多线程/Java多线程之间的协作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryho0030isui2fv72787","content":"<h2 id=\"Java多线程协作\"><a href=\"#Java多线程协作\" class=\"headerlink\" title=\"Java多线程协作\"></a>Java多线程协作</h2><p>Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在<code>Object</code>对象中有<code>wait()</code>和<code>notifyAll()</code>方法，在Java  SE 5多任务库中添加<code>Condition</code>类，其中有<code>await()</code>和<code>singal()</code>方法。</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>当一个在线程<strong>m</strong>中调用<code>t.join()</code>，<strong>m</strong>线程会被挂起，直至<strong>t</strong>执行结束(<code>t.isAlive</code>为false)；如果<strong>t</strong>线程调用<code>t.interrupt()</code>(在<strong>m</strong>线程之外)，则线程<strong>m</strong>中会继续执行任务。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java多线程协作\"><a href=\"#Java多线程协作\" class=\"headerlink\" title=\"Java多线程协作\"></a>Java多线程协作</h2><p>Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在<code>Object</code>对象中有<code>wait()</code>和<code>notifyAll()</code>方法，在Java  SE 5多任务库中添加<code>Condition</code>类，其中有<code>await()</code>和<code>singal()</code>方法。</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>当一个在线程<strong>m</strong>中调用<code>t.join()</code>，<strong>m</strong>线程会被挂起，直至<strong>t</strong>执行结束(<code>t.isAlive</code>为false)；如果<strong>t</strong>线程调用<code>t.interrupt()</code>(在<strong>m</strong>线程之外)，则线程<strong>m</strong>中会继续执行任务。</p>\n"},{"_content":"\n##Java多线程目录\n\n* [Java多线程与单例模式](Java多线程与单例模式.html)\n* [Java多线程基础](Java多线程基础.html)\n* [Java多线程间通信](Java多线程间通信.html)\n* [Java锁机制](Java锁机制.html)","source":"_posts/Java/Java多线程/README.md","raw":"\n##Java多线程目录\n\n* [Java多线程与单例模式](Java多线程与单例模式.html)\n* [Java多线程基础](Java多线程基础.html)\n* [Java多线程间通信](Java多线程间通信.html)\n* [Java锁机制](Java锁机制.html)","slug":"Java/Java多线程/README","published":1,"date":"2019-09-19T09:41:14.777Z","updated":"2019-10-08T06:19:41.310Z","title":"Java/Java多线程/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryho0031isuia53vfyg2","content":"<p>##Java多线程目录</p>\n<ul>\n<li><a href=\"Java多线程与单例模式.html\">Java多线程与单例模式</a></li>\n<li><a href=\"Java多线程基础.html\">Java多线程基础</a></li>\n<li><a href=\"Java多线程间通信.html\">Java多线程间通信</a></li>\n<li><a href=\"Java锁机制.html\">Java锁机制</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>##Java多线程目录</p>\n<ul>\n<li><a href=\"Java多线程与单例模式.html\">Java多线程与单例模式</a></li>\n<li><a href=\"Java多线程基础.html\">Java多线程基础</a></li>\n<li><a href=\"Java多线程间通信.html\">Java多线程间通信</a></li>\n<li><a href=\"Java锁机制.html\">Java锁机制</a></li>\n</ul>\n"},{"_content":"\n## Java设计模式目录\n\n* [观察者模式](观察者模式.html)\n\n\n","source":"_posts/Java/设计模式/README.md","raw":"\n## Java设计模式目录\n\n* [观察者模式](观察者模式.html)\n\n\n","slug":"Java/设计模式/README","published":1,"date":"2019-09-19T09:41:14.778Z","updated":"2019-10-08T06:19:41.311Z","title":"Java/设计模式/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhp0032isuieella7a3","content":"<h2 id=\"Java设计模式目录\"><a href=\"#Java设计模式目录\" class=\"headerlink\" title=\"Java设计模式目录\"></a>Java设计模式目录</h2><ul>\n<li><a href=\"观察者模式.html\">观察者模式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java设计模式目录\"><a href=\"#Java设计模式目录\" class=\"headerlink\" title=\"Java设计模式目录\"></a>Java设计模式目录</h2><ul>\n<li><a href=\"观察者模式.html\">观察者模式</a></li>\n</ul>\n"},{"_content":"# 代理模式\n\n### 代理模式介绍\n\n代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。\n\n代理模式主要由三部分组成：\n* Subject：一个将方法暴露给client的接口\n* Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类\n* Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。\n\n代理模式的结构\n![](/assets/proxy-design-pattern.jpg)\n\n\n### 静态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyTest extends RealSubject {\n        @Override\n        public void doSomething() {\n            System.out.println(\"proxy输出\");\n            super.doSomething();\n        }\n    }\n```\n测试类client\n```java\n    public class Client {\n\n        public static void main(String[] args) {\n            RealSubject proxy=new ProxyTest();\n            proxy.doSomething();\n        }\n    }\n    \n    //输出\n    //proxy输出\n    //RealSubject 输出\n\n```\n\n### 动态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyHandler implements InvocationHandler {\n\n        private Object tar;\n\n        //绑定委托对象，并返回代理类\n        public Object bind(Object tar){\n            this.tar=tar;\n            return                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this);\n        }\n\n        @Override\n        public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        \n            Object result=null;\n            //这里可以进行所谓的AOP编程\n            //在调用具体函数方法项之前，执行功能处理\n            result=method.invoke(tar,objects);\n            //在调用具体函数方法项之后，执行功能处理\n            return result;\n        }\n    }\n\n```\n\nClient\n```java\n    public class Client {\n\n    public static void main(String[] args) {\n\n        ProxyHandler proxyHandler=new ProxyHandler();\n        //绑定该类实现的所有接口\n        Subject sub=(Subject)proxyHandler.bind(new RealSubject());\n        sub.doSomething();\n        }\n    }\n```\n\n#### 动态代理模式详解\n\n#### InvocationHandler接口介绍\nInvocationHandler 源码\n```java\n    public interface InvocationHandler {\n        Object invoke(Object var1, Method var2, Object[] var3) throws     Throwable;\n    }\n```\nInvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。\n\n`invoke(Object var1, Method var2, Object[] var3)`方法中有三个参数：\n* Object var1：指代代理的真实对象\n* Method method：指代真实对象调用的方法\n* Object[] args：指代真实对象调用方法时的参数\n\n\n\n#### Proxy 类介绍\n\nProxy用来动态创建一个代理对象的类，\n`newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2)`方法中的参数\n\n* ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区\n* Class<?>[] var1：给代理对象提供的接口类型\n* InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法\n\n源码\n\n```java\n    public class Proxy implements Serializable {\n\n        public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) throws IllegalArgumentException {\n            Objects.requireNonNull(var2);\n            Class[] var3 = (Class[])var1.clone();                //用于将传入的Class进行复制       \n            SecurityManager var4 = System.getSecurityManager();\n            if (var4 != null) {\n                checkProxyAccess(Reflection.getCallerClass(), var0, var3);\n            }\n            //调用 getProxyClass0() 方法\n            Class var5 = getProxyClass0(var0, var3);\n\n            try {\n                if (var4 != null) {\n                    checkNewProxyPermission(Reflection.getCallerClass(), var5);\n                }\n                final Constructor var6 = var5.getConstructor(constructorParams);  //通过反射类中的Constructor获取构造函数\n                if (!Modifier.isPublic(var5.getModifiers())) {\n                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        var6.setAccessible(true);\n                        return null;\n                        }\n                    });\n                }\n               // 通过Constructor返回代理类的实例\n                return var6.newInstance(var2);\n            } //catch省略\n        }\n\n\n```\n`getProxyClass0()`源码，从缓存中获取代理类对象\n\n```java\n    public class Proxy implements Serializable {\n       //proxyClassCache对象定义\n        private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n        \n        //......\n        private static Class<?> getProxyClass0(ClassLoader var0, Class<?>... var1) {\n        if (var1.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        } else {\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        //......\n    }\n\n```java\n\n\n\n\n\n\n\n\n","source":"_posts/Java/设计模式/代理模式.md","raw":"# 代理模式\n\n### 代理模式介绍\n\n代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。\n\n代理模式主要由三部分组成：\n* Subject：一个将方法暴露给client的接口\n* Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类\n* Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。\n\n代理模式的结构\n![](/assets/proxy-design-pattern.jpg)\n\n\n### 静态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyTest extends RealSubject {\n        @Override\n        public void doSomething() {\n            System.out.println(\"proxy输出\");\n            super.doSomething();\n        }\n    }\n```\n测试类client\n```java\n    public class Client {\n\n        public static void main(String[] args) {\n            RealSubject proxy=new ProxyTest();\n            proxy.doSomething();\n        }\n    }\n    \n    //输出\n    //proxy输出\n    //RealSubject 输出\n\n```\n\n### 动态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyHandler implements InvocationHandler {\n\n        private Object tar;\n\n        //绑定委托对象，并返回代理类\n        public Object bind(Object tar){\n            this.tar=tar;\n            return                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this);\n        }\n\n        @Override\n        public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        \n            Object result=null;\n            //这里可以进行所谓的AOP编程\n            //在调用具体函数方法项之前，执行功能处理\n            result=method.invoke(tar,objects);\n            //在调用具体函数方法项之后，执行功能处理\n            return result;\n        }\n    }\n\n```\n\nClient\n```java\n    public class Client {\n\n    public static void main(String[] args) {\n\n        ProxyHandler proxyHandler=new ProxyHandler();\n        //绑定该类实现的所有接口\n        Subject sub=(Subject)proxyHandler.bind(new RealSubject());\n        sub.doSomething();\n        }\n    }\n```\n\n#### 动态代理模式详解\n\n#### InvocationHandler接口介绍\nInvocationHandler 源码\n```java\n    public interface InvocationHandler {\n        Object invoke(Object var1, Method var2, Object[] var3) throws     Throwable;\n    }\n```\nInvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。\n\n`invoke(Object var1, Method var2, Object[] var3)`方法中有三个参数：\n* Object var1：指代代理的真实对象\n* Method method：指代真实对象调用的方法\n* Object[] args：指代真实对象调用方法时的参数\n\n\n\n#### Proxy 类介绍\n\nProxy用来动态创建一个代理对象的类，\n`newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2)`方法中的参数\n\n* ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区\n* Class<?>[] var1：给代理对象提供的接口类型\n* InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法\n\n源码\n\n```java\n    public class Proxy implements Serializable {\n\n        public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) throws IllegalArgumentException {\n            Objects.requireNonNull(var2);\n            Class[] var3 = (Class[])var1.clone();                //用于将传入的Class进行复制       \n            SecurityManager var4 = System.getSecurityManager();\n            if (var4 != null) {\n                checkProxyAccess(Reflection.getCallerClass(), var0, var3);\n            }\n            //调用 getProxyClass0() 方法\n            Class var5 = getProxyClass0(var0, var3);\n\n            try {\n                if (var4 != null) {\n                    checkNewProxyPermission(Reflection.getCallerClass(), var5);\n                }\n                final Constructor var6 = var5.getConstructor(constructorParams);  //通过反射类中的Constructor获取构造函数\n                if (!Modifier.isPublic(var5.getModifiers())) {\n                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        var6.setAccessible(true);\n                        return null;\n                        }\n                    });\n                }\n               // 通过Constructor返回代理类的实例\n                return var6.newInstance(var2);\n            } //catch省略\n        }\n\n\n```\n`getProxyClass0()`源码，从缓存中获取代理类对象\n\n```java\n    public class Proxy implements Serializable {\n       //proxyClassCache对象定义\n        private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n        \n        //......\n        private static Class<?> getProxyClass0(ClassLoader var0, Class<?>... var1) {\n        if (var1.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        } else {\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        //......\n    }\n\n```java\n\n\n\n\n\n\n\n\n","slug":"Java/设计模式/代理模式","published":1,"date":"2019-11-28T12:18:36.264Z","updated":"2019-11-30T11:14:32.246Z","title":"Java/设计模式/代理模式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhp0033isui974x67lo","content":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"代理模式介绍\"><a href=\"#代理模式介绍\" class=\"headerlink\" title=\"代理模式介绍\"></a>代理模式介绍</h3><p>代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。</p>\n<p>代理模式主要由三部分组成：</p>\n<ul>\n<li>Subject：一个将方法暴露给client的接口</li>\n<li>Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类</li>\n<li>Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。</li>\n</ul>\n<p>代理模式的结构<br><img src=\"/assets/proxy-design-pattern.jpg\" alt=\"\"></p>\n<h3 id=\"静态代理实现方式\"><a href=\"#静态代理实现方式\" class=\"headerlink\" title=\"静态代理实现方式\"></a>静态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RealSubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"proxy输出\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RealSubject proxy=<span class=\"keyword\">new</span> ProxyTest();</span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//proxy输出</span></span><br><span class=\"line\"><span class=\"comment\">//RealSubject 输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态代理实现方式\"><a href=\"#动态代理实现方式\" class=\"headerlink\" title=\"动态代理实现方式\"></a>动态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object tar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定委托对象，并返回代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tar=tar;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Object result=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里可以进行所谓的AOP编程</span></span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之前，执行功能处理</span></span><br><span class=\"line\">        result=method.invoke(tar,objects);</span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之后，执行功能处理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyHandler proxyHandler=<span class=\"keyword\">new</span> ProxyHandler();</span><br><span class=\"line\">    <span class=\"comment\">//绑定该类实现的所有接口</span></span><br><span class=\"line\">    Subject sub=(Subject)proxyHandler.bind(<span class=\"keyword\">new</span> RealSubject());</span><br><span class=\"line\">    sub.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态代理模式详解\"><a href=\"#动态代理模式详解\" class=\"headerlink\" title=\"动态代理模式详解\"></a>动态代理模式详解</h4><h4 id=\"InvocationHandler接口介绍\"><a href=\"#InvocationHandler接口介绍\" class=\"headerlink\" title=\"InvocationHandler接口介绍\"></a>InvocationHandler接口介绍</h4><p>InvocationHandler 源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Method var2, Object[] var3)</span> <span class=\"keyword\">throws</span>     Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>\n<p><code>invoke(Object var1, Method var2, Object[] var3)</code>方法中有三个参数：</p>\n<ul>\n<li>Object var1：指代代理的真实对象</li>\n<li>Method method：指代真实对象调用的方法</li>\n<li>Object[] args：指代真实对象调用方法时的参数</li>\n</ul>\n<h4 id=\"Proxy-类介绍\"><a href=\"#Proxy-类介绍\" class=\"headerlink\" title=\"Proxy 类介绍\"></a>Proxy 类介绍</h4><p>Proxy用来动态创建一个代理对象的类，<br><code>newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</code>方法中的参数</p>\n<ul>\n<li>ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区</li>\n<li>Class&lt;?&gt;[] var1：给代理对象提供的接口类型</li>\n<li>InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法</li>\n</ul>\n<p>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(var2);</span><br><span class=\"line\">        Class[] var3 = (Class[])var1.clone();                <span class=\"comment\">//用于将传入的Class进行复制       </span></span><br><span class=\"line\">        SecurityManager var4 = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), var0, var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用 getProxyClass0() 方法</span></span><br><span class=\"line\">        Class var5 = getProxyClass0(var0, var3);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), var5);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor var6 = var5.getConstructor(constructorParams);  <span class=\"comment\">//通过反射类中的Constructor获取构造函数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(var5.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    var6.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 通过Constructor返回代理类的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> var6.newInstance(var2);</span><br><span class=\"line\">        &#125; <span class=\"comment\">//catch省略</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>getProxyClass0()</code>源码，从缓存中获取代理类对象</p>\n<pre><code class=\"java\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>{\n       <span class=\"comment\">//proxyClassCache对象定义</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class=\"keyword\">new</span> WeakCache(<span class=\"keyword\">new</span> Proxy.KeyFactory(), <span class=\"keyword\">new</span> Proxy.ProxyClassFactory());\n\n        <span class=\"comment\">//......</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) {\n        <span class=\"keyword\">if</span> (var1.length &gt; <span class=\"number\">65535</span>) {\n            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"interface limit exceeded\"</span>);\n        } <span class=\"keyword\">else</span> {\n            <span class=\"comment\">// proxyClassCache 来做一个中间的缓存</span>\n            <span class=\"keyword\">return</span> (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        <span class=\"comment\">//......</span>\n    }\n\n```java\n\n\n\n\n\n\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"代理模式介绍\"><a href=\"#代理模式介绍\" class=\"headerlink\" title=\"代理模式介绍\"></a>代理模式介绍</h3><p>代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。</p>\n<p>代理模式主要由三部分组成：</p>\n<ul>\n<li>Subject：一个将方法暴露给client的接口</li>\n<li>Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类</li>\n<li>Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。</li>\n</ul>\n<p>代理模式的结构<br><img src=\"/assets/proxy-design-pattern.jpg\" alt=\"\"></p>\n<h3 id=\"静态代理实现方式\"><a href=\"#静态代理实现方式\" class=\"headerlink\" title=\"静态代理实现方式\"></a>静态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RealSubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"proxy输出\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RealSubject proxy=<span class=\"keyword\">new</span> ProxyTest();</span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//proxy输出</span></span><br><span class=\"line\"><span class=\"comment\">//RealSubject 输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态代理实现方式\"><a href=\"#动态代理实现方式\" class=\"headerlink\" title=\"动态代理实现方式\"></a>动态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object tar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定委托对象，并返回代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tar=tar;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Object result=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里可以进行所谓的AOP编程</span></span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之前，执行功能处理</span></span><br><span class=\"line\">        result=method.invoke(tar,objects);</span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之后，执行功能处理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyHandler proxyHandler=<span class=\"keyword\">new</span> ProxyHandler();</span><br><span class=\"line\">    <span class=\"comment\">//绑定该类实现的所有接口</span></span><br><span class=\"line\">    Subject sub=(Subject)proxyHandler.bind(<span class=\"keyword\">new</span> RealSubject());</span><br><span class=\"line\">    sub.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态代理模式详解\"><a href=\"#动态代理模式详解\" class=\"headerlink\" title=\"动态代理模式详解\"></a>动态代理模式详解</h4><h4 id=\"InvocationHandler接口介绍\"><a href=\"#InvocationHandler接口介绍\" class=\"headerlink\" title=\"InvocationHandler接口介绍\"></a>InvocationHandler接口介绍</h4><p>InvocationHandler 源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Method var2, Object[] var3)</span> <span class=\"keyword\">throws</span>     Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>\n<p><code>invoke(Object var1, Method var2, Object[] var3)</code>方法中有三个参数：</p>\n<ul>\n<li>Object var1：指代代理的真实对象</li>\n<li>Method method：指代真实对象调用的方法</li>\n<li>Object[] args：指代真实对象调用方法时的参数</li>\n</ul>\n<h4 id=\"Proxy-类介绍\"><a href=\"#Proxy-类介绍\" class=\"headerlink\" title=\"Proxy 类介绍\"></a>Proxy 类介绍</h4><p>Proxy用来动态创建一个代理对象的类，<br><code>newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</code>方法中的参数</p>\n<ul>\n<li>ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区</li>\n<li>Class&lt;?&gt;[] var1：给代理对象提供的接口类型</li>\n<li>InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法</li>\n</ul>\n<p>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(var2);</span><br><span class=\"line\">        Class[] var3 = (Class[])var1.clone();                <span class=\"comment\">//用于将传入的Class进行复制       </span></span><br><span class=\"line\">        SecurityManager var4 = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), var0, var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用 getProxyClass0() 方法</span></span><br><span class=\"line\">        Class var5 = getProxyClass0(var0, var3);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), var5);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor var6 = var5.getConstructor(constructorParams);  <span class=\"comment\">//通过反射类中的Constructor获取构造函数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(var5.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    var6.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 通过Constructor返回代理类的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> var6.newInstance(var2);</span><br><span class=\"line\">        &#125; <span class=\"comment\">//catch省略</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>getProxyClass0()</code>源码，从缓存中获取代理类对象</p>\n<pre><code class=\"java\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>{\n       <span class=\"comment\">//proxyClassCache对象定义</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class=\"keyword\">new</span> WeakCache(<span class=\"keyword\">new</span> Proxy.KeyFactory(), <span class=\"keyword\">new</span> Proxy.ProxyClassFactory());\n\n        <span class=\"comment\">//......</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) {\n        <span class=\"keyword\">if</span> (var1.length &gt; <span class=\"number\">65535</span>) {\n            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"interface limit exceeded\"</span>);\n        } <span class=\"keyword\">else</span> {\n            <span class=\"comment\">// proxyClassCache 来做一个中间的缓存</span>\n            <span class=\"keyword\">return</span> (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        <span class=\"comment\">//......</span>\n    }\n\n```java\n\n\n\n\n\n\n\n</code></pre>\n"},{"_content":"\n## 观察者模式、订阅者模式、回调函数对比\n\n在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；\n\n在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心\n\n在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”\n\n\n### 本篇观察者模式主要在Android中实现\n\n\n\n\n\n### 在Java提供了Observer接口和Observable类方便快速实现观察者模式\n\n","source":"_posts/Java/设计模式/观察者模式.md","raw":"\n## 观察者模式、订阅者模式、回调函数对比\n\n在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；\n\n在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心\n\n在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”\n\n\n### 本篇观察者模式主要在Android中实现\n\n\n\n\n\n### 在Java提供了Observer接口和Observable类方便快速实现观察者模式\n\n","slug":"Java/设计模式/观察者模式","published":1,"date":"2019-09-19T09:41:14.779Z","updated":"2019-09-30T08:28:42.978Z","title":"Java/设计模式/观察者模式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhq0034isui1fgp9ydz","content":"<h2 id=\"观察者模式、订阅者模式、回调函数对比\"><a href=\"#观察者模式、订阅者模式、回调函数对比\" class=\"headerlink\" title=\"观察者模式、订阅者模式、回调函数对比\"></a>观察者模式、订阅者模式、回调函数对比</h2><p>在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；</p>\n<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心</p>\n<p>在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”</p>\n<h3 id=\"本篇观察者模式主要在Android中实现\"><a href=\"#本篇观察者模式主要在Android中实现\" class=\"headerlink\" title=\"本篇观察者模式主要在Android中实现\"></a>本篇观察者模式主要在Android中实现</h3><h3 id=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"><a href=\"#在Java提供了Observer接口和Observable类方便快速实现观察者模式\" class=\"headerlink\" title=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"></a>在Java提供了Observer接口和Observable类方便快速实现观察者模式</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"观察者模式、订阅者模式、回调函数对比\"><a href=\"#观察者模式、订阅者模式、回调函数对比\" class=\"headerlink\" title=\"观察者模式、订阅者模式、回调函数对比\"></a>观察者模式、订阅者模式、回调函数对比</h2><p>在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；</p>\n<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心</p>\n<p>在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”</p>\n<h3 id=\"本篇观察者模式主要在Android中实现\"><a href=\"#本篇观察者模式主要在Android中实现\" class=\"headerlink\" title=\"本篇观察者模式主要在Android中实现\"></a>本篇观察者模式主要在Android中实现</h3><h3 id=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"><a href=\"#在Java提供了Observer接口和Observable类方便快速实现观察者模式\" class=\"headerlink\" title=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"></a>在Java提供了Observer接口和Observable类方便快速实现观察者模式</h3>"},{"_content":"\n\n### 使用Lambda表达式遍历数组\n\n```kotlin\n    //val\n    stringArrays.forEach({\n        it->println(it)\n     })\n\n```\n\nKotlin中Array的`forEach()`函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；`action: (T) -> Unit`中`(T) -> Unit`是lambda表达式的类型，即函数的类型，此函数参数类型为`T`返回值为`Unit`\n\n```kotlin\n\n    public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n        for (element in this) action(element)\n    }\n```\n\nlambda表达式作为形参的类型\n\n```kotlin\n    ()->Int          //无参数，返回Int类型\n    (Int,Int)->Int   //两个整型参数，返回Int\n    (()->Unit,Int)->Int //一个lambda表达式参数，一个整型参数，返回Int \n\n```\n\n\n在kotlin中，可以把函数的最后一个lambda表达式移到括号外\n\n```kotlin\n    stringArrays.forEach(){\n        it->println(it)\n    }\n\n```\n\n如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用\n\n```kotlin\n    stringArrays.forEach(::println)\n\n```\n\n使用标签从Lambda表达式中返回,其中`forEachItem`为自定义标签，`@forEachItem`与return之间不能存在空格\n```kotlin\n    stringArrays.forEach forEachItem@{\n            if (it==1) return@forEachItem\n    }\n```\n\n\n\n在Lambda中最后一个表达式的值是默认的返回值\n\n\n\n#### 高阶函数\n\n高阶函数是将函数用作参数或返回值的函数\n","source":"_posts/Kotlin/Kotlin基础/Lambda表达式.md","raw":"\n\n### 使用Lambda表达式遍历数组\n\n```kotlin\n    //val\n    stringArrays.forEach({\n        it->println(it)\n     })\n\n```\n\nKotlin中Array的`forEach()`函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；`action: (T) -> Unit`中`(T) -> Unit`是lambda表达式的类型，即函数的类型，此函数参数类型为`T`返回值为`Unit`\n\n```kotlin\n\n    public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n        for (element in this) action(element)\n    }\n```\n\nlambda表达式作为形参的类型\n\n```kotlin\n    ()->Int          //无参数，返回Int类型\n    (Int,Int)->Int   //两个整型参数，返回Int\n    (()->Unit,Int)->Int //一个lambda表达式参数，一个整型参数，返回Int \n\n```\n\n\n在kotlin中，可以把函数的最后一个lambda表达式移到括号外\n\n```kotlin\n    stringArrays.forEach(){\n        it->println(it)\n    }\n\n```\n\n如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用\n\n```kotlin\n    stringArrays.forEach(::println)\n\n```\n\n使用标签从Lambda表达式中返回,其中`forEachItem`为自定义标签，`@forEachItem`与return之间不能存在空格\n```kotlin\n    stringArrays.forEach forEachItem@{\n            if (it==1) return@forEachItem\n    }\n```\n\n\n\n在Lambda中最后一个表达式的值是默认的返回值\n\n\n\n#### 高阶函数\n\n高阶函数是将函数用作参数或返回值的函数\n","slug":"Kotlin/Kotlin基础/Lambda表达式","published":1,"date":"2019-11-28T12:20:23.103Z","updated":"2019-11-30T11:14:32.247Z","title":"Kotlin/Kotlin基础/Lambda表达式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhr0035isuievb05lfn","content":"<h3 id=\"使用Lambda表达式遍历数组\"><a href=\"#使用Lambda表达式遍历数组\" class=\"headerlink\" title=\"使用Lambda表达式遍历数组\"></a>使用Lambda表达式遍历数组</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//val</span></span><br><span class=\"line\">stringArrays.forEach(&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Kotlin中Array的<code>forEach()</code>函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；<code>action: (T) -&gt; Unit</code>中<code>(T) -&gt; Unit</code>是lambda表达式的类型，即函数的类型，此函数参数类型为<code>T</code>返回值为<code>Unit</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lambda表达式作为形参的类型</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">()-&gt;<span class=\"built_in\">Int</span>          <span class=\"comment\">//无参数，返回Int类型</span></span><br><span class=\"line\">(<span class=\"built_in\">Int</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span>   <span class=\"comment\">//两个整型参数，返回Int</span></span><br><span class=\"line\">(()-&gt;<span class=\"built_in\">Unit</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span> <span class=\"comment\">//一个lambda表达式参数，一个整型参数，返回Int</span></span><br></pre></td></tr></table></figure>\n\n\n<p>在kotlin中，可以把函数的最后一个lambda表达式移到括号外</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach()&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach(::println)</span><br></pre></td></tr></table></figure>\n\n<p>使用标签从Lambda表达式中返回,其中<code>forEachItem</code>为自定义标签，<code>@forEachItem</code>与return之间不能存在空格</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach <span class=\"symbol\">forEachItem@</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it==<span class=\"number\">1</span>) <span class=\"keyword\">return</span><span class=\"symbol\">@forEachItem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在Lambda中最后一个表达式的值是默认的返回值</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>高阶函数是将函数用作参数或返回值的函数</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用Lambda表达式遍历数组\"><a href=\"#使用Lambda表达式遍历数组\" class=\"headerlink\" title=\"使用Lambda表达式遍历数组\"></a>使用Lambda表达式遍历数组</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//val</span></span><br><span class=\"line\">stringArrays.forEach(&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Kotlin中Array的<code>forEach()</code>函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；<code>action: (T) -&gt; Unit</code>中<code>(T) -&gt; Unit</code>是lambda表达式的类型，即函数的类型，此函数参数类型为<code>T</code>返回值为<code>Unit</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lambda表达式作为形参的类型</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">()-&gt;<span class=\"built_in\">Int</span>          <span class=\"comment\">//无参数，返回Int类型</span></span><br><span class=\"line\">(<span class=\"built_in\">Int</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span>   <span class=\"comment\">//两个整型参数，返回Int</span></span><br><span class=\"line\">(()-&gt;<span class=\"built_in\">Unit</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span> <span class=\"comment\">//一个lambda表达式参数，一个整型参数，返回Int</span></span><br></pre></td></tr></table></figure>\n\n\n<p>在kotlin中，可以把函数的最后一个lambda表达式移到括号外</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach()&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach(::println)</span><br></pre></td></tr></table></figure>\n\n<p>使用标签从Lambda表达式中返回,其中<code>forEachItem</code>为自定义标签，<code>@forEachItem</code>与return之间不能存在空格</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach <span class=\"symbol\">forEachItem@</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it==<span class=\"number\">1</span>) <span class=\"keyword\">return</span><span class=\"symbol\">@forEachItem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在Lambda中最后一个表达式的值是默认的返回值</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>高阶函数是将函数用作参数或返回值的函数</p>\n"},{"title":"remote: Permission to LuciusCS/test.git denied to Lrici.","description":"Examples and code for displaying images in posts.","_content":"\n\n\nmodified: 2017-07-27\n作死小能手又一次把自己玩挂了，明明有一个Github的账号，又申请了一个账号，用于测试权限的控制；然后添加到Git中，结果在Push自己原来项目的时候总是报错；\n\nremote: Permission to LuciusCS/test.git denied to Lrici.\nfatal: unable to access 'https://github.com/LuciusCS/test.git/': The requested URL returned error: 403\n\n\n\t/20170727/Image3.png\n\n\n没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；\n都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；\n\n方法一：修改配置文件，或者只在本仓库中设置用户名\n\ngit config –global user.name “name” \n\ngit config –global user.email “email” \n\n方法二：重新创建生成SSH KEY\n\n方法三：删除Config文件，再重建\n\n方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）\n\n方法五：按照The requested URL returned error: 403 403错误的解决方法\n\n重装大法：卸载Git，然后清除注册表（就差重装系统了）\n\n## 以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\n\n还是显示上面的错误！！！！\n\n## 终极方法：在凭证管理器中删除不需要账号的信息\n\n## 步骤：\n\n  Control Panel(控制面板)——>User Account and family Safety(用户账号和家庭安全)——>Manage Windows Credential(凭证管理)——>将跟Git有关的账号删除\n\n\n\t/20170727/Image1.png\n\t/20170727/Image4.png\n\n\n\n再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦\n\n\n\t/20170727/Image5.png\n\t/20170727/Image6.png\n\n\n\n\n\n\n","source":"_posts/Other/Git/2017-07-27-remote-permission-denied.md","raw":"---\ntitle: \"remote: Permission to LuciusCS/test.git denied to Lrici.\"\ndescription: \"Examples and code for displaying images in posts.\"\ntags: [error, git]\n\n---\n\n\n\nmodified: 2017-07-27\n作死小能手又一次把自己玩挂了，明明有一个Github的账号，又申请了一个账号，用于测试权限的控制；然后添加到Git中，结果在Push自己原来项目的时候总是报错；\n\nremote: Permission to LuciusCS/test.git denied to Lrici.\nfatal: unable to access 'https://github.com/LuciusCS/test.git/': The requested URL returned error: 403\n\n\n\t/20170727/Image3.png\n\n\n没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；\n都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；\n\n方法一：修改配置文件，或者只在本仓库中设置用户名\n\ngit config –global user.name “name” \n\ngit config –global user.email “email” \n\n方法二：重新创建生成SSH KEY\n\n方法三：删除Config文件，再重建\n\n方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）\n\n方法五：按照The requested URL returned error: 403 403错误的解决方法\n\n重装大法：卸载Git，然后清除注册表（就差重装系统了）\n\n## 以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\n\n还是显示上面的错误！！！！\n\n## 终极方法：在凭证管理器中删除不需要账号的信息\n\n## 步骤：\n\n  Control Panel(控制面板)——>User Account and family Safety(用户账号和家庭安全)——>Manage Windows Credential(凭证管理)——>将跟Git有关的账号删除\n\n\n\t/20170727/Image1.png\n\t/20170727/Image4.png\n\n\n\n再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦\n\n\n\t/20170727/Image5.png\n\t/20170727/Image6.png\n\n\n\n\n\n\n","slug":"Other/Git/2017-07-27-remote-permission-denied","published":1,"date":"2020-02-29T02:44:48.885Z","updated":"2020-02-29T03:11:08.907Z","_id":"ck770ryhs0036isui64jd4irx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27<br>作死小能手又一次把自己玩挂了，明明有一个Github的账号，又申请了一个账号，用于测试权限的控制；然后添加到Git中，结果在Push自己原来项目的时候总是报错；</p>\n<p>remote: Permission to LuciusCS/test.git denied to Lrici.<br>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/test.git/&#39;\">https://github.com/LuciusCS/test.git/&#39;</a>: The requested URL returned error: 403</p>\n<pre><code>/20170727/Image3.png</code></pre><p>没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；<br>都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；</p>\n<p>方法一：修改配置文件，或者只在本仓库中设置用户名</p>\n<p>git config –global user.name “name” </p>\n<p>git config –global user.email “email” </p>\n<p>方法二：重新创建生成SSH KEY</p>\n<p>方法三：删除Config文件，再重建</p>\n<p>方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）</p>\n<p>方法五：按照The requested URL returned error: 403 403错误的解决方法</p>\n<p>重装大法：卸载Git，然后清除注册表（就差重装系统了）</p>\n<h2 id=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"><a href=\"#以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\" class=\"headerlink\" title=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"></a>以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！</h2><p>还是显示上面的错误！！！！</p>\n<h2 id=\"终极方法：在凭证管理器中删除不需要账号的信息\"><a href=\"#终极方法：在凭证管理器中删除不需要账号的信息\" class=\"headerlink\" title=\"终极方法：在凭证管理器中删除不需要账号的信息\"></a>终极方法：在凭证管理器中删除不需要账号的信息</h2><h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><p>  Control Panel(控制面板)——&gt;User Account and family Safety(用户账号和家庭安全)——&gt;Manage Windows Credential(凭证管理)——&gt;将跟Git有关的账号删除</p>\n<pre><code>/20170727/Image1.png\n/20170727/Image4.png</code></pre><p>再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦</p>\n<pre><code>/20170727/Image5.png\n/20170727/Image6.png</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>modified: 2017-07-27<br>作死小能手又一次把自己玩挂了，明明有一个Github的账号，又申请了一个账号，用于测试权限的控制；然后添加到Git中，结果在Push自己原来项目的时候总是报错；</p>\n<p>remote: Permission to LuciusCS/test.git denied to Lrici.<br>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/test.git/&#39;\">https://github.com/LuciusCS/test.git/&#39;</a>: The requested URL returned error: 403</p>\n<pre><code>/20170727/Image3.png</code></pre><p>没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；<br>都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；</p>\n<p>方法一：修改配置文件，或者只在本仓库中设置用户名</p>\n<p>git config –global user.name “name” </p>\n<p>git config –global user.email “email” </p>\n<p>方法二：重新创建生成SSH KEY</p>\n<p>方法三：删除Config文件，再重建</p>\n<p>方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）</p>\n<p>方法五：按照The requested URL returned error: 403 403错误的解决方法</p>\n<p>重装大法：卸载Git，然后清除注册表（就差重装系统了）</p>\n<h2 id=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"><a href=\"#以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\" class=\"headerlink\" title=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"></a>以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！</h2><p>还是显示上面的错误！！！！</p>\n<h2 id=\"终极方法：在凭证管理器中删除不需要账号的信息\"><a href=\"#终极方法：在凭证管理器中删除不需要账号的信息\" class=\"headerlink\" title=\"终极方法：在凭证管理器中删除不需要账号的信息\"></a>终极方法：在凭证管理器中删除不需要账号的信息</h2><h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><p>  Control Panel(控制面板)——&gt;User Account and family Safety(用户账号和家庭安全)——&gt;Manage Windows Credential(凭证管理)——&gt;将跟Git有关的账号删除</p>\n<pre><code>/20170727/Image1.png\n/20170727/Image4.png</code></pre><p>再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦</p>\n<pre><code>/20170727/Image5.png\n/20170727/Image6.png</code></pre>"},{"_content":"## 常用Git操作\n\n### 一、将本地已有仓库推送到远程仓库\n\n* 1、将本地仓库与远程仓库建立关联\n```\n   git remote add github git@github.com:Lucius/GitTest.git\n```\n    查看本地仓库与远程仓库关联情况\n```\ngit remote -v\n```\n    删除与远程仓库关联 \n```\n git remote rm origin\n```\n\n* 2、设置用户名和密码\n```\ngit config -global user.name \"\"\ngit config -global user.email \"\"\n```\n* 3、设置SSH Key,\n    生成SSH Key\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n** -t 指定密钥类型，默认是 rsa ，可以省略。 **\n** -C 设置注释文字，比如邮箱。 **\n** -f 指定密钥文件存储文件名。 ** \n![](/assets/GitImg1.png)\n   在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中\n  ![](/assets/GitImg2.png)\n* 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg3.png)\n    当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现`fatal: refusing to merge unrelated histories`错误，需要使用下面命令：\n```\ngit pull origin master --allow-unrelated-histories\n```\n* 5、将本地仓库推送至远端\n```\n  git push -u origin master \n```\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误\n![](/assets/GitImg4.png)\n推送正常\n![](/assets/GitImg5.png)\n\n### 二、将本地分支提交到远程\n\n* 1、建立本地到上游（远端）仓的链接\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg6.png)\n\n* 2、拉取远程分支内容\n```\ngit pull --allow-unrelated-histories\n```\n* 3、将本地分支推送至远程\n```\ngit push origin EditBranch\n```\n![](/assets/GitImg7.png)\n\n\n### 三、合并多次提交\n\n```\ngit rebase -i HEAD~3\n```\n\n如果在合并的过程中出现冲突需要先解决冲突，再进行合并\n```\ngit rebase --continue  \n```\n\n如果放弃本次合并，使用\n```\ngit rebase --abort \n```\n### 四、Git多用户进行管理\n\n需要为每一个仓库设置user、email\n\n* 第一步：取消git的global用户以及邮箱\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n\n```\n\n\n* 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。\n\n```\ngit config  user.email \"xxxx@xx.com\"\ngit config  user.name \"xxxx\"\n\n```\n\n### 五、git reset --hard --soft与git revert\n\n`git reset --hard HEAD~1`修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。\n\n`git reset --soft HEAD~1`修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。\n\n#### `git revert`与`git reset`区别\n* `git reset`指向原地或者向前移动指针,直接删除commit，`git revert`创建一个逆向commit来覆盖之前commit,指针向后移动。\n*  在后续合并旧版本时，`git revert`的部分不再出现；而`git reset`在合并旧版本时，这些被回滚的提交还会再次被引入。\n\n#### 撤销 git reset\n\n`git reflog` 查看操作历史，找到之前 HEAD 的 hash 值，然后 `git reset --hard` 到那个 hash 即可\n\n\n### 六、`git cherry-pick`使用方法\n\n将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。\n\n```\ngit cherry-pick <commit id>:单独合并一个提交\ngit cherry-pick -x <commit id>：同上，不同点：保留原提交者信息。\n\ngit cherry-pick <start-commit-id>..<end-commit-id>：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支\n```\n\n\n### 七、修改git urls的路径方式\n\n#### 将urls由SSH模式修改为Https模式\n\n#### 将usrls由Https模式修改为SSH模式\n\n\n### 八、建立本地分支，并推送至远程\n\n\n### 九、更新fork的代码\n在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，\n\n\n\n\n\n\n","source":"_posts/Other/Git/Git.md","raw":"## 常用Git操作\n\n### 一、将本地已有仓库推送到远程仓库\n\n* 1、将本地仓库与远程仓库建立关联\n```\n   git remote add github git@github.com:Lucius/GitTest.git\n```\n    查看本地仓库与远程仓库关联情况\n```\ngit remote -v\n```\n    删除与远程仓库关联 \n```\n git remote rm origin\n```\n\n* 2、设置用户名和密码\n```\ngit config -global user.name \"\"\ngit config -global user.email \"\"\n```\n* 3、设置SSH Key,\n    生成SSH Key\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n** -t 指定密钥类型，默认是 rsa ，可以省略。 **\n** -C 设置注释文字，比如邮箱。 **\n** -f 指定密钥文件存储文件名。 ** \n![](/assets/GitImg1.png)\n   在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中\n  ![](/assets/GitImg2.png)\n* 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg3.png)\n    当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现`fatal: refusing to merge unrelated histories`错误，需要使用下面命令：\n```\ngit pull origin master --allow-unrelated-histories\n```\n* 5、将本地仓库推送至远端\n```\n  git push -u origin master \n```\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误\n![](/assets/GitImg4.png)\n推送正常\n![](/assets/GitImg5.png)\n\n### 二、将本地分支提交到远程\n\n* 1、建立本地到上游（远端）仓的链接\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg6.png)\n\n* 2、拉取远程分支内容\n```\ngit pull --allow-unrelated-histories\n```\n* 3、将本地分支推送至远程\n```\ngit push origin EditBranch\n```\n![](/assets/GitImg7.png)\n\n\n### 三、合并多次提交\n\n```\ngit rebase -i HEAD~3\n```\n\n如果在合并的过程中出现冲突需要先解决冲突，再进行合并\n```\ngit rebase --continue  \n```\n\n如果放弃本次合并，使用\n```\ngit rebase --abort \n```\n### 四、Git多用户进行管理\n\n需要为每一个仓库设置user、email\n\n* 第一步：取消git的global用户以及邮箱\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n\n```\n\n\n* 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。\n\n```\ngit config  user.email \"xxxx@xx.com\"\ngit config  user.name \"xxxx\"\n\n```\n\n### 五、git reset --hard --soft与git revert\n\n`git reset --hard HEAD~1`修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。\n\n`git reset --soft HEAD~1`修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。\n\n#### `git revert`与`git reset`区别\n* `git reset`指向原地或者向前移动指针,直接删除commit，`git revert`创建一个逆向commit来覆盖之前commit,指针向后移动。\n*  在后续合并旧版本时，`git revert`的部分不再出现；而`git reset`在合并旧版本时，这些被回滚的提交还会再次被引入。\n\n#### 撤销 git reset\n\n`git reflog` 查看操作历史，找到之前 HEAD 的 hash 值，然后 `git reset --hard` 到那个 hash 即可\n\n\n### 六、`git cherry-pick`使用方法\n\n将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。\n\n```\ngit cherry-pick <commit id>:单独合并一个提交\ngit cherry-pick -x <commit id>：同上，不同点：保留原提交者信息。\n\ngit cherry-pick <start-commit-id>..<end-commit-id>：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支\n```\n\n\n### 七、修改git urls的路径方式\n\n#### 将urls由SSH模式修改为Https模式\n\n#### 将usrls由Https模式修改为SSH模式\n\n\n### 八、建立本地分支，并推送至远程\n\n\n### 九、更新fork的代码\n在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，\n\n\n\n\n\n\n","slug":"Other/Git/Git","published":1,"date":"2019-09-19T09:41:14.780Z","updated":"2019-11-30T11:14:32.247Z","title":"Other/Git/Git","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhs0037isuieq176ns2","content":"<h2 id=\"常用Git操作\"><a href=\"#常用Git操作\" class=\"headerlink\" title=\"常用Git操作\"></a>常用Git操作</h2><h3 id=\"一、将本地已有仓库推送到远程仓库\"><a href=\"#一、将本地已有仓库推送到远程仓库\" class=\"headerlink\" title=\"一、将本地已有仓库推送到远程仓库\"></a>一、将本地已有仓库推送到远程仓库</h3><ul>\n<li><p>1、将本地仓库与远程仓库建立关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:Lucius&#x2F;GitTest.git</span><br></pre></td></tr></table></figure>\n<p>  查看本地仓库与远程仓库关联情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p>  删除与远程仓库关联 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2、设置用户名和密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -global user.name &quot;&quot;</span><br><span class=\"line\">git config -global user.email &quot;&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>3、设置SSH Key,<br>  生成SSH Key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li>\n<li><ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-C 设置注释文字，比如邮箱。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-f 指定密钥文件存储文件名。 **<br><img src=\"/assets/GitImg1.png\" alt=\"\"><br>在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中<br><img src=\"/assets/GitImg2.png\" alt=\"\"></li>\n</ul>\n</li>\n<li><p>4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg3.png\" alt=\"\"><br>  当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现<code>fatal: refusing to merge unrelated histories</code>错误，需要使用下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>5、将本地仓库推送至远端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误<br><img src=\"/assets/GitImg4.png\" alt=\"\"><br>推送正常<br><img src=\"/assets/GitImg5.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"二、将本地分支提交到远程\"><a href=\"#二、将本地分支提交到远程\" class=\"headerlink\" title=\"二、将本地分支提交到远程\"></a>二、将本地分支提交到远程</h3><ul>\n<li><p>1、建立本地到上游（远端）仓的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg6.png\" alt=\"\"></p>\n</li>\n<li><p>2、拉取远程分支内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>3、将本地分支推送至远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin EditBranch</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg7.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"三、合并多次提交\"><a href=\"#三、合并多次提交\" class=\"headerlink\" title=\"三、合并多次提交\"></a>三、合并多次提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n\n<p>如果在合并的过程中出现冲突需要先解决冲突，再进行合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --continue</span><br></pre></td></tr></table></figure>\n\n<p>如果放弃本次合并，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --abort</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、Git多用户进行管理\"><a href=\"#四、Git多用户进行管理\" class=\"headerlink\" title=\"四、Git多用户进行管理\"></a>四、Git多用户进行管理</h3><p>需要为每一个仓库设置user、email</p>\n<ul>\n<li>第一步：取消git的global用户以及邮箱</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset user.name</span><br><span class=\"line\">git config --global --unset user.email</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config  user.email &quot;xxxx@xx.com&quot;</span><br><span class=\"line\">git config  user.name &quot;xxxx&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git-reset-–hard-–soft与git-revert\"><a href=\"#五、git-reset-–hard-–soft与git-revert\" class=\"headerlink\" title=\"五、git reset –hard –soft与git revert\"></a>五、git reset –hard –soft与git revert</h3><p><code>git reset --hard HEAD~1</code>修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。</p>\n<p><code>git reset --soft HEAD~1</code>修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。</p>\n<h4 id=\"git-revert与git-reset区别\"><a href=\"#git-revert与git-reset区别\" class=\"headerlink\" title=\"git revert与git reset区别\"></a><code>git revert</code>与<code>git reset</code>区别</h4><ul>\n<li><code>git reset</code>指向原地或者向前移动指针,直接删除commit，<code>git revert</code>创建一个逆向commit来覆盖之前commit,指针向后移动。</li>\n<li>在后续合并旧版本时，<code>git revert</code>的部分不再出现；而<code>git reset</code>在合并旧版本时，这些被回滚的提交还会再次被引入。</li>\n</ul>\n<h4 id=\"撤销-git-reset\"><a href=\"#撤销-git-reset\" class=\"headerlink\" title=\"撤销 git reset\"></a>撤销 git reset</h4><p><code>git reflog</code> 查看操作历史，找到之前 HEAD 的 hash 值，然后 <code>git reset --hard</code> 到那个 hash 即可</p>\n<h3 id=\"六、git-cherry-pick使用方法\"><a href=\"#六、git-cherry-pick使用方法\" class=\"headerlink\" title=\"六、git cherry-pick使用方法\"></a>六、<code>git cherry-pick</code>使用方法</h3><p>将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;commit id&gt;:单独合并一个提交</span><br><span class=\"line\">git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。</span><br><span class=\"line\"></span><br><span class=\"line\">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"七、修改git-urls的路径方式\"><a href=\"#七、修改git-urls的路径方式\" class=\"headerlink\" title=\"七、修改git urls的路径方式\"></a>七、修改git urls的路径方式</h3><h4 id=\"将urls由SSH模式修改为Https模式\"><a href=\"#将urls由SSH模式修改为Https模式\" class=\"headerlink\" title=\"将urls由SSH模式修改为Https模式\"></a>将urls由SSH模式修改为Https模式</h4><h4 id=\"将usrls由Https模式修改为SSH模式\"><a href=\"#将usrls由Https模式修改为SSH模式\" class=\"headerlink\" title=\"将usrls由Https模式修改为SSH模式\"></a>将usrls由Https模式修改为SSH模式</h4><h3 id=\"八、建立本地分支，并推送至远程\"><a href=\"#八、建立本地分支，并推送至远程\" class=\"headerlink\" title=\"八、建立本地分支，并推送至远程\"></a>八、建立本地分支，并推送至远程</h3><h3 id=\"九、更新fork的代码\"><a href=\"#九、更新fork的代码\" class=\"headerlink\" title=\"九、更新fork的代码\"></a>九、更新fork的代码</h3><p>在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用Git操作\"><a href=\"#常用Git操作\" class=\"headerlink\" title=\"常用Git操作\"></a>常用Git操作</h2><h3 id=\"一、将本地已有仓库推送到远程仓库\"><a href=\"#一、将本地已有仓库推送到远程仓库\" class=\"headerlink\" title=\"一、将本地已有仓库推送到远程仓库\"></a>一、将本地已有仓库推送到远程仓库</h3><ul>\n<li><p>1、将本地仓库与远程仓库建立关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:Lucius&#x2F;GitTest.git</span><br></pre></td></tr></table></figure>\n<p>  查看本地仓库与远程仓库关联情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p>  删除与远程仓库关联 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2、设置用户名和密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -global user.name &quot;&quot;</span><br><span class=\"line\">git config -global user.email &quot;&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>3、设置SSH Key,<br>  生成SSH Key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li>\n<li><ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-C 设置注释文字，比如邮箱。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-f 指定密钥文件存储文件名。 **<br><img src=\"/assets/GitImg1.png\" alt=\"\"><br>在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中<br><img src=\"/assets/GitImg2.png\" alt=\"\"></li>\n</ul>\n</li>\n<li><p>4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg3.png\" alt=\"\"><br>  当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现<code>fatal: refusing to merge unrelated histories</code>错误，需要使用下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>5、将本地仓库推送至远端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误<br><img src=\"/assets/GitImg4.png\" alt=\"\"><br>推送正常<br><img src=\"/assets/GitImg5.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"二、将本地分支提交到远程\"><a href=\"#二、将本地分支提交到远程\" class=\"headerlink\" title=\"二、将本地分支提交到远程\"></a>二、将本地分支提交到远程</h3><ul>\n<li><p>1、建立本地到上游（远端）仓的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg6.png\" alt=\"\"></p>\n</li>\n<li><p>2、拉取远程分支内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>3、将本地分支推送至远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin EditBranch</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg7.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"三、合并多次提交\"><a href=\"#三、合并多次提交\" class=\"headerlink\" title=\"三、合并多次提交\"></a>三、合并多次提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n\n<p>如果在合并的过程中出现冲突需要先解决冲突，再进行合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --continue</span><br></pre></td></tr></table></figure>\n\n<p>如果放弃本次合并，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --abort</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、Git多用户进行管理\"><a href=\"#四、Git多用户进行管理\" class=\"headerlink\" title=\"四、Git多用户进行管理\"></a>四、Git多用户进行管理</h3><p>需要为每一个仓库设置user、email</p>\n<ul>\n<li>第一步：取消git的global用户以及邮箱</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset user.name</span><br><span class=\"line\">git config --global --unset user.email</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config  user.email &quot;xxxx@xx.com&quot;</span><br><span class=\"line\">git config  user.name &quot;xxxx&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git-reset-–hard-–soft与git-revert\"><a href=\"#五、git-reset-–hard-–soft与git-revert\" class=\"headerlink\" title=\"五、git reset –hard –soft与git revert\"></a>五、git reset –hard –soft与git revert</h3><p><code>git reset --hard HEAD~1</code>修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。</p>\n<p><code>git reset --soft HEAD~1</code>修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。</p>\n<h4 id=\"git-revert与git-reset区别\"><a href=\"#git-revert与git-reset区别\" class=\"headerlink\" title=\"git revert与git reset区别\"></a><code>git revert</code>与<code>git reset</code>区别</h4><ul>\n<li><code>git reset</code>指向原地或者向前移动指针,直接删除commit，<code>git revert</code>创建一个逆向commit来覆盖之前commit,指针向后移动。</li>\n<li>在后续合并旧版本时，<code>git revert</code>的部分不再出现；而<code>git reset</code>在合并旧版本时，这些被回滚的提交还会再次被引入。</li>\n</ul>\n<h4 id=\"撤销-git-reset\"><a href=\"#撤销-git-reset\" class=\"headerlink\" title=\"撤销 git reset\"></a>撤销 git reset</h4><p><code>git reflog</code> 查看操作历史，找到之前 HEAD 的 hash 值，然后 <code>git reset --hard</code> 到那个 hash 即可</p>\n<h3 id=\"六、git-cherry-pick使用方法\"><a href=\"#六、git-cherry-pick使用方法\" class=\"headerlink\" title=\"六、git cherry-pick使用方法\"></a>六、<code>git cherry-pick</code>使用方法</h3><p>将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;commit id&gt;:单独合并一个提交</span><br><span class=\"line\">git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。</span><br><span class=\"line\"></span><br><span class=\"line\">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"七、修改git-urls的路径方式\"><a href=\"#七、修改git-urls的路径方式\" class=\"headerlink\" title=\"七、修改git urls的路径方式\"></a>七、修改git urls的路径方式</h3><h4 id=\"将urls由SSH模式修改为Https模式\"><a href=\"#将urls由SSH模式修改为Https模式\" class=\"headerlink\" title=\"将urls由SSH模式修改为Https模式\"></a>将urls由SSH模式修改为Https模式</h4><h4 id=\"将usrls由Https模式修改为SSH模式\"><a href=\"#将usrls由Https模式修改为SSH模式\" class=\"headerlink\" title=\"将usrls由Https模式修改为SSH模式\"></a>将usrls由Https模式修改为SSH模式</h4><h3 id=\"八、建立本地分支，并推送至远程\"><a href=\"#八、建立本地分支，并推送至远程\" class=\"headerlink\" title=\"八、建立本地分支，并推送至远程\"></a>八、建立本地分支，并推送至远程</h3><h3 id=\"九、更新fork的代码\"><a href=\"#九、更新fork的代码\" class=\"headerlink\" title=\"九、更新fork的代码\"></a>九、更新fork的代码</h3><p>在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，</p>\n"},{"_content":"### fatal: unable to access 'https://github.com/LuciusCS/AndroidProject.git/': Empty reply from server\n\n","source":"_posts/Other/Git/Git出现问题.md","raw":"### fatal: unable to access 'https://github.com/LuciusCS/AndroidProject.git/': Empty reply from server\n\n","slug":"Other/Git/Git出现问题","published":1,"date":"2019-09-21T00:51:16.731Z","updated":"2019-09-21T00:52:10.120Z","title":"Other/Git/Git出现问题","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryht0039isuigayu9x6y","content":"<h3 id=\"fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\"><a href=\"#fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\" class=\"headerlink\" title=\"fatal: unable to access ‘https://github.com/LuciusCS/AndroidProject.git/&#39;: Empty reply from server\"></a>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/AndroidProject.git/&#39;\">https://github.com/LuciusCS/AndroidProject.git/&#39;</a>: Empty reply from server</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\"><a href=\"#fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\" class=\"headerlink\" title=\"fatal: unable to access ‘https://github.com/LuciusCS/AndroidProject.git/&#39;: Empty reply from server\"></a>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/AndroidProject.git/&#39;\">https://github.com/LuciusCS/AndroidProject.git/&#39;</a>: Empty reply from server</h3>"},{"_content":"\n\n## Android 在已有的项目中引入JNI 最简方式\n\n### JNI与NDK\n\nJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；\nNDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；\n\n            \n### 下载NDK和编译工具\n* NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。\n* CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。\n* LLDB：Android Studio 用于调试原生代码的调试程序。 \n\n安装方式：\n\nAndroid Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载\n\n![](/assets/Android JNI.png)\n\n在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置\n![](/assets/Android JNI1.png)\n\n\n\n### 添加CMakeLists.txt和native-lib-cpp文件\n\n现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码\n```xml\n\n     # 设置cmake的最低版本\n     cmake_minimum_required(VERSION 3.4.1)\n\n    # 设置生成的so库的信息\n    add_library( \n        #生成的so库的名字\n        native-lib\n        # 生成的so库的类型，类型分为两种：\n        #  STATIC：静态库，为目标文件的归档文件\n        #  SHARED：动态库，会被动态链接，在运行时被加载\n        SHARED\n        # 设置源文件的位置，可以是很多个源文件，都需要添加进去\n        native-lib.cpp)\n    # 从系统里查找依赖库，可添加多个\n    find_library(\n        log-lib\n        # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest\n        log)\n     # 配置目标库的链接，即相互依赖关系\n  target_link_libraries(\n        # 目标库（最终生成的库）\n        native-lib\n        # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用\n        # 如果是第三方库，可以直接引用\n        # 每行引用一个库\n        ${log-lib})\n\n\n```\n\n在Andorid的Module下，右键选择 **Link C++ Project with Gradle**，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码\n\n```xml\n    android {\n      …\n      externalNativeBuild {\n        cmake {\n            path file('src/main/cpp/CMakeLists.txt')\n        }\n    }\n```\n\n在native-lib.cpp添加如下代码，方法名命名规则`Java_demo_lucius_baselib_MainActivity_stringFromJNI`，以`Java`作为开头,`demo_lucius_baselib_MainActivity`是“包名+调用类名”，`stringFromJNI`方法名。即` Java_{package_and_classname}_{function_name}(JNI_arguments)`，包名的`.`被下划线替代。\n\n```c++\n    #include <jni.h>\n    #include <string>\n    extern \"C\" JNIEXPORT jstring JNICALL\n    Java_demo_lucius_baselib_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n        std::string text = \"String from C++\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n```\n在上述函数`JNI_arguments`有`JNIEnv*`和`jobject`\n* JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。\n* jobject，指向Java对象的`object`。\n\n`extern \"C\"`只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。\n\n\n在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\"\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    static {\n        //用于在运行时加载本地库\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        System.out.println(stringFromJNI());\n        }\n\n    public native String stringFromJNI();\n\n\n```\n\n### 在JNI中使用C语言，新建helloJIN.c文件\n\n```c\n    #include <jni.h>        // JNI header provided by JDK\n    #include <stdio.h>      // C Standard IO Header\n\n    // Implementation of the native method sayHello()\n    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {\n       printf(\"Hello World!\\n\");\n       return;\n    }\n\n```\n\n\n### JNI基础类型介绍\n\n在`jni.h`文件中定义了预编译类型，区分Java、C++以及C\n\n```c\n\n/* Primitive types that match up with Java equivalents. */\ntypedef uint8_t  jboolean; /* unsigned 8 bits */\ntypedef int8_t   jbyte;    /* signed 8 bits */\ntypedef uint16_t jchar;    /* unsigned 16 bits */\ntypedef int16_t  jshort;   /* signed 16 bits */\ntypedef int32_t  jint;     /* signed 32 bits */\ntypedef int64_t  jlong;    /* signed 64 bits */\ntypedef float    jfloat;   /* 32-bit IEEE 754 */\ntypedef double   jdouble;  /* 64-bit IEEE 754 */\n\n/* \"cardinal indices and sizes\" */\ntypedef jint     jsize;\n\n#ifdef __cplusplus\n/*\n * Reference types, in C++\n */\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n\ntypedef _jobject*       jobject;\ntypedef _jclass*        jclass;\ntypedef _jstring*       jstring;\ntypedef _jarray*        jarray;\ntypedef _jobjectArray*  jobjectArray;\ntypedef _jbooleanArray* jbooleanArray;\ntypedef _jbyteArray*    jbyteArray;\ntypedef _jcharArray*    jcharArray;\ntypedef _jshortArray*   jshortArray;\ntypedef _jintArray*     jintArray;\ntypedef _jlongArray*    jlongArray;\ntypedef _jfloatArray*   jfloatArray;\ntypedef _jdoubleArray*  jdoubleArray;\ntypedef _jthrowable*    jthrowable;\ntypedef _jobject*       jweak;\n\n\n#else /* not __cplusplus */\n\n/*\n * Reference types, in C.\n */\ntypedef void*           jobject;\ntypedef jobject         jclass;\ntypedef jobject         jstring;\ntypedef jobject         jarray;\ntypedef jarray          jobjectArray;\ntypedef jarray          jbooleanArray;\ntypedef jarray          jbyteArray;\ntypedef jarray          jcharArray;\ntypedef jarray          jshortArray;\ntypedef jarray          jintArray;\ntypedef jarray          jlongArray;\ntypedef jarray          jfloatArray;\ntypedef jarray          jdoubleArray;\ntypedef jobject         jthrowable;\ntypedef jobject         jweak;\n\n#endif /* not __cplusplus */\n\n```\n\n\n#### Java基本数据类型与Native层中的数据对应关系\n这些基本数据类型可以在Native层直接使用。\n\n![](/assets/Android JNI2.png)\n\n#### Java引用数据类型与Native层中的数据对应关系\nJava引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为`jobjectArray`类型进行使用。    \n\n![](/assets/Android JNI3.png)\n\n在JNI中二维数组的使用\n```java\n     //获取一维数组的引用，即jintArray类型\n     jclass intArrayClass=env->FindClass(\"[I\");  \n     //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize\n     jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null);\n     \n```\n\n#### jfieldID 和jmethodID\n\n当Native层需要调用Java的某个方法时，需用`jmethodID`表示，变量则用`jfieldID`表示。`jni.h`中对jfieldID和jmethodID的定义\n\n```c++\n    struct _jfieldID;                       /* opaque structure */\n    typedef struct _jfieldID* jfieldID;     /* field IDs */\n\n    struct _jmethodID;                      /* opaque structure */\n    typedef struct _jmethodID* jmethodID;   /* method IDs */\n```\n\n在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。\n\n```c++\n    //获取jfieldID\n      jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetFieldID(this, clazz, name, sig); }\n\n    //获取jmethodID\n     jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetMethodID(this, clazz, name, sig); }\n\n```\n以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用\n\n\n\n\n\n\n\n#### JavaVM介绍\n\nJavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。`jni.h`的定义中，在C++模式下，`JavaVM`是一个结构体；在C语言模式下`JavaVM`是是一个指向方法接口指针的指针。\n\n#### JNIEnv介绍\n\nJNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。`jni.h`的定义中，在C++模式下，`JNIEnv`是一个结构体；在C语言模式下`JNIEnv`是是一个指向方法接口指针的指针。\n\n**作用：**\n* 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;\n* 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;\n\n```c++\n\n    #if defined(__cplusplus)\n    typedef _JNIEnv JNIEnv;\n    typedef _JavaVM JavaVM;\n    #else\n    typedef const struct JNINativeInterface* JNIEnv;\n    typedef const struct JNIInvokeInterface* JavaVM;\n    #endif\n\n```\n\n\n\n#### JNIEnv和JavaVM调用方法\n\n* 对于C语言\n\n```\n    (*env)->方法名(env,参数列表)\n    (*vm)->方法名(vm,参数列表)\n\n```\n* 对于C++\n\n```\n    env->方法名(参数列表)\n    vm->方法名(参数列表)\n\n```\n\n### 在\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android JNI/Android Studio JNI引入.md","raw":"\n\n## Android 在已有的项目中引入JNI 最简方式\n\n### JNI与NDK\n\nJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；\nNDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；\n\n            \n### 下载NDK和编译工具\n* NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。\n* CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。\n* LLDB：Android Studio 用于调试原生代码的调试程序。 \n\n安装方式：\n\nAndroid Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载\n\n![](/assets/Android JNI.png)\n\n在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置\n![](/assets/Android JNI1.png)\n\n\n\n### 添加CMakeLists.txt和native-lib-cpp文件\n\n现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码\n```xml\n\n     # 设置cmake的最低版本\n     cmake_minimum_required(VERSION 3.4.1)\n\n    # 设置生成的so库的信息\n    add_library( \n        #生成的so库的名字\n        native-lib\n        # 生成的so库的类型，类型分为两种：\n        #  STATIC：静态库，为目标文件的归档文件\n        #  SHARED：动态库，会被动态链接，在运行时被加载\n        SHARED\n        # 设置源文件的位置，可以是很多个源文件，都需要添加进去\n        native-lib.cpp)\n    # 从系统里查找依赖库，可添加多个\n    find_library(\n        log-lib\n        # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest\n        log)\n     # 配置目标库的链接，即相互依赖关系\n  target_link_libraries(\n        # 目标库（最终生成的库）\n        native-lib\n        # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用\n        # 如果是第三方库，可以直接引用\n        # 每行引用一个库\n        ${log-lib})\n\n\n```\n\n在Andorid的Module下，右键选择 **Link C++ Project with Gradle**，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码\n\n```xml\n    android {\n      …\n      externalNativeBuild {\n        cmake {\n            path file('src/main/cpp/CMakeLists.txt')\n        }\n    }\n```\n\n在native-lib.cpp添加如下代码，方法名命名规则`Java_demo_lucius_baselib_MainActivity_stringFromJNI`，以`Java`作为开头,`demo_lucius_baselib_MainActivity`是“包名+调用类名”，`stringFromJNI`方法名。即` Java_{package_and_classname}_{function_name}(JNI_arguments)`，包名的`.`被下划线替代。\n\n```c++\n    #include <jni.h>\n    #include <string>\n    extern \"C\" JNIEXPORT jstring JNICALL\n    Java_demo_lucius_baselib_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n        std::string text = \"String from C++\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n```\n在上述函数`JNI_arguments`有`JNIEnv*`和`jobject`\n* JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。\n* jobject，指向Java对象的`object`。\n\n`extern \"C\"`只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。\n\n\n在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\"\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    static {\n        //用于在运行时加载本地库\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        System.out.println(stringFromJNI());\n        }\n\n    public native String stringFromJNI();\n\n\n```\n\n### 在JNI中使用C语言，新建helloJIN.c文件\n\n```c\n    #include <jni.h>        // JNI header provided by JDK\n    #include <stdio.h>      // C Standard IO Header\n\n    // Implementation of the native method sayHello()\n    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {\n       printf(\"Hello World!\\n\");\n       return;\n    }\n\n```\n\n\n### JNI基础类型介绍\n\n在`jni.h`文件中定义了预编译类型，区分Java、C++以及C\n\n```c\n\n/* Primitive types that match up with Java equivalents. */\ntypedef uint8_t  jboolean; /* unsigned 8 bits */\ntypedef int8_t   jbyte;    /* signed 8 bits */\ntypedef uint16_t jchar;    /* unsigned 16 bits */\ntypedef int16_t  jshort;   /* signed 16 bits */\ntypedef int32_t  jint;     /* signed 32 bits */\ntypedef int64_t  jlong;    /* signed 64 bits */\ntypedef float    jfloat;   /* 32-bit IEEE 754 */\ntypedef double   jdouble;  /* 64-bit IEEE 754 */\n\n/* \"cardinal indices and sizes\" */\ntypedef jint     jsize;\n\n#ifdef __cplusplus\n/*\n * Reference types, in C++\n */\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n\ntypedef _jobject*       jobject;\ntypedef _jclass*        jclass;\ntypedef _jstring*       jstring;\ntypedef _jarray*        jarray;\ntypedef _jobjectArray*  jobjectArray;\ntypedef _jbooleanArray* jbooleanArray;\ntypedef _jbyteArray*    jbyteArray;\ntypedef _jcharArray*    jcharArray;\ntypedef _jshortArray*   jshortArray;\ntypedef _jintArray*     jintArray;\ntypedef _jlongArray*    jlongArray;\ntypedef _jfloatArray*   jfloatArray;\ntypedef _jdoubleArray*  jdoubleArray;\ntypedef _jthrowable*    jthrowable;\ntypedef _jobject*       jweak;\n\n\n#else /* not __cplusplus */\n\n/*\n * Reference types, in C.\n */\ntypedef void*           jobject;\ntypedef jobject         jclass;\ntypedef jobject         jstring;\ntypedef jobject         jarray;\ntypedef jarray          jobjectArray;\ntypedef jarray          jbooleanArray;\ntypedef jarray          jbyteArray;\ntypedef jarray          jcharArray;\ntypedef jarray          jshortArray;\ntypedef jarray          jintArray;\ntypedef jarray          jlongArray;\ntypedef jarray          jfloatArray;\ntypedef jarray          jdoubleArray;\ntypedef jobject         jthrowable;\ntypedef jobject         jweak;\n\n#endif /* not __cplusplus */\n\n```\n\n\n#### Java基本数据类型与Native层中的数据对应关系\n这些基本数据类型可以在Native层直接使用。\n\n![](/assets/Android JNI2.png)\n\n#### Java引用数据类型与Native层中的数据对应关系\nJava引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为`jobjectArray`类型进行使用。    \n\n![](/assets/Android JNI3.png)\n\n在JNI中二维数组的使用\n```java\n     //获取一维数组的引用，即jintArray类型\n     jclass intArrayClass=env->FindClass(\"[I\");  \n     //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize\n     jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null);\n     \n```\n\n#### jfieldID 和jmethodID\n\n当Native层需要调用Java的某个方法时，需用`jmethodID`表示，变量则用`jfieldID`表示。`jni.h`中对jfieldID和jmethodID的定义\n\n```c++\n    struct _jfieldID;                       /* opaque structure */\n    typedef struct _jfieldID* jfieldID;     /* field IDs */\n\n    struct _jmethodID;                      /* opaque structure */\n    typedef struct _jmethodID* jmethodID;   /* method IDs */\n```\n\n在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。\n\n```c++\n    //获取jfieldID\n      jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetFieldID(this, clazz, name, sig); }\n\n    //获取jmethodID\n     jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetMethodID(this, clazz, name, sig); }\n\n```\n以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用\n\n\n\n\n\n\n\n#### JavaVM介绍\n\nJavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。`jni.h`的定义中，在C++模式下，`JavaVM`是一个结构体；在C语言模式下`JavaVM`是是一个指向方法接口指针的指针。\n\n#### JNIEnv介绍\n\nJNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。`jni.h`的定义中，在C++模式下，`JNIEnv`是一个结构体；在C语言模式下`JNIEnv`是是一个指向方法接口指针的指针。\n\n**作用：**\n* 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;\n* 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;\n\n```c++\n\n    #if defined(__cplusplus)\n    typedef _JNIEnv JNIEnv;\n    typedef _JavaVM JavaVM;\n    #else\n    typedef const struct JNINativeInterface* JNIEnv;\n    typedef const struct JNIInvokeInterface* JavaVM;\n    #endif\n\n```\n\n\n\n#### JNIEnv和JavaVM调用方法\n\n* 对于C语言\n\n```\n    (*env)->方法名(env,参数列表)\n    (*vm)->方法名(vm,参数列表)\n\n```\n* 对于C++\n\n```\n    env->方法名(参数列表)\n    vm->方法名(参数列表)\n\n```\n\n### 在\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android JNI/Android Studio JNI引入","published":1,"date":"2019-09-21T00:52:10.111Z","updated":"2019-09-27T08:23:54.029Z","title":"Android/Android JNI/Android Studio JNI引入","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryhy003disuigha5gmzp","content":"<h2 id=\"Android-在已有的项目中引入JNI-最简方式\"><a href=\"#Android-在已有的项目中引入JNI-最简方式\" class=\"headerlink\" title=\"Android 在已有的项目中引入JNI 最简方式\"></a>Android 在已有的项目中引入JNI 最简方式</h2><h3 id=\"JNI与NDK\"><a href=\"#JNI与NDK\" class=\"headerlink\" title=\"JNI与NDK\"></a>JNI与NDK</h3><p>JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；<br>NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；</p>\n<h3 id=\"下载NDK和编译工具\"><a href=\"#下载NDK和编译工具\" class=\"headerlink\" title=\"下载NDK和编译工具\"></a>下载NDK和编译工具</h3><ul>\n<li>NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。</li>\n<li>CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。</li>\n<li>LLDB：Android Studio 用于调试原生代码的调试程序。 </li>\n</ul>\n<p>安装方式：</p>\n<p>Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载</p>\n<p>![](/assets/Android JNI.png)</p>\n<p>在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置<br>![](/assets/Android JNI1.png)</p>\n<h3 id=\"添加CMakeLists-txt和native-lib-cpp文件\"><a href=\"#添加CMakeLists-txt和native-lib-cpp文件\" class=\"headerlink\" title=\"添加CMakeLists.txt和native-lib-cpp文件\"></a>添加CMakeLists.txt和native-lib-cpp文件</h3><p>现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   # 设置cmake的最低版本</span><br><span class=\"line\">   cmake_minimum_required(VERSION 3.4.1)</span><br><span class=\"line\"></span><br><span class=\"line\">  # 设置生成的so库的信息</span><br><span class=\"line\">  add_library( </span><br><span class=\"line\">      #生成的so库的名字</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 生成的so库的类型，类型分为两种：</span><br><span class=\"line\">      #  STATIC：静态库，为目标文件的归档文件</span><br><span class=\"line\">      #  SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class=\"line\">      SHARED</span><br><span class=\"line\">      # 设置源文件的位置，可以是很多个源文件，都需要添加进去</span><br><span class=\"line\">      native-lib.cpp)</span><br><span class=\"line\">  # 从系统里查找依赖库，可添加多个</span><br><span class=\"line\">  find_library(</span><br><span class=\"line\">      log-lib</span><br><span class=\"line\">      # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest</span><br><span class=\"line\">      log)</span><br><span class=\"line\">   # 配置目标库的链接，即相互依赖关系</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">      # 目标库（最终生成的库）</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加$&#123;&#125;进行引用</span><br><span class=\"line\">      # 如果是第三方库，可以直接引用</span><br><span class=\"line\">      # 每行引用一个库</span><br><span class=\"line\">      $&#123;log-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在Andorid的Module下，右键选择 <strong>Link C++ Project with Gradle</strong>，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  …</span><br><span class=\"line\">  externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path file('src/main/cpp/CMakeLists.txt')</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在native-lib.cpp添加如下代码，方法名命名规则<code>Java_demo_lucius_baselib_MainActivity_stringFromJNI</code>，以<code>Java</code>作为开头,<code>demo_lucius_baselib_MainActivity</code>是“包名+调用类名”，<code>stringFromJNI</code>方法名。即<code>Java_{package_and_classname}_{function_name}(JNI_arguments)</code>，包名的<code>.</code>被下划线替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_demo_lucius_baselib_MainActivity_stringFromJNI(</span><br><span class=\"line\">    JNIEnv *env,</span><br><span class=\"line\">    jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"built_in\">text</span> = <span class=\"string\">\"String from C++\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述函数<code>JNI_arguments</code>有<code>JNIEnv*</code>和<code>jobject</code></p>\n<ul>\n<li>JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。</li>\n<li>jobject，指向Java对象的<code>object</code>。</li>\n</ul>\n<p><code>extern &quot;C&quot;</code>只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。</p>\n<p>在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于在运行时加载本地库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">\"native-lib\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringFromJNI());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在JNI中使用C语言，新建helloJIN-c文件\"><a href=\"#在JNI中使用C语言，新建helloJIN-c文件\" class=\"headerlink\" title=\"在JNI中使用C语言，新建helloJIN.c文件\"></a>在JNI中使用C语言，新建helloJIN.c文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;        // JNI header provided by JDK</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;      // C Standard IO Header</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation of the native method sayHello()</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_HelloJNI_sayHello</span><span class=\"params\">(JNIEnv *env, jobject thisObj)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"JNI基础类型介绍\"><a href=\"#JNI基础类型介绍\" class=\"headerlink\" title=\"JNI基础类型介绍\"></a>JNI基础类型介绍</h3><p>在<code>jni.h</code>文件中定义了预编译类型，区分Java、C++以及C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Primitive types that match up with Java equivalents. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint8_t</span>  jboolean; <span class=\"comment\">/* unsigned 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int8_t</span>   jbyte;    <span class=\"comment\">/* signed 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint16_t</span> jchar;    <span class=\"comment\">/* unsigned 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int16_t</span>  jshort;   <span class=\"comment\">/* signed 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int32_t</span>  jint;     <span class=\"comment\">/* signed 32 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int64_t</span>  jlong;    <span class=\"comment\">/* signed 64 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">float</span>    jfloat;   <span class=\"comment\">/* 32-bit IEEE 754 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span>   jdouble;  <span class=\"comment\">/* 64-bit IEEE 754 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* \"cardinal indices and sizes\" */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jint     jsize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C++</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobject</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jclass</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jstring</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jarray</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobjectArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbooleanArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbyteArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jcharArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jshortArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jintArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jlongArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jfloatArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jdoubleArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jthrowable</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass*        jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jstring*       jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jarray*        jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jcharArray*    jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jshortArray*   jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jintArray*     jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jlongArray*    jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jthrowable*    jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>*           jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Java基本数据类型与Native层中的数据对应关系\"><a href=\"#Java基本数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java基本数据类型与Native层中的数据对应关系\"></a>Java基本数据类型与Native层中的数据对应关系</h4><p>这些基本数据类型可以在Native层直接使用。</p>\n<p>![](/assets/Android JNI2.png)</p>\n<h4 id=\"Java引用数据类型与Native层中的数据对应关系\"><a href=\"#Java引用数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java引用数据类型与Native层中的数据对应关系\"></a>Java引用数据类型与Native层中的数据对应关系</h4><p>Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为<code>jobjectArray</code>类型进行使用。    </p>\n<p>![](/assets/Android JNI3.png)</p>\n<p>在JNI中二维数组的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一维数组的引用，即jintArray类型</span></span><br><span class=\"line\">jclass intArrayClass=env-&gt;FindClass(<span class=\"string\">\"[I\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize</span></span><br><span class=\"line\">jobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"jfieldID-和jmethodID\"><a href=\"#jfieldID-和jmethodID\" class=\"headerlink\" title=\"jfieldID 和jmethodID\"></a>jfieldID 和jmethodID</h4><p>当Native层需要调用Java的某个方法时，需用<code>jmethodID</code>表示，变量则用<code>jfieldID</code>表示。<code>jni.h</code>中对jfieldID和jmethodID的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>                       <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>* <span class=\"title\">jfieldID</span>;</span>     <span class=\"comment\">/* field IDs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>                      <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>* <span class=\"title\">jmethodID</span>;</span>   <span class=\"comment\">/* method IDs */</span></span><br></pre></td></tr></table></figure>\n\n<p>在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取jfieldID</span></span><br><span class=\"line\">  <span class=\"function\">jfieldID <span class=\"title\">GetFieldID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetFieldID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取jmethodID</span></span><br><span class=\"line\"> <span class=\"function\">jmethodID <span class=\"title\">GetMethodID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetMethodID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br></pre></td></tr></table></figure>\n<p>以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用</p>\n<h4 id=\"JavaVM介绍\"><a href=\"#JavaVM介绍\" class=\"headerlink\" title=\"JavaVM介绍\"></a>JavaVM介绍</h4><p>JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。<code>jni.h</code>的定义中，在C++模式下，<code>JavaVM</code>是一个结构体；在C语言模式下<code>JavaVM</code>是是一个指向方法接口指针的指针。</p>\n<h4 id=\"JNIEnv介绍\"><a href=\"#JNIEnv介绍\" class=\"headerlink\" title=\"JNIEnv介绍\"></a>JNIEnv介绍</h4><p>JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。<code>jni.h</code>的定义中，在C++模式下，<code>JNIEnv</code>是一个结构体；在C语言模式下<code>JNIEnv</code>是是一个指向方法接口指针的指针。</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;</li>\n<li>操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(__cplusplus)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JNIEnv JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JavaVM JavaVM;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span>* <span class=\"title\">JNIEnv</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"JNIEnv和JavaVM调用方法\"><a href=\"#JNIEnv和JavaVM调用方法\" class=\"headerlink\" title=\"JNIEnv和JavaVM调用方法\"></a>JNIEnv和JavaVM调用方法</h4><ul>\n<li>对于C语言</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;方法名(env,参数列表)</span><br><span class=\"line\">(*vm)-&gt;方法名(vm,参数列表)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于C++</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env-&gt;方法名(参数列表)</span><br><span class=\"line\">vm-&gt;方法名(参数列表)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在\"><a href=\"#在\" class=\"headerlink\" title=\"在\"></a>在</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-在已有的项目中引入JNI-最简方式\"><a href=\"#Android-在已有的项目中引入JNI-最简方式\" class=\"headerlink\" title=\"Android 在已有的项目中引入JNI 最简方式\"></a>Android 在已有的项目中引入JNI 最简方式</h2><h3 id=\"JNI与NDK\"><a href=\"#JNI与NDK\" class=\"headerlink\" title=\"JNI与NDK\"></a>JNI与NDK</h3><p>JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；<br>NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；</p>\n<h3 id=\"下载NDK和编译工具\"><a href=\"#下载NDK和编译工具\" class=\"headerlink\" title=\"下载NDK和编译工具\"></a>下载NDK和编译工具</h3><ul>\n<li>NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。</li>\n<li>CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。</li>\n<li>LLDB：Android Studio 用于调试原生代码的调试程序。 </li>\n</ul>\n<p>安装方式：</p>\n<p>Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载</p>\n<p>![](/assets/Android JNI.png)</p>\n<p>在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置<br>![](/assets/Android JNI1.png)</p>\n<h3 id=\"添加CMakeLists-txt和native-lib-cpp文件\"><a href=\"#添加CMakeLists-txt和native-lib-cpp文件\" class=\"headerlink\" title=\"添加CMakeLists.txt和native-lib-cpp文件\"></a>添加CMakeLists.txt和native-lib-cpp文件</h3><p>现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   # 设置cmake的最低版本</span><br><span class=\"line\">   cmake_minimum_required(VERSION 3.4.1)</span><br><span class=\"line\"></span><br><span class=\"line\">  # 设置生成的so库的信息</span><br><span class=\"line\">  add_library( </span><br><span class=\"line\">      #生成的so库的名字</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 生成的so库的类型，类型分为两种：</span><br><span class=\"line\">      #  STATIC：静态库，为目标文件的归档文件</span><br><span class=\"line\">      #  SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class=\"line\">      SHARED</span><br><span class=\"line\">      # 设置源文件的位置，可以是很多个源文件，都需要添加进去</span><br><span class=\"line\">      native-lib.cpp)</span><br><span class=\"line\">  # 从系统里查找依赖库，可添加多个</span><br><span class=\"line\">  find_library(</span><br><span class=\"line\">      log-lib</span><br><span class=\"line\">      # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest</span><br><span class=\"line\">      log)</span><br><span class=\"line\">   # 配置目标库的链接，即相互依赖关系</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">      # 目标库（最终生成的库）</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加$&#123;&#125;进行引用</span><br><span class=\"line\">      # 如果是第三方库，可以直接引用</span><br><span class=\"line\">      # 每行引用一个库</span><br><span class=\"line\">      $&#123;log-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在Andorid的Module下，右键选择 <strong>Link C++ Project with Gradle</strong>，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  …</span><br><span class=\"line\">  externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path file('src/main/cpp/CMakeLists.txt')</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在native-lib.cpp添加如下代码，方法名命名规则<code>Java_demo_lucius_baselib_MainActivity_stringFromJNI</code>，以<code>Java</code>作为开头,<code>demo_lucius_baselib_MainActivity</code>是“包名+调用类名”，<code>stringFromJNI</code>方法名。即<code>Java_{package_and_classname}_{function_name}(JNI_arguments)</code>，包名的<code>.</code>被下划线替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_demo_lucius_baselib_MainActivity_stringFromJNI(</span><br><span class=\"line\">    JNIEnv *env,</span><br><span class=\"line\">    jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"built_in\">text</span> = <span class=\"string\">\"String from C++\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述函数<code>JNI_arguments</code>有<code>JNIEnv*</code>和<code>jobject</code></p>\n<ul>\n<li>JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。</li>\n<li>jobject，指向Java对象的<code>object</code>。</li>\n</ul>\n<p><code>extern &quot;C&quot;</code>只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。</p>\n<p>在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于在运行时加载本地库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">\"native-lib\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringFromJNI());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在JNI中使用C语言，新建helloJIN-c文件\"><a href=\"#在JNI中使用C语言，新建helloJIN-c文件\" class=\"headerlink\" title=\"在JNI中使用C语言，新建helloJIN.c文件\"></a>在JNI中使用C语言，新建helloJIN.c文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;        // JNI header provided by JDK</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;      // C Standard IO Header</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation of the native method sayHello()</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_HelloJNI_sayHello</span><span class=\"params\">(JNIEnv *env, jobject thisObj)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"JNI基础类型介绍\"><a href=\"#JNI基础类型介绍\" class=\"headerlink\" title=\"JNI基础类型介绍\"></a>JNI基础类型介绍</h3><p>在<code>jni.h</code>文件中定义了预编译类型，区分Java、C++以及C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Primitive types that match up with Java equivalents. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint8_t</span>  jboolean; <span class=\"comment\">/* unsigned 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int8_t</span>   jbyte;    <span class=\"comment\">/* signed 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint16_t</span> jchar;    <span class=\"comment\">/* unsigned 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int16_t</span>  jshort;   <span class=\"comment\">/* signed 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int32_t</span>  jint;     <span class=\"comment\">/* signed 32 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int64_t</span>  jlong;    <span class=\"comment\">/* signed 64 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">float</span>    jfloat;   <span class=\"comment\">/* 32-bit IEEE 754 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span>   jdouble;  <span class=\"comment\">/* 64-bit IEEE 754 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* \"cardinal indices and sizes\" */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jint     jsize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C++</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobject</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jclass</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jstring</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jarray</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobjectArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbooleanArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbyteArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jcharArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jshortArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jintArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jlongArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jfloatArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jdoubleArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jthrowable</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass*        jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jstring*       jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jarray*        jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jcharArray*    jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jshortArray*   jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jintArray*     jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jlongArray*    jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jthrowable*    jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>*           jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Java基本数据类型与Native层中的数据对应关系\"><a href=\"#Java基本数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java基本数据类型与Native层中的数据对应关系\"></a>Java基本数据类型与Native层中的数据对应关系</h4><p>这些基本数据类型可以在Native层直接使用。</p>\n<p>![](/assets/Android JNI2.png)</p>\n<h4 id=\"Java引用数据类型与Native层中的数据对应关系\"><a href=\"#Java引用数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java引用数据类型与Native层中的数据对应关系\"></a>Java引用数据类型与Native层中的数据对应关系</h4><p>Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为<code>jobjectArray</code>类型进行使用。    </p>\n<p>![](/assets/Android JNI3.png)</p>\n<p>在JNI中二维数组的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一维数组的引用，即jintArray类型</span></span><br><span class=\"line\">jclass intArrayClass=env-&gt;FindClass(<span class=\"string\">\"[I\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize</span></span><br><span class=\"line\">jobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"jfieldID-和jmethodID\"><a href=\"#jfieldID-和jmethodID\" class=\"headerlink\" title=\"jfieldID 和jmethodID\"></a>jfieldID 和jmethodID</h4><p>当Native层需要调用Java的某个方法时，需用<code>jmethodID</code>表示，变量则用<code>jfieldID</code>表示。<code>jni.h</code>中对jfieldID和jmethodID的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>                       <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>* <span class=\"title\">jfieldID</span>;</span>     <span class=\"comment\">/* field IDs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>                      <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>* <span class=\"title\">jmethodID</span>;</span>   <span class=\"comment\">/* method IDs */</span></span><br></pre></td></tr></table></figure>\n\n<p>在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取jfieldID</span></span><br><span class=\"line\">  <span class=\"function\">jfieldID <span class=\"title\">GetFieldID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetFieldID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取jmethodID</span></span><br><span class=\"line\"> <span class=\"function\">jmethodID <span class=\"title\">GetMethodID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetMethodID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br></pre></td></tr></table></figure>\n<p>以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用</p>\n<h4 id=\"JavaVM介绍\"><a href=\"#JavaVM介绍\" class=\"headerlink\" title=\"JavaVM介绍\"></a>JavaVM介绍</h4><p>JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。<code>jni.h</code>的定义中，在C++模式下，<code>JavaVM</code>是一个结构体；在C语言模式下<code>JavaVM</code>是是一个指向方法接口指针的指针。</p>\n<h4 id=\"JNIEnv介绍\"><a href=\"#JNIEnv介绍\" class=\"headerlink\" title=\"JNIEnv介绍\"></a>JNIEnv介绍</h4><p>JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。<code>jni.h</code>的定义中，在C++模式下，<code>JNIEnv</code>是一个结构体；在C语言模式下<code>JNIEnv</code>是是一个指向方法接口指针的指针。</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;</li>\n<li>操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(__cplusplus)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JNIEnv JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JavaVM JavaVM;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span>* <span class=\"title\">JNIEnv</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"JNIEnv和JavaVM调用方法\"><a href=\"#JNIEnv和JavaVM调用方法\" class=\"headerlink\" title=\"JNIEnv和JavaVM调用方法\"></a>JNIEnv和JavaVM调用方法</h4><ul>\n<li>对于C语言</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;方法名(env,参数列表)</span><br><span class=\"line\">(*vm)-&gt;方法名(vm,参数列表)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于C++</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env-&gt;方法名(参数列表)</span><br><span class=\"line\">vm-&gt;方法名(参数列表)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在\"><a href=\"#在\" class=\"headerlink\" title=\"在\"></a>在</h3>"},{"title":"Android Service介绍","description":"Android Service介绍","_content":"\n\n# Android开发Service介绍\n\nService是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。\n\n## 不同类型的Service介绍\n\n### Foreground service\n\nForeground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)\n\n### Background service\n\nBackground service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。\n\n* 注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。\n\n### Bound\n\n当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。\n\n\n不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。\n\n\n## Service的使用\n\n创建一个Service,需要创建Service的子类，并在其中重写回调函数。\n\n### 函数的介绍\n\n#### onStartCommend()\n\n其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。\n\n#### onBind()\n\n其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。**在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null**\n\n#### onCreate()\n\n在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。\n\n#### onDestory()\n\n当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。\n\n### 在menifest中声明一个service\n\n```xml\n<manifest ... >\n  ...\n  <application ... >\n      <service android:name=\".ExampleService\" />\n      ...\n  </application>\n</manifest>\n\n```\n\n* 注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service\n\n## 创建一个Started service\n\n当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。\n\n应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。\n\n例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。\n\n* 注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。\n\n### 两个可以继承启动的service类\n\n#### Service类\n\nService类是所有service的基类，当在继承这一个类的时候，**需要创建一个新的线程，使得service可以再其中完成它的工作** ***（很重要）***，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。\n\n#### IntentService类\n\nIntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。\n\n### 继承IntentService类\n\n在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类\n\n**IntentService类所做的工作**\n\n* 创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。\n* 创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。\n* 当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。\n* 提供onBind()的默认实现方法，并返回null。\n* 提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。\n\n为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。\n\n\n\n\n## 创建一个Bound Service\n\nBound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。\n\n\n## 给用户发送notifications\n\n当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity\n\n\n## 运行foreground service\n\nforeground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。\n\n**谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。**\n\n让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。\n\n\n\n```\n\n//代码\n\n```\n\n## service的生命周期\n\nservice的生命周期从创建至销毁有两种情况\n\n### 通过调用startService()创建service\n\n其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service\n\n### 通过调用bindService()创建service\n\n其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。\n\n\n/source/img/201807/service_lifecycle.png\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/2018-07-31-android-service-introduction.md","raw":"---\ntitle: \"Android Service介绍\"\ndescription: \"Android Service介绍\"\ntags: [Android]\n\n---\n\n\n# Android开发Service介绍\n\nService是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。\n\n## 不同类型的Service介绍\n\n### Foreground service\n\nForeground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)\n\n### Background service\n\nBackground service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。\n\n* 注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。\n\n### Bound\n\n当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。\n\n\n不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。\n\n\n## Service的使用\n\n创建一个Service,需要创建Service的子类，并在其中重写回调函数。\n\n### 函数的介绍\n\n#### onStartCommend()\n\n其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。\n\n#### onBind()\n\n其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。**在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null**\n\n#### onCreate()\n\n在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。\n\n#### onDestory()\n\n当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。\n\n### 在menifest中声明一个service\n\n```xml\n<manifest ... >\n  ...\n  <application ... >\n      <service android:name=\".ExampleService\" />\n      ...\n  </application>\n</manifest>\n\n```\n\n* 注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service\n\n## 创建一个Started service\n\n当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。\n\n应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。\n\n例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。\n\n* 注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。\n\n### 两个可以继承启动的service类\n\n#### Service类\n\nService类是所有service的基类，当在继承这一个类的时候，**需要创建一个新的线程，使得service可以再其中完成它的工作** ***（很重要）***，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。\n\n#### IntentService类\n\nIntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。\n\n### 继承IntentService类\n\n在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类\n\n**IntentService类所做的工作**\n\n* 创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。\n* 创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。\n* 当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。\n* 提供onBind()的默认实现方法，并返回null。\n* 提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。\n\n为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。\n\n\n\n\n## 创建一个Bound Service\n\nBound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。\n\n\n## 给用户发送notifications\n\n当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity\n\n\n## 运行foreground service\n\nforeground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。\n\n**谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。**\n\n让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。\n\n\n\n```\n\n//代码\n\n```\n\n## service的生命周期\n\nservice的生命周期从创建至销毁有两种情况\n\n### 通过调用startService()创建service\n\n其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service\n\n### 通过调用bindService()创建service\n\n其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。\n\n\n/source/img/201807/service_lifecycle.png\n\n\n\n\n\n\n\n","slug":"Android/Android基础/2018-07-31-android-service-introduction","published":1,"date":"2020-02-29T02:45:21.613Z","updated":"2020-02-29T03:17:02.276Z","_id":"ck770ryhz003eisui4rxhajyw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android开发Service介绍\"><a href=\"#Android开发Service介绍\" class=\"headerlink\" title=\"Android开发Service介绍\"></a>Android开发Service介绍</h1><p>Service是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。</p>\n<h2 id=\"不同类型的Service介绍\"><a href=\"#不同类型的Service介绍\" class=\"headerlink\" title=\"不同类型的Service介绍\"></a>不同类型的Service介绍</h2><h3 id=\"Foreground-service\"><a href=\"#Foreground-service\" class=\"headerlink\" title=\"Foreground service\"></a>Foreground service</h3><p>Foreground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)</p>\n<h3 id=\"Background-service\"><a href=\"#Background-service\" class=\"headerlink\" title=\"Background service\"></a>Background service</h3><p>Background service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。</p>\n<ul>\n<li>注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。</li>\n</ul>\n<h3 id=\"Bound\"><a href=\"#Bound\" class=\"headerlink\" title=\"Bound\"></a>Bound</h3><p>当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。</p>\n<p>不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。</p>\n<h2 id=\"Service的使用\"><a href=\"#Service的使用\" class=\"headerlink\" title=\"Service的使用\"></a>Service的使用</h2><p>创建一个Service,需要创建Service的子类，并在其中重写回调函数。</p>\n<h3 id=\"函数的介绍\"><a href=\"#函数的介绍\" class=\"headerlink\" title=\"函数的介绍\"></a>函数的介绍</h3><h4 id=\"onStartCommend\"><a href=\"#onStartCommend\" class=\"headerlink\" title=\"onStartCommend()\"></a>onStartCommend()</h4><p>其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。</p>\n<h4 id=\"onBind\"><a href=\"#onBind\" class=\"headerlink\" title=\"onBind()\"></a>onBind()</h4><p>其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。<strong>在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null</strong></p>\n<h4 id=\"onCreate\"><a href=\"#onCreate\" class=\"headerlink\" title=\"onCreate()\"></a>onCreate()</h4><p>在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。</p>\n<h4 id=\"onDestory\"><a href=\"#onDestory\" class=\"headerlink\" title=\"onDestory()\"></a>onDestory()</h4><p>当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。</p>\n<h3 id=\"在menifest中声明一个service\"><a href=\"#在menifest中声明一个service\" class=\"headerlink\" title=\"在menifest中声明一个service\"></a>在menifest中声明一个service</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".ExampleService\"</span> /&gt;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service</li>\n</ul>\n<h2 id=\"创建一个Started-service\"><a href=\"#创建一个Started-service\" class=\"headerlink\" title=\"创建一个Started service\"></a>创建一个Started service</h2><p>当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。</p>\n<p>应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。</p>\n<p>例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。</p>\n<ul>\n<li>注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。</li>\n</ul>\n<h3 id=\"两个可以继承启动的service类\"><a href=\"#两个可以继承启动的service类\" class=\"headerlink\" title=\"两个可以继承启动的service类\"></a>两个可以继承启动的service类</h3><h4 id=\"Service类\"><a href=\"#Service类\" class=\"headerlink\" title=\"Service类\"></a>Service类</h4><p>Service类是所有service的基类，当在继承这一个类的时候，<strong>需要创建一个新的线程，使得service可以再其中完成它的工作</strong> <strong><em>（很重要）</em></strong>，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。</p>\n<h4 id=\"IntentService类\"><a href=\"#IntentService类\" class=\"headerlink\" title=\"IntentService类\"></a>IntentService类</h4><p>IntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。</p>\n<h3 id=\"继承IntentService类\"><a href=\"#继承IntentService类\" class=\"headerlink\" title=\"继承IntentService类\"></a>继承IntentService类</h3><p>在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类</p>\n<p><strong>IntentService类所做的工作</strong></p>\n<ul>\n<li>创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。</li>\n<li>创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。</li>\n<li>当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。</li>\n<li>提供onBind()的默认实现方法，并返回null。</li>\n<li>提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。</li>\n</ul>\n<p>为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。</p>\n<h2 id=\"创建一个Bound-Service\"><a href=\"#创建一个Bound-Service\" class=\"headerlink\" title=\"创建一个Bound Service\"></a>创建一个Bound Service</h2><p>Bound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。</p>\n<h2 id=\"给用户发送notifications\"><a href=\"#给用户发送notifications\" class=\"headerlink\" title=\"给用户发送notifications\"></a>给用户发送notifications</h2><p>当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity</p>\n<h2 id=\"运行foreground-service\"><a href=\"#运行foreground-service\" class=\"headerlink\" title=\"运行foreground service\"></a>运行foreground service</h2><p>foreground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。</p>\n<p><strong>谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。</strong></p>\n<p>让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;代码</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"service的生命周期\"><a href=\"#service的生命周期\" class=\"headerlink\" title=\"service的生命周期\"></a>service的生命周期</h2><p>service的生命周期从创建至销毁有两种情况</p>\n<h3 id=\"通过调用startService-创建service\"><a href=\"#通过调用startService-创建service\" class=\"headerlink\" title=\"通过调用startService()创建service\"></a>通过调用startService()创建service</h3><p>其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service</p>\n<h3 id=\"通过调用bindService-创建service\"><a href=\"#通过调用bindService-创建service\" class=\"headerlink\" title=\"通过调用bindService()创建service\"></a>通过调用bindService()创建service</h3><p>其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。</p>\n<p>/source/img/201807/service_lifecycle.png</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android开发Service介绍\"><a href=\"#Android开发Service介绍\" class=\"headerlink\" title=\"Android开发Service介绍\"></a>Android开发Service介绍</h1><p>Service是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。</p>\n<h2 id=\"不同类型的Service介绍\"><a href=\"#不同类型的Service介绍\" class=\"headerlink\" title=\"不同类型的Service介绍\"></a>不同类型的Service介绍</h2><h3 id=\"Foreground-service\"><a href=\"#Foreground-service\" class=\"headerlink\" title=\"Foreground service\"></a>Foreground service</h3><p>Foreground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)</p>\n<h3 id=\"Background-service\"><a href=\"#Background-service\" class=\"headerlink\" title=\"Background service\"></a>Background service</h3><p>Background service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。</p>\n<ul>\n<li>注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。</li>\n</ul>\n<h3 id=\"Bound\"><a href=\"#Bound\" class=\"headerlink\" title=\"Bound\"></a>Bound</h3><p>当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。</p>\n<p>不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。</p>\n<h2 id=\"Service的使用\"><a href=\"#Service的使用\" class=\"headerlink\" title=\"Service的使用\"></a>Service的使用</h2><p>创建一个Service,需要创建Service的子类，并在其中重写回调函数。</p>\n<h3 id=\"函数的介绍\"><a href=\"#函数的介绍\" class=\"headerlink\" title=\"函数的介绍\"></a>函数的介绍</h3><h4 id=\"onStartCommend\"><a href=\"#onStartCommend\" class=\"headerlink\" title=\"onStartCommend()\"></a>onStartCommend()</h4><p>其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。</p>\n<h4 id=\"onBind\"><a href=\"#onBind\" class=\"headerlink\" title=\"onBind()\"></a>onBind()</h4><p>其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。<strong>在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null</strong></p>\n<h4 id=\"onCreate\"><a href=\"#onCreate\" class=\"headerlink\" title=\"onCreate()\"></a>onCreate()</h4><p>在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。</p>\n<h4 id=\"onDestory\"><a href=\"#onDestory\" class=\"headerlink\" title=\"onDestory()\"></a>onDestory()</h4><p>当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。</p>\n<h3 id=\"在menifest中声明一个service\"><a href=\"#在menifest中声明一个service\" class=\"headerlink\" title=\"在menifest中声明一个service\"></a>在menifest中声明一个service</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".ExampleService\"</span> /&gt;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service</li>\n</ul>\n<h2 id=\"创建一个Started-service\"><a href=\"#创建一个Started-service\" class=\"headerlink\" title=\"创建一个Started service\"></a>创建一个Started service</h2><p>当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。</p>\n<p>应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。</p>\n<p>例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。</p>\n<ul>\n<li>注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。</li>\n</ul>\n<h3 id=\"两个可以继承启动的service类\"><a href=\"#两个可以继承启动的service类\" class=\"headerlink\" title=\"两个可以继承启动的service类\"></a>两个可以继承启动的service类</h3><h4 id=\"Service类\"><a href=\"#Service类\" class=\"headerlink\" title=\"Service类\"></a>Service类</h4><p>Service类是所有service的基类，当在继承这一个类的时候，<strong>需要创建一个新的线程，使得service可以再其中完成它的工作</strong> <strong><em>（很重要）</em></strong>，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。</p>\n<h4 id=\"IntentService类\"><a href=\"#IntentService类\" class=\"headerlink\" title=\"IntentService类\"></a>IntentService类</h4><p>IntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。</p>\n<h3 id=\"继承IntentService类\"><a href=\"#继承IntentService类\" class=\"headerlink\" title=\"继承IntentService类\"></a>继承IntentService类</h3><p>在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类</p>\n<p><strong>IntentService类所做的工作</strong></p>\n<ul>\n<li>创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。</li>\n<li>创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。</li>\n<li>当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。</li>\n<li>提供onBind()的默认实现方法，并返回null。</li>\n<li>提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。</li>\n</ul>\n<p>为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。</p>\n<h2 id=\"创建一个Bound-Service\"><a href=\"#创建一个Bound-Service\" class=\"headerlink\" title=\"创建一个Bound Service\"></a>创建一个Bound Service</h2><p>Bound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。</p>\n<h2 id=\"给用户发送notifications\"><a href=\"#给用户发送notifications\" class=\"headerlink\" title=\"给用户发送notifications\"></a>给用户发送notifications</h2><p>当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity</p>\n<h2 id=\"运行foreground-service\"><a href=\"#运行foreground-service\" class=\"headerlink\" title=\"运行foreground service\"></a>运行foreground service</h2><p>foreground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。</p>\n<p><strong>谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。</strong></p>\n<p>让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;代码</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"service的生命周期\"><a href=\"#service的生命周期\" class=\"headerlink\" title=\"service的生命周期\"></a>service的生命周期</h2><p>service的生命周期从创建至销毁有两种情况</p>\n<h3 id=\"通过调用startService-创建service\"><a href=\"#通过调用startService-创建service\" class=\"headerlink\" title=\"通过调用startService()创建service\"></a>通过调用startService()创建service</h3><p>其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service</p>\n<h3 id=\"通过调用bindService-创建service\"><a href=\"#通过调用bindService-创建service\" class=\"headerlink\" title=\"通过调用bindService()创建service\"></a>通过调用bindService()创建service</h3><p>其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。</p>\n<p>/source/img/201807/service_lifecycle.png</p>\n"},{"title":"Android Broadcast介绍","description":"Android Broadcast介绍","_content":"\n# Android Broadcast介绍\n\nmodified: 2018-08-01\nAndroid应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。\n\n手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。\n\n广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。\n\n### 广播中的一些变化\n\n* 在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO\n* 在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效\n* 从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。\n\n## 接收广播\n\n手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。**在Android 8.0(API 26)之后建议使用第二种方式**\n\n### 在menifest文件中声明receiver\n\n通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。\n\n#### 1、menifest文件配置\n\n```xml\n<receiver\n       android:name=\".receiver.BroadcastReceiverTest\"\n       android:exported=\"true\">\n       <intent-filter>\n            <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n             <action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/>\n        </intent-filter>\n</receiver>\n\n```\n### 2、继承BroadcastReceiver类\n\n当用户手机充电时，将会弹出充电的提示。\n\n```java\n\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n    }\n}\n```\n## 通过Context-register的方式注册Receiver\n###1、创建一个BroadcastReceiverTest实例\n```\nBroadcastReceiverTest br=new BroadcastReceiverTest()\n```\n\n###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播\n\n```java\n//用于监控网络的状态变化\nIntentFilter intentFilter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\nintentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nthis.registerReceiver(br,intentFilter);\n```\n\n* 注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。\n\n###3、停止接收广播\n\n停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。\n\n**一定要记得unregister receiver**，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(***防止广播被重复多次注册***)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。\n\n## Broadcast对进程的影响\n\nBroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。\n\n当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。\n\n因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。\n\n```java\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n        final PendingResult pendingResult=goAsync();\n\n        AsyncTask<String,Integer,String>asyncTask=new AsyncTask<String, Integer, String>() {\n            @Override\n            protected String doInBackground(String... strings) {\n                Log.i(\"+++++++++\",\"++++\");\n                pendingResult.finish();\n                return \"测试\";\n            }\n        };\n\n        asyncTask.execute();\n\n    }\n}\n\n```\n\n## 发送广播\n\n### Android提供三种方式发送广播\n\n* 通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。\n* 通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。\n* 通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。\n\n**发送广播的例子**\n\n```java\nIntent intent = new Intent();\nintent.setAction(\"com.example.broadcast.MY_NOTIFICATION\");\nintent.putExtra(\"data\",\"Notice me senpai!\");\nsendBroadcast(intent);\n```\n\n广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。\n\n* 注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。\n\n## 通过permissions限制广播的发送\n\n广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。\n\n### 带有权限的广播发送\n\n当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。\n例如：\n```\nsendBroadcast(new Intent(\"com.example.NOTIFY\"), Manifest.permission.SEND_SMS);\n```\n\n这一条广播的接收者，只能是已经在manifest文件中申请了权限的App\n\n```\n<uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\n```\n\n### 带有权限的广播接收\n无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。**发送广播的App一定要取得相应的权限**\n\n例如：在manifest文件中添加权限限制。\n\n```xml\n<receiver android:name=\".MyBroadcastReceiver\"\n          android:permission=\"android.permission.SEND_SMS\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.AIRPLANE_MODE\"/>\n    </intent-filter>\n</receiver>\n\n``` \n\n使用context-register方式注册广播权限限制\n\n```java\nIntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nregisterReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );\n```\n\n\n\n","source":"_posts/Android/Android基础/2018-08-01-android-broadcast-introduction.md","raw":"---\ntitle: \"Android Broadcast介绍\"\ndescription: \"Android Broadcast介绍\"\ntags: [Android]\n\n\n\n---\n\n# Android Broadcast介绍\n\nmodified: 2018-08-01\nAndroid应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。\n\n手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。\n\n广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。\n\n### 广播中的一些变化\n\n* 在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO\n* 在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效\n* 从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。\n\n## 接收广播\n\n手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。**在Android 8.0(API 26)之后建议使用第二种方式**\n\n### 在menifest文件中声明receiver\n\n通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。\n\n#### 1、menifest文件配置\n\n```xml\n<receiver\n       android:name=\".receiver.BroadcastReceiverTest\"\n       android:exported=\"true\">\n       <intent-filter>\n            <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n             <action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/>\n        </intent-filter>\n</receiver>\n\n```\n### 2、继承BroadcastReceiver类\n\n当用户手机充电时，将会弹出充电的提示。\n\n```java\n\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n    }\n}\n```\n## 通过Context-register的方式注册Receiver\n###1、创建一个BroadcastReceiverTest实例\n```\nBroadcastReceiverTest br=new BroadcastReceiverTest()\n```\n\n###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播\n\n```java\n//用于监控网络的状态变化\nIntentFilter intentFilter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\nintentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nthis.registerReceiver(br,intentFilter);\n```\n\n* 注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。\n\n###3、停止接收广播\n\n停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。\n\n**一定要记得unregister receiver**，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(***防止广播被重复多次注册***)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。\n\n## Broadcast对进程的影响\n\nBroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。\n\n当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。\n\n因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。\n\n```java\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n        final PendingResult pendingResult=goAsync();\n\n        AsyncTask<String,Integer,String>asyncTask=new AsyncTask<String, Integer, String>() {\n            @Override\n            protected String doInBackground(String... strings) {\n                Log.i(\"+++++++++\",\"++++\");\n                pendingResult.finish();\n                return \"测试\";\n            }\n        };\n\n        asyncTask.execute();\n\n    }\n}\n\n```\n\n## 发送广播\n\n### Android提供三种方式发送广播\n\n* 通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。\n* 通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。\n* 通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。\n\n**发送广播的例子**\n\n```java\nIntent intent = new Intent();\nintent.setAction(\"com.example.broadcast.MY_NOTIFICATION\");\nintent.putExtra(\"data\",\"Notice me senpai!\");\nsendBroadcast(intent);\n```\n\n广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。\n\n* 注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。\n\n## 通过permissions限制广播的发送\n\n广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。\n\n### 带有权限的广播发送\n\n当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。\n例如：\n```\nsendBroadcast(new Intent(\"com.example.NOTIFY\"), Manifest.permission.SEND_SMS);\n```\n\n这一条广播的接收者，只能是已经在manifest文件中申请了权限的App\n\n```\n<uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\n```\n\n### 带有权限的广播接收\n无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。**发送广播的App一定要取得相应的权限**\n\n例如：在manifest文件中添加权限限制。\n\n```xml\n<receiver android:name=\".MyBroadcastReceiver\"\n          android:permission=\"android.permission.SEND_SMS\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.AIRPLANE_MODE\"/>\n    </intent-filter>\n</receiver>\n\n``` \n\n使用context-register方式注册广播权限限制\n\n```java\nIntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nregisterReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );\n```\n\n\n\n","slug":"Android/Android基础/2018-08-01-android-broadcast-introduction","published":1,"date":"2020-02-29T02:45:21.654Z","updated":"2020-02-29T02:53:24.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi0003fisui4d375asd","content":"<h1 id=\"Android-Broadcast介绍\"><a href=\"#Android-Broadcast介绍\" class=\"headerlink\" title=\"Android Broadcast介绍\"></a>Android Broadcast介绍</h1><p>modified: 2018-08-01<br>Android应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。</p>\n<p>手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。</p>\n<p>广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。</p>\n<h3 id=\"广播中的一些变化\"><a href=\"#广播中的一些变化\" class=\"headerlink\" title=\"广播中的一些变化\"></a>广播中的一些变化</h3><ul>\n<li>在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO</li>\n<li>在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效</li>\n<li>从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。</li>\n</ul>\n<h2 id=\"接收广播\"><a href=\"#接收广播\" class=\"headerlink\" title=\"接收广播\"></a>接收广播</h2><p>手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。<strong>在Android 8.0(API 26)之后建议使用第二种方式</strong></p>\n<h3 id=\"在menifest文件中声明receiver\"><a href=\"#在menifest文件中声明receiver\" class=\"headerlink\" title=\"在menifest文件中声明receiver\"></a>在menifest文件中声明receiver</h3><p>通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。</p>\n<h4 id=\"1、menifest文件配置\"><a href=\"#1、menifest文件配置\" class=\"headerlink\" title=\"1、menifest文件配置\"></a>1、menifest文件配置</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">android:name</span>=<span class=\"string\">\".receiver.BroadcastReceiverTest\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">android:exported</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.ACTION_POWER_CONNECTED\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、继承BroadcastReceiver类\"><a href=\"#2、继承BroadcastReceiver类\" class=\"headerlink\" title=\"2、继承BroadcastReceiver类\"></a>2、继承BroadcastReceiver类</h3><p>当用户手机充电时，将会弹出充电的提示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过Context-register的方式注册Receiver\"><a href=\"#通过Context-register的方式注册Receiver\" class=\"headerlink\" title=\"通过Context-register的方式注册Receiver\"></a>通过Context-register的方式注册Receiver</h2><p>###1、创建一个BroadcastReceiverTest实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BroadcastReceiverTest br&#x3D;new BroadcastReceiverTest()</span><br></pre></td></tr></table></figure>\n\n<p>###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于监控网络的状态变化</span></span><br><span class=\"line\">IntentFilter intentFilter=<span class=\"keyword\">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class=\"line\">intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.registerReceiver(br,intentFilter);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。</li>\n</ul>\n<p>###3、停止接收广播</p>\n<p>停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。</p>\n<p><strong>一定要记得unregister receiver</strong>，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(<strong><em>防止广播被重复多次注册</em></strong>)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。</p>\n<h2 id=\"Broadcast对进程的影响\"><a href=\"#Broadcast对进程的影响\" class=\"headerlink\" title=\"Broadcast对进程的影响\"></a>Broadcast对进程的影响</h2><p>BroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。</p>\n<p>当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。</p>\n<p>因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PendingResult pendingResult=goAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        AsyncTask&lt;String,Integer,String&gt;asyncTask=<span class=\"keyword\">new</span> AsyncTask&lt;String, Integer, String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... strings)</span> </span>&#123;</span><br><span class=\"line\">                Log.i(<span class=\"string\">\"+++++++++\"</span>,<span class=\"string\">\"++++\"</span>);</span><br><span class=\"line\">                pendingResult.finish();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"测试\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        asyncTask.execute();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发送广播\"><a href=\"#发送广播\" class=\"headerlink\" title=\"发送广播\"></a>发送广播</h2><h3 id=\"Android提供三种方式发送广播\"><a href=\"#Android提供三种方式发送广播\" class=\"headerlink\" title=\"Android提供三种方式发送广播\"></a>Android提供三种方式发送广播</h3><ul>\n<li>通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。</li>\n<li>通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。</li>\n<li>通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。</li>\n</ul>\n<p><strong>发送广播的例子</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">\"com.example.broadcast.MY_NOTIFICATION\"</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>,<span class=\"string\">\"Notice me senpai!\"</span>);</span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。</p>\n<ul>\n<li>注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。</li>\n</ul>\n<h2 id=\"通过permissions限制广播的发送\"><a href=\"#通过permissions限制广播的发送\" class=\"headerlink\" title=\"通过permissions限制广播的发送\"></a>通过permissions限制广播的发送</h2><p>广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。</p>\n<h3 id=\"带有权限的广播发送\"><a href=\"#带有权限的广播发送\" class=\"headerlink\" title=\"带有权限的广播发送\"></a>带有权限的广播发送</h3><p>当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS);</span><br></pre></td></tr></table></figure>\n\n<p>这一条广播的接收者，只能是已经在manifest文件中申请了权限的App</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name&#x3D;&quot;android.permission.SEND_SMS&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"带有权限的广播接收\"><a href=\"#带有权限的广播接收\" class=\"headerlink\" title=\"带有权限的广播接收\"></a>带有权限的广播接收</h3><p>无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。<strong>发送广播的App一定要取得相应的权限</strong></p>\n<p>例如：在manifest文件中添加权限限制。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".MyBroadcastReceiver\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:permission</span>=<span class=\"string\">\"android.permission.SEND_SMS\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.AIRPLANE_MODE\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">使用context-register方式注册广播权限限制</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">IntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\">registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-Broadcast介绍\"><a href=\"#Android-Broadcast介绍\" class=\"headerlink\" title=\"Android Broadcast介绍\"></a>Android Broadcast介绍</h1><p>modified: 2018-08-01<br>Android应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。</p>\n<p>手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。</p>\n<p>广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。</p>\n<h3 id=\"广播中的一些变化\"><a href=\"#广播中的一些变化\" class=\"headerlink\" title=\"广播中的一些变化\"></a>广播中的一些变化</h3><ul>\n<li>在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO</li>\n<li>在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效</li>\n<li>从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。</li>\n</ul>\n<h2 id=\"接收广播\"><a href=\"#接收广播\" class=\"headerlink\" title=\"接收广播\"></a>接收广播</h2><p>手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。<strong>在Android 8.0(API 26)之后建议使用第二种方式</strong></p>\n<h3 id=\"在menifest文件中声明receiver\"><a href=\"#在menifest文件中声明receiver\" class=\"headerlink\" title=\"在menifest文件中声明receiver\"></a>在menifest文件中声明receiver</h3><p>通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。</p>\n<h4 id=\"1、menifest文件配置\"><a href=\"#1、menifest文件配置\" class=\"headerlink\" title=\"1、menifest文件配置\"></a>1、menifest文件配置</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">android:name</span>=<span class=\"string\">\".receiver.BroadcastReceiverTest\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">android:exported</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.BOOT_COMPLETED\"</span>/&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.ACTION_POWER_CONNECTED\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、继承BroadcastReceiver类\"><a href=\"#2、继承BroadcastReceiver类\" class=\"headerlink\" title=\"2、继承BroadcastReceiver类\"></a>2、继承BroadcastReceiver类</h3><p>当用户手机充电时，将会弹出充电的提示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过Context-register的方式注册Receiver\"><a href=\"#通过Context-register的方式注册Receiver\" class=\"headerlink\" title=\"通过Context-register的方式注册Receiver\"></a>通过Context-register的方式注册Receiver</h2><p>###1、创建一个BroadcastReceiverTest实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BroadcastReceiverTest br&#x3D;new BroadcastReceiverTest()</span><br></pre></td></tr></table></figure>\n\n<p>###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于监控网络的状态变化</span></span><br><span class=\"line\">IntentFilter intentFilter=<span class=\"keyword\">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class=\"line\">intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.registerReceiver(br,intentFilter);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。</li>\n</ul>\n<p>###3、停止接收广播</p>\n<p>停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。</p>\n<p><strong>一定要记得unregister receiver</strong>，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(<strong><em>防止广播被重复多次注册</em></strong>)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。</p>\n<h2 id=\"Broadcast对进程的影响\"><a href=\"#Broadcast对进程的影响\" class=\"headerlink\" title=\"Broadcast对进程的影响\"></a>Broadcast对进程的影响</h2><p>BroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。</p>\n<p>当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。</p>\n<p>因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PendingResult pendingResult=goAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        AsyncTask&lt;String,Integer,String&gt;asyncTask=<span class=\"keyword\">new</span> AsyncTask&lt;String, Integer, String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... strings)</span> </span>&#123;</span><br><span class=\"line\">                Log.i(<span class=\"string\">\"+++++++++\"</span>,<span class=\"string\">\"++++\"</span>);</span><br><span class=\"line\">                pendingResult.finish();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"测试\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        asyncTask.execute();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发送广播\"><a href=\"#发送广播\" class=\"headerlink\" title=\"发送广播\"></a>发送广播</h2><h3 id=\"Android提供三种方式发送广播\"><a href=\"#Android提供三种方式发送广播\" class=\"headerlink\" title=\"Android提供三种方式发送广播\"></a>Android提供三种方式发送广播</h3><ul>\n<li>通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。</li>\n<li>通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。</li>\n<li>通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。</li>\n</ul>\n<p><strong>发送广播的例子</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">\"com.example.broadcast.MY_NOTIFICATION\"</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">\"data\"</span>,<span class=\"string\">\"Notice me senpai!\"</span>);</span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。</p>\n<ul>\n<li>注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。</li>\n</ul>\n<h2 id=\"通过permissions限制广播的发送\"><a href=\"#通过permissions限制广播的发送\" class=\"headerlink\" title=\"通过permissions限制广播的发送\"></a>通过permissions限制广播的发送</h2><p>广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。</p>\n<h3 id=\"带有权限的广播发送\"><a href=\"#带有权限的广播发送\" class=\"headerlink\" title=\"带有权限的广播发送\"></a>带有权限的广播发送</h3><p>当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS);</span><br></pre></td></tr></table></figure>\n\n<p>这一条广播的接收者，只能是已经在manifest文件中申请了权限的App</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name&#x3D;&quot;android.permission.SEND_SMS&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"带有权限的广播接收\"><a href=\"#带有权限的广播接收\" class=\"headerlink\" title=\"带有权限的广播接收\"></a>带有权限的广播接收</h3><p>无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。<strong>发送广播的App一定要取得相应的权限</strong></p>\n<p>例如：在manifest文件中添加权限限制。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".MyBroadcastReceiver\"</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:permission</span>=<span class=\"string\">\"android.permission.SEND_SMS\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.AIRPLANE_MODE\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">使用context-register方式注册广播权限限制</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">IntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\">registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"\n### gradle介绍\n\ngradle和make以及ant不同，它基于Groovy语言，而非一种配置；\n\nGradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，\n\n\n\n#### 在Moudle的build.gradle中添加依赖包\n\n```java\n    android { ... }\n\n    dependencies {\n        // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`\n        implementation project(\":mylibrary\")\n\n        // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 \n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n        // 依赖于远程库\n        implementation 'com.example.android:app-magic:12.3'\n    }\n\n```\n\n依赖包的配置有以下类型：`implementation`、`api`、`compileOnly`、`runtimeOnly`、`annotationProcessor`、`lintChecks`、`lintPublish`\n在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。\n\n```java\n    dependencies {\n        freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n    }\n\n```\n如果需要将依赖作为变量，与flavor和build type进行结合，要在`configurations`代码块中进行初始化。\n```java\n    configurations {\n        //初始化只与freeDebugRuntimeOnly相关的依赖\n        freeDebugRuntimeOnly {}\n    }\n\n    dependencies {\n        freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n```\n\n\n### 在Debug模式下使用正式签名\n\n在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错`ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.`\n\n```java\n\n    android{\n           ...\n        signingConfigs {\n            release {\n                //.jks文件放在项目目录（app目录）\n                storeFile file(\"app.jks\")//签名文件名\n                storePassword \"password\"//密码\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"//密码\n                }\n\n            debug {\n                storeFile file(\"app.jks\")\n                storePassword\"password\"\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"\n            }\n        }   \n           \n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n                signingConfig signingConfigs.release\n            }\n            debug {\n            signingConfig signingConfigs.release\n            }\n        }\n\n       ....\n    }\n```\n\n### 加速项目的构建速度\n\n#### 优化项目配置\n有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个`dev`flavor和`prod`flavor(发布版本)。\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n  productFlavors {\n    //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；\n    dev {\n      \n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n    }\n\n    prod {\n      // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。\n      \n    }\n  }\n}\n\n```\n\n可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出`devDemo`和`prodFull`\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n\n  // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度\n  flavorDimensions \"stage\", \"mode\"\n\n  productFlavors {\n    dev {\n      dimension \"stage\"\n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n      \n      //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片\n      resConfigs \"en\", \"xxhdpi\"\n      ...\n    }\n\n    prod {\n      dimension \"stage\"\n      ...\n    }\n\n    demo {\n      dimension \"mode\"\n      ...\n    }\n\n    full {\n      dimension \"mode\"\n      ...\n    }\n  }\n}\n\n```\n#### 编译类型配置\n\n```java\n    android {\n      ...\n      buildTypes {\n        debug {\n          //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`\n          ext.enableCrashlytics = false\n          //防止Crashlytics 每次更新编译的id\n          ext.alwaysUpdateBuildId = false\n        }\n}\n\n```\n#### 在Debug版本构建的过程中使用静态常量\n在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。\n\n```java\n\nint MILLIS_IN_MINUTE = 1000 * 60\nint minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE\n\nandroid {\n    ...\n    defaultConfig {\n  \n        //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk\n        versionCode 1\n        versionName \"1.0\"\n        ...\n    }\n\n    //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。\n    //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理\n    applicationVariants.all { variant ->\n        if (variant.buildType.name == \"release\") {\n            variant.mergedFlavor.versionCode = minutesSinceEpoch;\n            variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName;\n        }\n    }\n}\n\n```\n\n#### 使用增量注解处理（incremental annotation processors）\nAndroid Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。\n\n```xml\n     android.enableSeparateAnnotationProcessing = true\n```\n\n\n#### 其他方式\n\n* 使用确定的依赖，避免使用`+`，如：'com.android.tools.build:gradle:2.+'\n* 使用离线模式进行编译\n* 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。\n* 创建自定义编译任务\n* 将图片转换为WebP\n   \n   WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。\n* 禁用PNG压缩\n\n  ```java\n  \n  android {\n    buildTypes {\n        release {\n            //禁用PNG压缩\n            crunchPngs false\n        }\n    }\n\n    // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩\n    //  aaptOptions {\n    //      cruncherEnabled false\n    //  }\n}\n  ```\n  \n* 使用编译缓存\n在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，`clean build`会变得更快，因为其会调用缓存中的文件，而非重新生成。\n在gradle.gradle.properties 中指定编译缓存的路径，默认路径为`<user-home>/.android/build-cache/`\n\n```xml\n    // 执行绝对路径或者相对路径\n    android.buildCacheDir=<path-to-directory>\n    android.enableBuildCache=true\n```\n\n#### 打包编译多个版本的apk，待续\n\n\n\n\n","source":"_posts/Android/Other/Module的.gradle配置.md","raw":"\n### gradle介绍\n\ngradle和make以及ant不同，它基于Groovy语言，而非一种配置；\n\nGradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，\n\n\n\n#### 在Moudle的build.gradle中添加依赖包\n\n```java\n    android { ... }\n\n    dependencies {\n        // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`\n        implementation project(\":mylibrary\")\n\n        // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 \n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n        // 依赖于远程库\n        implementation 'com.example.android:app-magic:12.3'\n    }\n\n```\n\n依赖包的配置有以下类型：`implementation`、`api`、`compileOnly`、`runtimeOnly`、`annotationProcessor`、`lintChecks`、`lintPublish`\n在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。\n\n```java\n    dependencies {\n        freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n    }\n\n```\n如果需要将依赖作为变量，与flavor和build type进行结合，要在`configurations`代码块中进行初始化。\n```java\n    configurations {\n        //初始化只与freeDebugRuntimeOnly相关的依赖\n        freeDebugRuntimeOnly {}\n    }\n\n    dependencies {\n        freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n```\n\n\n### 在Debug模式下使用正式签名\n\n在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错`ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.`\n\n```java\n\n    android{\n           ...\n        signingConfigs {\n            release {\n                //.jks文件放在项目目录（app目录）\n                storeFile file(\"app.jks\")//签名文件名\n                storePassword \"password\"//密码\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"//密码\n                }\n\n            debug {\n                storeFile file(\"app.jks\")\n                storePassword\"password\"\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"\n            }\n        }   \n           \n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n                signingConfig signingConfigs.release\n            }\n            debug {\n            signingConfig signingConfigs.release\n            }\n        }\n\n       ....\n    }\n```\n\n### 加速项目的构建速度\n\n#### 优化项目配置\n有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个`dev`flavor和`prod`flavor(发布版本)。\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n  productFlavors {\n    //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；\n    dev {\n      \n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n    }\n\n    prod {\n      // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。\n      \n    }\n  }\n}\n\n```\n\n可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出`devDemo`和`prodFull`\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n\n  // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度\n  flavorDimensions \"stage\", \"mode\"\n\n  productFlavors {\n    dev {\n      dimension \"stage\"\n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n      \n      //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片\n      resConfigs \"en\", \"xxhdpi\"\n      ...\n    }\n\n    prod {\n      dimension \"stage\"\n      ...\n    }\n\n    demo {\n      dimension \"mode\"\n      ...\n    }\n\n    full {\n      dimension \"mode\"\n      ...\n    }\n  }\n}\n\n```\n#### 编译类型配置\n\n```java\n    android {\n      ...\n      buildTypes {\n        debug {\n          //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`\n          ext.enableCrashlytics = false\n          //防止Crashlytics 每次更新编译的id\n          ext.alwaysUpdateBuildId = false\n        }\n}\n\n```\n#### 在Debug版本构建的过程中使用静态常量\n在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。\n\n```java\n\nint MILLIS_IN_MINUTE = 1000 * 60\nint minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE\n\nandroid {\n    ...\n    defaultConfig {\n  \n        //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk\n        versionCode 1\n        versionName \"1.0\"\n        ...\n    }\n\n    //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。\n    //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理\n    applicationVariants.all { variant ->\n        if (variant.buildType.name == \"release\") {\n            variant.mergedFlavor.versionCode = minutesSinceEpoch;\n            variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName;\n        }\n    }\n}\n\n```\n\n#### 使用增量注解处理（incremental annotation processors）\nAndroid Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。\n\n```xml\n     android.enableSeparateAnnotationProcessing = true\n```\n\n\n#### 其他方式\n\n* 使用确定的依赖，避免使用`+`，如：'com.android.tools.build:gradle:2.+'\n* 使用离线模式进行编译\n* 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。\n* 创建自定义编译任务\n* 将图片转换为WebP\n   \n   WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。\n* 禁用PNG压缩\n\n  ```java\n  \n  android {\n    buildTypes {\n        release {\n            //禁用PNG压缩\n            crunchPngs false\n        }\n    }\n\n    // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩\n    //  aaptOptions {\n    //      cruncherEnabled false\n    //  }\n}\n  ```\n  \n* 使用编译缓存\n在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，`clean build`会变得更快，因为其会调用缓存中的文件，而非重新生成。\n在gradle.gradle.properties 中指定编译缓存的路径，默认路径为`<user-home>/.android/build-cache/`\n\n```xml\n    // 执行绝对路径或者相对路径\n    android.buildCacheDir=<path-to-directory>\n    android.enableBuildCache=true\n```\n\n#### 打包编译多个版本的apk，待续\n\n\n\n\n","slug":"Android/Other/Module的.gradle配置","published":1,"date":"2019-09-30T08:28:42.959Z","updated":"2019-09-30T08:28:42.959Z","title":"Android/Other/Module的.gradle配置","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi0003hisuie17u7vey","content":"<h3 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h3><p>gradle和make以及ant不同，它基于Groovy语言，而非一种配置；</p>\n<p>Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，</p>\n<h4 id=\"在Moudle的build-gradle中添加依赖包\"><a href=\"#在Moudle的build-gradle中添加依赖包\" class=\"headerlink\" title=\"在Moudle的build.gradle中添加依赖包\"></a>在Moudle的build.gradle中添加依赖包</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`</span></span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">\":mylibrary\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 </span></span></span><br><span class=\"line\"><span class=\"function\">    implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于远程库</span></span></span><br><span class=\"line\"><span class=\"function\">    implementation 'com.example.android:app-magic:12.3'</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>依赖包的配置有以下类型：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code>、<code>annotationProcessor</code>、<code>lintChecks</code>、<code>lintPublish</code><br>在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    freeImplementation <span class=\"string\">'com.google.firebase:firebase-ads:9.8.0'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要将依赖作为变量，与flavor和build type进行结合，要在<code>configurations</code>代码块中进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化只与freeDebugRuntimeOnly相关的依赖</span></span><br><span class=\"line\">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">freeDebugRuntimeOnly <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"在Debug模式下使用正式签名\"><a href=\"#在Debug模式下使用正式签名\" class=\"headerlink\" title=\"在Debug模式下使用正式签名\"></a>在Debug模式下使用正式签名</h3><p>在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错<code>ERROR: Could not get unknown property &#39;release&#39; for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//.jks文件放在项目目录（app目录）</span></span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span><span class=\"comment\">//签名文件名</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword \"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;   </span></span><br><span class=\"line\"><span class=\"function\">       </span></span><br><span class=\"line\"><span class=\"function\">    buildTypes </span>&#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class=\"line\"><span class=\"function\">            signingConfig signingConfigs.release</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">        signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加速项目的构建速度\"><a href=\"#加速项目的构建速度\" class=\"headerlink\" title=\"加速项目的构建速度\"></a>加速项目的构建速度</h3><h4 id=\"优化项目配置\"><a href=\"#优化项目配置\" class=\"headerlink\" title=\"优化项目配置\"></a>优化项目配置</h4><p>有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个<code>dev</code>flavor和<code>prod</code>flavor(发布版本)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；</span></span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出<code>devDemo</code>和<code>prodFull</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度</span></span><br><span class=\"line\">  flavorDimensions <span class=\"string\">\"stage\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片</span></span><br><span class=\"line\">      resConfigs <span class=\"string\">\"en\"</span>, <span class=\"string\">\"xxhdpi\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    demo &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    full &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译类型配置\"><a href=\"#编译类型配置\" class=\"headerlink\" title=\"编译类型配置\"></a>编译类型配置</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    android &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      buildTypes &#123;</span><br><span class=\"line\">        debug &#123;</span><br><span class=\"line\">          <span class=\"comment\">//如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`</span></span><br><span class=\"line\">          ext.enableCrashlytics = <span class=\"keyword\">false</span></span><br><span class=\"line\">          <span class=\"comment\">//防止Crashlytics 每次更新编译的id</span></span><br><span class=\"line\">          ext.alwaysUpdateBuildId = <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Debug版本构建的过程中使用静态常量\"><a href=\"#在Debug版本构建的过程中使用静态常量\" class=\"headerlink\" title=\"在Debug版本构建的过程中使用静态常量\"></a>在Debug版本构建的过程中使用静态常量</h4><p>在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MILLIS_IN_MINUTE = <span class=\"number\">1000</span> * <span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理</span></span><br><span class=\"line\">    applicationVariants.all &#123; variant -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variant.buildType.name == <span class=\"string\">\"release\"</span>) &#123;</span><br><span class=\"line\">            variant.mergedFlavor.versionCode = minutesSinceEpoch;</span><br><span class=\"line\">            variant.mergedFlavor.versionName = minutesSinceEpoch + <span class=\"string\">\"-\"</span> + variant.flavorName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用增量注解处理（incremental-annotation-processors）\"><a href=\"#使用增量注解处理（incremental-annotation-processors）\" class=\"headerlink\" title=\"使用增量注解处理（incremental annotation processors）\"></a>使用增量注解处理（incremental annotation processors）</h4><p>Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.enableSeparateAnnotationProcessing = true</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h4><ul>\n<li><p>使用确定的依赖，避免使用<code>+</code>，如：’com.android.tools.build:gradle:2.+’</p>\n</li>\n<li><p>使用离线模式进行编译</p>\n</li>\n<li><p>创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。</p>\n</li>\n<li><p>创建自定义编译任务</p>\n</li>\n<li><p>将图片转换为WebP</p>\n<p> WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。</p>\n</li>\n<li><p>禁用PNG压缩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//禁用PNG压缩</span></span><br><span class=\"line\">            crunchPngs <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩</span></span><br><span class=\"line\">    <span class=\"comment\">//  aaptOptions &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      cruncherEnabled false</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用编译缓存<br>在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，<code>clean build</code>会变得更快，因为其会调用缓存中的文件，而非重新生成。<br>在gradle.gradle.properties 中指定编译缓存的路径，默认路径为<code>&lt;user-home&gt;/.android/build-cache/</code></p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 执行绝对路径或者相对路径</span><br><span class=\"line\">android.buildCacheDir=<span class=\"tag\">&lt;<span class=\"name\">path-to-directory</span>&gt;</span></span><br><span class=\"line\">android.enableBuildCache=true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打包编译多个版本的apk，待续\"><a href=\"#打包编译多个版本的apk，待续\" class=\"headerlink\" title=\"打包编译多个版本的apk，待续\"></a>打包编译多个版本的apk，待续</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h3><p>gradle和make以及ant不同，它基于Groovy语言，而非一种配置；</p>\n<p>Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，</p>\n<h4 id=\"在Moudle的build-gradle中添加依赖包\"><a href=\"#在Moudle的build-gradle中添加依赖包\" class=\"headerlink\" title=\"在Moudle的build.gradle中添加依赖包\"></a>在Moudle的build.gradle中添加依赖包</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`</span></span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">\":mylibrary\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 </span></span></span><br><span class=\"line\"><span class=\"function\">    implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于远程库</span></span></span><br><span class=\"line\"><span class=\"function\">    implementation 'com.example.android:app-magic:12.3'</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>依赖包的配置有以下类型：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code>、<code>annotationProcessor</code>、<code>lintChecks</code>、<code>lintPublish</code><br>在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    freeImplementation <span class=\"string\">'com.google.firebase:firebase-ads:9.8.0'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要将依赖作为变量，与flavor和build type进行结合，要在<code>configurations</code>代码块中进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化只与freeDebugRuntimeOnly相关的依赖</span></span><br><span class=\"line\">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">freeDebugRuntimeOnly <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"在Debug模式下使用正式签名\"><a href=\"#在Debug模式下使用正式签名\" class=\"headerlink\" title=\"在Debug模式下使用正式签名\"></a>在Debug模式下使用正式签名</h3><p>在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错<code>ERROR: Could not get unknown property &#39;release&#39; for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//.jks文件放在项目目录（app目录）</span></span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span><span class=\"comment\">//签名文件名</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword \"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;   </span></span><br><span class=\"line\"><span class=\"function\">       </span></span><br><span class=\"line\"><span class=\"function\">    buildTypes </span>&#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class=\"line\"><span class=\"function\">            signingConfig signingConfigs.release</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">        signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加速项目的构建速度\"><a href=\"#加速项目的构建速度\" class=\"headerlink\" title=\"加速项目的构建速度\"></a>加速项目的构建速度</h3><h4 id=\"优化项目配置\"><a href=\"#优化项目配置\" class=\"headerlink\" title=\"优化项目配置\"></a>优化项目配置</h4><p>有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个<code>dev</code>flavor和<code>prod</code>flavor(发布版本)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；</span></span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出<code>devDemo</code>和<code>prodFull</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度</span></span><br><span class=\"line\">  flavorDimensions <span class=\"string\">\"stage\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片</span></span><br><span class=\"line\">      resConfigs <span class=\"string\">\"en\"</span>, <span class=\"string\">\"xxhdpi\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    demo &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    full &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译类型配置\"><a href=\"#编译类型配置\" class=\"headerlink\" title=\"编译类型配置\"></a>编译类型配置</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    android &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      buildTypes &#123;</span><br><span class=\"line\">        debug &#123;</span><br><span class=\"line\">          <span class=\"comment\">//如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`</span></span><br><span class=\"line\">          ext.enableCrashlytics = <span class=\"keyword\">false</span></span><br><span class=\"line\">          <span class=\"comment\">//防止Crashlytics 每次更新编译的id</span></span><br><span class=\"line\">          ext.alwaysUpdateBuildId = <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Debug版本构建的过程中使用静态常量\"><a href=\"#在Debug版本构建的过程中使用静态常量\" class=\"headerlink\" title=\"在Debug版本构建的过程中使用静态常量\"></a>在Debug版本构建的过程中使用静态常量</h4><p>在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MILLIS_IN_MINUTE = <span class=\"number\">1000</span> * <span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理</span></span><br><span class=\"line\">    applicationVariants.all &#123; variant -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variant.buildType.name == <span class=\"string\">\"release\"</span>) &#123;</span><br><span class=\"line\">            variant.mergedFlavor.versionCode = minutesSinceEpoch;</span><br><span class=\"line\">            variant.mergedFlavor.versionName = minutesSinceEpoch + <span class=\"string\">\"-\"</span> + variant.flavorName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用增量注解处理（incremental-annotation-processors）\"><a href=\"#使用增量注解处理（incremental-annotation-processors）\" class=\"headerlink\" title=\"使用增量注解处理（incremental annotation processors）\"></a>使用增量注解处理（incremental annotation processors）</h4><p>Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.enableSeparateAnnotationProcessing = true</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h4><ul>\n<li><p>使用确定的依赖，避免使用<code>+</code>，如：’com.android.tools.build:gradle:2.+’</p>\n</li>\n<li><p>使用离线模式进行编译</p>\n</li>\n<li><p>创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。</p>\n</li>\n<li><p>创建自定义编译任务</p>\n</li>\n<li><p>将图片转换为WebP</p>\n<p> WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。</p>\n</li>\n<li><p>禁用PNG压缩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//禁用PNG压缩</span></span><br><span class=\"line\">            crunchPngs <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩</span></span><br><span class=\"line\">    <span class=\"comment\">//  aaptOptions &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      cruncherEnabled false</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用编译缓存<br>在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，<code>clean build</code>会变得更快，因为其会调用缓存中的文件，而非重新生成。<br>在gradle.gradle.properties 中指定编译缓存的路径，默认路径为<code>&lt;user-home&gt;/.android/build-cache/</code></p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 执行绝对路径或者相对路径</span><br><span class=\"line\">android.buildCacheDir=<span class=\"tag\">&lt;<span class=\"name\">path-to-directory</span>&gt;</span></span><br><span class=\"line\">android.enableBuildCache=true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打包编译多个版本的apk，待续\"><a href=\"#打包编译多个版本的apk，待续\" class=\"headerlink\" title=\"打包编译多个版本的apk，待续\"></a>打包编译多个版本的apk，待续</h4>"},{"_content":"# Generics(泛型)\n\n一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。\n\nGeneric Programming\\(泛型编程\\)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming\\(泛型编程\\)可以使得对象\\(object\\)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。\n\n如果没有泛型，参数的类型会被忽略，\n\n\n\n## 装箱和拆箱\n\n在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。\n\n将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，**会返回之前缓存的对象**，\n\n```java\n    \n    int a=100;\n    int b=100;\n    int c=200;\n    int d=200;\n    System.out.println(a==b);\n    System.out.println(c==d);\n\n```\n输出结果为\n\n```java\n    true;\n    false;\n```\n\nJava通过泛型可以自动进行装箱与拆箱。\n\n```java\n\n    Integer i=new Integer(xx);\n\n```\n**会触发自动装箱**\n\n```java\n    Integer i=xx;\n```\n**不会触发自动装箱**\n\n**注意：**操作符`==` 在基础类型中以及引用类型中采用不同的定义方式，在`int`类型中，`==`用于通过值的大小定义的，而在`Integer`中是通过对象定义的。在比较两个类对象时应使用euqal\n\n\n\n## 遍历循环\n\nfor循环可以被用于实现Iterable<E>接口的任何类中，\n\n```java\n    List<Integer>ints=Arrays.asList(1,2,3);\n    int s=0;\n    for(int n:ints){\n       s+=n;\n    }\n```\n等价于\n\n```java\n    for(Iterators<Integer>it=ints.iterator();it.hasNext();){\n       int n=it.next();\n       s+=n;\n    }\n```\n\n\n## Iterable<E>接口\n\n所有的`Collection`都实现了Iterable<E>接口\n\n\n## 泛型方法和可变参数(Generic Methods and Varargs)\n\n将任意类型的array转换成List\n\n```java\n    class List{\n       public static<T> List<T> toList(T[] arr){\n           List<T>list=new ArrayList<T>();\n           for(T elt:arr)list.add(elt);\n           return list;\n       }\n    }\n```\n\n将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将`T[]`使用`T...`来替代。\n\n```java\n\nclass Lists{\n        public static<T>List<T>toList(T...arr){\n            List<T>list=new ArrayList<T>();\n            for(T elt:arr)list.add(elt);\n            return list;\n        }\n}\n```\n调用方式\n\n```java\n     List<Integer> ints = Lists.toList(1, 2, 3); \n     List<String> words = Lists.toList(\"hello\", \"world\");\n```\n\n### 子类型和通配符(SubTyping and Wildcards)\n\n**子类型和替换原则**\n\n子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。\n\n```java\n    List<Number>nums=new ArrayList<Number>();\n    nums.add(2);\n    nums.add(3.14);\n```\n\n根据替换规则可以在Number的List中添加`Integer`和`Double`类型的对象。\n\n\n```java\n    List<Integer>ints=new ArrayList<Integer>();\n    ints.add(2);\n    ints.add(3);\n    List<Number>nums=ints;    //在编译时报错\n    nums.add(3.14);\n\n```\n\n报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用`List<? extends Number>nums=ints`，因为List<Integer>是List<? extends Number>的子类型。\n\n### 带有extends的通配符\n\n以Collection接口中的addAll方法为例\n\n```java\n    interface Collection<E>{\n     \n     ...\n     public boolean addAll(Collection<? extends E>c);\n     ...\n    \n    }\n```\n\n`? extends E`表示可以使用E的子类型作为参数添加到Collection中\n\n```java\n\n    List<Number>nums=new ArrayList<Number>();\n    List<Integer>ints=Array.asList(1,2);\n    List<Double>dbls=Array.asList(2.23,3.55);\n    nums.addAll(ints);\n    nums.addAll(dbls);\n```\n在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection<? extends Number>的子类型。如果addAll(Collection<? extends E>c)中没有通配符，那么上面的语句在编译时会报错。\n\n### 带有super的通配符\n\n将一个List拷贝到另外一个List\n\n```java\n\n    public static <T>void copy(List<? super T>dst,List<? extend T>src)\n    {\n       for(int i=0;i<src.size();i++){\n           dst.set(i,src.get(i));\n       }\n    }\n\n```\n\n`? super T`的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;\n典型例子\n\n```java\n    List<Object>objs=Array.<Object>asList(2,3,\"four\");\n    List<Integer>ints=Array.asList(5,6);\n    Collection.copy(objs,ints);\n    Collection.<Object>copy(objs,ints);\n    Collection.<Number>copy(objs,ints);\n    Collection.<Integer>copy(objs,ints);\n    \n```\n\n通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。\n\n### Get和Put原则\n？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的\n\n### 数组\n\n在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。\n```java\n    \n    Integer[] ints=new Integer[]{1,2,3};\n    Number[] nums=ints;\n    num[2]=3.14;  //运行时错误\n\n```\n\nInteger[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。\n\n与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List<? extends T>的子类型。\n\n```java\n    List<Integer>ints=Array.asList(1,2,3);\n    List<Number nums>=ints;      //在编译时会报错\n    List<? extends Number>nums1=ints; //编译通过\n    nums1.set(2,3.14)           //编译错误\n\n```\n\n第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。\n\n\n在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List<? super T>的子类型，数组不支持子类型的逆变。\n\nArrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。\n\n### 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\n\n* 使用通配符判断Collection中是否有指定的对象\n\n```java\n    interface Collection<E>{\n        ...\n        public boolean contains(Object o);\n        public boolean containsAll(Collection<?>c);\n        ...\n    }\n    \n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);\n    ints.containsAll(objs);\n    ...\n```\n\n在`containsAll(Collection<?>c)`方法中 `Collection<?>c`是`Collection<?>c`的缩写(abbreviation)，继承Object是通配符常用的方式。\n\n* 类型参数\n可以通过类型参数来替换通配符的编码方式\n\n```java\n\n    interface Collection<E>{\n        ...\n        public boolean contains(E o);\n        public boolean containsAll(Collection<? extend E>c);\n        ...\n    }\n    \n\n\n```\n\n但实际在编译的过程中使用\n\n```java\n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);     //编译时报错\n    ints.containsAll(objs); //编译时报错\n    ...\n```\n\n两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。\n\n### \n\n\n\n\n\n\n\n","source":"_posts/Java/Java基础/Java泛型.md","raw":"# Generics(泛型)\n\n一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。\n\nGeneric Programming\\(泛型编程\\)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming\\(泛型编程\\)可以使得对象\\(object\\)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。\n\n如果没有泛型，参数的类型会被忽略，\n\n\n\n## 装箱和拆箱\n\n在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。\n\n将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，**会返回之前缓存的对象**，\n\n```java\n    \n    int a=100;\n    int b=100;\n    int c=200;\n    int d=200;\n    System.out.println(a==b);\n    System.out.println(c==d);\n\n```\n输出结果为\n\n```java\n    true;\n    false;\n```\n\nJava通过泛型可以自动进行装箱与拆箱。\n\n```java\n\n    Integer i=new Integer(xx);\n\n```\n**会触发自动装箱**\n\n```java\n    Integer i=xx;\n```\n**不会触发自动装箱**\n\n**注意：**操作符`==` 在基础类型中以及引用类型中采用不同的定义方式，在`int`类型中，`==`用于通过值的大小定义的，而在`Integer`中是通过对象定义的。在比较两个类对象时应使用euqal\n\n\n\n## 遍历循环\n\nfor循环可以被用于实现Iterable<E>接口的任何类中，\n\n```java\n    List<Integer>ints=Arrays.asList(1,2,3);\n    int s=0;\n    for(int n:ints){\n       s+=n;\n    }\n```\n等价于\n\n```java\n    for(Iterators<Integer>it=ints.iterator();it.hasNext();){\n       int n=it.next();\n       s+=n;\n    }\n```\n\n\n## Iterable<E>接口\n\n所有的`Collection`都实现了Iterable<E>接口\n\n\n## 泛型方法和可变参数(Generic Methods and Varargs)\n\n将任意类型的array转换成List\n\n```java\n    class List{\n       public static<T> List<T> toList(T[] arr){\n           List<T>list=new ArrayList<T>();\n           for(T elt:arr)list.add(elt);\n           return list;\n       }\n    }\n```\n\n将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将`T[]`使用`T...`来替代。\n\n```java\n\nclass Lists{\n        public static<T>List<T>toList(T...arr){\n            List<T>list=new ArrayList<T>();\n            for(T elt:arr)list.add(elt);\n            return list;\n        }\n}\n```\n调用方式\n\n```java\n     List<Integer> ints = Lists.toList(1, 2, 3); \n     List<String> words = Lists.toList(\"hello\", \"world\");\n```\n\n### 子类型和通配符(SubTyping and Wildcards)\n\n**子类型和替换原则**\n\n子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。\n\n```java\n    List<Number>nums=new ArrayList<Number>();\n    nums.add(2);\n    nums.add(3.14);\n```\n\n根据替换规则可以在Number的List中添加`Integer`和`Double`类型的对象。\n\n\n```java\n    List<Integer>ints=new ArrayList<Integer>();\n    ints.add(2);\n    ints.add(3);\n    List<Number>nums=ints;    //在编译时报错\n    nums.add(3.14);\n\n```\n\n报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用`List<? extends Number>nums=ints`，因为List<Integer>是List<? extends Number>的子类型。\n\n### 带有extends的通配符\n\n以Collection接口中的addAll方法为例\n\n```java\n    interface Collection<E>{\n     \n     ...\n     public boolean addAll(Collection<? extends E>c);\n     ...\n    \n    }\n```\n\n`? extends E`表示可以使用E的子类型作为参数添加到Collection中\n\n```java\n\n    List<Number>nums=new ArrayList<Number>();\n    List<Integer>ints=Array.asList(1,2);\n    List<Double>dbls=Array.asList(2.23,3.55);\n    nums.addAll(ints);\n    nums.addAll(dbls);\n```\n在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection<? extends Number>的子类型。如果addAll(Collection<? extends E>c)中没有通配符，那么上面的语句在编译时会报错。\n\n### 带有super的通配符\n\n将一个List拷贝到另外一个List\n\n```java\n\n    public static <T>void copy(List<? super T>dst,List<? extend T>src)\n    {\n       for(int i=0;i<src.size();i++){\n           dst.set(i,src.get(i));\n       }\n    }\n\n```\n\n`? super T`的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;\n典型例子\n\n```java\n    List<Object>objs=Array.<Object>asList(2,3,\"four\");\n    List<Integer>ints=Array.asList(5,6);\n    Collection.copy(objs,ints);\n    Collection.<Object>copy(objs,ints);\n    Collection.<Number>copy(objs,ints);\n    Collection.<Integer>copy(objs,ints);\n    \n```\n\n通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。\n\n### Get和Put原则\n？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的\n\n### 数组\n\n在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。\n```java\n    \n    Integer[] ints=new Integer[]{1,2,3};\n    Number[] nums=ints;\n    num[2]=3.14;  //运行时错误\n\n```\n\nInteger[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。\n\n与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List<? extends T>的子类型。\n\n```java\n    List<Integer>ints=Array.asList(1,2,3);\n    List<Number nums>=ints;      //在编译时会报错\n    List<? extends Number>nums1=ints; //编译通过\n    nums1.set(2,3.14)           //编译错误\n\n```\n\n第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。\n\n\n在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List<? super T>的子类型，数组不支持子类型的逆变。\n\nArrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。\n\n### 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\n\n* 使用通配符判断Collection中是否有指定的对象\n\n```java\n    interface Collection<E>{\n        ...\n        public boolean contains(Object o);\n        public boolean containsAll(Collection<?>c);\n        ...\n    }\n    \n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);\n    ints.containsAll(objs);\n    ...\n```\n\n在`containsAll(Collection<?>c)`方法中 `Collection<?>c`是`Collection<?>c`的缩写(abbreviation)，继承Object是通配符常用的方式。\n\n* 类型参数\n可以通过类型参数来替换通配符的编码方式\n\n```java\n\n    interface Collection<E>{\n        ...\n        public boolean contains(E o);\n        public boolean containsAll(Collection<? extend E>c);\n        ...\n    }\n    \n\n\n```\n\n但实际在编译的过程中使用\n\n```java\n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);     //编译时报错\n    ints.containsAll(objs); //编译时报错\n    ...\n```\n\n两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。\n\n### \n\n\n\n\n\n\n\n","slug":"Java/Java基础/Java泛型","published":1,"date":"2019-09-19T09:41:14.772Z","updated":"2019-09-30T08:28:42.970Z","title":"Java/Java基础/Java泛型","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi1003jisui83t22bze","content":"<h1 id=\"Generics-泛型\"><a href=\"#Generics-泛型\" class=\"headerlink\" title=\"Generics(泛型)\"></a>Generics(泛型)</h1><p>一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。</p>\n<p>Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。</p>\n<p>如果没有泛型，参数的类型会被忽略，</p>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><p>在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。</p>\n<p>将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，<strong>会返回之前缓存的对象</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c=<span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d=<span class=\"number\">200</span>;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Java通过泛型可以自动进行装箱与拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer i=<span class=\"keyword\">new</span> Integer(xx);</span><br></pre></td></tr></table></figure>\n<p><strong>会触发自动装箱</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i=xx;</span><br></pre></td></tr></table></figure>\n<p><strong>不会触发自动装箱</strong></p>\n<p><strong>注意：</strong>操作符<code>==</code> 在基础类型中以及引用类型中采用不同的定义方式，在<code>int</code>类型中，<code>==</code>用于通过值的大小定义的，而在<code>Integer</code>中是通过对象定义的。在比较两个类对象时应使用euqal</p>\n<h2 id=\"遍历循环\"><a href=\"#遍历循环\" class=\"headerlink\" title=\"遍历循环\"></a>遍历循环</h2><p>for循环可以被用于实现Iterable<E>接口的任何类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n:ints)&#123;</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n=it.next();</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable<E>接口</h2><p>所有的<code>Collection</code>都实现了Iterable<E>接口</p>\n<h2 id=\"泛型方法和可变参数-Generic-Methods-and-Varargs\"><a href=\"#泛型方法和可变参数-Generic-Methods-and-Varargs\" class=\"headerlink\" title=\"泛型方法和可变参数(Generic Methods and Varargs)\"></a>泛型方法和可变参数(Generic Methods and Varargs)</h2><p>将任意类型的array转换成List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; List&lt;T&gt; <span class=\"title\">toList</span><span class=\"params\">(T[] arr)</span></span>&#123;</span><br><span class=\"line\">       List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将<code>T[]</code>使用<code>T...</code>来替代。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lists</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt;List&lt;T&gt;toList(T...arr)&#123;</span><br><span class=\"line\">            List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ints = Lists.toList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">List&lt;String&gt; words = Lists.toList(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子类型和通配符-SubTyping-and-Wildcards\"><a href=\"#子类型和通配符-SubTyping-and-Wildcards\" class=\"headerlink\" title=\"子类型和通配符(SubTyping and Wildcards)\"></a>子类型和通配符(SubTyping and Wildcards)</h3><p><strong>子类型和替换原则</strong></p>\n<p>子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据替换规则可以在Number的List中添加<code>Integer</code>和<code>Double</code>类型的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">ints.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">ints.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number&gt;nums=ints;    <span class=\"comment\">//在编译时报错</span></span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用<code>List&lt;? extends Number&gt;nums=ints</code>，因为List<Integer>是List&lt;? extends Number&gt;的子类型。</p>\n<h3 id=\"带有extends的通配符\"><a href=\"#带有extends的通配符\" class=\"headerlink\" title=\"带有extends的通配符\"></a>带有extends的通配符</h3><p>以Collection接口中的addAll方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt;c)</span></span>;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? extends E</code>表示可以使用E的子类型作为参数添加到Collection中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">List&lt;Double&gt;dbls=Array.asList(<span class=\"number\">2.23</span>,<span class=\"number\">3.55</span>);</span><br><span class=\"line\">nums.addAll(ints);</span><br><span class=\"line\">nums.addAll(dbls);</span><br></pre></td></tr></table></figure>\n<p>在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。</p>\n<h3 id=\"带有super的通配符\"><a href=\"#带有super的通配符\" class=\"headerlink\" title=\"带有super的通配符\"></a>带有super的通配符</h3><p>将一个List拷贝到另外一个List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt;dst,List&lt;? extend T&gt;src)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;src.size();i++)&#123;</span><br><span class=\"line\">       dst.set(i,src.get(i));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? super T</code>的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;<br>典型例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">Collection.copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Object&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Number&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Integer&gt;copy(objs,ints);</span><br></pre></td></tr></table></figure>\n\n<p>通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。</p>\n<h3 id=\"Get和Put原则\"><a href=\"#Get和Put原则\" class=\"headerlink\" title=\"Get和Put原则\"></a>Get和Put原则</h3><p>？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer[] ints=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Number[] nums=ints;</span><br><span class=\"line\">num[<span class=\"number\">2</span>]=<span class=\"number\">3.14</span>;  <span class=\"comment\">//运行时错误</span></span><br></pre></td></tr></table></figure>\n\n<p>Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。</p>\n<p>与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List&lt;? extends T&gt;的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number nums&gt;=ints;      <span class=\"comment\">//在编译时会报错</span></span><br><span class=\"line\">List&lt;? extends Number&gt;nums1=ints; <span class=\"comment\">//编译通过</span></span><br><span class=\"line\">nums1.set(<span class=\"number\">2</span>,<span class=\"number\">3.14</span>)           <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。</p>\n<p>在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。</p>\n<p>Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。</p>\n<h3 id=\"通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\"><a href=\"#通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\" class=\"headerlink\" title=\"通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\"></a>通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）</h3><ul>\n<li>使用通配符判断Collection中是否有指定的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);</span><br><span class=\"line\">ints.containsAll(objs);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在<code>containsAll(Collection&lt;?&gt;c)</code>方法中 <code>Collection&lt;?&gt;c</code>是<code>Collection&lt;?&gt;c</code>的缩写(abbreviation)，继承Object是通配符常用的方式。</p>\n<ul>\n<li>类型参数<br>可以通过类型参数来替换通配符的编码方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(E o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;? extend E&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但实际在编译的过程中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);     <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">ints.containsAll(objs); <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Generics-泛型\"><a href=\"#Generics-泛型\" class=\"headerlink\" title=\"Generics(泛型)\"></a>Generics(泛型)</h1><p>一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。</p>\n<p>Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。</p>\n<p>如果没有泛型，参数的类型会被忽略，</p>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><p>在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。</p>\n<p>将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，<strong>会返回之前缓存的对象</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c=<span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d=<span class=\"number\">200</span>;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Java通过泛型可以自动进行装箱与拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer i=<span class=\"keyword\">new</span> Integer(xx);</span><br></pre></td></tr></table></figure>\n<p><strong>会触发自动装箱</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i=xx;</span><br></pre></td></tr></table></figure>\n<p><strong>不会触发自动装箱</strong></p>\n<p><strong>注意：</strong>操作符<code>==</code> 在基础类型中以及引用类型中采用不同的定义方式，在<code>int</code>类型中，<code>==</code>用于通过值的大小定义的，而在<code>Integer</code>中是通过对象定义的。在比较两个类对象时应使用euqal</p>\n<h2 id=\"遍历循环\"><a href=\"#遍历循环\" class=\"headerlink\" title=\"遍历循环\"></a>遍历循环</h2><p>for循环可以被用于实现Iterable<E>接口的任何类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n:ints)&#123;</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n=it.next();</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable<E>接口</h2><p>所有的<code>Collection</code>都实现了Iterable<E>接口</p>\n<h2 id=\"泛型方法和可变参数-Generic-Methods-and-Varargs\"><a href=\"#泛型方法和可变参数-Generic-Methods-and-Varargs\" class=\"headerlink\" title=\"泛型方法和可变参数(Generic Methods and Varargs)\"></a>泛型方法和可变参数(Generic Methods and Varargs)</h2><p>将任意类型的array转换成List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; List&lt;T&gt; <span class=\"title\">toList</span><span class=\"params\">(T[] arr)</span></span>&#123;</span><br><span class=\"line\">       List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将<code>T[]</code>使用<code>T...</code>来替代。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lists</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt;List&lt;T&gt;toList(T...arr)&#123;</span><br><span class=\"line\">            List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ints = Lists.toList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">List&lt;String&gt; words = Lists.toList(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子类型和通配符-SubTyping-and-Wildcards\"><a href=\"#子类型和通配符-SubTyping-and-Wildcards\" class=\"headerlink\" title=\"子类型和通配符(SubTyping and Wildcards)\"></a>子类型和通配符(SubTyping and Wildcards)</h3><p><strong>子类型和替换原则</strong></p>\n<p>子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据替换规则可以在Number的List中添加<code>Integer</code>和<code>Double</code>类型的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">ints.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">ints.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number&gt;nums=ints;    <span class=\"comment\">//在编译时报错</span></span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用<code>List&lt;? extends Number&gt;nums=ints</code>，因为List<Integer>是List&lt;? extends Number&gt;的子类型。</p>\n<h3 id=\"带有extends的通配符\"><a href=\"#带有extends的通配符\" class=\"headerlink\" title=\"带有extends的通配符\"></a>带有extends的通配符</h3><p>以Collection接口中的addAll方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt;c)</span></span>;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? extends E</code>表示可以使用E的子类型作为参数添加到Collection中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">List&lt;Double&gt;dbls=Array.asList(<span class=\"number\">2.23</span>,<span class=\"number\">3.55</span>);</span><br><span class=\"line\">nums.addAll(ints);</span><br><span class=\"line\">nums.addAll(dbls);</span><br></pre></td></tr></table></figure>\n<p>在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。</p>\n<h3 id=\"带有super的通配符\"><a href=\"#带有super的通配符\" class=\"headerlink\" title=\"带有super的通配符\"></a>带有super的通配符</h3><p>将一个List拷贝到另外一个List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt;dst,List&lt;? extend T&gt;src)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;src.size();i++)&#123;</span><br><span class=\"line\">       dst.set(i,src.get(i));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? super T</code>的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;<br>典型例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">Collection.copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Object&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Number&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Integer&gt;copy(objs,ints);</span><br></pre></td></tr></table></figure>\n\n<p>通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。</p>\n<h3 id=\"Get和Put原则\"><a href=\"#Get和Put原则\" class=\"headerlink\" title=\"Get和Put原则\"></a>Get和Put原则</h3><p>？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer[] ints=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Number[] nums=ints;</span><br><span class=\"line\">num[<span class=\"number\">2</span>]=<span class=\"number\">3.14</span>;  <span class=\"comment\">//运行时错误</span></span><br></pre></td></tr></table></figure>\n\n<p>Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。</p>\n<p>与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List&lt;? extends T&gt;的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number nums&gt;=ints;      <span class=\"comment\">//在编译时会报错</span></span><br><span class=\"line\">List&lt;? extends Number&gt;nums1=ints; <span class=\"comment\">//编译通过</span></span><br><span class=\"line\">nums1.set(<span class=\"number\">2</span>,<span class=\"number\">3.14</span>)           <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。</p>\n<p>在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。</p>\n<p>Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。</p>\n<h3 id=\"通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\"><a href=\"#通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\" class=\"headerlink\" title=\"通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\"></a>通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）</h3><ul>\n<li>使用通配符判断Collection中是否有指定的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);</span><br><span class=\"line\">ints.containsAll(objs);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在<code>containsAll(Collection&lt;?&gt;c)</code>方法中 <code>Collection&lt;?&gt;c</code>是<code>Collection&lt;?&gt;c</code>的缩写(abbreviation)，继承Object是通配符常用的方式。</p>\n<ul>\n<li>类型参数<br>可以通过类型参数来替换通配符的编码方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(E o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;? extend E&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但实际在编译的过程中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);     <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">ints.containsAll(objs); <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>"},{"_content":"### Runnable接口\n\n仅调用Runnable的`run()`方法不能产生一个新的线程，新线程的执行必须通过`Thread.start()`方法来执行。\n\n通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。\n\n实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。\n\nThread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。\n\n### Thread类\n\nThread类的构造函数需要Runnable实例，调用Thread类的`start()`方法，可以对线程进行必要额初始化，然后执行Runnable实例的`run()`方法。\n\n静态方法`Thread.yield()`用于通知CPU从一个线程切换至另外一个线程；\n\n**注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。**\n\n\n### 多线程框架Executor的使用\nExecutors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。\n\n ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。\n \n Executors中的`shutdown()`方法用于停止向Executor中提交新的任务，在`shutdown()`方法调用之前提交的同步线程任务则会继续执行。\n \n ***注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理***\n \n#### Executor、Executors、ExecutorService区别\n\n* Executor是一个接口，用于并发提交的任务，只有`execute()`一个方法，没有返回值，不能对任务进行任何操作。\n\n```java\n    public interface Executor {\n        void execute(Runnable var1);\n    }\n```\n\n* Executors类提供不同的工厂方法来创建不同类型的线程池，包括：`newSingleThreadExecutor()`、`newFixedThreadPool(int numOfThreads)`、`newCachedThreadPool()`\n\n```java\n\n    public class Executors {\n            //...\n            public static ExecutorService newFixedThreadPool(int var0) {\n            return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());\n        }\n        \n        //...\n    }\n\n```\n\n\n* ExecutorService 是继承自`Exxecutor`的接口，其中有异步执行和关闭线程池的方法。可以通过`submit()`方法来提交任务，同时可以对任务进行取消等操作。\n\n```java\n    public interface ExecutorService extends Executor {\n        //...\n        void shutdown();\n\n        List<Runnable> shutdownNow();\n\n        boolean isShutdown();\n\n        boolean isTerminated();\n        //...          \n          \n    }\n```\n\n \n ### 不同线程池的使用\n\nCachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。\n\n ```java\n     ExecutorService exec = Executors.newCachedThreadPool();\n ```\n \n FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。\n \n ```java\n     ExecutorService exec = Executors.newFixedThreadPool(5); \n ```\n \n SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。\n \n ```java\n     Executors.newSingleThreadExecutor(); \n ```\n \n ### 任务的回调\n \n使用Callable和Future,一个产生结果，一个拿到结果\n \n每一个**Runnable**都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用**Callable**接口，而非**Runnable接口**。\n\nCallable接口带有`type`类型参数，该参数表示`call()`方法（非`run()`）方法执行完成后的返回值，必须通过调用` ExecutorService submit()`调用来执行。\n\n`submit()`方法返回一个一个Future对象，可以通过调用Future的`isDone()`方法来判断当前任务是否执行结束。调用Future的`get()`方法，如果当前任务没有结束，则会被阻塞，直至任务结束\n\n```java\n     class CallableResult implements Callable<String> {   \n        private int id;    \n        public TaskWithResult(int id) {     \n          this.id = id; \n         } \n           public String call() {    \n            return \"result\" + id;  \n           }\n        }\n        \n      public class CallableDemo {   \n        public static void main(String[] args) {   \n        ExecutorService exec = Executors.newCachedThreadPool();                    \n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();               \n         for(int i = 0; i < 10; i++)\n          results.add(exec.submit(new CallableResult(i)));  \n         for(Future<String> fs : results)     \n                try {               \n                   System.out.println(fs.get()); \n                } catch(InterruptedException e) {\n                    System.out.println(e);         \n                    return;      \n                } catch(ExecutionException e) {     \n                    System.out.println(e);      \n                } finally{        \n                     exec.shutdown(); \n                 } \n             } \n     }\n\n```\n\n### 任务的暂停\n\n通过调用`TimeUnit.MILLISECONDS.sleep(100);`来阻塞当前线程指定的时间。\n\n\n### 线程优先级\n \n JDK有十中不同的优先级。\n \n 线程优先级`Thread.MIN_PRIORIT`、`Thread.MAX_PRIORITY`，通过`setPriority()`方法进行设置，以及`getPriority()`方法进行获取。\n\n```\n     public void run() {Thread.currentThread().setPriority(priority);\n```\n\n\n### 守护线程Daemon threads \n\n守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在`thread.start();`之前调用`daemon.setDaemon(true)`;\n\n如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用`isDaemon()`方法进行查看是否为守护线程。\n\n\n\n### 数据共享\n\n#### synchronized关键字\n\n使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。\n```java\n\n    synchronized void f() { /* ... */ }\n```\n\n当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。\n\n在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。\n\n\n#### Lock对象的使用\n\n在调用`lock()`方法后，一定需要添加在`try-finally`的代码块，并在finally中调用`unlock()`方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在`try`代码块中实现，这样可以保证锁释放之前返回需要的值。***如果`lock.lock()`方法调用失败会出现什么情况***\n\n```\n     private Lock lock = new ReentrantLock();\n     int num=0;\n     \n     public int f(){\n        lock.lock();    \n        try {       \n             Thread.yield();   \n             return num++;    \n         }finally {      \n            lock.unlock();  \n        }   \n```\n当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。\n\n```java\n     boolean captured = false;    \n      try {      \n        captured = lock.tryLock(2, TimeUnit.SECONDS);   //限制请求次数\n        //captured = lock.tryLock();          //不限制请求次数\n       } catch(InterruptedException e) {      \n         throw new RuntimeException(e);     \n       } \n      try {       \n         System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured);    \n       } finally {     \n              if(captured)        \n              lock.unlock();    \n       }   \n\n```\n\n#### 原子性和波动性（Atomicity and Volality（易变的））\n原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是`synchronized`而非`volatile`。\n\n原子操作被应用于除`long`和`double`的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（`long`和`double`类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在`long`和`double`数据类型使用`volatile`关键字可以保证其操作的原子性。\n\n在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。\n\n当一个变量`volatile`关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。`volatile`关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。`volatile`关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。\n\n atomicity和volatility是两个不同的概念，原子性操作如果是非`volatile`类型的，那么其不会被立即刷到内存中；如果一个变量在一个` synchronized `的方法或者代码块中，那么变量也会被刷到内存中。\n\n\n#### Atomic classes （原子类）\n\n在Java SE 5中介绍了特殊的原子类：`Atomiclnteger`, `AtomicLong`, `AtomicReference`；对其操作时提供了原子类型的状态。\n\n#### 临界区\n\n在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。\n\n\n使用`synchronized`创建临界区\n```java\n     synchronized(syncObject) {  \n       // This code can be accessed \n      }\n    \n    \n    class PairManager2 extends PairManager { \n     public void increment() { \n         Pair temp;     \n         synchronized(this) {   \n             p.incrementX();    \n             p.incrementY();     \n             emp = getPair();   \n         }   \n         store(temp); \n        }\n    } \n   \n```\n\n使用功`Lock`锁创建临界区\n\n```java\n    class ExplicitPairManager2 extends PairManager {\n      private Lock lock = new ReentrantLock();  \n      public void increment() {    \n         Pair temp;     \n         lock.lock();    \n         try {     \n           p.incrementX();    \n           p.incrementY();     \n           temp = getPair();   \n           } finally {     \n             lock.unlock();   \n             }   \n           store(temp);  \n     } \n    }\n\n```\n\n\n\n\n\n\n\n\n \n ","source":"_posts/Java/Java多线程/Java多线程基础.md","raw":"### Runnable接口\n\n仅调用Runnable的`run()`方法不能产生一个新的线程，新线程的执行必须通过`Thread.start()`方法来执行。\n\n通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。\n\n实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。\n\nThread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。\n\n### Thread类\n\nThread类的构造函数需要Runnable实例，调用Thread类的`start()`方法，可以对线程进行必要额初始化，然后执行Runnable实例的`run()`方法。\n\n静态方法`Thread.yield()`用于通知CPU从一个线程切换至另外一个线程；\n\n**注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。**\n\n\n### 多线程框架Executor的使用\nExecutors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。\n\n ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。\n \n Executors中的`shutdown()`方法用于停止向Executor中提交新的任务，在`shutdown()`方法调用之前提交的同步线程任务则会继续执行。\n \n ***注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理***\n \n#### Executor、Executors、ExecutorService区别\n\n* Executor是一个接口，用于并发提交的任务，只有`execute()`一个方法，没有返回值，不能对任务进行任何操作。\n\n```java\n    public interface Executor {\n        void execute(Runnable var1);\n    }\n```\n\n* Executors类提供不同的工厂方法来创建不同类型的线程池，包括：`newSingleThreadExecutor()`、`newFixedThreadPool(int numOfThreads)`、`newCachedThreadPool()`\n\n```java\n\n    public class Executors {\n            //...\n            public static ExecutorService newFixedThreadPool(int var0) {\n            return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());\n        }\n        \n        //...\n    }\n\n```\n\n\n* ExecutorService 是继承自`Exxecutor`的接口，其中有异步执行和关闭线程池的方法。可以通过`submit()`方法来提交任务，同时可以对任务进行取消等操作。\n\n```java\n    public interface ExecutorService extends Executor {\n        //...\n        void shutdown();\n\n        List<Runnable> shutdownNow();\n\n        boolean isShutdown();\n\n        boolean isTerminated();\n        //...          \n          \n    }\n```\n\n \n ### 不同线程池的使用\n\nCachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。\n\n ```java\n     ExecutorService exec = Executors.newCachedThreadPool();\n ```\n \n FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。\n \n ```java\n     ExecutorService exec = Executors.newFixedThreadPool(5); \n ```\n \n SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。\n \n ```java\n     Executors.newSingleThreadExecutor(); \n ```\n \n ### 任务的回调\n \n使用Callable和Future,一个产生结果，一个拿到结果\n \n每一个**Runnable**都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用**Callable**接口，而非**Runnable接口**。\n\nCallable接口带有`type`类型参数，该参数表示`call()`方法（非`run()`）方法执行完成后的返回值，必须通过调用` ExecutorService submit()`调用来执行。\n\n`submit()`方法返回一个一个Future对象，可以通过调用Future的`isDone()`方法来判断当前任务是否执行结束。调用Future的`get()`方法，如果当前任务没有结束，则会被阻塞，直至任务结束\n\n```java\n     class CallableResult implements Callable<String> {   \n        private int id;    \n        public TaskWithResult(int id) {     \n          this.id = id; \n         } \n           public String call() {    \n            return \"result\" + id;  \n           }\n        }\n        \n      public class CallableDemo {   \n        public static void main(String[] args) {   \n        ExecutorService exec = Executors.newCachedThreadPool();                    \n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();               \n         for(int i = 0; i < 10; i++)\n          results.add(exec.submit(new CallableResult(i)));  \n         for(Future<String> fs : results)     \n                try {               \n                   System.out.println(fs.get()); \n                } catch(InterruptedException e) {\n                    System.out.println(e);         \n                    return;      \n                } catch(ExecutionException e) {     \n                    System.out.println(e);      \n                } finally{        \n                     exec.shutdown(); \n                 } \n             } \n     }\n\n```\n\n### 任务的暂停\n\n通过调用`TimeUnit.MILLISECONDS.sleep(100);`来阻塞当前线程指定的时间。\n\n\n### 线程优先级\n \n JDK有十中不同的优先级。\n \n 线程优先级`Thread.MIN_PRIORIT`、`Thread.MAX_PRIORITY`，通过`setPriority()`方法进行设置，以及`getPriority()`方法进行获取。\n\n```\n     public void run() {Thread.currentThread().setPriority(priority);\n```\n\n\n### 守护线程Daemon threads \n\n守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在`thread.start();`之前调用`daemon.setDaemon(true)`;\n\n如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用`isDaemon()`方法进行查看是否为守护线程。\n\n\n\n### 数据共享\n\n#### synchronized关键字\n\n使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。\n```java\n\n    synchronized void f() { /* ... */ }\n```\n\n当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。\n\n在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。\n\n\n#### Lock对象的使用\n\n在调用`lock()`方法后，一定需要添加在`try-finally`的代码块，并在finally中调用`unlock()`方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在`try`代码块中实现，这样可以保证锁释放之前返回需要的值。***如果`lock.lock()`方法调用失败会出现什么情况***\n\n```\n     private Lock lock = new ReentrantLock();\n     int num=0;\n     \n     public int f(){\n        lock.lock();    \n        try {       \n             Thread.yield();   \n             return num++;    \n         }finally {      \n            lock.unlock();  \n        }   \n```\n当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。\n\n```java\n     boolean captured = false;    \n      try {      \n        captured = lock.tryLock(2, TimeUnit.SECONDS);   //限制请求次数\n        //captured = lock.tryLock();          //不限制请求次数\n       } catch(InterruptedException e) {      \n         throw new RuntimeException(e);     \n       } \n      try {       \n         System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured);    \n       } finally {     \n              if(captured)        \n              lock.unlock();    \n       }   \n\n```\n\n#### 原子性和波动性（Atomicity and Volality（易变的））\n原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是`synchronized`而非`volatile`。\n\n原子操作被应用于除`long`和`double`的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（`long`和`double`类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在`long`和`double`数据类型使用`volatile`关键字可以保证其操作的原子性。\n\n在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。\n\n当一个变量`volatile`关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。`volatile`关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。`volatile`关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。\n\n atomicity和volatility是两个不同的概念，原子性操作如果是非`volatile`类型的，那么其不会被立即刷到内存中；如果一个变量在一个` synchronized `的方法或者代码块中，那么变量也会被刷到内存中。\n\n\n#### Atomic classes （原子类）\n\n在Java SE 5中介绍了特殊的原子类：`Atomiclnteger`, `AtomicLong`, `AtomicReference`；对其操作时提供了原子类型的状态。\n\n#### 临界区\n\n在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。\n\n\n使用`synchronized`创建临界区\n```java\n     synchronized(syncObject) {  \n       // This code can be accessed \n      }\n    \n    \n    class PairManager2 extends PairManager { \n     public void increment() { \n         Pair temp;     \n         synchronized(this) {   \n             p.incrementX();    \n             p.incrementY();     \n             emp = getPair();   \n         }   \n         store(temp); \n        }\n    } \n   \n```\n\n使用功`Lock`锁创建临界区\n\n```java\n    class ExplicitPairManager2 extends PairManager {\n      private Lock lock = new ReentrantLock();  \n      public void increment() {    \n         Pair temp;     \n         lock.lock();    \n         try {     \n           p.incrementX();    \n           p.incrementY();     \n           temp = getPair();   \n           } finally {     \n             lock.unlock();   \n             }   \n           store(temp);  \n     } \n    }\n\n```\n\n\n\n\n\n\n\n\n \n ","slug":"Java/Java多线程/Java多线程基础","published":1,"date":"2019-09-19T09:41:14.776Z","updated":"2019-09-30T08:28:42.974Z","title":"Java/Java多线程/Java多线程基础","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi1003kisui3ldgfxj4","content":"<h3 id=\"Runnable接口\"><a href=\"#Runnable接口\" class=\"headerlink\" title=\"Runnable接口\"></a>Runnable接口</h3><p>仅调用Runnable的<code>run()</code>方法不能产生一个新的线程，新线程的执行必须通过<code>Thread.start()</code>方法来执行。</p>\n<p>通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。</p>\n<p>实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。</p>\n<p>Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p>Thread类的构造函数需要Runnable实例，调用Thread类的<code>start()</code>方法，可以对线程进行必要额初始化，然后执行Runnable实例的<code>run()</code>方法。</p>\n<p>静态方法<code>Thread.yield()</code>用于通知CPU从一个线程切换至另外一个线程；</p>\n<p><strong>注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</strong></p>\n<h3 id=\"多线程框架Executor的使用\"><a href=\"#多线程框架Executor的使用\" class=\"headerlink\" title=\"多线程框架Executor的使用\"></a>多线程框架Executor的使用</h3><p>Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。</p>\n<p> ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。</p>\n<p> Executors中的<code>shutdown()</code>方法用于停止向Executor中提交新的任务，在<code>shutdown()</code>方法调用之前提交的同步线程任务则会继续执行。</p>\n<p> <strong><em>注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理</em></strong></p>\n<h4 id=\"Executor、Executors、ExecutorService区别\"><a href=\"#Executor、Executors、ExecutorService区别\" class=\"headerlink\" title=\"Executor、Executors、ExecutorService区别\"></a>Executor、Executors、ExecutorService区别</h4><ul>\n<li>Executor是一个接口，用于并发提交的任务，只有<code>execute()</code>一个方法，没有返回值，不能对任务进行任何操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Executors类提供不同的工厂方法来创建不同类型的线程池，包括：<code>newSingleThreadExecutor()</code>、<code>newFixedThreadPool(int numOfThreads)</code>、<code>newCachedThreadPool()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Executors</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(var0, var0, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>ExecutorService 是继承自<code>Exxecutor</code>的接口，其中有异步执行和关闭线程池的方法。可以通过<code>submit()</code>方法来提交任务，同时可以对任务进行取消等操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//...          </span></span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"不同线程池的使用\"><a href=\"#不同线程池的使用\" class=\"headerlink\" title=\"不同线程池的使用\"></a>不同线程池的使用</h3><p>CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p> FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p> SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的回调\"><a href=\"#任务的回调\" class=\"headerlink\" title=\"任务的回调\"></a>任务的回调</h3><p>使用Callable和Future,一个产生结果，一个拿到结果</p>\n<p>每一个<strong>Runnable</strong>都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用<strong>Callable</strong>接口，而非<strong>Runnable接口</strong>。</p>\n<p>Callable接口带有<code>type</code>类型参数，该参数表示<code>call()</code>方法（非<code>run()</code>）方法执行完成后的返回值，必须通过调用<code>ExecutorService submit()</code>调用来执行。</p>\n<p><code>submit()</code>方法返回一个一个Future对象，可以通过调用Future的<code>isDone()</code>方法来判断当前任务是否执行结束。调用Future的<code>get()</code>方法，如果当前任务没有结束，则会被阻塞，直至任务结束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"result\"</span> + id;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;   </span><br><span class=\"line\">   ExecutorService exec = Executors.newCachedThreadPool();                    </span><br><span class=\"line\">   ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();               </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">     results.add(exec.submit(<span class=\"keyword\">new</span> CallableResult(i)));  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Future&lt;String&gt; fs : results)     </span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;               </span><br><span class=\"line\">              System.out.println(fs.get()); </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">               System.out.println(e);         </span><br><span class=\"line\">               <span class=\"keyword\">return</span>;      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(ExecutionException e) &#123;     </span><br><span class=\"line\">               System.out.println(e);      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span>&#123;        </span><br><span class=\"line\">                exec.shutdown(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的暂停\"><a href=\"#任务的暂停\" class=\"headerlink\" title=\"任务的暂停\"></a>任务的暂停</h3><p>通过调用<code>TimeUnit.MILLISECONDS.sleep(100);</code>来阻塞当前线程指定的时间。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p> JDK有十中不同的优先级。</p>\n<p> 线程优先级<code>Thread.MIN_PRIORIT</code>、<code>Thread.MAX_PRIORITY</code>，通过<code>setPriority()</code>方法进行设置，以及<code>getPriority()</code>方法进行获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;Thread.currentThread().setPriority(priority);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"守护线程Daemon-threads\"><a href=\"#守护线程Daemon-threads\" class=\"headerlink\" title=\"守护线程Daemon threads\"></a>守护线程Daemon threads</h3><p>守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在<code>thread.start();</code>之前调用<code>daemon.setDaemon(true)</code>;</p>\n<p>如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用<code>isDaemon()</code>方法进行查看是否为守护线程。</p>\n<h3 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h3><h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。</p>\n<p>在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。</p>\n<h4 id=\"Lock对象的使用\"><a href=\"#Lock对象的使用\" class=\"headerlink\" title=\"Lock对象的使用\"></a>Lock对象的使用</h4><p>在调用<code>lock()</code>方法后，一定需要添加在<code>try-finally</code>的代码块，并在finally中调用<code>unlock()</code>方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在<code>try</code>代码块中实现，这样可以保证锁释放之前返回需要的值。<strong><em>如果<code>lock.lock()</code>方法调用失败会出现什么情况</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Lock lock &#x3D; new ReentrantLock();</span><br><span class=\"line\">int num&#x3D;0;</span><br><span class=\"line\"></span><br><span class=\"line\">public int f()&#123;</span><br><span class=\"line\">   lock.lock();    </span><br><span class=\"line\">   try &#123;       </span><br><span class=\"line\">        Thread.yield();   </span><br><span class=\"line\">        return num++;    </span><br><span class=\"line\">    &#125;finally &#123;      </span><br><span class=\"line\">       lock.unlock();  </span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;    </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;      </span><br><span class=\"line\">   captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);   <span class=\"comment\">//限制请求次数</span></span><br><span class=\"line\">   <span class=\"comment\">//captured = lock.tryLock();          //不限制请求次数</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);     </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;       </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"tryLock(2, TimeUnit.SECONDS): \"</span> + captured);    </span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         <span class=\"keyword\">if</span>(captured)        </span><br><span class=\"line\">         lock.unlock();    </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原子性和波动性（Atomicity-and-Volality（易变的））\"><a href=\"#原子性和波动性（Atomicity-and-Volality（易变的））\" class=\"headerlink\" title=\"原子性和波动性（Atomicity and Volality（易变的））\"></a>原子性和波动性（Atomicity and Volality（易变的））</h4><p>原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是<code>synchronized</code>而非<code>volatile</code>。</p>\n<p>原子操作被应用于除<code>long</code>和<code>double</code>的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（<code>long</code>和<code>double</code>类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在<code>long</code>和<code>double</code>数据类型使用<code>volatile</code>关键字可以保证其操作的原子性。</p>\n<p>在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。</p>\n<p>当一个变量<code>volatile</code>关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。<code>volatile</code>关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。<code>volatile</code>关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。</p>\n<p> atomicity和volatility是两个不同的概念，原子性操作如果是非<code>volatile</code>类型的，那么其不会被立即刷到内存中；如果一个变量在一个<code>synchronized</code>的方法或者代码块中，那么变量也会被刷到内存中。</p>\n<h4 id=\"Atomic-classes-（原子类）\"><a href=\"#Atomic-classes-（原子类）\" class=\"headerlink\" title=\"Atomic classes （原子类）\"></a>Atomic classes （原子类）</h4><p>在Java SE 5中介绍了特殊的原子类：<code>Atomiclnteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>；对其操作时提供了原子类型的状态。</p>\n<h4 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h4><p>在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。</p>\n<p>使用<code>synchronized</code>创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">synchronized</span>(syncObject) &#123;  </span><br><span class=\"line\">   <span class=\"comment\">// This code can be accessed </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;   </span><br><span class=\"line\">         p.incrementX();    </span><br><span class=\"line\">         p.incrementY();     </span><br><span class=\"line\">         emp = getPair();   </span><br><span class=\"line\">     &#125;   </span><br><span class=\"line\">     store(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用功<code>Lock</code>锁创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExplicitPairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     lock.lock();    </span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;     </span><br><span class=\"line\">       p.incrementX();    </span><br><span class=\"line\">       p.incrementY();     </span><br><span class=\"line\">       temp = getPair();   </span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         lock.unlock();   </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">       store(temp);  </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Runnable接口\"><a href=\"#Runnable接口\" class=\"headerlink\" title=\"Runnable接口\"></a>Runnable接口</h3><p>仅调用Runnable的<code>run()</code>方法不能产生一个新的线程，新线程的执行必须通过<code>Thread.start()</code>方法来执行。</p>\n<p>通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。</p>\n<p>实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。</p>\n<p>Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p>Thread类的构造函数需要Runnable实例，调用Thread类的<code>start()</code>方法，可以对线程进行必要额初始化，然后执行Runnable实例的<code>run()</code>方法。</p>\n<p>静态方法<code>Thread.yield()</code>用于通知CPU从一个线程切换至另外一个线程；</p>\n<p><strong>注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</strong></p>\n<h3 id=\"多线程框架Executor的使用\"><a href=\"#多线程框架Executor的使用\" class=\"headerlink\" title=\"多线程框架Executor的使用\"></a>多线程框架Executor的使用</h3><p>Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。</p>\n<p> ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。</p>\n<p> Executors中的<code>shutdown()</code>方法用于停止向Executor中提交新的任务，在<code>shutdown()</code>方法调用之前提交的同步线程任务则会继续执行。</p>\n<p> <strong><em>注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理</em></strong></p>\n<h4 id=\"Executor、Executors、ExecutorService区别\"><a href=\"#Executor、Executors、ExecutorService区别\" class=\"headerlink\" title=\"Executor、Executors、ExecutorService区别\"></a>Executor、Executors、ExecutorService区别</h4><ul>\n<li>Executor是一个接口，用于并发提交的任务，只有<code>execute()</code>一个方法，没有返回值，不能对任务进行任何操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Executors类提供不同的工厂方法来创建不同类型的线程池，包括：<code>newSingleThreadExecutor()</code>、<code>newFixedThreadPool(int numOfThreads)</code>、<code>newCachedThreadPool()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Executors</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(var0, var0, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>ExecutorService 是继承自<code>Exxecutor</code>的接口，其中有异步执行和关闭线程池的方法。可以通过<code>submit()</code>方法来提交任务，同时可以对任务进行取消等操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//...          </span></span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"不同线程池的使用\"><a href=\"#不同线程池的使用\" class=\"headerlink\" title=\"不同线程池的使用\"></a>不同线程池的使用</h3><p>CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p> FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p> SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的回调\"><a href=\"#任务的回调\" class=\"headerlink\" title=\"任务的回调\"></a>任务的回调</h3><p>使用Callable和Future,一个产生结果，一个拿到结果</p>\n<p>每一个<strong>Runnable</strong>都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用<strong>Callable</strong>接口，而非<strong>Runnable接口</strong>。</p>\n<p>Callable接口带有<code>type</code>类型参数，该参数表示<code>call()</code>方法（非<code>run()</code>）方法执行完成后的返回值，必须通过调用<code>ExecutorService submit()</code>调用来执行。</p>\n<p><code>submit()</code>方法返回一个一个Future对象，可以通过调用Future的<code>isDone()</code>方法来判断当前任务是否执行结束。调用Future的<code>get()</code>方法，如果当前任务没有结束，则会被阻塞，直至任务结束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"result\"</span> + id;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;   </span><br><span class=\"line\">   ExecutorService exec = Executors.newCachedThreadPool();                    </span><br><span class=\"line\">   ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();               </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">     results.add(exec.submit(<span class=\"keyword\">new</span> CallableResult(i)));  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Future&lt;String&gt; fs : results)     </span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;               </span><br><span class=\"line\">              System.out.println(fs.get()); </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">               System.out.println(e);         </span><br><span class=\"line\">               <span class=\"keyword\">return</span>;      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(ExecutionException e) &#123;     </span><br><span class=\"line\">               System.out.println(e);      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span>&#123;        </span><br><span class=\"line\">                exec.shutdown(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的暂停\"><a href=\"#任务的暂停\" class=\"headerlink\" title=\"任务的暂停\"></a>任务的暂停</h3><p>通过调用<code>TimeUnit.MILLISECONDS.sleep(100);</code>来阻塞当前线程指定的时间。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p> JDK有十中不同的优先级。</p>\n<p> 线程优先级<code>Thread.MIN_PRIORIT</code>、<code>Thread.MAX_PRIORITY</code>，通过<code>setPriority()</code>方法进行设置，以及<code>getPriority()</code>方法进行获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;Thread.currentThread().setPriority(priority);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"守护线程Daemon-threads\"><a href=\"#守护线程Daemon-threads\" class=\"headerlink\" title=\"守护线程Daemon threads\"></a>守护线程Daemon threads</h3><p>守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在<code>thread.start();</code>之前调用<code>daemon.setDaemon(true)</code>;</p>\n<p>如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用<code>isDaemon()</code>方法进行查看是否为守护线程。</p>\n<h3 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h3><h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。</p>\n<p>在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。</p>\n<h4 id=\"Lock对象的使用\"><a href=\"#Lock对象的使用\" class=\"headerlink\" title=\"Lock对象的使用\"></a>Lock对象的使用</h4><p>在调用<code>lock()</code>方法后，一定需要添加在<code>try-finally</code>的代码块，并在finally中调用<code>unlock()</code>方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在<code>try</code>代码块中实现，这样可以保证锁释放之前返回需要的值。<strong><em>如果<code>lock.lock()</code>方法调用失败会出现什么情况</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Lock lock &#x3D; new ReentrantLock();</span><br><span class=\"line\">int num&#x3D;0;</span><br><span class=\"line\"></span><br><span class=\"line\">public int f()&#123;</span><br><span class=\"line\">   lock.lock();    </span><br><span class=\"line\">   try &#123;       </span><br><span class=\"line\">        Thread.yield();   </span><br><span class=\"line\">        return num++;    </span><br><span class=\"line\">    &#125;finally &#123;      </span><br><span class=\"line\">       lock.unlock();  </span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;    </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;      </span><br><span class=\"line\">   captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);   <span class=\"comment\">//限制请求次数</span></span><br><span class=\"line\">   <span class=\"comment\">//captured = lock.tryLock();          //不限制请求次数</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);     </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;       </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"tryLock(2, TimeUnit.SECONDS): \"</span> + captured);    </span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         <span class=\"keyword\">if</span>(captured)        </span><br><span class=\"line\">         lock.unlock();    </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原子性和波动性（Atomicity-and-Volality（易变的））\"><a href=\"#原子性和波动性（Atomicity-and-Volality（易变的））\" class=\"headerlink\" title=\"原子性和波动性（Atomicity and Volality（易变的））\"></a>原子性和波动性（Atomicity and Volality（易变的））</h4><p>原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是<code>synchronized</code>而非<code>volatile</code>。</p>\n<p>原子操作被应用于除<code>long</code>和<code>double</code>的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（<code>long</code>和<code>double</code>类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在<code>long</code>和<code>double</code>数据类型使用<code>volatile</code>关键字可以保证其操作的原子性。</p>\n<p>在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。</p>\n<p>当一个变量<code>volatile</code>关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。<code>volatile</code>关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。<code>volatile</code>关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。</p>\n<p> atomicity和volatility是两个不同的概念，原子性操作如果是非<code>volatile</code>类型的，那么其不会被立即刷到内存中；如果一个变量在一个<code>synchronized</code>的方法或者代码块中，那么变量也会被刷到内存中。</p>\n<h4 id=\"Atomic-classes-（原子类）\"><a href=\"#Atomic-classes-（原子类）\" class=\"headerlink\" title=\"Atomic classes （原子类）\"></a>Atomic classes （原子类）</h4><p>在Java SE 5中介绍了特殊的原子类：<code>Atomiclnteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>；对其操作时提供了原子类型的状态。</p>\n<h4 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h4><p>在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。</p>\n<p>使用<code>synchronized</code>创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">synchronized</span>(syncObject) &#123;  </span><br><span class=\"line\">   <span class=\"comment\">// This code can be accessed </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;   </span><br><span class=\"line\">         p.incrementX();    </span><br><span class=\"line\">         p.incrementY();     </span><br><span class=\"line\">         emp = getPair();   </span><br><span class=\"line\">     &#125;   </span><br><span class=\"line\">     store(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用功<code>Lock</code>锁创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExplicitPairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     lock.lock();    </span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;     </span><br><span class=\"line\">       p.incrementX();    </span><br><span class=\"line\">       p.incrementY();     </span><br><span class=\"line\">       temp = getPair();   </span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         lock.unlock();   </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">       store(temp);  </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n"},{"_content":"# 线程间通信\n\n* 使用单向管道（Pipe）传递数据\n* 共享内存（Shared Memory）通信\n* 使用阻塞队列（Blocking Queue）实现生产者-消费者模式\n* 处理消息队列（Message Queue）\n\n\n## wait/notify机制\n\n等待/通知机制主要由Object类中的三个方法进行保证\n\n1、wait()；notify();notifyAll()\n上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；`wait();notify();notifyAll()`只有在被`synchronized `修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出`IllegalMonitorStateException`异常。\n\n1)wait()\n让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用`notify()`或者`notifyAll()`时唤醒当前线程。`wait()`也可以作为任务同步的一种方式。\n\n**注：调用`sleep()`和`yield()`方法不能释放当前的对象锁**\n`wait()`方法有两种用法：\n* ` wait(long timeout)`等待一定的时间，但与`sleep()`方法不同，其会释放对象锁\n* 使用`wait()`等待`notify()`或者`notifyAll()`唤醒。 \n\n\n2)notify()\n唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；\n\n3)notifyAll()\n唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过`synchronized(x)`来获取对象锁。\n\n```java\n     synchronized(x) { \n       x.notifyAll();\n     }\n\n```\n\n\n2、方法调用与线程状态关系\n\n每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列\n\n## Condition\n\nCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；\n\n对应关系\n\n* Condition中的await()对应Object的wait()\n* Condition中的signal()对应Object的notify()\n* Condition中的signalAll()对应Object中的notifyAll();\n\n**Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同**\n\n### 生产者消费者模型\n\n线程锁控制代码\n```java\npublic class Service {\n\n    //线程锁\n    private ReentrantLock lock=new ReentrantLock();\n    //生产者线程控制\n    private Condition conditionCustomer=lock.newCondition();\n    //消费者线程控制\n    private Condition conditionProducer=lock.newCondition();\n    //用于表示需要生产\n    private boolean hasValue=false;\n    //用于随机消费时间；\n    private static Random rand = new Random(2000);\n\n    //用于生产者\n    public void produce(){\n        try {\n            lock.lock();\n            while (hasValue){\n                System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionCustomer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\");\n            Thread.sleep(rand.nextInt(500));\n            hasValue=true;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的消费者线程\n            conditionProducer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //用于消费者\n    public void custome(){\n        try{\n            lock.lock();\n            while (!hasValue){\n                System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionProducer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\");\n            Thread.sleep(rand.nextInt(4000));\n            hasValue=false;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的生产者线程\n            conditionCustomer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n消费者线程\n\n```java\npublic class CustomerThread extends Thread {\n\n    private Service service;\n    public CustomerThread(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        while (true){\n            service.custome();\n        }\n    }\n}\n\n```\n测试代码\n```java\n\npublic class Customer_ServiceMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n        CustomerThread[] customerThread=new CustomerThread[10];\n        ProducerThread[] producerThreads=new ProducerThread[10];\n        for (int i=0;i<3;i++){\n            customerThread[i]=new CustomerThread(service);\n            customerThread[i].setName(\"生产者Thread：\"+i);\n            producerThreads[i]=new ProducerThread(service);\n            producerThreads[i].setName(\"消费者Thread：\"+i);\n            customerThread[i].start();\n            producerThreads[i].start();\n\n        }\n    }\n    }\n\n```\n\n运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。\n\n```xml\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：2await\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：2await\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n\n```\n\n\n### 线程间通信管道模式\n\n#### CountDownLatch的使用\n\n用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。\n\n任务执行线程\n```java\n    public class Task extends Thread {\n\n    private static Random random = new Random(100);\n\n    private final CountDownLatch latch;\n\n    //使用CountDownLatch会被自动要求加上此构造函数\n    public Task(CountDownLatch latch, String name) {\n        this.latch = latch;\n        this.setName(name);\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            doWork();\n            //用于倒数技术\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doWork() throws InterruptedException {\n        //random.nextInt(2000)在Java中是线程安全的来自TIJ\n        TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));\n        System.out.println(this.getName() + \"completed\");\n    }\n}\n```\n等待任务执行完毕，需要唤醒的线程\n```java\n  public class WaitingTask implements Runnable {\n    \n    private final CountDownLatch latch;\n\n    public WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            latch.await();\n            System.out.println(\"Latch阻塞运行至waiting class\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n\n```\n测试代码\n```java\npublic class TestCountDown {\n\n    static final int SIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n\n        ExecutorService exec = Executors.newFixedThreadPool(5);\n        //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数\n        CountDownLatch latch = new CountDownLatch(SIZE);\n      // for (int i=0;i<10;i++){   //可以有多个等待线程\n        exec.execute(new WaitingTask(latch));\n      // }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new Task(latch,\"线程\"+i));\n        }\n        System.out.println(\"启动所有任务\");\n        exec.shutdown();  //任务只有在执行完毕后才会结束\n    }\n}\n\n```\n任务执行结果\n```xml\n启动所有任务\n线程0completed\n线程4completed\n线程1completed\n线程2completed\n线程3completed\nLatch阻塞运行至waiting class\n\nProcess finished with exit code 0\n\n```\n\n\n#### CyclicBarrier的使用\n\n`CyclicBarrier`类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于`join`)，与`CountDownLatch`类的使用类似，`CountDownLatch`类只能执行一次，而`CyclicBarrier`可以进行多次使用。\n以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；\n\n运动员代码\n```java\n\npublic class Athlete extends Thread {\n\n    //用于表示耗时\n    private double time =90;\n\n    private static Random rand = new Random(1);\n\n    private static CyclicBarrier cyclicBarrier;\n\n    public Athlete(CyclicBarrier cyclicBarrier){\n        this.cyclicBarrier=cyclicBarrier;\n    }\n\n    public synchronized double getTime(){\n        return time;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()){\n                synchronized (this){\n                    time =(double)(rand.nextInt(20)+90)/10;\n                    System.out.println(getName()+\"跑步耗时：\"+ getTime());\n                }\n                Thread.sleep(1000);\n                cyclicBarrier.await();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n所有运动员跑完标志输出代码\n\n```java\npublic class RunningCtrl extends Thread{\n\n    public RunningCtrl(){\n\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n    }\n}\n\n```\n\n测试代码\n\n```java\npublic class CyclicBarrierMain {\n\n    public static void main(String[] args) {\n\n        RunningCtrl  runningCtrl=new RunningCtrl();\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i <5; i++) {\n            Athlete athlete = new Athlete(cyclicBarrier);\n            athlete.setName(\"选手：\"+i);\n            exec.execute(athlete);\n        }\n    }\n}\n\n```\n\n运行结果\n```xml\n\n选手：0跑步耗时：9.5\n选手：1跑步耗时：9.8\n选手：4跑步耗时：10.4\n选手：2跑步耗时：9.7\n选手：3跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：0跑步耗时：10.4\n选手：2跑步耗时：9.8\n选手：1跑步耗时：9.6\n选手：4跑步耗时：9.4\n选手：3跑步耗时：10.8\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：9.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：9.2\n选手：2跑步耗时：9.3\n选手：0跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：1跑步耗时：10.4\n选手：2跑步耗时：9.2\n选手：0跑步耗时：9.9\n选手：3跑步耗时：10.2\n选手：4跑步耗时：10.6\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：10.2\n选手：2跑步耗时：10.9\n选手：0跑步耗时：10.6\n选手：3跑步耗时：10.0\n选手：1跑步耗时：10.4\n++++++++++++++++++++++++++++++++\n选手：2跑步耗时：10.8\n选手：4跑步耗时：10.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：10.3\n选手：0跑步耗时：9.2\n++++++++++++++++++++++++++++++++\n```\n\n#### `DelayQueue`的使用\n\n`DelayQueue`是一个无界的阻塞队列，实现`Delayed`接口。只有当`delay`被激发时，该对象才能从队列中获取数据\n\n\n\n### 线程间通信管道模式\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java多线程/Java线程间通信.md","raw":"# 线程间通信\n\n* 使用单向管道（Pipe）传递数据\n* 共享内存（Shared Memory）通信\n* 使用阻塞队列（Blocking Queue）实现生产者-消费者模式\n* 处理消息队列（Message Queue）\n\n\n## wait/notify机制\n\n等待/通知机制主要由Object类中的三个方法进行保证\n\n1、wait()；notify();notifyAll()\n上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；`wait();notify();notifyAll()`只有在被`synchronized `修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出`IllegalMonitorStateException`异常。\n\n1)wait()\n让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用`notify()`或者`notifyAll()`时唤醒当前线程。`wait()`也可以作为任务同步的一种方式。\n\n**注：调用`sleep()`和`yield()`方法不能释放当前的对象锁**\n`wait()`方法有两种用法：\n* ` wait(long timeout)`等待一定的时间，但与`sleep()`方法不同，其会释放对象锁\n* 使用`wait()`等待`notify()`或者`notifyAll()`唤醒。 \n\n\n2)notify()\n唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；\n\n3)notifyAll()\n唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过`synchronized(x)`来获取对象锁。\n\n```java\n     synchronized(x) { \n       x.notifyAll();\n     }\n\n```\n\n\n2、方法调用与线程状态关系\n\n每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列\n\n## Condition\n\nCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；\n\n对应关系\n\n* Condition中的await()对应Object的wait()\n* Condition中的signal()对应Object的notify()\n* Condition中的signalAll()对应Object中的notifyAll();\n\n**Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同**\n\n### 生产者消费者模型\n\n线程锁控制代码\n```java\npublic class Service {\n\n    //线程锁\n    private ReentrantLock lock=new ReentrantLock();\n    //生产者线程控制\n    private Condition conditionCustomer=lock.newCondition();\n    //消费者线程控制\n    private Condition conditionProducer=lock.newCondition();\n    //用于表示需要生产\n    private boolean hasValue=false;\n    //用于随机消费时间；\n    private static Random rand = new Random(2000);\n\n    //用于生产者\n    public void produce(){\n        try {\n            lock.lock();\n            while (hasValue){\n                System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionCustomer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\");\n            Thread.sleep(rand.nextInt(500));\n            hasValue=true;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的消费者线程\n            conditionProducer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //用于消费者\n    public void custome(){\n        try{\n            lock.lock();\n            while (!hasValue){\n                System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionProducer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\");\n            Thread.sleep(rand.nextInt(4000));\n            hasValue=false;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的生产者线程\n            conditionCustomer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n消费者线程\n\n```java\npublic class CustomerThread extends Thread {\n\n    private Service service;\n    public CustomerThread(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        while (true){\n            service.custome();\n        }\n    }\n}\n\n```\n测试代码\n```java\n\npublic class Customer_ServiceMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n        CustomerThread[] customerThread=new CustomerThread[10];\n        ProducerThread[] producerThreads=new ProducerThread[10];\n        for (int i=0;i<3;i++){\n            customerThread[i]=new CustomerThread(service);\n            customerThread[i].setName(\"生产者Thread：\"+i);\n            producerThreads[i]=new ProducerThread(service);\n            producerThreads[i].setName(\"消费者Thread：\"+i);\n            customerThread[i].start();\n            producerThreads[i].start();\n\n        }\n    }\n    }\n\n```\n\n运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。\n\n```xml\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：2await\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：2await\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n\n```\n\n\n### 线程间通信管道模式\n\n#### CountDownLatch的使用\n\n用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。\n\n任务执行线程\n```java\n    public class Task extends Thread {\n\n    private static Random random = new Random(100);\n\n    private final CountDownLatch latch;\n\n    //使用CountDownLatch会被自动要求加上此构造函数\n    public Task(CountDownLatch latch, String name) {\n        this.latch = latch;\n        this.setName(name);\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            doWork();\n            //用于倒数技术\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doWork() throws InterruptedException {\n        //random.nextInt(2000)在Java中是线程安全的来自TIJ\n        TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));\n        System.out.println(this.getName() + \"completed\");\n    }\n}\n```\n等待任务执行完毕，需要唤醒的线程\n```java\n  public class WaitingTask implements Runnable {\n    \n    private final CountDownLatch latch;\n\n    public WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            latch.await();\n            System.out.println(\"Latch阻塞运行至waiting class\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n\n```\n测试代码\n```java\npublic class TestCountDown {\n\n    static final int SIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n\n        ExecutorService exec = Executors.newFixedThreadPool(5);\n        //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数\n        CountDownLatch latch = new CountDownLatch(SIZE);\n      // for (int i=0;i<10;i++){   //可以有多个等待线程\n        exec.execute(new WaitingTask(latch));\n      // }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new Task(latch,\"线程\"+i));\n        }\n        System.out.println(\"启动所有任务\");\n        exec.shutdown();  //任务只有在执行完毕后才会结束\n    }\n}\n\n```\n任务执行结果\n```xml\n启动所有任务\n线程0completed\n线程4completed\n线程1completed\n线程2completed\n线程3completed\nLatch阻塞运行至waiting class\n\nProcess finished with exit code 0\n\n```\n\n\n#### CyclicBarrier的使用\n\n`CyclicBarrier`类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于`join`)，与`CountDownLatch`类的使用类似，`CountDownLatch`类只能执行一次，而`CyclicBarrier`可以进行多次使用。\n以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；\n\n运动员代码\n```java\n\npublic class Athlete extends Thread {\n\n    //用于表示耗时\n    private double time =90;\n\n    private static Random rand = new Random(1);\n\n    private static CyclicBarrier cyclicBarrier;\n\n    public Athlete(CyclicBarrier cyclicBarrier){\n        this.cyclicBarrier=cyclicBarrier;\n    }\n\n    public synchronized double getTime(){\n        return time;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()){\n                synchronized (this){\n                    time =(double)(rand.nextInt(20)+90)/10;\n                    System.out.println(getName()+\"跑步耗时：\"+ getTime());\n                }\n                Thread.sleep(1000);\n                cyclicBarrier.await();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n所有运动员跑完标志输出代码\n\n```java\npublic class RunningCtrl extends Thread{\n\n    public RunningCtrl(){\n\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n    }\n}\n\n```\n\n测试代码\n\n```java\npublic class CyclicBarrierMain {\n\n    public static void main(String[] args) {\n\n        RunningCtrl  runningCtrl=new RunningCtrl();\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i <5; i++) {\n            Athlete athlete = new Athlete(cyclicBarrier);\n            athlete.setName(\"选手：\"+i);\n            exec.execute(athlete);\n        }\n    }\n}\n\n```\n\n运行结果\n```xml\n\n选手：0跑步耗时：9.5\n选手：1跑步耗时：9.8\n选手：4跑步耗时：10.4\n选手：2跑步耗时：9.7\n选手：3跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：0跑步耗时：10.4\n选手：2跑步耗时：9.8\n选手：1跑步耗时：9.6\n选手：4跑步耗时：9.4\n选手：3跑步耗时：10.8\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：9.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：9.2\n选手：2跑步耗时：9.3\n选手：0跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：1跑步耗时：10.4\n选手：2跑步耗时：9.2\n选手：0跑步耗时：9.9\n选手：3跑步耗时：10.2\n选手：4跑步耗时：10.6\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：10.2\n选手：2跑步耗时：10.9\n选手：0跑步耗时：10.6\n选手：3跑步耗时：10.0\n选手：1跑步耗时：10.4\n++++++++++++++++++++++++++++++++\n选手：2跑步耗时：10.8\n选手：4跑步耗时：10.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：10.3\n选手：0跑步耗时：9.2\n++++++++++++++++++++++++++++++++\n```\n\n#### `DelayQueue`的使用\n\n`DelayQueue`是一个无界的阻塞队列，实现`Delayed`接口。只有当`delay`被激发时，该对象才能从队列中获取数据\n\n\n\n### 线程间通信管道模式\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/Java多线程/Java线程间通信","published":1,"date":"2019-09-19T09:41:14.777Z","updated":"2019-09-30T08:28:42.975Z","title":"Java/Java多线程/Java线程间通信","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi2003lisui3lyq1w95","content":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><ul>\n<li>使用单向管道（Pipe）传递数据</li>\n<li>共享内存（Shared Memory）通信</li>\n<li>使用阻塞队列（Blocking Queue）实现生产者-消费者模式</li>\n<li>处理消息队列（Message Queue）</li>\n</ul>\n<h2 id=\"wait-notify机制\"><a href=\"#wait-notify机制\" class=\"headerlink\" title=\"wait/notify机制\"></a>wait/notify机制</h2><p>等待/通知机制主要由Object类中的三个方法进行保证</p>\n<p>1、wait()；notify();notifyAll()<br>上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；<code>wait();notify();notifyAll()</code>只有在被<code>synchronized</code>修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出<code>IllegalMonitorStateException</code>异常。</p>\n<p>1)wait()<br>让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用<code>notify()</code>或者<code>notifyAll()</code>时唤醒当前线程。<code>wait()</code>也可以作为任务同步的一种方式。</p>\n<p><strong>注：调用<code>sleep()</code>和<code>yield()</code>方法不能释放当前的对象锁</strong><br><code>wait()</code>方法有两种用法：</p>\n<ul>\n<li><code>wait(long timeout)</code>等待一定的时间，但与<code>sleep()</code>方法不同，其会释放对象锁</li>\n<li>使用<code>wait()</code>等待<code>notify()</code>或者<code>notifyAll()</code>唤醒。 </li>\n</ul>\n<p>2)notify()<br>唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；</p>\n<p>3)notifyAll()<br>唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过<code>synchronized(x)</code>来获取对象锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(x) &#123; </span><br><span class=\"line\">  x.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2、方法调用与线程状态关系</p>\n<p>每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列</p>\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p>Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；</p>\n<p>对应关系</p>\n<ul>\n<li>Condition中的await()对应Object的wait()</li>\n<li>Condition中的signal()对应Object的notify()</li>\n<li>Condition中的signalAll()对应Object中的notifyAll();</li>\n</ul>\n<p><strong>Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同</strong></p>\n<h3 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h3><p>线程锁控制代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">//生产者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionCustomer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//消费者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionProducer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//用于表示需要生产</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用于随机消费时间；</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于生产者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"生产线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionCustomer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">500</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有消费者线程 \"</span>+<span class=\"string\">\"....\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的消费者线程</span></span><br><span class=\"line\">            conditionProducer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">custome</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"消费线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionProducer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">4000</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有生产者线程 \"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的生产者线程</span></span><br><span class=\"line\">            conditionCustomer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomerThread</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            service.custome();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer_ServiceMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Service service=<span class=\"keyword\">new</span> Service();</span><br><span class=\"line\">        CustomerThread[] customerThread=<span class=\"keyword\">new</span> CustomerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        ProducerThread[] producerThreads=<span class=\"keyword\">new</span> ProducerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            customerThread[i]=<span class=\"keyword\">new</span> CustomerThread(service);</span><br><span class=\"line\">            customerThread[i].setName(<span class=\"string\">\"生产者Thread：\"</span>+i);</span><br><span class=\"line\">            producerThreads[i]=<span class=\"keyword\">new</span> ProducerThread(service);</span><br><span class=\"line\">            producerThreads[i].setName(<span class=\"string\">\"消费者Thread：\"</span>+i);</span><br><span class=\"line\">            customerThread[i].start();</span><br><span class=\"line\">            producerThreads[i].start();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：2await</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：2await</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"线程间通信管道模式\"><a href=\"#线程间通信管道模式\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3><h4 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h4><p>用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。</p>\n<p>任务执行线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用CountDownLatch会被自动要求加上此构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setName(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doWork();</span><br><span class=\"line\">            <span class=\"comment\">//用于倒数技术</span></span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//random.nextInt(2000)在Java中是线程安全的来自TIJ</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\"completed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等待任务执行完毕，需要唤醒的线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitingTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WaitingTask</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           latch.await();</span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"Latch阻塞运行至waiting class\"</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCountDown</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数</span></span><br><span class=\"line\">        CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(SIZE);</span><br><span class=\"line\">      <span class=\"comment\">// for (int i=0;i&lt;10;i++)&#123;   //可以有多个等待线程</span></span><br><span class=\"line\">        exec.execute(<span class=\"keyword\">new</span> WaitingTask(latch));</span><br><span class=\"line\">      <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> Task(latch,<span class=\"string\">\"线程\"</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"启动所有任务\"</span>);</span><br><span class=\"line\">        exec.shutdown();  <span class=\"comment\">//任务只有在执行完毕后才会结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任务执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动所有任务</span><br><span class=\"line\">线程0completed</span><br><span class=\"line\">线程4completed</span><br><span class=\"line\">线程1completed</span><br><span class=\"line\">线程2completed</span><br><span class=\"line\">线程3completed</span><br><span class=\"line\">Latch阻塞运行至waiting class</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h4><p><code>CyclicBarrier</code>类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于<code>join</code>)，与<code>CountDownLatch</code>类的使用类似，<code>CountDownLatch</code>类只能执行一次，而<code>CyclicBarrier</code>可以进行多次使用。<br>以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；</p>\n<p>运动员代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Athlete</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示耗时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> time =<span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Athlete</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cyclicBarrier=cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">double</span> <span class=\"title\">getTime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.interrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                    time =(<span class=\"keyword\">double</span>)(rand.nextInt(<span class=\"number\">20</span>)+<span class=\"number\">90</span>)/<span class=\"number\">10</span>;</span><br><span class=\"line\">                    System.out.println(getName()+<span class=\"string\">\"跑步耗时：\"</span>+ getTime());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有运动员跑完标志输出代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunningCtrl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RunningCtrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"++++++++++++++++++++++++++++++++\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RunningCtrl  runningCtrl=<span class=\"keyword\">new</span> RunningCtrl();</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>,runningCtrl);</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Athlete athlete = <span class=\"keyword\">new</span> Athlete(cyclicBarrier);</span><br><span class=\"line\">            athlete.setName(<span class=\"string\">\"选手：\"</span>+i);</span><br><span class=\"line\">            exec.execute(athlete);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">选手：0跑步耗时：9.5</span><br><span class=\"line\">选手：1跑步耗时：9.8</span><br><span class=\"line\">选手：4跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：0跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.8</span><br><span class=\"line\">选手：1跑步耗时：9.6</span><br><span class=\"line\">选手：4跑步耗时：9.4</span><br><span class=\"line\">选手：3跑步耗时：10.8</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：9.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：9.2</span><br><span class=\"line\">选手：2跑步耗时：9.3</span><br><span class=\"line\">选手：0跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.2</span><br><span class=\"line\">选手：0跑步耗时：9.9</span><br><span class=\"line\">选手：3跑步耗时：10.2</span><br><span class=\"line\">选手：4跑步耗时：10.6</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：10.2</span><br><span class=\"line\">选手：2跑步耗时：10.9</span><br><span class=\"line\">选手：0跑步耗时：10.6</span><br><span class=\"line\">选手：3跑步耗时：10.0</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：2跑步耗时：10.8</span><br><span class=\"line\">选手：4跑步耗时：10.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">选手：0跑步耗时：9.2</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DelayQueue的使用\"><a href=\"#DelayQueue的使用\" class=\"headerlink\" title=\"DelayQueue的使用\"></a><code>DelayQueue</code>的使用</h4><p><code>DelayQueue</code>是一个无界的阻塞队列，实现<code>Delayed</code>接口。只有当<code>delay</code>被激发时，该对象才能从队列中获取数据</p>\n<h3 id=\"线程间通信管道模式-1\"><a href=\"#线程间通信管道模式-1\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><ul>\n<li>使用单向管道（Pipe）传递数据</li>\n<li>共享内存（Shared Memory）通信</li>\n<li>使用阻塞队列（Blocking Queue）实现生产者-消费者模式</li>\n<li>处理消息队列（Message Queue）</li>\n</ul>\n<h2 id=\"wait-notify机制\"><a href=\"#wait-notify机制\" class=\"headerlink\" title=\"wait/notify机制\"></a>wait/notify机制</h2><p>等待/通知机制主要由Object类中的三个方法进行保证</p>\n<p>1、wait()；notify();notifyAll()<br>上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；<code>wait();notify();notifyAll()</code>只有在被<code>synchronized</code>修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出<code>IllegalMonitorStateException</code>异常。</p>\n<p>1)wait()<br>让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用<code>notify()</code>或者<code>notifyAll()</code>时唤醒当前线程。<code>wait()</code>也可以作为任务同步的一种方式。</p>\n<p><strong>注：调用<code>sleep()</code>和<code>yield()</code>方法不能释放当前的对象锁</strong><br><code>wait()</code>方法有两种用法：</p>\n<ul>\n<li><code>wait(long timeout)</code>等待一定的时间，但与<code>sleep()</code>方法不同，其会释放对象锁</li>\n<li>使用<code>wait()</code>等待<code>notify()</code>或者<code>notifyAll()</code>唤醒。 </li>\n</ul>\n<p>2)notify()<br>唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；</p>\n<p>3)notifyAll()<br>唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过<code>synchronized(x)</code>来获取对象锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(x) &#123; </span><br><span class=\"line\">  x.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2、方法调用与线程状态关系</p>\n<p>每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列</p>\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p>Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；</p>\n<p>对应关系</p>\n<ul>\n<li>Condition中的await()对应Object的wait()</li>\n<li>Condition中的signal()对应Object的notify()</li>\n<li>Condition中的signalAll()对应Object中的notifyAll();</li>\n</ul>\n<p><strong>Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同</strong></p>\n<h3 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h3><p>线程锁控制代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">//生产者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionCustomer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//消费者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionProducer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//用于表示需要生产</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用于随机消费时间；</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于生产者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"生产线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionCustomer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">500</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有消费者线程 \"</span>+<span class=\"string\">\"....\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的消费者线程</span></span><br><span class=\"line\">            conditionProducer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">custome</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"消费线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionProducer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">4000</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有生产者线程 \"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的生产者线程</span></span><br><span class=\"line\">            conditionCustomer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomerThread</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            service.custome();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer_ServiceMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Service service=<span class=\"keyword\">new</span> Service();</span><br><span class=\"line\">        CustomerThread[] customerThread=<span class=\"keyword\">new</span> CustomerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        ProducerThread[] producerThreads=<span class=\"keyword\">new</span> ProducerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            customerThread[i]=<span class=\"keyword\">new</span> CustomerThread(service);</span><br><span class=\"line\">            customerThread[i].setName(<span class=\"string\">\"生产者Thread：\"</span>+i);</span><br><span class=\"line\">            producerThreads[i]=<span class=\"keyword\">new</span> ProducerThread(service);</span><br><span class=\"line\">            producerThreads[i].setName(<span class=\"string\">\"消费者Thread：\"</span>+i);</span><br><span class=\"line\">            customerThread[i].start();</span><br><span class=\"line\">            producerThreads[i].start();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：2await</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：2await</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"线程间通信管道模式\"><a href=\"#线程间通信管道模式\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3><h4 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h4><p>用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。</p>\n<p>任务执行线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用CountDownLatch会被自动要求加上此构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setName(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doWork();</span><br><span class=\"line\">            <span class=\"comment\">//用于倒数技术</span></span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//random.nextInt(2000)在Java中是线程安全的来自TIJ</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\"completed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等待任务执行完毕，需要唤醒的线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitingTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WaitingTask</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           latch.await();</span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"Latch阻塞运行至waiting class\"</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCountDown</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数</span></span><br><span class=\"line\">        CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(SIZE);</span><br><span class=\"line\">      <span class=\"comment\">// for (int i=0;i&lt;10;i++)&#123;   //可以有多个等待线程</span></span><br><span class=\"line\">        exec.execute(<span class=\"keyword\">new</span> WaitingTask(latch));</span><br><span class=\"line\">      <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> Task(latch,<span class=\"string\">\"线程\"</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"启动所有任务\"</span>);</span><br><span class=\"line\">        exec.shutdown();  <span class=\"comment\">//任务只有在执行完毕后才会结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任务执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动所有任务</span><br><span class=\"line\">线程0completed</span><br><span class=\"line\">线程4completed</span><br><span class=\"line\">线程1completed</span><br><span class=\"line\">线程2completed</span><br><span class=\"line\">线程3completed</span><br><span class=\"line\">Latch阻塞运行至waiting class</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h4><p><code>CyclicBarrier</code>类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于<code>join</code>)，与<code>CountDownLatch</code>类的使用类似，<code>CountDownLatch</code>类只能执行一次，而<code>CyclicBarrier</code>可以进行多次使用。<br>以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；</p>\n<p>运动员代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Athlete</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示耗时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> time =<span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Athlete</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cyclicBarrier=cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">double</span> <span class=\"title\">getTime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.interrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                    time =(<span class=\"keyword\">double</span>)(rand.nextInt(<span class=\"number\">20</span>)+<span class=\"number\">90</span>)/<span class=\"number\">10</span>;</span><br><span class=\"line\">                    System.out.println(getName()+<span class=\"string\">\"跑步耗时：\"</span>+ getTime());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有运动员跑完标志输出代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunningCtrl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RunningCtrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"++++++++++++++++++++++++++++++++\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RunningCtrl  runningCtrl=<span class=\"keyword\">new</span> RunningCtrl();</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>,runningCtrl);</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Athlete athlete = <span class=\"keyword\">new</span> Athlete(cyclicBarrier);</span><br><span class=\"line\">            athlete.setName(<span class=\"string\">\"选手：\"</span>+i);</span><br><span class=\"line\">            exec.execute(athlete);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">选手：0跑步耗时：9.5</span><br><span class=\"line\">选手：1跑步耗时：9.8</span><br><span class=\"line\">选手：4跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：0跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.8</span><br><span class=\"line\">选手：1跑步耗时：9.6</span><br><span class=\"line\">选手：4跑步耗时：9.4</span><br><span class=\"line\">选手：3跑步耗时：10.8</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：9.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：9.2</span><br><span class=\"line\">选手：2跑步耗时：9.3</span><br><span class=\"line\">选手：0跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.2</span><br><span class=\"line\">选手：0跑步耗时：9.9</span><br><span class=\"line\">选手：3跑步耗时：10.2</span><br><span class=\"line\">选手：4跑步耗时：10.6</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：10.2</span><br><span class=\"line\">选手：2跑步耗时：10.9</span><br><span class=\"line\">选手：0跑步耗时：10.6</span><br><span class=\"line\">选手：3跑步耗时：10.0</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：2跑步耗时：10.8</span><br><span class=\"line\">选手：4跑步耗时：10.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">选手：0跑步耗时：9.2</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DelayQueue的使用\"><a href=\"#DelayQueue的使用\" class=\"headerlink\" title=\"DelayQueue的使用\"></a><code>DelayQueue</code>的使用</h4><p><code>DelayQueue</code>是一个无界的阻塞队列，实现<code>Delayed</code>接口。只有当<code>delay</code>被激发时，该对象才能从队列中获取数据</p>\n<h3 id=\"线程间通信管道模式-1\"><a href=\"#线程间通信管道模式-1\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3>"},{"_content":"","source":"_posts/Java/Java基础/Img/README.md","raw":"","slug":"Java/Java基础/Img/README","published":1,"date":"2019-09-27T08:23:54.079Z","updated":"2019-09-27T08:23:54.079Z","title":"Java/Java基础/Img/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi2003misui9rzxd9qa","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/设计模式/Img/README.md","raw":"","slug":"Java/设计模式/Img/README","published":1,"date":"2019-11-28T12:20:23.102Z","updated":"2019-11-28T12:20:23.102Z","title":"Java/设计模式/Img/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryi3003nisui4qyabgbk","content":"","site":{"data":{}},"excerpt":"","more":""},{"thumbnail":"/assets/Android JNI.png","toc":true,"description":"测试摘要","_content":"\n\n## Retrofit 框架使用\n\n\n#### 请求内容与返回值\n\n使用PostMan进行请求测试\n请求：`https://api.github.com/search/repositories?q=android`\n\n<!--more-->\n返回值：\n\nHeader:\n![](/assets/Retrofit.png)\n\n\nBody:\n```json\n{\n    \"total_count\": 943593,\n    \"incomplete_results\": false,\n    \"items\": [\n        {\n            \"id\": 82128465,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\",\n            \"name\": \"Android\",\n            \"full_name\": \"open-android/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"open-android\",\n                \"id\": 23095877,\n                \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\",\n                \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\",\n                //……\n            },\n            \"html_url\": \"https://github.com/open-android/Android\",\n            \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\",\n            \"fork\": false,\n            \"url\": \"https://api.github.com/repos/open-android/Android\",\n            //……\n        },\n        {\n            \"id\": 12544093,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\",\n            \"name\": \"Android\",\n            \"full_name\": \"hmkcode/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"hmkcode\",\n                \"id\": 3790597,\n                //……\n            },\n            //……\n        }\n    ]\n}\n```\n#### 引入Retrofit依赖\n\n```java\n    implementation 'com.squareup.retrofit2:retrofit:2.5.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'\n```\n#### 根据返回的请求结果定义Repository Bean类\n返回的报文采用google.gson进行处理，金处理必要的值\n\n```java\npublic class RepoBean {\n\n    //用于表示Repo id\n    private int id;\n    //用于表示RepoName\n    private String name;\n\n    //用于表示完整名称\n    //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注\n    @SerializedName(\"full_name\")\n    private String fullName;\n    \n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 根据返回的请求结果定义一次查询结果\n\n```java\npublic class SearchRepoBean {\n\n    //用于表示仓库数量\n    @SerializedName(\"total_count\")\n    private int totalCount;\n    //用于表示是否为完整结果\n    private boolean incompleteResults;\n    //用于表示持有的所有的仓库类\n    private List<RepoBean>items;\n\n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 定义网络请求API接口\n\n```java\n    public interface GithubService {\n        \n        //@Get注解，表示以Get方法发送网络请求\n        //返回类型为Call<SearchRepoBean>，SearchRepoBean是接收数据的类，可以自定义\n        @GET(\"search/repositories\")\n        Call<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n\n```\n\n#### 初始化Retrofit实例，生成接口实现类\n\n```java\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")                   //设置网络请求的URL地址           \n                .addConverterFactory(GsonConverterFactory.create())   //设置数据解析器 \n                .build();\n\n        githubService = retrofit.create(GithubService.class);\n\n```\n\n#### 进行网络请求\n\n```java\n\n    Call<SearchRepoBean> call = githubService.getRepoInfo(\"Android\");\n        //同步请求方式\n        //call.request();\n        //异步请求方式\n        call.enqueue(new Callback<SearchRepoBean>() {\n            @Override\n            public void onResponse(Call<SearchRepoBean> call, Response<SearchRepoBean> response) {\n              //输出请求结果 \n              //  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());\n               // List<RepoBean>repoBeans=new ArrayList<>();\n               // repoBeans.addAll(response.body().getItems());\n               // for (int i=repoBeans.size()-1;i>=0;i--){\n               //  LogUtils.printInfo(repoBeans.get(i).getFullName());\n               // }\n              }\n\n            @Override\n            public void onFailure(Call<SearchRepoBean> call, Throwable t) {\n                }\n            });\n```\n\n#### 将请求值的返回设为LiveData\n\n将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现\n\n```java\n    public interface GithubService {\n         @GET(\"search/repositories\")\n         LiveData<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n```\n自定义LiveDataCallAdapterFactory \n\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n\n        //用于获取泛型的参数\n        Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n        Class<?> rawObserverType = getRawType(observerType);\n\n\n        LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType);\n\n        return liveDataCallAdapter;\n        }\n    }\n\n\n```\n自定义 LiveDataCallAdapter\n```java\n\n    public class LiveDataCallAdapter<R> implements CallAdapter<R, LiveData<SearchRepoBean>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<SearchRepoBean> adapt(final Call<R> call) {\n\n             LiveData<SearchRepoBean>searchRepoBeanLiveData=new LiveData<SearchRepoBean>() {\n\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n    \n                    @Override\n                    public void onResponse(Call<R> call, Response<R> response) {\n                        postValue((SearchRepoBean) response.body());\n                    }\n\n                    @Override\n                    public void onFailure(Call<R> call, Throwable t) {\n                        LogUtils.printInfo(\"error\");\n                    }\n                });\n            }\n        };\n        //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值\n       return searchRepoBeanLiveData;\n    }\n    }\n\n```\n为Retrofit实例添加CallAdapterFactory\n\n```java\n      Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(new LiveDataCallAdapterFactory())\n                .build();\n\n```\n调用方法\n```java\n\n            repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n            repoBeanLiveData.observe(GithubApiActivity.this, new Observer<SearchRepoBean>() {\n                @Override\n                public void onChanged(SearchRepoBean searchRepoBean) {                            \n                     //输出结果\n                    }\n                });\n\n```\n\n\n#### 添加通用的响应实体\n\n通过`LiveDataCallAdapter` 和`LiveDataCallAdapterFactory` 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为`SearchRepoBean`类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。\n\n定义一个通用的响应实体\n\n```java\n    public class ApiResponse<T> {\n\n    public ApiResponseSuccess<T> create(Response<T> response) {\n        if (response.isSuccessful()) {\n            return new ApiResponseSuccess<T>(response.body());\n        } else {\n            return null;\n        }\n    }\n\n    //用于表示返回成功的值\n    public static class ApiResponseSuccess<T> extends ApiResponse<T> {\n        /用于表示请求返回成功的内容，在本代码中是SearchRepoBean\n        private T body;\n\n        public ApiResponseSuccess(T body) {\n            this.body = body;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n  }\n\n```\n修改LiveDataCallAdapterFactory\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n            //用于获取泛型的参数\n            //return type为LiveData<ApiResponse<SearchRepoBean>> \n            //observerType为ApiResponse<SearchRepoBean>\n            Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n            //bodyType为SearchRepoBean\n            Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType);\n            LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType);\n\n            return liveDataCallAdapter;\n        }\n    }\n\n```\n修改LiveDataCallAdapter\n\n```java\n    public class LiveDataCallAdapter<R> implements CallAdapter<R,LiveData<ApiResponse<R>>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<ApiResponse<R>> adapt(final Call<R> call) {\n            LiveData<ApiResponse<R>> result=new LiveData<ApiResponse<R>>() {\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n                        @Override\n                        public void onResponse(Call<R> call, Response<R> response) {\n                       postValue(new ApiResponse<R>().create(response));\n                    }\n\n                        @Override\n                        public void onFailure(Call<R> call, Throwable t) {\n                          //  LogUtils.printInfo(\"+++++!2312qwqweww31\");\n                        }\n                    });\n                }\n            };\n        return result;\n    }\n}\n```\n\n修改调用方法\n```java\n    repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n    repoBeanLiveData.observe(GithubApiActivity.this, new Observer<ApiResponse<SearchRepoBean>>() {\n        @Override\n        public void onChanged(ApiResponse<SearchRepoBean> searchRepoBeanApiResponse) {\n            SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();\n           //输出结果\n        }\n    });\n\n```\n\n## 源码详解\n\n##### Retrofit构建中的`.baseUrl(\"https://api.github.com/\")`介绍\nRetrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型\n```java\n\n    public final class Retrofit {\n\n      public static final class Builder {\n             public Builder baseUrl(String baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  return baseUrl(HttpUrl.get(baseUrl));\n                }\n                \n            public Builder baseUrl(HttpUrl baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  List<String> pathSegments = baseUrl.pathSegments();\n                  if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n                    throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n                  }\n              this.baseUrl = baseUrl;\n              return this;\n            }\n          }\n        }\n\n```\n\n##### Retrofit构建中的`.addConverterFactory(GsonConverterFactory.create())`\n通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory\n\n```java\n    public Builder addConverterFactory(Converter.Factory factory) {\n      converterFactories.add(checkNotNull(factory, \"factory == null\"));\n      return this;\n    }\n\n```\nConverter接口源码，核心是`T convert(F value)`,将F类型的数据转换为T类型\n\n```java\n\npublic interface Converter<F, T> {\n  //将F类型的数据转换为T类型\n  @Nullable T convert(F value) throws IOException;\n\n  //根据数据类型创建Converter创建 Converter\n  abstract class Factory {\n    //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。\n    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,\n        Annotation[] annotations, Retrofit retrofit) {\n      return null;\n    }\n\n       //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody\n    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,\n        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n      return null;\n    }\n        //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String\n    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n      return null;\n    }\n\n    protected static Type getParameterUpperBound(int index, ParameterizedType type) {\n      return Utils.getParameterUpperBound(index, type);\n    }\n\n    protected static Class<?> getRawType(Type type) {\n      return Utils.getRawType(type);\n    }\n  }\n}\n\n```\n\n\n##### Retrofit构建中的`.addCallAdapterFactory(new LiveDataCallAdapterFactory())`\n用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用\n\n```java\npublic final class Retrofit {\n      final List<CallAdapter.Factory> callAdapterFactories;\n      \n      //…………\n      public Builder addCallAdapterFactory(CallAdapter.Factory factory) {\n          callAdapterFactories.add(checkNotNull(factory, \"factory == null\"));\n          return this;\n        }\n      //…………\n}\n\n```\n\n##### 最终用来创建Service的代码`retrofit.create(GithubService.class)`\ncreate()采用代理的方式进行创建，\n\n```java\npublic final class Retrofit {\n  //……\n  public <T> T create(final Class<T> service) {\n    //判断定义的接口服务是否可用\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // 如果是Object本身的方法，正常调用后返回\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            //如果是platform默认的方法，正常调用后返回\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            //解析我们定义的网络请求的方法\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n  //……\n}\n```\n`loadServiceMethod(Method method)`源码解析,其实际上是HttpServiceMethod对象\n\n```java\n\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    //从解析的缓存中获取\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        \n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n\n```\n` static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method)`源码\n\n```java\nabstract class ServiceMethod<T> {\n      static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n      //RequestFactory负责解析接口并且生成Request\n        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n       //…………\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract T invoke(Object[] args);\n}\n\n\n```\n\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)`源码\n\n```java\n\n//将一个接口方法转变为一个Http请求\nfinal class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {\n\n  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n      //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码\n    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);\n \n    //……\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    okhttp3.Call.Factory callFactory = retrofit.callFactory;\n    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);\n  }\n\n  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(\n      Retrofit retrofit, Method method) {\n    Type returnType = method.getGenericReturnType();\n    Annotation[] annotations = method.getAnnotations();\n    try {\n      //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter\n      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);\n    } catch (RuntimeException e) { // Wide exception range because factories are user code.\n      throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n    }\n  }\n\n //…………\n\n  private final RequestFactory requestFactory;\n  private final okhttp3.Call.Factory callFactory;\n  private final CallAdapter<ResponseT, ReturnT> callAdapter;\n  private final Converter<ResponseBody, ResponseT> responseConverter;\n\n  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n      CallAdapter<ResponseT, ReturnT> callAdapter,\n      Converter<ResponseBody, ResponseT> responseConverter) {\n    this.requestFactory = requestFactory;\n    this.callFactory = callFactory;\n    this.callAdapter = callAdapter;\n    this.responseConverter = responseConverter;\n  }\n\n  //代理调用的invoke最终会调用下面invoke方法\n  @Override ReturnT invoke(Object[] args) {\n    return callAdapter.adapt(\n        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));\n  }\n}\n\n\n`call.enqueue(new Callback<SearchRepoBean>() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})`\n\n```java\n\nfinal class OkHttpCall<T> implements Call<T> {\n\n    //……\n   @Override public void enqueue(final Callback<T> callback) {\n\n    //……\n    call.enqueue(new okhttp3.Callback() {\n      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        //……\n        try {\n          callback.onResponse(OkHttpCall.this, response);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n    });\n   }\n    //……\n}\n\n```\n\n\n\n\n\n\n\n","source":"_posts/Android/框架/Retrofit 2.5 框架使用与源码分析.md","raw":"---\nthumbnail: /assets/Android JNI.png\ntoc: true\ncategories: Android\ntags: [Android]\ndescription: 测试摘要\n---\n\n\n## Retrofit 框架使用\n\n\n#### 请求内容与返回值\n\n使用PostMan进行请求测试\n请求：`https://api.github.com/search/repositories?q=android`\n\n<!--more-->\n返回值：\n\nHeader:\n![](/assets/Retrofit.png)\n\n\nBody:\n```json\n{\n    \"total_count\": 943593,\n    \"incomplete_results\": false,\n    \"items\": [\n        {\n            \"id\": 82128465,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\",\n            \"name\": \"Android\",\n            \"full_name\": \"open-android/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"open-android\",\n                \"id\": 23095877,\n                \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\",\n                \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\",\n                //……\n            },\n            \"html_url\": \"https://github.com/open-android/Android\",\n            \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\",\n            \"fork\": false,\n            \"url\": \"https://api.github.com/repos/open-android/Android\",\n            //……\n        },\n        {\n            \"id\": 12544093,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\",\n            \"name\": \"Android\",\n            \"full_name\": \"hmkcode/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"hmkcode\",\n                \"id\": 3790597,\n                //……\n            },\n            //……\n        }\n    ]\n}\n```\n#### 引入Retrofit依赖\n\n```java\n    implementation 'com.squareup.retrofit2:retrofit:2.5.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'\n```\n#### 根据返回的请求结果定义Repository Bean类\n返回的报文采用google.gson进行处理，金处理必要的值\n\n```java\npublic class RepoBean {\n\n    //用于表示Repo id\n    private int id;\n    //用于表示RepoName\n    private String name;\n\n    //用于表示完整名称\n    //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注\n    @SerializedName(\"full_name\")\n    private String fullName;\n    \n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 根据返回的请求结果定义一次查询结果\n\n```java\npublic class SearchRepoBean {\n\n    //用于表示仓库数量\n    @SerializedName(\"total_count\")\n    private int totalCount;\n    //用于表示是否为完整结果\n    private boolean incompleteResults;\n    //用于表示持有的所有的仓库类\n    private List<RepoBean>items;\n\n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 定义网络请求API接口\n\n```java\n    public interface GithubService {\n        \n        //@Get注解，表示以Get方法发送网络请求\n        //返回类型为Call<SearchRepoBean>，SearchRepoBean是接收数据的类，可以自定义\n        @GET(\"search/repositories\")\n        Call<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n\n```\n\n#### 初始化Retrofit实例，生成接口实现类\n\n```java\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")                   //设置网络请求的URL地址           \n                .addConverterFactory(GsonConverterFactory.create())   //设置数据解析器 \n                .build();\n\n        githubService = retrofit.create(GithubService.class);\n\n```\n\n#### 进行网络请求\n\n```java\n\n    Call<SearchRepoBean> call = githubService.getRepoInfo(\"Android\");\n        //同步请求方式\n        //call.request();\n        //异步请求方式\n        call.enqueue(new Callback<SearchRepoBean>() {\n            @Override\n            public void onResponse(Call<SearchRepoBean> call, Response<SearchRepoBean> response) {\n              //输出请求结果 \n              //  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());\n               // List<RepoBean>repoBeans=new ArrayList<>();\n               // repoBeans.addAll(response.body().getItems());\n               // for (int i=repoBeans.size()-1;i>=0;i--){\n               //  LogUtils.printInfo(repoBeans.get(i).getFullName());\n               // }\n              }\n\n            @Override\n            public void onFailure(Call<SearchRepoBean> call, Throwable t) {\n                }\n            });\n```\n\n#### 将请求值的返回设为LiveData\n\n将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现\n\n```java\n    public interface GithubService {\n         @GET(\"search/repositories\")\n         LiveData<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n```\n自定义LiveDataCallAdapterFactory \n\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n\n        //用于获取泛型的参数\n        Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n        Class<?> rawObserverType = getRawType(observerType);\n\n\n        LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType);\n\n        return liveDataCallAdapter;\n        }\n    }\n\n\n```\n自定义 LiveDataCallAdapter\n```java\n\n    public class LiveDataCallAdapter<R> implements CallAdapter<R, LiveData<SearchRepoBean>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<SearchRepoBean> adapt(final Call<R> call) {\n\n             LiveData<SearchRepoBean>searchRepoBeanLiveData=new LiveData<SearchRepoBean>() {\n\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n    \n                    @Override\n                    public void onResponse(Call<R> call, Response<R> response) {\n                        postValue((SearchRepoBean) response.body());\n                    }\n\n                    @Override\n                    public void onFailure(Call<R> call, Throwable t) {\n                        LogUtils.printInfo(\"error\");\n                    }\n                });\n            }\n        };\n        //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值\n       return searchRepoBeanLiveData;\n    }\n    }\n\n```\n为Retrofit实例添加CallAdapterFactory\n\n```java\n      Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(new LiveDataCallAdapterFactory())\n                .build();\n\n```\n调用方法\n```java\n\n            repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n            repoBeanLiveData.observe(GithubApiActivity.this, new Observer<SearchRepoBean>() {\n                @Override\n                public void onChanged(SearchRepoBean searchRepoBean) {                            \n                     //输出结果\n                    }\n                });\n\n```\n\n\n#### 添加通用的响应实体\n\n通过`LiveDataCallAdapter` 和`LiveDataCallAdapterFactory` 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为`SearchRepoBean`类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。\n\n定义一个通用的响应实体\n\n```java\n    public class ApiResponse<T> {\n\n    public ApiResponseSuccess<T> create(Response<T> response) {\n        if (response.isSuccessful()) {\n            return new ApiResponseSuccess<T>(response.body());\n        } else {\n            return null;\n        }\n    }\n\n    //用于表示返回成功的值\n    public static class ApiResponseSuccess<T> extends ApiResponse<T> {\n        /用于表示请求返回成功的内容，在本代码中是SearchRepoBean\n        private T body;\n\n        public ApiResponseSuccess(T body) {\n            this.body = body;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n  }\n\n```\n修改LiveDataCallAdapterFactory\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n            //用于获取泛型的参数\n            //return type为LiveData<ApiResponse<SearchRepoBean>> \n            //observerType为ApiResponse<SearchRepoBean>\n            Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n            //bodyType为SearchRepoBean\n            Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType);\n            LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType);\n\n            return liveDataCallAdapter;\n        }\n    }\n\n```\n修改LiveDataCallAdapter\n\n```java\n    public class LiveDataCallAdapter<R> implements CallAdapter<R,LiveData<ApiResponse<R>>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<ApiResponse<R>> adapt(final Call<R> call) {\n            LiveData<ApiResponse<R>> result=new LiveData<ApiResponse<R>>() {\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n                        @Override\n                        public void onResponse(Call<R> call, Response<R> response) {\n                       postValue(new ApiResponse<R>().create(response));\n                    }\n\n                        @Override\n                        public void onFailure(Call<R> call, Throwable t) {\n                          //  LogUtils.printInfo(\"+++++!2312qwqweww31\");\n                        }\n                    });\n                }\n            };\n        return result;\n    }\n}\n```\n\n修改调用方法\n```java\n    repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n    repoBeanLiveData.observe(GithubApiActivity.this, new Observer<ApiResponse<SearchRepoBean>>() {\n        @Override\n        public void onChanged(ApiResponse<SearchRepoBean> searchRepoBeanApiResponse) {\n            SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();\n           //输出结果\n        }\n    });\n\n```\n\n## 源码详解\n\n##### Retrofit构建中的`.baseUrl(\"https://api.github.com/\")`介绍\nRetrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型\n```java\n\n    public final class Retrofit {\n\n      public static final class Builder {\n             public Builder baseUrl(String baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  return baseUrl(HttpUrl.get(baseUrl));\n                }\n                \n            public Builder baseUrl(HttpUrl baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  List<String> pathSegments = baseUrl.pathSegments();\n                  if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n                    throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n                  }\n              this.baseUrl = baseUrl;\n              return this;\n            }\n          }\n        }\n\n```\n\n##### Retrofit构建中的`.addConverterFactory(GsonConverterFactory.create())`\n通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory\n\n```java\n    public Builder addConverterFactory(Converter.Factory factory) {\n      converterFactories.add(checkNotNull(factory, \"factory == null\"));\n      return this;\n    }\n\n```\nConverter接口源码，核心是`T convert(F value)`,将F类型的数据转换为T类型\n\n```java\n\npublic interface Converter<F, T> {\n  //将F类型的数据转换为T类型\n  @Nullable T convert(F value) throws IOException;\n\n  //根据数据类型创建Converter创建 Converter\n  abstract class Factory {\n    //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。\n    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,\n        Annotation[] annotations, Retrofit retrofit) {\n      return null;\n    }\n\n       //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody\n    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,\n        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n      return null;\n    }\n        //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String\n    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n      return null;\n    }\n\n    protected static Type getParameterUpperBound(int index, ParameterizedType type) {\n      return Utils.getParameterUpperBound(index, type);\n    }\n\n    protected static Class<?> getRawType(Type type) {\n      return Utils.getRawType(type);\n    }\n  }\n}\n\n```\n\n\n##### Retrofit构建中的`.addCallAdapterFactory(new LiveDataCallAdapterFactory())`\n用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用\n\n```java\npublic final class Retrofit {\n      final List<CallAdapter.Factory> callAdapterFactories;\n      \n      //…………\n      public Builder addCallAdapterFactory(CallAdapter.Factory factory) {\n          callAdapterFactories.add(checkNotNull(factory, \"factory == null\"));\n          return this;\n        }\n      //…………\n}\n\n```\n\n##### 最终用来创建Service的代码`retrofit.create(GithubService.class)`\ncreate()采用代理的方式进行创建，\n\n```java\npublic final class Retrofit {\n  //……\n  public <T> T create(final Class<T> service) {\n    //判断定义的接口服务是否可用\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // 如果是Object本身的方法，正常调用后返回\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            //如果是platform默认的方法，正常调用后返回\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            //解析我们定义的网络请求的方法\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n  //……\n}\n```\n`loadServiceMethod(Method method)`源码解析,其实际上是HttpServiceMethod对象\n\n```java\n\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    //从解析的缓存中获取\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        \n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n\n```\n` static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method)`源码\n\n```java\nabstract class ServiceMethod<T> {\n      static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n      //RequestFactory负责解析接口并且生成Request\n        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n       //…………\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract T invoke(Object[] args);\n}\n\n\n```\n\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)`源码\n\n```java\n\n//将一个接口方法转变为一个Http请求\nfinal class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {\n\n  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n      //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码\n    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);\n \n    //……\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    okhttp3.Call.Factory callFactory = retrofit.callFactory;\n    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);\n  }\n\n  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(\n      Retrofit retrofit, Method method) {\n    Type returnType = method.getGenericReturnType();\n    Annotation[] annotations = method.getAnnotations();\n    try {\n      //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter\n      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);\n    } catch (RuntimeException e) { // Wide exception range because factories are user code.\n      throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n    }\n  }\n\n //…………\n\n  private final RequestFactory requestFactory;\n  private final okhttp3.Call.Factory callFactory;\n  private final CallAdapter<ResponseT, ReturnT> callAdapter;\n  private final Converter<ResponseBody, ResponseT> responseConverter;\n\n  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n      CallAdapter<ResponseT, ReturnT> callAdapter,\n      Converter<ResponseBody, ResponseT> responseConverter) {\n    this.requestFactory = requestFactory;\n    this.callFactory = callFactory;\n    this.callAdapter = callAdapter;\n    this.responseConverter = responseConverter;\n  }\n\n  //代理调用的invoke最终会调用下面invoke方法\n  @Override ReturnT invoke(Object[] args) {\n    return callAdapter.adapt(\n        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));\n  }\n}\n\n\n`call.enqueue(new Callback<SearchRepoBean>() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})`\n\n```java\n\nfinal class OkHttpCall<T> implements Call<T> {\n\n    //……\n   @Override public void enqueue(final Callback<T> callback) {\n\n    //……\n    call.enqueue(new okhttp3.Callback() {\n      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        //……\n        try {\n          callback.onResponse(OkHttpCall.this, response);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n    });\n   }\n    //……\n}\n\n```\n\n\n\n\n\n\n\n","slug":"Android/框架/Retrofit 2.5 框架使用与源码分析","published":1,"date":"2019-11-30T11:13:20.728Z","updated":"2020-02-29T01:58:48.659Z","title":"Android/框架/Retrofit 2.5 框架使用与源码分析","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryia003oisui3wlmhbee","content":"<h2 id=\"Retrofit-框架使用\"><a href=\"#Retrofit-框架使用\" class=\"headerlink\" title=\"Retrofit 框架使用\"></a>Retrofit 框架使用</h2><h4 id=\"请求内容与返回值\"><a href=\"#请求内容与返回值\" class=\"headerlink\" title=\"请求内容与返回值\"></a>请求内容与返回值</h4><p>使用PostMan进行请求测试<br>请求：<code>https://api.github.com/search/repositories?q=android</code></p>\n<a id=\"more\"></a>\n<p>返回值：</p>\n<p>Header:<br><img src=\"/assets/Retrofit.png\" alt=\"\"></p>\n<p>Body:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"total_count\"</span>: <span class=\"number\">943593</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"incomplete_results\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"items\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">82128465</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"open-android\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">23095877</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDQ6VXNlcjIzMDk1ODc3\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"avatar_url\"</span>: <span class=\"string\">\"https://avatars2.githubusercontent.com/u/23095877?v=4\"</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"html_url\"</span>: <span class=\"string\">\"https://github.com/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"fork\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/repos/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">12544093</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"hmkcode/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"hmkcode\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">3790597</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引入Retrofit依赖\"><a href=\"#引入Retrofit依赖\" class=\"headerlink\" title=\"引入Retrofit依赖\"></a>引入Retrofit依赖</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:retrofit:2.5.0'</span></span><br><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义Repository-Bean类\"><a href=\"#根据返回的请求结果定义Repository-Bean类\" class=\"headerlink\" title=\"根据返回的请求结果定义Repository Bean类\"></a>根据返回的请求结果定义Repository Bean类</h4><p>返回的报文采用google.gson进行处理，金处理必要的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示Repo id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示RepoName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示完整名称</span></span><br><span class=\"line\">    <span class=\"comment\">//Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"full_name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fullName;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"根据返回的请求结果定义一次查询结果\"><a href=\"#根据返回的请求结果定义一次查询结果\" class=\"headerlink\" title=\"根据返回的请求结果定义一次查询结果\"></a>根据返回的请求结果定义一次查询结果</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SearchRepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示仓库数量</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"total_count\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示是否为完整结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> incompleteResults;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示持有的所有的仓库类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RepoBean&gt;items;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义网络请求API接口\"><a href=\"#定义网络请求API接口\" class=\"headerlink\" title=\"定义网络请求API接口\"></a>定义网络请求API接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//@Get注解，表示以Get方法发送网络请求</span></span><br><span class=\"line\">    <span class=\"comment\">//返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化Retrofit实例，生成接口实现类\"><a href=\"#初始化Retrofit实例，生成接口实现类\" class=\"headerlink\" title=\"初始化Retrofit实例，生成接口实现类\"></a>初始化Retrofit实例，生成接口实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)                   <span class=\"comment\">//设置网络请求的URL地址           </span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())   <span class=\"comment\">//设置数据解析器 </span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">githubService = retrofit.create(GithubService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//同步请求方式</span></span><br><span class=\"line\">    <span class=\"comment\">//call.request();</span></span><br><span class=\"line\">    <span class=\"comment\">//异步请求方式</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//输出请求结果 </span></span><br><span class=\"line\">          <span class=\"comment\">//  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());</span></span><br><span class=\"line\">           <span class=\"comment\">// List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"comment\">// repoBeans.addAll(response.body().getItems());</span></span><br><span class=\"line\">           <span class=\"comment\">// for (int i=repoBeans.size()-1;i&gt;=0;i--)&#123;</span></span><br><span class=\"line\">           <span class=\"comment\">//  LogUtils.printInfo(repoBeans.get(i).getFullName());</span></span><br><span class=\"line\">           <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将请求值的返回设为LiveData\"><a href=\"#将请求值的返回设为LiveData\" class=\"headerlink\" title=\"将请求值的返回设为LiveData\"></a>将请求值的返回设为LiveData</h4><p>将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">     <span class=\"function\">LiveData&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义LiveDataCallAdapterFactory </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">    Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; rawObserverType = getRawType(observerType);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(rawObserverType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义 LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">LiveData</span>&lt;<span class=\"title\">SearchRepoBean</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;SearchRepoBean&gt; <span class=\"title\">adapt</span><span class=\"params\">(<span class=\"keyword\">final</span> Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=<span class=\"keyword\">new</span> LiveData&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                    postValue((SearchRepoBean) response.body());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                    LogUtils.printInfo(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> searchRepoBeanLiveData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为Retrofit实例添加CallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">          .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)</span><br><span class=\"line\">          .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">          .addCallAdapterFactory(<span class=\"keyword\">new</span> LiveDataCallAdapterFactory())</span><br><span class=\"line\">          .build();</span><br></pre></td></tr></table></figure>\n<p>调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(SearchRepoBean searchRepoBean)</span> </span>&#123;                            </span><br><span class=\"line\">         <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"添加通用的响应实体\"><a href=\"#添加通用的响应实体\" class=\"headerlink\" title=\"添加通用的响应实体\"></a>添加通用的响应实体</h4><p>通过<code>LiveDataCallAdapter</code> 和<code>LiveDataCallAdapterFactory</code> 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为<code>SearchRepoBean</code>类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。</p>\n<p>定义一个通用的响应实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ApiResponseSuccess&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.isSuccessful()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiResponseSuccess&lt;T&gt;(response.body());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用于表示返回成功的值</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponseSuccess</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      /用于表示请求返回成功的内容，在本代码中是SearchRepoBean</span><br><span class=\"line\">      <span class=\"keyword\">private</span> T body;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiResponseSuccess</span><span class=\"params\">(T body)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getBody</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">        <span class=\"comment\">//return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//observerType为ApiResponse&lt;SearchRepoBean&gt;</span></span><br><span class=\"line\">        Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\">        <span class=\"comment\">//bodyType为SearchRepoBean</span></span><br><span class=\"line\">        Type bodyType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) observerType);</span><br><span class=\"line\">        LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(bodyType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>,<span class=\"title\">LiveData</span>&lt;<span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">R</span>&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(<span class=\"keyword\">final</span> Call&lt;R&gt; call) &#123;</span><br><span class=\"line\">            LiveData&lt;ApiResponse&lt;R&gt;&gt; result=<span class=\"keyword\">new</span> LiveData&lt;ApiResponse&lt;R&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                       postValue(<span class=\"keyword\">new</span> ApiResponse&lt;R&gt;().create(response));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                          <span class=\"comment\">//  LogUtils.printInfo(\"+++++!2312qwqweww31\");</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse)</span> </span>&#123;</span><br><span class=\"line\">        SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();</span><br><span class=\"line\">       <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h5 id=\"Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\"><a href=\"#Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\" class=\"headerlink\" title=\"Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍\"></a>Retrofit构建中的<code>.baseUrl(&quot;https://api.github.com/&quot;)</code>介绍</h5><p>Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(String baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"string\">\"\"</span>.equals(pathSegments.get(pathSegments.size() - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"baseUrl must end in /: \"</span> + baseUrl);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.baseUrl = baseUrl;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\"><a href=\"#Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\" class=\"headerlink\" title=\"Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())\"></a>Retrofit构建中的<code>.addConverterFactory(GsonConverterFactory.create())</code></h5><p>通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addConverterFactory</span><span class=\"params\">(Converter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">  converterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Converter接口源码，核心是<code>T convert(F value)</code>,将F类型的数据转换为T类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">F</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将F类型的数据转换为T类型</span></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">convert</span><span class=\"params\">(F value)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据数据类型创建Converter创建 Converter</span></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Type <span class=\"title\">getParameterUpperBound</span><span class=\"params\">(<span class=\"keyword\">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getRawType(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\"><a href=\"#Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\" class=\"headerlink\" title=\"Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())\"></a>Retrofit构建中的<code>.addCallAdapterFactory(new LiveDataCallAdapterFactory())</code></h5><p>用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addCallAdapterFactory</span><span class=\"params\">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">          callAdapterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"最终用来创建Service的代码retrofit-create-GithubService-class\"><a href=\"#最终用来创建Service的代码retrofit-create-GithubService-class\" class=\"headerlink\" title=\"最终用来创建Service的代码retrofit.create(GithubService.class)\"></a>最终用来创建Service的代码<code>retrofit.create(GithubService.class)</code></h5><p>create()采用代理的方式进行创建，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断定义的接口服务是否可用</span></span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是Object本身的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是platform默认的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解析我们定义的网络请求的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loadServiceMethod(Method method)</code>源码解析,其实际上是HttpServiceMethod对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//从解析的缓存中获取</span></span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//RequestFactory负责解析接口并且生成Request</span></span><br><span class=\"line\">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//…………</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将一个接口方法转变为一个Http请求</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServiceMethod</span>&lt;<span class=\"title\">ResponseT</span>, <span class=\"title\">ReturnT</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">ReturnT</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">CallAdapter&lt;ResponseT, ReturnT&gt; <span class=\"title\">createCallAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123; <span class=\"comment\">// Wide exception range because factories are user code.</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> methodError(method, e, <span class=\"string\">\"Unable to create call adapter for %s\"</span>, returnType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//…………</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestFactory requestFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> okhttp3.Call.Factory callFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;ResponseBody, ResponseT&gt; responseConverter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HttpServiceMethod</span><span class=\"params\">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.requestFactory = requestFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callFactory = callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callAdapter = callAdapter;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.responseConverter = responseConverter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//代理调用的invoke最终会调用下面invoke方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callAdapter.adapt(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;&#125;)`最终调用的方法是OkhttpCall中的`call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkHttpCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">        Response&lt;T&gt; response;</span><br><span class=\"line\">        <span class=\"comment\">//……</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">          t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"Retrofit-框架使用\"><a href=\"#Retrofit-框架使用\" class=\"headerlink\" title=\"Retrofit 框架使用\"></a>Retrofit 框架使用</h2><h4 id=\"请求内容与返回值\"><a href=\"#请求内容与返回值\" class=\"headerlink\" title=\"请求内容与返回值\"></a>请求内容与返回值</h4><p>使用PostMan进行请求测试<br>请求：<code>https://api.github.com/search/repositories?q=android</code></p>","more":"<p>返回值：</p>\n<p>Header:<br><img src=\"/assets/Retrofit.png\" alt=\"\"></p>\n<p>Body:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"total_count\"</span>: <span class=\"number\">943593</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"incomplete_results\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"items\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">82128465</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"open-android\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">23095877</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDQ6VXNlcjIzMDk1ODc3\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"avatar_url\"</span>: <span class=\"string\">\"https://avatars2.githubusercontent.com/u/23095877?v=4\"</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"html_url\"</span>: <span class=\"string\">\"https://github.com/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"fork\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/repos/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">12544093</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"hmkcode/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"hmkcode\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">3790597</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引入Retrofit依赖\"><a href=\"#引入Retrofit依赖\" class=\"headerlink\" title=\"引入Retrofit依赖\"></a>引入Retrofit依赖</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:retrofit:2.5.0'</span></span><br><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义Repository-Bean类\"><a href=\"#根据返回的请求结果定义Repository-Bean类\" class=\"headerlink\" title=\"根据返回的请求结果定义Repository Bean类\"></a>根据返回的请求结果定义Repository Bean类</h4><p>返回的报文采用google.gson进行处理，金处理必要的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示Repo id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示RepoName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示完整名称</span></span><br><span class=\"line\">    <span class=\"comment\">//Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"full_name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fullName;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"根据返回的请求结果定义一次查询结果\"><a href=\"#根据返回的请求结果定义一次查询结果\" class=\"headerlink\" title=\"根据返回的请求结果定义一次查询结果\"></a>根据返回的请求结果定义一次查询结果</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SearchRepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示仓库数量</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"total_count\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示是否为完整结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> incompleteResults;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示持有的所有的仓库类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RepoBean&gt;items;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义网络请求API接口\"><a href=\"#定义网络请求API接口\" class=\"headerlink\" title=\"定义网络请求API接口\"></a>定义网络请求API接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//@Get注解，表示以Get方法发送网络请求</span></span><br><span class=\"line\">    <span class=\"comment\">//返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化Retrofit实例，生成接口实现类\"><a href=\"#初始化Retrofit实例，生成接口实现类\" class=\"headerlink\" title=\"初始化Retrofit实例，生成接口实现类\"></a>初始化Retrofit实例，生成接口实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)                   <span class=\"comment\">//设置网络请求的URL地址           </span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())   <span class=\"comment\">//设置数据解析器 </span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">githubService = retrofit.create(GithubService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//同步请求方式</span></span><br><span class=\"line\">    <span class=\"comment\">//call.request();</span></span><br><span class=\"line\">    <span class=\"comment\">//异步请求方式</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//输出请求结果 </span></span><br><span class=\"line\">          <span class=\"comment\">//  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());</span></span><br><span class=\"line\">           <span class=\"comment\">// List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"comment\">// repoBeans.addAll(response.body().getItems());</span></span><br><span class=\"line\">           <span class=\"comment\">// for (int i=repoBeans.size()-1;i&gt;=0;i--)&#123;</span></span><br><span class=\"line\">           <span class=\"comment\">//  LogUtils.printInfo(repoBeans.get(i).getFullName());</span></span><br><span class=\"line\">           <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将请求值的返回设为LiveData\"><a href=\"#将请求值的返回设为LiveData\" class=\"headerlink\" title=\"将请求值的返回设为LiveData\"></a>将请求值的返回设为LiveData</h4><p>将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">     <span class=\"function\">LiveData&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义LiveDataCallAdapterFactory </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">    Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; rawObserverType = getRawType(observerType);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(rawObserverType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义 LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">LiveData</span>&lt;<span class=\"title\">SearchRepoBean</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;SearchRepoBean&gt; <span class=\"title\">adapt</span><span class=\"params\">(<span class=\"keyword\">final</span> Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=<span class=\"keyword\">new</span> LiveData&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                    postValue((SearchRepoBean) response.body());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                    LogUtils.printInfo(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> searchRepoBeanLiveData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为Retrofit实例添加CallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">          .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)</span><br><span class=\"line\">          .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">          .addCallAdapterFactory(<span class=\"keyword\">new</span> LiveDataCallAdapterFactory())</span><br><span class=\"line\">          .build();</span><br></pre></td></tr></table></figure>\n<p>调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(SearchRepoBean searchRepoBean)</span> </span>&#123;                            </span><br><span class=\"line\">         <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"添加通用的响应实体\"><a href=\"#添加通用的响应实体\" class=\"headerlink\" title=\"添加通用的响应实体\"></a>添加通用的响应实体</h4><p>通过<code>LiveDataCallAdapter</code> 和<code>LiveDataCallAdapterFactory</code> 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为<code>SearchRepoBean</code>类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。</p>\n<p>定义一个通用的响应实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ApiResponseSuccess&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.isSuccessful()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiResponseSuccess&lt;T&gt;(response.body());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用于表示返回成功的值</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponseSuccess</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      /用于表示请求返回成功的内容，在本代码中是SearchRepoBean</span><br><span class=\"line\">      <span class=\"keyword\">private</span> T body;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiResponseSuccess</span><span class=\"params\">(T body)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getBody</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">        <span class=\"comment\">//return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//observerType为ApiResponse&lt;SearchRepoBean&gt;</span></span><br><span class=\"line\">        Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\">        <span class=\"comment\">//bodyType为SearchRepoBean</span></span><br><span class=\"line\">        Type bodyType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) observerType);</span><br><span class=\"line\">        LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(bodyType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>,<span class=\"title\">LiveData</span>&lt;<span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">R</span>&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(<span class=\"keyword\">final</span> Call&lt;R&gt; call) &#123;</span><br><span class=\"line\">            LiveData&lt;ApiResponse&lt;R&gt;&gt; result=<span class=\"keyword\">new</span> LiveData&lt;ApiResponse&lt;R&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                       postValue(<span class=\"keyword\">new</span> ApiResponse&lt;R&gt;().create(response));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                          <span class=\"comment\">//  LogUtils.printInfo(\"+++++!2312qwqweww31\");</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse)</span> </span>&#123;</span><br><span class=\"line\">        SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();</span><br><span class=\"line\">       <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h5 id=\"Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\"><a href=\"#Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\" class=\"headerlink\" title=\"Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍\"></a>Retrofit构建中的<code>.baseUrl(&quot;https://api.github.com/&quot;)</code>介绍</h5><p>Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(String baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"string\">\"\"</span>.equals(pathSegments.get(pathSegments.size() - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"baseUrl must end in /: \"</span> + baseUrl);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.baseUrl = baseUrl;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\"><a href=\"#Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\" class=\"headerlink\" title=\"Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())\"></a>Retrofit构建中的<code>.addConverterFactory(GsonConverterFactory.create())</code></h5><p>通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addConverterFactory</span><span class=\"params\">(Converter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">  converterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Converter接口源码，核心是<code>T convert(F value)</code>,将F类型的数据转换为T类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">F</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将F类型的数据转换为T类型</span></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">convert</span><span class=\"params\">(F value)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据数据类型创建Converter创建 Converter</span></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Type <span class=\"title\">getParameterUpperBound</span><span class=\"params\">(<span class=\"keyword\">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getRawType(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\"><a href=\"#Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\" class=\"headerlink\" title=\"Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())\"></a>Retrofit构建中的<code>.addCallAdapterFactory(new LiveDataCallAdapterFactory())</code></h5><p>用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addCallAdapterFactory</span><span class=\"params\">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">          callAdapterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"最终用来创建Service的代码retrofit-create-GithubService-class\"><a href=\"#最终用来创建Service的代码retrofit-create-GithubService-class\" class=\"headerlink\" title=\"最终用来创建Service的代码retrofit.create(GithubService.class)\"></a>最终用来创建Service的代码<code>retrofit.create(GithubService.class)</code></h5><p>create()采用代理的方式进行创建，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断定义的接口服务是否可用</span></span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是Object本身的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是platform默认的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解析我们定义的网络请求的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loadServiceMethod(Method method)</code>源码解析,其实际上是HttpServiceMethod对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//从解析的缓存中获取</span></span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//RequestFactory负责解析接口并且生成Request</span></span><br><span class=\"line\">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//…………</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将一个接口方法转变为一个Http请求</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServiceMethod</span>&lt;<span class=\"title\">ResponseT</span>, <span class=\"title\">ReturnT</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">ReturnT</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">CallAdapter&lt;ResponseT, ReturnT&gt; <span class=\"title\">createCallAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123; <span class=\"comment\">// Wide exception range because factories are user code.</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> methodError(method, e, <span class=\"string\">\"Unable to create call adapter for %s\"</span>, returnType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//…………</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestFactory requestFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> okhttp3.Call.Factory callFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;ResponseBody, ResponseT&gt; responseConverter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HttpServiceMethod</span><span class=\"params\">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.requestFactory = requestFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callFactory = callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callAdapter = callAdapter;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.responseConverter = responseConverter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//代理调用的invoke最终会调用下面invoke方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callAdapter.adapt(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;&#125;)`最终调用的方法是OkhttpCall中的`call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkHttpCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">        Response&lt;T&gt; response;</span><br><span class=\"line\">        <span class=\"comment\">//……</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">          t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"# 结构化组件介绍\n\n结构化组件\\(Android Architecture Components\\)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。\n\n* 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。\n* 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。\n* ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁\n* Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。\n\n## 结构化组件推荐\n\n结构化组件的工作原理介绍如图所示，\n\n* Entity\\(实体\\)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。\n* SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。\n* Dao：用于获取数据的Object，将Sql语句映射为`Funcation`，通常需要在`SQLite OpenHelper`中进行定义，但使用Room持久化层，只需调用方法即可，不需要再`SQLite OpenHelper`中进行定义。\n* Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在`SQLite Openhelper`中进行处理），Room数据库使用Dao来操作SQLite Database。\n* Repository：使用Repository来操作多种数据源。\n* ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，\n* LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。`LiveData`可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，`LiveData`可以自动感知与它相关的组件的生命周期的改变。\n\n","source":"_posts/Android/框架/AAC/Android Architecture Components.md","raw":"# 结构化组件介绍\n\n结构化组件\\(Android Architecture Components\\)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。\n\n* 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。\n* 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。\n* ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁\n* Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。\n\n## 结构化组件推荐\n\n结构化组件的工作原理介绍如图所示，\n\n* Entity\\(实体\\)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。\n* SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。\n* Dao：用于获取数据的Object，将Sql语句映射为`Funcation`，通常需要在`SQLite OpenHelper`中进行定义，但使用Room持久化层，只需调用方法即可，不需要再`SQLite OpenHelper`中进行定义。\n* Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在`SQLite Openhelper`中进行处理），Room数据库使用Dao来操作SQLite Database。\n* Repository：使用Repository来操作多种数据源。\n* ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，\n* LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。`LiveData`可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，`LiveData`可以自动感知与它相关的组件的生命周期的改变。\n\n","slug":"Android/框架/AAC/Android Architecture Components","published":1,"date":"2019-09-19T09:41:14.748Z","updated":"2019-09-19T09:41:14.748Z","title":"Android/框架/AAC/Android Architecture Components","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryia003pisui4q5d79i7","content":"<h1 id=\"结构化组件介绍\"><a href=\"#结构化组件介绍\" class=\"headerlink\" title=\"结构化组件介绍\"></a>结构化组件介绍</h1><p>结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。</p>\n<ul>\n<li>使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。</li>\n<li>使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。</li>\n<li>ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁</li>\n<li>Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。</li>\n</ul>\n<h2 id=\"结构化组件推荐\"><a href=\"#结构化组件推荐\" class=\"headerlink\" title=\"结构化组件推荐\"></a>结构化组件推荐</h2><p>结构化组件的工作原理介绍如图所示，</p>\n<ul>\n<li>Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。</li>\n<li>SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。</li>\n<li>Dao：用于获取数据的Object，将Sql语句映射为<code>Funcation</code>，通常需要在<code>SQLite OpenHelper</code>中进行定义，但使用Room持久化层，只需调用方法即可，不需要再<code>SQLite OpenHelper</code>中进行定义。</li>\n<li>Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在<code>SQLite Openhelper</code>中进行处理），Room数据库使用Dao来操作SQLite Database。</li>\n<li>Repository：使用Repository来操作多种数据源。</li>\n<li>ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，</li>\n<li>LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。<code>LiveData</code>可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，<code>LiveData</code>可以自动感知与它相关的组件的生命周期的改变。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"结构化组件介绍\"><a href=\"#结构化组件介绍\" class=\"headerlink\" title=\"结构化组件介绍\"></a>结构化组件介绍</h1><p>结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。</p>\n<ul>\n<li>使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。</li>\n<li>使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。</li>\n<li>ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁</li>\n<li>Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。</li>\n</ul>\n<h2 id=\"结构化组件推荐\"><a href=\"#结构化组件推荐\" class=\"headerlink\" title=\"结构化组件推荐\"></a>结构化组件推荐</h2><p>结构化组件的工作原理介绍如图所示，</p>\n<ul>\n<li>Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。</li>\n<li>SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。</li>\n<li>Dao：用于获取数据的Object，将Sql语句映射为<code>Funcation</code>，通常需要在<code>SQLite OpenHelper</code>中进行定义，但使用Room持久化层，只需调用方法即可，不需要再<code>SQLite OpenHelper</code>中进行定义。</li>\n<li>Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在<code>SQLite Openhelper</code>中进行处理），Room数据库使用Dao来操作SQLite Database。</li>\n<li>Repository：使用Repository来操作多种数据源。</li>\n<li>ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，</li>\n<li>LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。<code>LiveData</code>可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，<code>LiveData</code>可以自动感知与它相关的组件的生命周期的改变。</li>\n</ul>\n"},{"_content":"\n## Android生命周期感知组件详解\n\n使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 `onStart()` `onStop()`中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。\n\n### Lifecycle类\n\n![](/assets/lifecycle.png)\n\nLifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。\n\n* Event\n\n    由framework层分发的以及`Lifecycle`类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调\n\n* State\n   \n    表示由`Lifecycle`对象跟踪的组件的当前的状态\n    \n### LifecycleOwner\n\n`LifecycleOwner`是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。\n\n源码：\n\n```java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     *\n    @NonNull\n    Lifecycle getLifecycle();\n}\n\n```\n\n一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现`LifecycleOwner`接口。\n\n\n### LifecycleObserver\n\n`LifecycleObserver`接口可以与实现`LifecycleOwner`接口的类配合使用，实现`LifecycleOwner`接口的类提供`Lifecycle`，而`LifecycleObserver`可以注册至被观察者。\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/Android Lifecycle-Aware组件详解.md","raw":"\n## Android生命周期感知组件详解\n\n使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 `onStart()` `onStop()`中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。\n\n### Lifecycle类\n\n![](/assets/lifecycle.png)\n\nLifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。\n\n* Event\n\n    由framework层分发的以及`Lifecycle`类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调\n\n* State\n   \n    表示由`Lifecycle`对象跟踪的组件的当前的状态\n    \n### LifecycleOwner\n\n`LifecycleOwner`是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。\n\n源码：\n\n```java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     *\n    @NonNull\n    Lifecycle getLifecycle();\n}\n\n```\n\n一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现`LifecycleOwner`接口。\n\n\n### LifecycleObserver\n\n`LifecycleObserver`接口可以与实现`LifecycleOwner`接口的类配合使用，实现`LifecycleOwner`接口的类提供`Lifecycle`，而`LifecycleObserver`可以注册至被观察者。\n\n\n\n\n\n","slug":"Android/框架/AAC/Android Lifecycle-Aware组件详解","published":1,"date":"2019-11-28T12:20:15.895Z","updated":"2019-11-30T11:14:32.184Z","title":"Android/框架/AAC/Android Lifecycle-Aware组件详解","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryib003risui050ngruo","content":"<h2 id=\"Android生命周期感知组件详解\"><a href=\"#Android生命周期感知组件详解\" class=\"headerlink\" title=\"Android生命周期感知组件详解\"></a>Android生命周期感知组件详解</h2><p>使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 <code>onStart()</code> <code>onStop()</code>中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。</p>\n<h3 id=\"Lifecycle类\"><a href=\"#Lifecycle类\" class=\"headerlink\" title=\"Lifecycle类\"></a>Lifecycle类</h3><p><img src=\"/assets/lifecycle.png\" alt=\"\"></p>\n<p>Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。</p>\n<ul>\n<li><p>Event</p>\n<p>  由framework层分发的以及<code>Lifecycle</code>类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调</p>\n</li>\n<li><p>State</p>\n<p>  表示由<code>Lifecycle</code>对象跟踪的组件的当前的状态</p>\n</li>\n</ul>\n<h3 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h3><p><code>LifecycleOwner</code>是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">@NonNull</span></span></span><br><span class=\"line\"><span class=\"comment\">    Lifecycle getLifecycle();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现<code>LifecycleOwner</code>接口。</p>\n<h3 id=\"LifecycleObserver\"><a href=\"#LifecycleObserver\" class=\"headerlink\" title=\"LifecycleObserver\"></a>LifecycleObserver</h3><p><code>LifecycleObserver</code>接口可以与实现<code>LifecycleOwner</code>接口的类配合使用，实现<code>LifecycleOwner</code>接口的类提供<code>Lifecycle</code>，而<code>LifecycleObserver</code>可以注册至被观察者。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android生命周期感知组件详解\"><a href=\"#Android生命周期感知组件详解\" class=\"headerlink\" title=\"Android生命周期感知组件详解\"></a>Android生命周期感知组件详解</h2><p>使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 <code>onStart()</code> <code>onStop()</code>中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。</p>\n<h3 id=\"Lifecycle类\"><a href=\"#Lifecycle类\" class=\"headerlink\" title=\"Lifecycle类\"></a>Lifecycle类</h3><p><img src=\"/assets/lifecycle.png\" alt=\"\"></p>\n<p>Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。</p>\n<ul>\n<li><p>Event</p>\n<p>  由framework层分发的以及<code>Lifecycle</code>类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调</p>\n</li>\n<li><p>State</p>\n<p>  表示由<code>Lifecycle</code>对象跟踪的组件的当前的状态</p>\n</li>\n</ul>\n<h3 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h3><p><code>LifecycleOwner</code>是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">@NonNull</span></span></span><br><span class=\"line\"><span class=\"comment\">    Lifecycle getLifecycle();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现<code>LifecycleOwner</code>接口。</p>\n<h3 id=\"LifecycleObserver\"><a href=\"#LifecycleObserver\" class=\"headerlink\" title=\"LifecycleObserver\"></a>LifecycleObserver</h3><p><code>LifecycleObserver</code>接口可以与实现<code>LifecycleOwner</code>接口的类配合使用，实现<code>LifecycleOwner</code>接口的类提供<code>Lifecycle</code>，而<code>LifecycleObserver</code>可以注册至被观察者。</p>\n"},{"_content":"## Databinding点击事件的几种实现方式\n\n代码片段\n\n```\n    //BaseActivity中\n    public void click(View view){\n    }\n    \n    public void click1(){\n    }\n    \n    public void click2(int id){\n    }\n    \n    //xml文件中\n    <variable\n        name=\"activity\"\n        type=\".BaseActivity\" />\n    \n    <variable\n        name=\"user\"\n        type=\".User\" />\n    \n\n```\n\n### 1、@{activity.click}\n`click`函数带有参数\n\n```\n    <TextView\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"wrap_content\"\n         android:text=\"点击事件\"\n         android:onClick=\"@{activity.click}\"\n    />\n```\n\n### 2、@{()->activity.click()}\n`click`函数无参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click1()}\"\n    />\n```\n\n### 3、@{activity::click}\n`click`带参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{activity::click}\"\n    />\n```\n\n### 4、@{()->activity.click(user.id)}\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(user.id)}\"\n    />\n```\n\n### 5、@{()->activity.click(3)}\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(3)}\"\n    />\n```\n\n### 6、自定义View中DataBinding的点击事件\n\n\n\n### 7、在RecyclerView中的item添加点击事件\n\n```\n    // 按钮点击\n            holder.getBinding.getRoot().findViewById(R.id.btn_edit)\n            .setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    // todo\n                }\n            });\n\n```\n\n## DataBinding赋值操作\n\n方法一：\n\n\n\n\n\n## Databinding特殊用法\n```\n    <CheckBox\n        android:id=\"@+id/showName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n    <TextView\n        android:text=\"@{user.firstName}\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"@{showName.checked ? View.VISIBLE :             View.GONE}\"\n        />\n\n```\n\n## 注意事项\n\n**在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误**\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/DataBinding的使用.md","raw":"## Databinding点击事件的几种实现方式\n\n代码片段\n\n```\n    //BaseActivity中\n    public void click(View view){\n    }\n    \n    public void click1(){\n    }\n    \n    public void click2(int id){\n    }\n    \n    //xml文件中\n    <variable\n        name=\"activity\"\n        type=\".BaseActivity\" />\n    \n    <variable\n        name=\"user\"\n        type=\".User\" />\n    \n\n```\n\n### 1、@{activity.click}\n`click`函数带有参数\n\n```\n    <TextView\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"wrap_content\"\n         android:text=\"点击事件\"\n         android:onClick=\"@{activity.click}\"\n    />\n```\n\n### 2、@{()->activity.click()}\n`click`函数无参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click1()}\"\n    />\n```\n\n### 3、@{activity::click}\n`click`带参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{activity::click}\"\n    />\n```\n\n### 4、@{()->activity.click(user.id)}\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(user.id)}\"\n    />\n```\n\n### 5、@{()->activity.click(3)}\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(3)}\"\n    />\n```\n\n### 6、自定义View中DataBinding的点击事件\n\n\n\n### 7、在RecyclerView中的item添加点击事件\n\n```\n    // 按钮点击\n            holder.getBinding.getRoot().findViewById(R.id.btn_edit)\n            .setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    // todo\n                }\n            });\n\n```\n\n## DataBinding赋值操作\n\n方法一：\n\n\n\n\n\n## Databinding特殊用法\n```\n    <CheckBox\n        android:id=\"@+id/showName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n    <TextView\n        android:text=\"@{user.firstName}\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"@{showName.checked ? View.VISIBLE :             View.GONE}\"\n        />\n\n```\n\n## 注意事项\n\n**在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误**\n\n\n\n\n\n\n","slug":"Android/框架/AAC/DataBinding的使用","published":1,"date":"2019-09-30T07:19:02.853Z","updated":"2020-02-26T06:12:59.613Z","title":"Android/框架/AAC/DataBinding的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryic003sisui5hwxdj7e","content":"<h2 id=\"Databinding点击事件的几种实现方式\"><a href=\"#Databinding点击事件的几种实现方式\" class=\"headerlink\" title=\"Databinding点击事件的几种实现方式\"></a>Databinding点击事件的几种实现方式</h2><p>代码片段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;BaseActivity中</span><br><span class=\"line\">public void click(View view)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click1()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click2(int id)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;xml文件中</span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;activity&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.BaseActivity&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;user&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.User&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、-activity-click\"><a href=\"#1、-activity-click\" class=\"headerlink\" title=\"1、@{activity.click}\"></a>1、@{activity.click}</h3><p><code>click</code>函数带有参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">     android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">     android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">     android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">     android:onClick&#x3D;&quot;@&#123;activity.click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、-gt-activity-click\"><a href=\"#2、-gt-activity-click\" class=\"headerlink\" title=\"2、@{()-&gt;activity.click()}\"></a>2、@{()-&gt;activity.click()}</h3><p><code>click</code>函数无参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click1()&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、-activity-click\"><a href=\"#3、-activity-click\" class=\"headerlink\" title=\"3、@{activity::click}\"></a>3、@{activity::click}</h3><p><code>click</code>带参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;activity::click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、-gt-activity-click-user-id\"><a href=\"#4、-gt-activity-click-user-id\" class=\"headerlink\" title=\"4、@{()-&gt;activity.click(user.id)}\"></a>4、@{()-&gt;activity.click(user.id)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(user.id)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、-gt-activity-click-3\"><a href=\"#5、-gt-activity-click-3\" class=\"headerlink\" title=\"5、@{()-&gt;activity.click(3)}\"></a>5、@{()-&gt;activity.click(3)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(3)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、自定义View中DataBinding的点击事件\"><a href=\"#6、自定义View中DataBinding的点击事件\" class=\"headerlink\" title=\"6、自定义View中DataBinding的点击事件\"></a>6、自定义View中DataBinding的点击事件</h3><h3 id=\"7、在RecyclerView中的item添加点击事件\"><a href=\"#7、在RecyclerView中的item添加点击事件\" class=\"headerlink\" title=\"7、在RecyclerView中的item添加点击事件\"></a>7、在RecyclerView中的item添加点击事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 按钮点击</span><br><span class=\"line\">        holder.getBinding.getRoot().findViewById(R.id.btn_edit)</span><br><span class=\"line\">        .setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; todo</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DataBinding赋值操作\"><a href=\"#DataBinding赋值操作\" class=\"headerlink\" title=\"DataBinding赋值操作\"></a>DataBinding赋值操作</h2><p>方法一：</p>\n<h2 id=\"Databinding特殊用法\"><a href=\"#Databinding特殊用法\" class=\"headerlink\" title=\"Databinding特殊用法\"></a>Databinding特殊用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CheckBox</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;showName&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility&#x3D;&quot;@&#123;showName.checked ? View.VISIBLE :             View.GONE&#125;&quot;</span><br><span class=\"line\">    &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Databinding点击事件的几种实现方式\"><a href=\"#Databinding点击事件的几种实现方式\" class=\"headerlink\" title=\"Databinding点击事件的几种实现方式\"></a>Databinding点击事件的几种实现方式</h2><p>代码片段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;BaseActivity中</span><br><span class=\"line\">public void click(View view)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click1()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click2(int id)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;xml文件中</span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;activity&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.BaseActivity&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;user&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.User&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、-activity-click\"><a href=\"#1、-activity-click\" class=\"headerlink\" title=\"1、@{activity.click}\"></a>1、@{activity.click}</h3><p><code>click</code>函数带有参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">     android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">     android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">     android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">     android:onClick&#x3D;&quot;@&#123;activity.click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、-gt-activity-click\"><a href=\"#2、-gt-activity-click\" class=\"headerlink\" title=\"2、@{()-&gt;activity.click()}\"></a>2、@{()-&gt;activity.click()}</h3><p><code>click</code>函数无参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click1()&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、-activity-click\"><a href=\"#3、-activity-click\" class=\"headerlink\" title=\"3、@{activity::click}\"></a>3、@{activity::click}</h3><p><code>click</code>带参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;activity::click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、-gt-activity-click-user-id\"><a href=\"#4、-gt-activity-click-user-id\" class=\"headerlink\" title=\"4、@{()-&gt;activity.click(user.id)}\"></a>4、@{()-&gt;activity.click(user.id)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(user.id)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、-gt-activity-click-3\"><a href=\"#5、-gt-activity-click-3\" class=\"headerlink\" title=\"5、@{()-&gt;activity.click(3)}\"></a>5、@{()-&gt;activity.click(3)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(3)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、自定义View中DataBinding的点击事件\"><a href=\"#6、自定义View中DataBinding的点击事件\" class=\"headerlink\" title=\"6、自定义View中DataBinding的点击事件\"></a>6、自定义View中DataBinding的点击事件</h3><h3 id=\"7、在RecyclerView中的item添加点击事件\"><a href=\"#7、在RecyclerView中的item添加点击事件\" class=\"headerlink\" title=\"7、在RecyclerView中的item添加点击事件\"></a>7、在RecyclerView中的item添加点击事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 按钮点击</span><br><span class=\"line\">        holder.getBinding.getRoot().findViewById(R.id.btn_edit)</span><br><span class=\"line\">        .setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; todo</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DataBinding赋值操作\"><a href=\"#DataBinding赋值操作\" class=\"headerlink\" title=\"DataBinding赋值操作\"></a>DataBinding赋值操作</h2><p>方法一：</p>\n<h2 id=\"Databinding特殊用法\"><a href=\"#Databinding特殊用法\" class=\"headerlink\" title=\"Databinding特殊用法\"></a>Databinding特殊用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CheckBox</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;showName&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility&#x3D;&quot;@&#123;showName.checked ? View.VISIBLE :             View.GONE&#125;&quot;</span><br><span class=\"line\">    &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误</strong></p>\n"},{"_content":"\n\n## LiveData介绍\n`LiveData`是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。`LiveData`是一个抽象类，其继承关系如下：\n\n![](/assets/livedata.png)\n\n#### LiveData的优势\n* 保证UI界面与数据相匹配\n* 无内存泄漏\n    \n    观察者绑定至`Lifecycle`，当观察者的生命周期结束后，其会自动清理\n* 不会由于Activity stop而发生崩溃\n\n    如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据\n* 合理的数据配置\n         \n    如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 \n* 数据共享\n\n    可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。\n\n### 在具有生命周期的对象中使用LiveData\n\n#### 定义被观察者\n在定义被观察者对象时通常使用`MutableLiveData`类，在Activity中定义一个被观察的对象：\n\n```java\n  \n    MutableLiveData<String> mutableLiveData=new MutableLiveData<>();\n\n```\n\n#### 注册观察者：\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mutableLiveData.observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String s) {\n                Log.i(\"输出数据：\",s);\n            }\n        });\n    }\n```\n\n被观察者`mutableLiveData`的数据修改有两种方式：`setValue(T value)`和`postValue(T value) `。当被观察者数据在UI主线程中进行修改时，使用`setValue(T value)`，当被观察者在子线程中使用时，使用`postValue(T value) `；\n\n#### 通过`setValue(T value)`修改被观察者并通知观察者\n\n```\n    mutableLiveData.setValue(\"TEST\");\n```\n\n`setValue(T value)`源码：\n```java\n    @MainThread\n    protected void setValue(T value) {\n        assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常\n        mVersion++;\n        mData = value;\n        dispatchingValue(null);  //用于数据分发通知观察者\n    }\n\n```\n在`setValue(T value)`中调用`dispatchingValue(null)`，用于通知观察者。\n\n`dispatchingValue(@Nullable ObserverWrapper initiator)`源码\n```java\n    //参数ObserverWrapper是每一个观察者的封装\n    void dispatchingValue(@Nullable ObserverWrapper initiator) {\n       \n        //...\n        do {\n            mDispatchInvalidated = false;\n                //...\n                //遍历所有的观察者，并进行通知\n                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                    //considerNotify用于通知观察者\n                    considerNotify(iterator.next().getValue());\n                    if (mDispatchInvalidated) {\n                        break;\n                    }\n            }\n        } while (mDispatchInvalidated);\n        mDispatchingValue = false;\n    }\n\n```\n\n在`dispatchingValue(@Nullable ObserverWrapper initiator)`方法中调用`considerNotify(ObserverWrapper observer)`通知观察者\n\n```java\n    private void considerNotify(ObserverWrapper observer) {\n        if (!observer.mActive) {\n            return;\n        }\n        if (!observer.shouldBeActive()) {\n            observer.activeStateChanged(false);\n            return;\n        }\n        if (observer.mLastVersion >= mVersion) {\n            return;\n        }\n        observer.mLastVersion = mVersion;\n        observer.mObserver.onChanged((T) mData);\n    }\n```\n\n\n#### 通过`postValue(T value) `修改被观察者并通知观察者\n\n```\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                mutableLiveData.postValue(\"TEST\");\n            }\n        }).start();\n\n```\n\n`postValue(T value) `源码：\n\n```java\n    protected void postValue(T value) {\n        boolean postTask;\n        synchronized (mDataLock) {\n            postTask = mPendingData == NOT_SET;\n            mPendingData = value;\n        }\n        if (!postTask) {\n            return;\n        }\n        \n        //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n```\n`mPostValueRunnable`源码：\n```java\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            //...\n            //依然是调用setValue对数据进行修改\n            setValue((T) newValue);\n        }\n    };\n\n```\n\n#### 在不具有生命周期的对象中使用LiveData\n\n```\n    public class TestLiveDataBean {\n\n        MutableLiveData<String> mutableLiveData = new MutableLiveData<>();\n        \n        Observer<String> observer;\n\n        public TestLiveDataBean() {\n            observer = new Observer<String>() {\n                @Override\n                public void onChanged(String s) {\n                    LogUtils.printInfo(s);\n                }\n            };\n            //添加观察者\n            mutableLiveData.observeForever(observer);\n        }\n\n        public void setValue() {\n            //无论setValue是否在UI主线程中，都可以用postValue\n            mutableLiveData.postValue(\"测试\");\n            //当在子线程中调用setValue报错\n            //mutableLiveData.setValue(\"测试\");\n        }\n    \n          public void removeObserver() {\n            mutableLiveData.removeObserver(observer);\n        }\n    }\n\n```\n`observeForever()`与`removeOberver()`方法需要成对进行使用，通过`observeForever()`方法添加观察者，该方法只能在主线程中调用;\n\n```java\n\n    @MainThread\n    public void observeForever(@NonNull Observer<? super T> observer) {\n        assertMainThread(\"observeForever\");\n        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        if (existing instanceof LiveData.LifecycleBoundObserver) {\n            throw new IllegalArgumentException(\"Cannot add the same observer\"\n                    + \" with different lifecycles\");\n        }\n        if (existing != null) {\n            return;\n        }\n        wrapper.activeStateChanged(true);\n    }\n\n```\n\n\n观察者使用完毕后，需要通过`removeOberver()`方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用\n\n`removeObserver(@NonNull final Observer<? super T> observer)`源码：\n```java\n\n    @MainThread\n    public void removeObserver(@NonNull final Observer<? super T> observer) {\n        assertMainThread(\"removeObserver\");\n        ObserverWrapper removed = mObservers.remove(observer);\n        if (removed == null) {\n            return;\n        }\n        removed.detachObserver();\n        removed.activeStateChanged(false);\n    }\n\n\n```\n\n### MediatorLiveData介绍\n\n`MediatorLiveData`是`LiveData`的一个子类，可以将`LiveData`的数据源合并至一起；当任一`LiveData`数据源的数据发生改变后，都会触发`MediatorLiveData`的观察者。\n\n\n### 继承LiveData进行数据共享\n\n\n","source":"_posts/Android/框架/AAC/Android Livedata详解.md","raw":"\n\n## LiveData介绍\n`LiveData`是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。`LiveData`是一个抽象类，其继承关系如下：\n\n![](/assets/livedata.png)\n\n#### LiveData的优势\n* 保证UI界面与数据相匹配\n* 无内存泄漏\n    \n    观察者绑定至`Lifecycle`，当观察者的生命周期结束后，其会自动清理\n* 不会由于Activity stop而发生崩溃\n\n    如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据\n* 合理的数据配置\n         \n    如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 \n* 数据共享\n\n    可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。\n\n### 在具有生命周期的对象中使用LiveData\n\n#### 定义被观察者\n在定义被观察者对象时通常使用`MutableLiveData`类，在Activity中定义一个被观察的对象：\n\n```java\n  \n    MutableLiveData<String> mutableLiveData=new MutableLiveData<>();\n\n```\n\n#### 注册观察者：\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mutableLiveData.observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String s) {\n                Log.i(\"输出数据：\",s);\n            }\n        });\n    }\n```\n\n被观察者`mutableLiveData`的数据修改有两种方式：`setValue(T value)`和`postValue(T value) `。当被观察者数据在UI主线程中进行修改时，使用`setValue(T value)`，当被观察者在子线程中使用时，使用`postValue(T value) `；\n\n#### 通过`setValue(T value)`修改被观察者并通知观察者\n\n```\n    mutableLiveData.setValue(\"TEST\");\n```\n\n`setValue(T value)`源码：\n```java\n    @MainThread\n    protected void setValue(T value) {\n        assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常\n        mVersion++;\n        mData = value;\n        dispatchingValue(null);  //用于数据分发通知观察者\n    }\n\n```\n在`setValue(T value)`中调用`dispatchingValue(null)`，用于通知观察者。\n\n`dispatchingValue(@Nullable ObserverWrapper initiator)`源码\n```java\n    //参数ObserverWrapper是每一个观察者的封装\n    void dispatchingValue(@Nullable ObserverWrapper initiator) {\n       \n        //...\n        do {\n            mDispatchInvalidated = false;\n                //...\n                //遍历所有的观察者，并进行通知\n                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                    //considerNotify用于通知观察者\n                    considerNotify(iterator.next().getValue());\n                    if (mDispatchInvalidated) {\n                        break;\n                    }\n            }\n        } while (mDispatchInvalidated);\n        mDispatchingValue = false;\n    }\n\n```\n\n在`dispatchingValue(@Nullable ObserverWrapper initiator)`方法中调用`considerNotify(ObserverWrapper observer)`通知观察者\n\n```java\n    private void considerNotify(ObserverWrapper observer) {\n        if (!observer.mActive) {\n            return;\n        }\n        if (!observer.shouldBeActive()) {\n            observer.activeStateChanged(false);\n            return;\n        }\n        if (observer.mLastVersion >= mVersion) {\n            return;\n        }\n        observer.mLastVersion = mVersion;\n        observer.mObserver.onChanged((T) mData);\n    }\n```\n\n\n#### 通过`postValue(T value) `修改被观察者并通知观察者\n\n```\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                mutableLiveData.postValue(\"TEST\");\n            }\n        }).start();\n\n```\n\n`postValue(T value) `源码：\n\n```java\n    protected void postValue(T value) {\n        boolean postTask;\n        synchronized (mDataLock) {\n            postTask = mPendingData == NOT_SET;\n            mPendingData = value;\n        }\n        if (!postTask) {\n            return;\n        }\n        \n        //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n```\n`mPostValueRunnable`源码：\n```java\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            //...\n            //依然是调用setValue对数据进行修改\n            setValue((T) newValue);\n        }\n    };\n\n```\n\n#### 在不具有生命周期的对象中使用LiveData\n\n```\n    public class TestLiveDataBean {\n\n        MutableLiveData<String> mutableLiveData = new MutableLiveData<>();\n        \n        Observer<String> observer;\n\n        public TestLiveDataBean() {\n            observer = new Observer<String>() {\n                @Override\n                public void onChanged(String s) {\n                    LogUtils.printInfo(s);\n                }\n            };\n            //添加观察者\n            mutableLiveData.observeForever(observer);\n        }\n\n        public void setValue() {\n            //无论setValue是否在UI主线程中，都可以用postValue\n            mutableLiveData.postValue(\"测试\");\n            //当在子线程中调用setValue报错\n            //mutableLiveData.setValue(\"测试\");\n        }\n    \n          public void removeObserver() {\n            mutableLiveData.removeObserver(observer);\n        }\n    }\n\n```\n`observeForever()`与`removeOberver()`方法需要成对进行使用，通过`observeForever()`方法添加观察者，该方法只能在主线程中调用;\n\n```java\n\n    @MainThread\n    public void observeForever(@NonNull Observer<? super T> observer) {\n        assertMainThread(\"observeForever\");\n        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        if (existing instanceof LiveData.LifecycleBoundObserver) {\n            throw new IllegalArgumentException(\"Cannot add the same observer\"\n                    + \" with different lifecycles\");\n        }\n        if (existing != null) {\n            return;\n        }\n        wrapper.activeStateChanged(true);\n    }\n\n```\n\n\n观察者使用完毕后，需要通过`removeOberver()`方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用\n\n`removeObserver(@NonNull final Observer<? super T> observer)`源码：\n```java\n\n    @MainThread\n    public void removeObserver(@NonNull final Observer<? super T> observer) {\n        assertMainThread(\"removeObserver\");\n        ObserverWrapper removed = mObservers.remove(observer);\n        if (removed == null) {\n            return;\n        }\n        removed.detachObserver();\n        removed.activeStateChanged(false);\n    }\n\n\n```\n\n### MediatorLiveData介绍\n\n`MediatorLiveData`是`LiveData`的一个子类，可以将`LiveData`的数据源合并至一起；当任一`LiveData`数据源的数据发生改变后，都会触发`MediatorLiveData`的观察者。\n\n\n### 继承LiveData进行数据共享\n\n\n","slug":"Android/框架/AAC/Android Livedata详解","published":1,"date":"2019-11-28T12:20:15.896Z","updated":"2020-02-26T06:12:59.606Z","title":"Android/框架/AAC/Android Livedata详解","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryic003uisui7wwzhnkt","content":"<h2 id=\"LiveData介绍\"><a href=\"#LiveData介绍\" class=\"headerlink\" title=\"LiveData介绍\"></a>LiveData介绍</h2><p><code>LiveData</code>是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。<code>LiveData</code>是一个抽象类，其继承关系如下：</p>\n<p><img src=\"/assets/livedata.png\" alt=\"\"></p>\n<h4 id=\"LiveData的优势\"><a href=\"#LiveData的优势\" class=\"headerlink\" title=\"LiveData的优势\"></a>LiveData的优势</h4><ul>\n<li><p>保证UI界面与数据相匹配</p>\n</li>\n<li><p>无内存泄漏</p>\n<p>  观察者绑定至<code>Lifecycle</code>，当观察者的生命周期结束后，其会自动清理</p>\n</li>\n<li><p>不会由于Activity stop而发生崩溃</p>\n<p>  如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据</p>\n</li>\n<li><p>合理的数据配置</p>\n<p>  如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 </p>\n</li>\n<li><p>数据共享</p>\n<p>  可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。</p>\n</li>\n</ul>\n<h3 id=\"在具有生命周期的对象中使用LiveData\"><a href=\"#在具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在具有生命周期的对象中使用LiveData\"></a>在具有生命周期的对象中使用LiveData</h3><h4 id=\"定义被观察者\"><a href=\"#定义被观察者\" class=\"headerlink\" title=\"定义被观察者\"></a>定义被观察者</h4><p>在定义被观察者对象时通常使用<code>MutableLiveData</code>类，在Activity中定义一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">MutableLiveData&lt;String&gt; mutableLiveData=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注册观察者：\"><a href=\"#注册观察者：\" class=\"headerlink\" title=\"注册观察者：\"></a>注册观察者：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    mutableLiveData.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">            Log.i(<span class=\"string\">\"输出数据：\"</span>,s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者<code>mutableLiveData</code>的数据修改有两种方式：<code>setValue(T value)</code>和<code>postValue(T value)</code>。当被观察者数据在UI主线程中进行修改时，使用<code>setValue(T value)</code>，当被观察者在子线程中使用时，使用<code>postValue(T value)</code>；</p>\n<h4 id=\"通过setValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过setValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过setValue(T value)修改被观察者并通知观察者\"></a>通过<code>setValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableLiveData.setValue(&quot;TEST&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><code>setValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>); <span class=\"comment\">//用于判断是否在主线程，否则抛出异常</span></span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);  <span class=\"comment\">//用于数据分发通知观察者</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>setValue(T value)</code>中调用<code>dispatchingValue(null)</code>，用于通知观察者。</p>\n<p><code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//参数ObserverWrapper是每一个观察者的封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"comment\">//遍历所有的观察者，并进行通知</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//considerNotify用于通知观察者</span></span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>方法中调用<code>considerNotify(ObserverWrapper observer)</code>通知观察者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"通过postValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过postValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过postValue(T value)修改被观察者并通知观察者\"></a>通过<code>postValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;TEST&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><code>postValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;</span><br><span class=\"line\">        mPendingData = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行</span></span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mPostValueRunnable</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//依然是调用setValue对数据进行修改</span></span><br><span class=\"line\">        setValue((T) newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在不具有生命周期的对象中使用LiveData\"><a href=\"#在不具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在不具有生命周期的对象中使用LiveData\"></a>在不具有生命周期的对象中使用LiveData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestLiveDataBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MutableLiveData&lt;String&gt; mutableLiveData &#x3D; new MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Observer&lt;String&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestLiveDataBean() &#123;</span><br><span class=\"line\">        observer &#x3D; new Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onChanged(String s) &#123;</span><br><span class=\"line\">                LogUtils.printInfo(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F;添加观察者</span><br><span class=\"line\">        mutableLiveData.observeForever(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setValue() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;无论setValue是否在UI主线程中，都可以用postValue</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;测试&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;当在子线程中调用setValue报错</span><br><span class=\"line\">        &#x2F;&#x2F;mutableLiveData.setValue(&quot;测试&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public void removeObserver() &#123;</span><br><span class=\"line\">        mutableLiveData.removeObserver(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>observeForever()</code>与<code>removeOberver()</code>方法需要成对进行使用，通过<code>observeForever()</code>方法添加观察者，该方法只能在主线程中调用;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"observeForever\"</span>);</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing <span class=\"keyword\">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span></span><br><span class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>观察者使用完毕后，需要通过<code>removeOberver()</code>方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用</p>\n<p><code>removeObserver(@NonNull final Observer&lt;? super T&gt; observer)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"removeObserver\"</span>);</span><br><span class=\"line\">    ObserverWrapper removed = mObservers.remove(observer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    removed.detachObserver();</span><br><span class=\"line\">    removed.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MediatorLiveData介绍\"><a href=\"#MediatorLiveData介绍\" class=\"headerlink\" title=\"MediatorLiveData介绍\"></a>MediatorLiveData介绍</h3><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，可以将<code>LiveData</code>的数据源合并至一起；当任一<code>LiveData</code>数据源的数据发生改变后，都会触发<code>MediatorLiveData</code>的观察者。</p>\n<h3 id=\"继承LiveData进行数据共享\"><a href=\"#继承LiveData进行数据共享\" class=\"headerlink\" title=\"继承LiveData进行数据共享\"></a>继承LiveData进行数据共享</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LiveData介绍\"><a href=\"#LiveData介绍\" class=\"headerlink\" title=\"LiveData介绍\"></a>LiveData介绍</h2><p><code>LiveData</code>是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。<code>LiveData</code>是一个抽象类，其继承关系如下：</p>\n<p><img src=\"/assets/livedata.png\" alt=\"\"></p>\n<h4 id=\"LiveData的优势\"><a href=\"#LiveData的优势\" class=\"headerlink\" title=\"LiveData的优势\"></a>LiveData的优势</h4><ul>\n<li><p>保证UI界面与数据相匹配</p>\n</li>\n<li><p>无内存泄漏</p>\n<p>  观察者绑定至<code>Lifecycle</code>，当观察者的生命周期结束后，其会自动清理</p>\n</li>\n<li><p>不会由于Activity stop而发生崩溃</p>\n<p>  如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据</p>\n</li>\n<li><p>合理的数据配置</p>\n<p>  如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 </p>\n</li>\n<li><p>数据共享</p>\n<p>  可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。</p>\n</li>\n</ul>\n<h3 id=\"在具有生命周期的对象中使用LiveData\"><a href=\"#在具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在具有生命周期的对象中使用LiveData\"></a>在具有生命周期的对象中使用LiveData</h3><h4 id=\"定义被观察者\"><a href=\"#定义被观察者\" class=\"headerlink\" title=\"定义被观察者\"></a>定义被观察者</h4><p>在定义被观察者对象时通常使用<code>MutableLiveData</code>类，在Activity中定义一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">MutableLiveData&lt;String&gt; mutableLiveData=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注册观察者：\"><a href=\"#注册观察者：\" class=\"headerlink\" title=\"注册观察者：\"></a>注册观察者：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    mutableLiveData.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">            Log.i(<span class=\"string\">\"输出数据：\"</span>,s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者<code>mutableLiveData</code>的数据修改有两种方式：<code>setValue(T value)</code>和<code>postValue(T value)</code>。当被观察者数据在UI主线程中进行修改时，使用<code>setValue(T value)</code>，当被观察者在子线程中使用时，使用<code>postValue(T value)</code>；</p>\n<h4 id=\"通过setValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过setValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过setValue(T value)修改被观察者并通知观察者\"></a>通过<code>setValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableLiveData.setValue(&quot;TEST&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><code>setValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>); <span class=\"comment\">//用于判断是否在主线程，否则抛出异常</span></span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);  <span class=\"comment\">//用于数据分发通知观察者</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>setValue(T value)</code>中调用<code>dispatchingValue(null)</code>，用于通知观察者。</p>\n<p><code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//参数ObserverWrapper是每一个观察者的封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"comment\">//遍历所有的观察者，并进行通知</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//considerNotify用于通知观察者</span></span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>方法中调用<code>considerNotify(ObserverWrapper observer)</code>通知观察者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"通过postValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过postValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过postValue(T value)修改被观察者并通知观察者\"></a>通过<code>postValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;TEST&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><code>postValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;</span><br><span class=\"line\">        mPendingData = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行</span></span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mPostValueRunnable</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//依然是调用setValue对数据进行修改</span></span><br><span class=\"line\">        setValue((T) newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在不具有生命周期的对象中使用LiveData\"><a href=\"#在不具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在不具有生命周期的对象中使用LiveData\"></a>在不具有生命周期的对象中使用LiveData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestLiveDataBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MutableLiveData&lt;String&gt; mutableLiveData &#x3D; new MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Observer&lt;String&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestLiveDataBean() &#123;</span><br><span class=\"line\">        observer &#x3D; new Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onChanged(String s) &#123;</span><br><span class=\"line\">                LogUtils.printInfo(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F;添加观察者</span><br><span class=\"line\">        mutableLiveData.observeForever(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setValue() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;无论setValue是否在UI主线程中，都可以用postValue</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;测试&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;当在子线程中调用setValue报错</span><br><span class=\"line\">        &#x2F;&#x2F;mutableLiveData.setValue(&quot;测试&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public void removeObserver() &#123;</span><br><span class=\"line\">        mutableLiveData.removeObserver(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>observeForever()</code>与<code>removeOberver()</code>方法需要成对进行使用，通过<code>observeForever()</code>方法添加观察者，该方法只能在主线程中调用;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"observeForever\"</span>);</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing <span class=\"keyword\">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span></span><br><span class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>观察者使用完毕后，需要通过<code>removeOberver()</code>方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用</p>\n<p><code>removeObserver(@NonNull final Observer&lt;? super T&gt; observer)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"removeObserver\"</span>);</span><br><span class=\"line\">    ObserverWrapper removed = mObservers.remove(observer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    removed.detachObserver();</span><br><span class=\"line\">    removed.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MediatorLiveData介绍\"><a href=\"#MediatorLiveData介绍\" class=\"headerlink\" title=\"MediatorLiveData介绍\"></a>MediatorLiveData介绍</h3><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，可以将<code>LiveData</code>的数据源合并至一起；当任一<code>LiveData</code>数据源的数据发生改变后，都会触发<code>MediatorLiveData</code>的观察者。</p>\n<h3 id=\"继承LiveData进行数据共享\"><a href=\"#继承LiveData进行数据共享\" class=\"headerlink\" title=\"继承LiveData进行数据共享\"></a>继承LiveData进行数据共享</h3>"},{"_content":"# Android框架组件paging+room的使用\n\n## 简介：\n\n### DataSource\n\nDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，\n\n\n创建一个`PagedList`被观察者的对象，需要将一个`DataSource.Factory`的实例传递给`LivePagedListBuilder`对象。一个DataSource对象为单一的`PagedList`加载pages。当数据更新时，工厂类会创建一个`PagedSource`的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供`DataSource.Factory`对象，或者可以自己创建`DataSource.Factory`\n\nRoom持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：\n\n```java\n@Query(\"SELECT * FROM COUNTRIES\")\npublic abstract DataSource.Factory<Integer,Country> getCountries();\n```\n\n### PagedList\n\nPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。\n\n### PagedListAdapter\n\nPagedListAdapter是一个`RecyclerView.Adapter`用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？\n\n## 将架构组件添加到项目中\n\n在build.gradle中添加下面的依赖\n\n```markup\n    //recyclerView\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n\n    // ViewModel and LiveData\n    implementation \"android.arch.lifecycle:extensions:1.1.1\"\n    annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"\n\n   // Room\n    implementation \"android.arch.persistence.room:runtime:1.1.1\"\n    annotationProcessor \"android.arch.persistence.room:compiler:1.1.1\"\n\n    // Paging\n    implementation \"android.arch.paging:runtime:1.0.1\"\n```\n\n## 创建DataSource\n\n### 创建实体\n\n### 创建Dao层\n\nDataSource.Factory\\(在Room中实现\\)创建\n\n### 创建数据库\n\n### 创建ViewModel\n\nLivePagedListBuilder会使用\n\nLivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。\n\n创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：\n\n* setPageSize\\(int\\)：\n* setPrefetchDistance\\(int\\)：\n* setInitialLoadSizeHint\\(int\\)：设置页面中第一次显示的数量\n* setEnablePlaceholders\\(boolean\\) ：\n\n在`onCreate`方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。\n\n## 创建Adapter\n\n使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用`DiffCallback`来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：\n\n* areItemsTheSame:判断是否指向了同一个数据元素。\n* areContentsTheSame:判断\n\n","source":"_posts/Android/框架/AAC/Paging和Room使用.md","raw":"# Android框架组件paging+room的使用\n\n## 简介：\n\n### DataSource\n\nDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，\n\n\n创建一个`PagedList`被观察者的对象，需要将一个`DataSource.Factory`的实例传递给`LivePagedListBuilder`对象。一个DataSource对象为单一的`PagedList`加载pages。当数据更新时，工厂类会创建一个`PagedSource`的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供`DataSource.Factory`对象，或者可以自己创建`DataSource.Factory`\n\nRoom持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：\n\n```java\n@Query(\"SELECT * FROM COUNTRIES\")\npublic abstract DataSource.Factory<Integer,Country> getCountries();\n```\n\n### PagedList\n\nPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。\n\n### PagedListAdapter\n\nPagedListAdapter是一个`RecyclerView.Adapter`用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？\n\n## 将架构组件添加到项目中\n\n在build.gradle中添加下面的依赖\n\n```markup\n    //recyclerView\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n\n    // ViewModel and LiveData\n    implementation \"android.arch.lifecycle:extensions:1.1.1\"\n    annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"\n\n   // Room\n    implementation \"android.arch.persistence.room:runtime:1.1.1\"\n    annotationProcessor \"android.arch.persistence.room:compiler:1.1.1\"\n\n    // Paging\n    implementation \"android.arch.paging:runtime:1.0.1\"\n```\n\n## 创建DataSource\n\n### 创建实体\n\n### 创建Dao层\n\nDataSource.Factory\\(在Room中实现\\)创建\n\n### 创建数据库\n\n### 创建ViewModel\n\nLivePagedListBuilder会使用\n\nLivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。\n\n创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：\n\n* setPageSize\\(int\\)：\n* setPrefetchDistance\\(int\\)：\n* setInitialLoadSizeHint\\(int\\)：设置页面中第一次显示的数量\n* setEnablePlaceholders\\(boolean\\) ：\n\n在`onCreate`方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。\n\n## 创建Adapter\n\n使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用`DiffCallback`来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：\n\n* areItemsTheSame:判断是否指向了同一个数据元素。\n* areContentsTheSame:判断\n\n","slug":"Android/框架/AAC/Paging和Room使用","published":1,"date":"2019-09-30T07:19:02.865Z","updated":"2019-09-30T08:28:42.964Z","title":"Android/框架/AAC/Paging和Room使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryic003visui8z2r73n6","content":"<h1 id=\"Android框架组件paging-room的使用\"><a href=\"#Android框架组件paging-room的使用\" class=\"headerlink\" title=\"Android框架组件paging+room的使用\"></a>Android框架组件paging+room的使用</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><h3 id=\"DataSource\"><a href=\"#DataSource\" class=\"headerlink\" title=\"DataSource\"></a>DataSource</h3><p>DataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，</p>\n<p>创建一个<code>PagedList</code>被观察者的对象，需要将一个<code>DataSource.Factory</code>的实例传递给<code>LivePagedListBuilder</code>对象。一个DataSource对象为单一的<code>PagedList</code>加载pages。当数据更新时，工厂类会创建一个<code>PagedSource</code>的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供<code>DataSource.Factory</code>对象，或者可以自己创建<code>DataSource.Factory</code></p>\n<p>Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * FROM COUNTRIES\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DataSource.<span class=\"function\">Factory&lt;Integer,Country&gt; <span class=\"title\">getCountries</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PagedList\"><a href=\"#PagedList\" class=\"headerlink\" title=\"PagedList\"></a>PagedList</h3><p>PagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。</p>\n<h3 id=\"PagedListAdapter\"><a href=\"#PagedListAdapter\" class=\"headerlink\" title=\"PagedListAdapter\"></a>PagedListAdapter</h3><p>PagedListAdapter是一个<code>RecyclerView.Adapter</code>用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？</p>\n<h2 id=\"将架构组件添加到项目中\"><a href=\"#将架构组件添加到项目中\" class=\"headerlink\" title=\"将架构组件添加到项目中\"></a>将架构组件添加到项目中</h2><p>在build.gradle中添加下面的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;recyclerView</span><br><span class=\"line\"> implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; ViewModel and LiveData</span><br><span class=\"line\"> implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Room</span><br><span class=\"line\"> implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; Paging</span><br><span class=\"line\"> implementation &quot;android.arch.paging:runtime:1.0.1&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建DataSource\"><a href=\"#创建DataSource\" class=\"headerlink\" title=\"创建DataSource\"></a>创建DataSource</h2><h3 id=\"创建实体\"><a href=\"#创建实体\" class=\"headerlink\" title=\"创建实体\"></a>创建实体</h3><h3 id=\"创建Dao层\"><a href=\"#创建Dao层\" class=\"headerlink\" title=\"创建Dao层\"></a>创建Dao层</h3><p>DataSource.Factory(在Room中实现)创建</p>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h3 id=\"创建ViewModel\"><a href=\"#创建ViewModel\" class=\"headerlink\" title=\"创建ViewModel\"></a>创建ViewModel</h3><p>LivePagedListBuilder会使用</p>\n<p>LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。</p>\n<p>创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：</p>\n<ul>\n<li>setPageSize(int)：</li>\n<li>setPrefetchDistance(int)：</li>\n<li>setInitialLoadSizeHint(int)：设置页面中第一次显示的数量</li>\n<li>setEnablePlaceholders(boolean) ：</li>\n</ul>\n<p>在<code>onCreate</code>方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。</p>\n<h2 id=\"创建Adapter\"><a href=\"#创建Adapter\" class=\"headerlink\" title=\"创建Adapter\"></a>创建Adapter</h2><p>使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用<code>DiffCallback</code>来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：</p>\n<ul>\n<li>areItemsTheSame:判断是否指向了同一个数据元素。</li>\n<li>areContentsTheSame:判断</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android框架组件paging-room的使用\"><a href=\"#Android框架组件paging-room的使用\" class=\"headerlink\" title=\"Android框架组件paging+room的使用\"></a>Android框架组件paging+room的使用</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><h3 id=\"DataSource\"><a href=\"#DataSource\" class=\"headerlink\" title=\"DataSource\"></a>DataSource</h3><p>DataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，</p>\n<p>创建一个<code>PagedList</code>被观察者的对象，需要将一个<code>DataSource.Factory</code>的实例传递给<code>LivePagedListBuilder</code>对象。一个DataSource对象为单一的<code>PagedList</code>加载pages。当数据更新时，工厂类会创建一个<code>PagedSource</code>的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供<code>DataSource.Factory</code>对象，或者可以自己创建<code>DataSource.Factory</code></p>\n<p>Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * FROM COUNTRIES\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DataSource.<span class=\"function\">Factory&lt;Integer,Country&gt; <span class=\"title\">getCountries</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PagedList\"><a href=\"#PagedList\" class=\"headerlink\" title=\"PagedList\"></a>PagedList</h3><p>PagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。</p>\n<h3 id=\"PagedListAdapter\"><a href=\"#PagedListAdapter\" class=\"headerlink\" title=\"PagedListAdapter\"></a>PagedListAdapter</h3><p>PagedListAdapter是一个<code>RecyclerView.Adapter</code>用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？</p>\n<h2 id=\"将架构组件添加到项目中\"><a href=\"#将架构组件添加到项目中\" class=\"headerlink\" title=\"将架构组件添加到项目中\"></a>将架构组件添加到项目中</h2><p>在build.gradle中添加下面的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;recyclerView</span><br><span class=\"line\"> implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; ViewModel and LiveData</span><br><span class=\"line\"> implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Room</span><br><span class=\"line\"> implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; Paging</span><br><span class=\"line\"> implementation &quot;android.arch.paging:runtime:1.0.1&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建DataSource\"><a href=\"#创建DataSource\" class=\"headerlink\" title=\"创建DataSource\"></a>创建DataSource</h2><h3 id=\"创建实体\"><a href=\"#创建实体\" class=\"headerlink\" title=\"创建实体\"></a>创建实体</h3><h3 id=\"创建Dao层\"><a href=\"#创建Dao层\" class=\"headerlink\" title=\"创建Dao层\"></a>创建Dao层</h3><p>DataSource.Factory(在Room中实现)创建</p>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h3 id=\"创建ViewModel\"><a href=\"#创建ViewModel\" class=\"headerlink\" title=\"创建ViewModel\"></a>创建ViewModel</h3><p>LivePagedListBuilder会使用</p>\n<p>LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。</p>\n<p>创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：</p>\n<ul>\n<li>setPageSize(int)：</li>\n<li>setPrefetchDistance(int)：</li>\n<li>setInitialLoadSizeHint(int)：设置页面中第一次显示的数量</li>\n<li>setEnablePlaceholders(boolean) ：</li>\n</ul>\n<p>在<code>onCreate</code>方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。</p>\n<h2 id=\"创建Adapter\"><a href=\"#创建Adapter\" class=\"headerlink\" title=\"创建Adapter\"></a>创建Adapter</h2><p>使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用<code>DiffCallback</code>来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：</p>\n<ul>\n<li>areItemsTheSame:判断是否指向了同一个数据元素。</li>\n<li>areContentsTheSame:判断</li>\n</ul>\n"},{"_content":"\n### 1、数据库在表中可以指定多个主键\n\n```java\n\n    @Entity(primaryKeys = {\"firstName\", \"lastName\"})\n    public class User{\n         \n         public String firstName;\n         public String lastName;\n         \n         \n         //使用Ignore使得该变量不生成表段名\n         \n         @Ignore\n         Bitmap bitmap;\n    }\n\n```\n如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns\n\n```\n    public class RemotePerson extends Person {\n        @PrimaryKey\n        public int id;\n\n        public boolean hasVpn;\n    }\n\n```\n\n### 2、Entity进行嵌套\n\n如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded\n\n```\n    public class Address {\n        public String street;\n        public String state;\n        public String city;\n    \n        @ColumnInfo(name = \"post_code\")\n        public int postCode;\n    }    \n\n    @Entity\n    public class Person{\n        @PrimaryKey\n        public int id;\n\n        public String firstName;\n\n        @Embedded\n        public Address address;\n    }\n\n```\n\n这样在Person表中有id,firstName,street,state,city,post_code等字段\n\n### 3、插入数据产生冲突时操作\n\n```\n    @Dao\n    public interface UserDao{\n        //插入如果冲突则替换    \n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        public void insertUser(User ... users);\n    \n    }\n\n```\n\n### 用于对数据表中某一列进行更新\n\n```\n     @Query(\"UPDATE item SET quantity = quantity + 1 WHERE id = :id\")\n     void updateQuantity(int id)\n     //item为表名\n\n```\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/Room数据库.md","raw":"\n### 1、数据库在表中可以指定多个主键\n\n```java\n\n    @Entity(primaryKeys = {\"firstName\", \"lastName\"})\n    public class User{\n         \n         public String firstName;\n         public String lastName;\n         \n         \n         //使用Ignore使得该变量不生成表段名\n         \n         @Ignore\n         Bitmap bitmap;\n    }\n\n```\n如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns\n\n```\n    public class RemotePerson extends Person {\n        @PrimaryKey\n        public int id;\n\n        public boolean hasVpn;\n    }\n\n```\n\n### 2、Entity进行嵌套\n\n如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded\n\n```\n    public class Address {\n        public String street;\n        public String state;\n        public String city;\n    \n        @ColumnInfo(name = \"post_code\")\n        public int postCode;\n    }    \n\n    @Entity\n    public class Person{\n        @PrimaryKey\n        public int id;\n\n        public String firstName;\n\n        @Embedded\n        public Address address;\n    }\n\n```\n\n这样在Person表中有id,firstName,street,state,city,post_code等字段\n\n### 3、插入数据产生冲突时操作\n\n```\n    @Dao\n    public interface UserDao{\n        //插入如果冲突则替换    \n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        public void insertUser(User ... users);\n    \n    }\n\n```\n\n### 用于对数据表中某一列进行更新\n\n```\n     @Query(\"UPDATE item SET quantity = quantity + 1 WHERE id = :id\")\n     void updateQuantity(int id)\n     //item为表名\n\n```\n\n\n\n\n\n\n","slug":"Android/框架/AAC/Room数据库","published":1,"date":"2019-09-30T07:19:02.871Z","updated":"2019-09-30T08:28:42.965Z","title":"Android/框架/AAC/Room数据库","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryie003wisui694v3lqg","content":"<h3 id=\"1、数据库在表中可以指定多个主键\"><a href=\"#1、数据库在表中可以指定多个主键\" class=\"headerlink\" title=\"1、数据库在表中可以指定多个主键\"></a>1、数据库在表中可以指定多个主键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span>(primaryKeys = &#123;<span class=\"string\">\"firstName\"</span>, <span class=\"string\">\"lastName\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> String firstName;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> String lastName;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//使用Ignore使得该变量不生成表段名</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"meta\">@Ignore</span></span><br><span class=\"line\">     Bitmap bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RemotePerson extends Person &#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean hasVpn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、Entity进行嵌套\"><a href=\"#2、Entity进行嵌套\" class=\"headerlink\" title=\"2、Entity进行嵌套\"></a>2、Entity进行嵌套</h3><p>如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Address &#123;</span><br><span class=\"line\">    public String street;</span><br><span class=\"line\">    public String state;</span><br><span class=\"line\">    public String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ColumnInfo(name &#x3D; &quot;post_code&quot;)</span><br><span class=\"line\">    public int postCode;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    public Address address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在Person表中有id,firstName,street,state,city,post_code等字段</p>\n<h3 id=\"3、插入数据产生冲突时操作\"><a href=\"#3、插入数据产生冲突时操作\" class=\"headerlink\" title=\"3、插入数据产生冲突时操作\"></a>3、插入数据产生冲突时操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface UserDao&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;插入如果冲突则替换    </span><br><span class=\"line\">    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)</span><br><span class=\"line\">    public void insertUser(User ... users);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用于对数据表中某一列进行更新\"><a href=\"#用于对数据表中某一列进行更新\" class=\"headerlink\" title=\"用于对数据表中某一列进行更新\"></a>用于对数据表中某一列进行更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Query(&quot;UPDATE item SET quantity &#x3D; quantity + 1 WHERE id &#x3D; :id&quot;)</span><br><span class=\"line\">void updateQuantity(int id)</span><br><span class=\"line\">&#x2F;&#x2F;item为表名</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、数据库在表中可以指定多个主键\"><a href=\"#1、数据库在表中可以指定多个主键\" class=\"headerlink\" title=\"1、数据库在表中可以指定多个主键\"></a>1、数据库在表中可以指定多个主键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span>(primaryKeys = &#123;<span class=\"string\">\"firstName\"</span>, <span class=\"string\">\"lastName\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> String firstName;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> String lastName;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//使用Ignore使得该变量不生成表段名</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"meta\">@Ignore</span></span><br><span class=\"line\">     Bitmap bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RemotePerson extends Person &#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean hasVpn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、Entity进行嵌套\"><a href=\"#2、Entity进行嵌套\" class=\"headerlink\" title=\"2、Entity进行嵌套\"></a>2、Entity进行嵌套</h3><p>如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Address &#123;</span><br><span class=\"line\">    public String street;</span><br><span class=\"line\">    public String state;</span><br><span class=\"line\">    public String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ColumnInfo(name &#x3D; &quot;post_code&quot;)</span><br><span class=\"line\">    public int postCode;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    public Address address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在Person表中有id,firstName,street,state,city,post_code等字段</p>\n<h3 id=\"3、插入数据产生冲突时操作\"><a href=\"#3、插入数据产生冲突时操作\" class=\"headerlink\" title=\"3、插入数据产生冲突时操作\"></a>3、插入数据产生冲突时操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface UserDao&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;插入如果冲突则替换    </span><br><span class=\"line\">    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)</span><br><span class=\"line\">    public void insertUser(User ... users);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用于对数据表中某一列进行更新\"><a href=\"#用于对数据表中某一列进行更新\" class=\"headerlink\" title=\"用于对数据表中某一列进行更新\"></a>用于对数据表中某一列进行更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Query(&quot;UPDATE item SET quantity &#x3D; quantity + 1 WHERE id &#x3D; :id&quot;)</span><br><span class=\"line\">void updateQuantity(int id)</span><br><span class=\"line\">&#x2F;&#x2F;item为表名</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n"},{"_content":"WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。\n\n在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。\n\n当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。\n\nWorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service\n\nWorkManager可以执行两种类型的任务\n\n* 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中\n\n```java\n    WorkManager workManager=workManager.getInstance();\n    workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build());\n    \n```\n\n因为没有加其他的限制条件，所以上述任务只会执行一次；\n\n* 多次任务，如：每天将应用数据同步至服务器；\n\n创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中\n\n```\n    new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);\n    \n    PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();\n    WorkManager.getInstance().enqueue(dataCheckWork);\n    \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/WorkManager介绍.md","raw":"WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。\n\n在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。\n\n当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。\n\nWorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service\n\nWorkManager可以执行两种类型的任务\n\n* 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中\n\n```java\n    WorkManager workManager=workManager.getInstance();\n    workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build());\n    \n```\n\n因为没有加其他的限制条件，所以上述任务只会执行一次；\n\n* 多次任务，如：每天将应用数据同步至服务器；\n\n创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中\n\n```\n    new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);\n    \n    PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();\n    WorkManager.getInstance().enqueue(dataCheckWork);\n    \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/框架/AAC/WorkManager介绍","published":1,"date":"2019-09-30T07:19:02.876Z","updated":"2019-09-30T08:28:42.965Z","title":"Android/框架/AAC/WorkManager介绍","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryie003xisuie6qt4grh","content":"<p>WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。</p>\n<p>在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。</p>\n<p>当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。</p>\n<p>WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service</p>\n<p>WorkManager可以执行两种类型的任务</p>\n<ul>\n<li>只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkManager workManager=workManager.getInstance();</span><br><span class=\"line\">workManager.enqueue(<span class=\"keyword\">new</span> OneTimeWorkRequest.Builder(MyWork<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">build</span>())</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为没有加其他的限制条件，所以上述任务只会执行一次；</p>\n<ul>\n<li>多次任务，如：每天将应用数据同步至服务器；</li>\n</ul>\n<p>创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PeriodicWorkRequest.Builder dataCheckBuilder&#x3D;new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);</span><br><span class=\"line\"></span><br><span class=\"line\">PeriodicWorkRequest dataCheckWork&#x3D;dataCheckBuilder.build();</span><br><span class=\"line\">WorkManager.getInstance().enqueue(dataCheckWork);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。</p>\n<p>在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。</p>\n<p>当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。</p>\n<p>WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service</p>\n<p>WorkManager可以执行两种类型的任务</p>\n<ul>\n<li>只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkManager workManager=workManager.getInstance();</span><br><span class=\"line\">workManager.enqueue(<span class=\"keyword\">new</span> OneTimeWorkRequest.Builder(MyWork<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">build</span>())</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为没有加其他的限制条件，所以上述任务只会执行一次；</p>\n<ul>\n<li>多次任务，如：每天将应用数据同步至服务器；</li>\n</ul>\n<p>创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PeriodicWorkRequest.Builder dataCheckBuilder&#x3D;new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);</span><br><span class=\"line\"></span><br><span class=\"line\">PeriodicWorkRequest dataCheckWork&#x3D;dataCheckBuilder.build();</span><br><span class=\"line\">WorkManager.getInstance().enqueue(dataCheckWork);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"_content":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","source":"_posts/Android/框架/AAC/Lifecycle和Room的使用.md","raw":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","slug":"Android/框架/AAC/Lifecycle和Room的使用","published":1,"date":"2019-09-30T07:19:02.859Z","updated":"2019-11-30T11:14:32.187Z","title":"Android/框架/AAC/Lifecycle和Room的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryig003yisuidqc15n95","content":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n"},{"_content":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","source":"_posts/Android/框架/AAC/Room和Lifecycle构建程序.md","raw":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","slug":"Android/框架/AAC/Room和Lifecycle构建程序","published":1,"date":"2019-09-19T09:41:14.749Z","updated":"2019-09-19T09:41:14.749Z","title":"Android/框架/AAC/Room和Lifecycle构建程序","comments":1,"layout":"post","photos":[],"link":"","_id":"ck770ryig003zisui9q0e40re","content":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck770ryh80025isui466416rx","category_id":"ck770ryha0028isuiau9iemq8","_id":"ck770ryhe002hisuifil1a2as"},{"post_id":"ck770ryia003oisui3wlmhbee","category_id":"ck770ryha0028isuiau9iemq8","_id":"ck770ryic003tisui1xqdgjt0"}],"PostTag":[{"post_id":"ck770ryfs0009isuifk6r56bt","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryfv000cisui2b0j0hnn"},{"post_id":"ck770ryfn0005isui4cqf0xji","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryfw000eisui3z5thsiz"},{"post_id":"ck770ryft000aisuifl7b2vuy","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryfx000hisuiccz495vi"},{"post_id":"ck770ryfv000disui5nau0ucw","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryfy000jisui10it1yge"},{"post_id":"ck770ryfo0006isuicgrt24ud","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg0000lisui07l26nxb"},{"post_id":"ck770ryfw000fisui0oq47uh3","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg0000nisuib5vr2xd7"},{"post_id":"ck770ryfy000iisui3b5x7nyr","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg1000pisuibhuxfhy7"},{"post_id":"ck770ryfs0008isui9arv8vd5","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg2000risuifvbvehay"},{"post_id":"ck770ryfy000kisuiakmt8wc7","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg2000tisuicifw2yca"},{"post_id":"ck770ryg0000misui3anicmaj","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg3000visuia36g2zbr"},{"post_id":"ck770ryg1000oisui5hvuba4o","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg4000xisui03zi836l"},{"post_id":"ck770ryg1000qisui8dhg3nd4","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg4000zisuia3b7ep7k"},{"post_id":"ck770ryg2000sisui1wnz82d9","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg50011isuig76y3agp"},{"post_id":"ck770ryg3000uisui6izg2sed","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg60013isuihu8jhdiz"},{"post_id":"ck770ryg3000wisui6b9289dc","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770ryg60015isuievcj4izp"},{"post_id":"ck770ryg9001bisui1p9abdjn","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygd001eisui00lr8upn"},{"post_id":"ck770ryg70017isui72c986yj","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygd001gisui6ggd0u5e"},{"post_id":"ck770ryga001cisui9x8hdm1k","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770ryge001jisuicsom1h6y"},{"post_id":"ck770rygd001fisuieo0i0p5i","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygf001lisui2ax6ae3x"},{"post_id":"ck770ryg80018isuiaereglz4","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygf001misui4tlo2dky"},{"post_id":"ck770rygd001hisui8s1w5cjf","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygf001nisuiei47anao"},{"post_id":"ck770ryge001kisui4nf7dp3s","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygf001oisuifnkrhach"},{"post_id":"ck770ryg8001aisuiftwv8bey","tag_id":"ck770ryg80019isuibxyc7b5u","_id":"ck770rygg001pisuidc96bjuz"},{"post_id":"ck770rygp001qisui3lhqfm4y","tag_id":"ck770ryfq0007isui8oog8v6r","_id":"ck770rygq001sisuidgi980q2"},{"post_id":"ck770ryh70024isuiapjh8kvs","tag_id":"ck770ryh90026isui1mo62upj","_id":"ck770ryhc002cisui35qzfqk0"},{"post_id":"ck770ryh80025isui466416rx","tag_id":"ck770ryh90026isui1mo62upj","_id":"ck770ryhd002fisuicc7ucbd7"},{"post_id":"ck770ryhs0036isui64jd4irx","tag_id":"ck770ryht0038isui7mwiff6w","_id":"ck770ryhu003bisui9wkn1x0v"},{"post_id":"ck770ryhs0036isui64jd4irx","tag_id":"ck770ryhu003aisuiaibc5o2c","_id":"ck770ryhu003cisuihlcc5bdb"},{"post_id":"ck770ryhz003eisui4rxhajyw","tag_id":"ck770ryh90026isui1mo62upj","_id":"ck770ryi0003gisuigpzz52wr"},{"post_id":"ck770ryi0003fisui4d375asd","tag_id":"ck770ryh90026isui1mo62upj","_id":"ck770ryi1003iisui9vk848lg"},{"post_id":"ck770ryia003oisui3wlmhbee","tag_id":"ck770ryh90026isui1mo62upj","_id":"ck770ryib003qisui076g5n02"}],"Tag":[{"name":"数据结构","_id":"ck770ryfq0007isui8oog8v6r"},{"name":"pat","_id":"ck770ryg80019isuibxyc7b5u"},{"name":"Android","_id":"ck770ryh90026isui1mo62upj"},{"name":"error","_id":"ck770ryht0038isui7mwiff6w"},{"name":"git","_id":"ck770ryhu003aisuiaibc5o2c"}]}}