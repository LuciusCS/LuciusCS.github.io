{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/og_image.png","path":"images/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/wechat_donate.png","path":"images/wechat_donate.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/alipay_donate.png","path":"images/alipay_donate.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1582721089046},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1582721089047},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1582721089054},{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1582721089046},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1582772035277},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1582721089047},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1582721089047},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1582721089048},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1582721089048},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1582721089048},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1582721089048},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1582721089048},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1582721089048},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1582721089048},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1582721089049},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1582721089049},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1582721089049},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1582721089048},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1582721089053},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1582721089053},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1582721089053},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1582721089054},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1582721089054},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1582721089049},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1582721089054},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1582721089054},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1582721089050},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1582721089053},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1582721089049},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1582721089050},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1582721089050},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1582721089051},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1582721089051},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1582721089050},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1582721089051},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1582721089051},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1582721089051},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1582721089052},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1582721089053},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1582721089052},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1582721089055},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1582721089053},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1582721089053},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1582721089066},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1582721089053},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1582721089067},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1582721089067},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1582721089067},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1582721089068},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1582721089067},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1582721089070},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1582721089070},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1582721089070},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1582721089066},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1582721089057},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1582721089051},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1582721089069},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1582721089051},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1582721089052},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1582721089052},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1582721089055},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1582721089055},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1582721089052},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1582721089052},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1582721089056},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1582721089055},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1582721089056},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1582721089056},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1582721089056},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1582721089056},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1582721089056},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1582721089056},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1582721089057},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1582721089057},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1582721089064},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1582721089068},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1582721089068},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1582721089068},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1582721089069},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1582721089069},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1582721089069},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1582721089063},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1582721089059},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1582721089066},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1582721089062},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1582721089060},{"_id":"public/2020/02/26/hello-world/index.html","hash":"99add18944f2c6bfdc8e3a3c3e7d438ce84bf6d3","modified":1582806711577},{"_id":"public/archives/index.html","hash":"27a3acf9902f3eee8404e56425d7b7de2af63c52","modified":1582805617599},{"_id":"public/archives/2020/index.html","hash":"c9aa80278b05ac14c389385c6a4f20f0a750cfc1","modified":1582805617599},{"_id":"public/archives/2020/02/index.html","hash":"3fdd0ecc56aea395c78551991c4c028ee6c65464","modified":1582805617599},{"_id":"public/index.html","hash":"7002a7d0164a86d6f044c1c781bb101665333b02","modified":1582805617599},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1582801639235},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1582801639235},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1582801639235},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1582801639235},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1582801639235},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1582801639235},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1582801639235},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1582801639235},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1582801639235},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1582801639235},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1582801639235},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1582801639235},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1582801639235},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1582801639235},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1582801639235},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1582801639235},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1582801639235},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1582801639235},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1582721257192},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1582801639235},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1582801639235},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1582801639235},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1582801639235},{"_id":"themes/icarus/.gitignore","hash":"d1841a9f4c79119ea348d4274483cc679b0f5946","modified":1582802873698},{"_id":"themes/icarus/_config.yml","hash":"6cf43e3ff954246b494d5a86ef2b063dfa2b5487","modified":1582806701160},{"_id":"themes/icarus/README.md","hash":"921a87a50b130e1324fc0111e325d949ff74e1df","modified":1582773322749},{"_id":"themes/icarus/LICENSE","hash":"62e3701684087bc9a66f0b20386036ede9b430b7","modified":1582773322749},{"_id":"themes/icarus/package-lock.json","hash":"d40be8909ce30f75bc05ac6599302c3d6aab81cf","modified":1582721417219},{"_id":"themes/icarus/package.json","hash":"77068f22af71471a21ce3828018e9dc1e68feb5a","modified":1582773322782},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"e50411021e3c85860fc4b96f446267ba9871dcde","modified":1582773322748},{"_id":"themes/icarus/languages/de.yml","hash":"ef43979c403b3a221585d5dd0b7205627437818e","modified":1582773322760},{"_id":"themes/icarus/languages/es.yml","hash":"f0ea2c482a8bc5ed43452ecc7ebe601504e0cc54","modified":1582773322760},{"_id":"themes/icarus/languages/id.yml","hash":"ee655e6a045eb28ea480a348bbefd10ef115494b","modified":1582773322761},{"_id":"themes/icarus/languages/ko.yml","hash":"2d12f3975b576afb025df773e30521b58abd015e","modified":1582773322761},{"_id":"themes/icarus/languages/ja.yml","hash":"3c921f24b19a797b2ae23cf621a35bb9b043ddf9","modified":1582773322761},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"28ae713d8d26ab875104684e604592f4c495b638","modified":1582773322762},{"_id":"themes/icarus/languages/pl.yml","hash":"a6dbd568cb18104685b20ab7b5767f455628f61c","modified":1582773322761},{"_id":"themes/icarus/languages/ru.yml","hash":"62451109780acfe2db8630248005697c10a68a61","modified":1582773322762},{"_id":"themes/icarus/languages/fr.yml","hash":"b85a2d4fcc790a8b84326235850eb54532f6b75e","modified":1582773322760},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"1ca3f7b92872443c79b5f8026272b3bd21b4dd46","modified":1582773322763},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"3f66c8c96138784aca7bf2af5b72c5a8b8b47eab","modified":1582773322764},{"_id":"themes/icarus/languages/vn.yml","hash":"cd2d57a3fe6389bdd76f193c6c662d242960ed02","modified":1582773322763},{"_id":"themes/icarus/languages/tr.yml","hash":"2e334f0f98756256754f48d8dff3baa045700283","modified":1582773322763},{"_id":"themes/icarus/scripts/index.js","hash":"9cfc27c4242440afa262218912698274c0eb5810","modified":1582773322782},{"_id":"themes/icarus/layout/category.ejs","hash":"3526103940eccd83937bcb6d1a59e9a285bec920","modified":1582773322764},{"_id":"themes/icarus/layout/index.ejs","hash":"44d905e3077e8a723ed6b714cca3047a68ce85e2","modified":1582773322771},{"_id":"themes/icarus/layout/layout.ejs","hash":"14ffb4a07adc9f882166d4406996301f005b8162","modified":1582773322771},{"_id":"themes/icarus/languages/en.yml","hash":"55f97341ef33ccc685508aa262dd5c3b75eb5da8","modified":1582773322760},{"_id":"themes/icarus/layout/archive.ejs","hash":"32a56ca892464c5b91b27033eb4544848105f1a1","modified":1582773322764},{"_id":"themes/icarus/layout/post.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1581951736000},{"_id":"themes/icarus/layout/page.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1581951736000},{"_id":"themes/icarus/layout/tag.ejs","hash":"8ba86c65f9f4680266102344144a6669a241e0d8","modified":1582773322779},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"b921f7ab80c3de92291ce2c9081baa4464133787","modified":1582773322751},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"7c7cec251070d72c33139d5c19bef03dc9a57e15","modified":1582773322751},{"_id":"themes/icarus/includes/generators/categories.js","hash":"6aef75f08a11a06e5c72d9b0b768c3aa7462080c","modified":1582773322752},{"_id":"themes/icarus/includes/common/utils.js","hash":"4099226113e3d631b58452f529d58cf00758fd24","modified":1582773322751},{"_id":"themes/icarus/includes/generators/category.js","hash":"1f40399fc0d56f89490d669c6399cd40b9465e93","modified":1582773322752},{"_id":"themes/icarus/includes/generators/insight.js","hash":"8fcac981ab9537fc110ff8a6d00f67bd6f41aeec","modified":1582773322752},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"10ed3f19f2bc317e4c706f74bc8cc27c87c533e4","modified":1582773322753},{"_id":"themes/icarus/includes/generators/tags.js","hash":"ee929b68019b4759099d292257971d3267c5abd7","modified":1582773322752},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"f020fad32fd9977a17b19b755bb9e5fd506fc5a9","modified":1582773322753},{"_id":"themes/icarus/includes/helpers/override.js","hash":"ede8fc3132b2ab557d51b521264d5574fc8fb6d0","modified":1582773322754},{"_id":"themes/icarus/includes/helpers/page.js","hash":"1486792ec2528fa656ad258d588a6d261bd94467","modified":1582773322754},{"_id":"themes/icarus/includes/helpers/site.js","hash":"4142e0b3418ff2ef186979d8bb7023f54ca3185d","modified":1582773322754},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"7625a4adbaaf4ce80ef4af2c34b4cdae194a0c4b","modified":1582773322755},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"90ccc9987856958eb3ddf5a1a0ed564e7098559f","modified":1582773322755},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"e2a6c34d7ac9a5af828670da4ff1ce92ed298e49","modified":1582773322755},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"bc47f29f158b5c61de45c3b7ab7b8932e145bed6","modified":1582773322756},{"_id":"themes/icarus/includes/helpers/config.js","hash":"f1becefd247f03bf5b31347ffda23e9480bb4566","modified":1582773322753},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"6b65be067c332fba3c901e863a5802089a2149a3","modified":1582773322756},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"5424cb681dbb475908f3708d8635380cf48a610e","modified":1582773322756},{"_id":"themes/icarus/layout/tags.ejs","hash":"9b185ad009855aa645e6fb5ccb28c022571852d0","modified":1582773322779},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"1ef55aafe89be3b3aee110cbea319ff0a7cf0df8","modified":1582773322757},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"cde56bce96c74ea40d8ebe5824e0b6b0b46c051a","modified":1582773322757},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"1920b18326cae129b92973a8954d922e3b5449fe","modified":1582773322757},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"222a535e4fe9517ca4b6089a704fd38d6bec1a8a","modified":1582773322758},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"b36aa88d2fc573eaa97df93ce5e00ad8610f6f16","modified":1582773322758},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"cb99fedec56fb1b1df72d90769d245fb0dd08a9d","modified":1582773322757},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"cf52737b5be1d3e8a71af89ec617cb12ea39393f","modified":1582773322758},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"d7d0c360ae885a2bf1ebcb7089265bf524da5af6","modified":1582773322759},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"a69b003cd482c2fe4495705c5e075d73e7e54ceb","modified":1582773322759},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"73d0ff7bc3e40d7178fb5627fec2a41c15c585e6","modified":1582773322759},{"_id":"themes/icarus/includes/utils/lru.js","hash":"0538e293f46091315938ed7fc87ecaf3a53f8d19","modified":1582773322759},{"_id":"themes/icarus/layout/categories.ejs","hash":"5df2ae61ec3869d265113d695e2e25aaa60e8e67","modified":1582773322764},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"82045466b47540eaaac619f6d4365115860abfa7","modified":1582773322758},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"ab0304e684db5e2f45520a511df5aa36a04d2f2a","modified":1582773322783},{"_id":"themes/icarus/source/css/search.css","hash":"b2fb780ce22684998a47b282a57f603511b040b2","modified":1582773322783},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1581951736000},{"_id":"themes/icarus/source/css/insight.css","hash":"10aedd26a4930166b826d72b25cdbd509609b84b","modified":1582773322783},{"_id":"themes/icarus/source/css/progressbar.css","hash":"a3ef2b1ee0ee0889a82c3c693e53139fd4c0d143","modified":1582773322783},{"_id":"themes/icarus/source/css/style.styl","hash":"802ac5c845a2fd7979bec8fc88a9ec35aca22942","modified":1582773322784},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1582773322786},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"0c59b27d77fbf53fe9197d0856f87114b2bb33aa","modified":1582773322786},{"_id":"themes/icarus/source/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1582773322785},{"_id":"themes/icarus/source/js/gallery.js","hash":"c161252f214d787a9fd895c4c5124579169445d1","modified":1582773322786},{"_id":"themes/icarus/source/js/insight.js","hash":"c8669315f46c197efe9e9cd448d5b983049f348d","modified":1582773322787},{"_id":"themes/icarus/source/js/main.js","hash":"bc2267b464ae86d972088d2fdc9da4f608015f4e","modified":1582773322787},{"_id":"themes/icarus/layout/comment/changyan.locals.js","hash":"ebbf95d3d6fe947f8f2b70363148a389cec04df5","modified":1582773322765},{"_id":"themes/icarus/source/js/animation.js","hash":"eabfccd284ca67920dd7977aa664d8b32b1911f7","modified":1582773322786},{"_id":"themes/icarus/source/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1582773322785},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"e5e0c9c0fe24352d5e3f06370fe29597831824ce","modified":1582773322764},{"_id":"themes/icarus/layout/comment/facebook.locals.js","hash":"e63545f9b9ce54fcd5d0fdf97a0dfe3fb552f0d8","modified":1582773322765},{"_id":"themes/icarus/layout/comment/disqus.locals.js","hash":"14c7a55a0c3be3185c52e5bc9ce82bb505758790","modified":1582773322765},{"_id":"themes/icarus/source/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1581951736000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"4361769d1aa3a321da6de8891bfe668c1bf7ba77","modified":1582773322765},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"d52b3569994ad85e3b809b96173ca44097c83c09","modified":1582773322766},{"_id":"themes/icarus/layout/comment/isso.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322766},{"_id":"themes/icarus/layout/comment/gitment.locals.js","hash":"f1f2e209d34ec15137b09c4840e51932aa82010c","modified":1582773322766},{"_id":"themes/icarus/layout/comment/gitalk.locals.js","hash":"f1f2e209d34ec15137b09c4840e51932aa82010c","modified":1582773322766},{"_id":"themes/icarus/layout/comment/livere.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322767},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"780e933c7b2297843208c78085f7ab99f63dec38","modified":1582773322765},{"_id":"themes/icarus/layout/comment/utterances.ejs","hash":"fac2c6382d8ea93c1aab9dab16fbce6c12193269","modified":1582773322767},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"31471cd05018583249b4c09a78cf1d02e7987244","modified":1581951736000},{"_id":"themes/icarus/layout/comment/valine.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322767},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"d5e1a396e23df4e75e139d12846290bdb08ba01e","modified":1581951736000},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"55bfe636859f118b40750bd36e2c3ef1a2ec4c0e","modified":1582773322766},{"_id":"themes/icarus/layout/comment/utterances.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322767},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"c3b24c01f6d9ae8aac4dab9af658ba7b6566419f","modified":1582773322770},{"_id":"themes/icarus/layout/donate/patreon.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322770},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"792a1e44b71ed8048903ea898aeaf74a6c109037","modified":1582773322767},{"_id":"themes/icarus/layout/donate/paypal.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322771},{"_id":"themes/icarus/layout/donate/alipay.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322770},{"_id":"themes/icarus/layout/donate/wechat.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322771},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"456b0dcdd005ff04210c1cebbddd2b9fa2a94dca","modified":1582773322771},{"_id":"themes/icarus/layout/common/article.ejs","hash":"ac22def9b6229dd4102c18b4e6aae3329e6f87a5","modified":1582773322768},{"_id":"themes/icarus/layout/common/article.locals.js","hash":"5330bb3f8dbebd7add4be133b0f43741b7615dbe","modified":1582773322768},{"_id":"themes/icarus/layout/common/footer.locals.js","hash":"9a8a5f8e7cb746a46262deeed64a61d3ecda9d1b","modified":1582773322768},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"f2f349865fbeff42495cf24cd220737530f5bdf1","modified":1582773322768},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"79171794ca43d66b8f7ed549f96dc6e46bfd5b76","modified":1582773322770},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"969b013fff396934543adb868dfec7cef6eee392","modified":1582773322770},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"92efd4c3f4a47d8423fe7e09ecdddb2e335553cc","modified":1582773322769},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"ab31313e825d65d4d5a633225814a881a90f07d5","modified":1582773322769},{"_id":"themes/icarus/layout/common/navbar.locals.js","hash":"c489aec088b079da7e93a7be59720a4e658c7dff","modified":1582773322769},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"a112cebca5316ed444103efc6de298e9dc355d77","modified":1582773322769},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"d83bf233d398ef3bb3c9a93a101cf4e0a1d8c58f","modified":1582773322772},{"_id":"themes/icarus/layout/plugin/animejs.locals.js","hash":"57a0770ed07b5ffb2220a296fb862fd2dea9b9b2","modified":1582773322772},{"_id":"themes/icarus/layout/plugin/back-to-top.locals.js","hash":"57a0770ed07b5ffb2220a296fb862fd2dea9b9b2","modified":1582773322772},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"b29d5b8e6c155010a18fac71d9e6dc0d5e0d0db4","modified":1582773322772},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"371699761b0eceeffba2d6adb53b045d516b3660","modified":1582773322772},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"4285b0ae608c7c54e4ecbebb6d22d4cd1be28f70","modified":1581951736000},{"_id":"themes/icarus/layout/plugin/busuanzi.locals.js","hash":"20267ab6493a0863be1bf2d4dfad5604546c7210","modified":1582773322773},{"_id":"themes/icarus/layout/plugin/baidu-analytics.locals.js","hash":"b0c5adc41f9f9f764e9760b5b8b72c6dc705d95c","modified":1582773322773},{"_id":"themes/icarus/layout/plugin/gallery.locals.js","hash":"69a5297ab1b5d055fb557113f7867404ab9b5ef4","modified":1582773322773},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"5415bb022663c94ad0125f87e909ab2ee86b40c4","modified":1582773322773},{"_id":"themes/icarus/layout/plugin/google-analytics.locals.js","hash":"b0c5adc41f9f9f764e9760b5b8b72c6dc705d95c","modified":1582773322774},{"_id":"themes/icarus/layout/common/head.ejs","hash":"0942538abea7c9b4b6db418d9c45e894cb0beb25","modified":1582773322768},{"_id":"themes/icarus/layout/plugin/hotjar.locals.js","hash":"3ea362b078fd7340807c85eabb6aa45690bd2bea","modified":1582773322774},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"4e316230392bc8aa84d61306832cecce8544d1dc","modified":1582773322769},{"_id":"themes/icarus/layout/plugin/mathjax.locals.js","hash":"22956a4f26fb3db4365d74b2cb0b57b8a0139293","modified":1582773322774},{"_id":"themes/icarus/layout/plugin/outdated-browser.locals.js","hash":"69a5297ab1b5d055fb557113f7867404ab9b5ef4","modified":1582773322775},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"3cf9f7eb54d9074746a4f7d56f25904417692beb","modified":1582773322774},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"810948096dec70a55cc68d443d50faef9e8d76ca","modified":1582773322773},{"_id":"themes/icarus/layout/plugin/progressbar.locals.js","hash":"20267ab6493a0863be1bf2d4dfad5604546c7210","modified":1582773322775},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"9f5c9821483062ed3eb043d7c6fb8a840936e063","modified":1582773322775},{"_id":"themes/icarus/layout/search/baidu.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322776},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"46622b19f0b6a3a8db6183f82f72a93a2b862ec4","modified":1582773322774},{"_id":"themes/icarus/layout/search/google-cse.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322776},{"_id":"themes/icarus/layout/search/insight.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322777},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"3f4a588a5a7221697a8d6889753bacae8a2e7b37","modified":1582773322774},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"9cc26da261527bbba8b0180e0f73e0c6ae5416b5","modified":1582773322777},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"c5a79c1450abf38317e697ef7a819858ff6ae898","modified":1582773322776},{"_id":"themes/icarus/layout/share/addthis.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322777},{"_id":"themes/icarus/layout/share/addtoany.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322777},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"1a00151869919b230f1c0a0bec10475e24b81c97","modified":1582773322776},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"04930e5dde7d47ddb1375730504edbfb59afaed5","modified":1582773322777},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"b22352d27cd0636898207a840a20b6c85267b23b","modified":1582773322776},{"_id":"themes/icarus/layout/share/bdshare.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322778},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"b59c0708480ead768d15ef53ce028b5f1a715960","modified":1582773322778},{"_id":"themes/icarus/layout/share/sharejs.locals.js","hash":"74ca321ba6b946dd41081048f365845df9091817","modified":1582773322778},{"_id":"themes/icarus/layout/share/sharethis.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322779},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"96950a7e27b7b0b808d5b5a81f192d5e0fec1967","modified":1582773322779},{"_id":"themes/icarus/layout/widget/archive.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322779},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"307d905cd39ac4908ef5589829a18777f314428d","modified":1582773322778},{"_id":"themes/icarus/layout/widget/category.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322780},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"17e58e537645c4434a1140377ae3e7f43cca4927","modified":1581951736000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"bf99172a93b4c2ca6b6c8763d96ed1aba9dc7556","modified":1582773322780},{"_id":"themes/icarus/layout/widget/profile.locals.js","hash":"f8d6fd0df6bd4167320d19096485b34ab88d3b10","modified":1582773322780},{"_id":"themes/icarus/layout/widget/links.locals.js","hash":"858444815fa442a871ba0bd9b1ce2e7b27297245","modified":1582773322780},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"53768bf260c34f8621aaf14911d3f97ad5b58053","modified":1582773322781},{"_id":"themes/icarus/layout/widget/subscribe_email.locals.js","hash":"4e4e2510d22e1650faf6c7818b3a117abcba789d","modified":1582773322781},{"_id":"themes/icarus/layout/widget/recent_posts.locals.js","hash":"78c28ef3ec6e8c4e21c1f8296f58c370e429eb1c","modified":1582773322781},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"e41aff420cc4ea1c454de49bd8af0e7a93f3db3f","modified":1581951736000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"9c22ce29afca4ed6261eaf86d7393b0c73334ff4","modified":1582773322781},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"4d86e28e0008997435b8faa786db6e56b7133aef","modified":1582773322782},{"_id":"themes/icarus/layout/widget/tagcloud.locals.js","hash":"01915ead507c6acaf66effac75bc3babed8a48bc","modified":1582773322782},{"_id":"themes/icarus/layout/widget/subscribe_email.ejs","hash":"5aa11b4b076ed147b0b2566ce215d245493e9de2","modified":1582773322781},{"_id":"themes/icarus/layout/widget/toc.locals.js","hash":"a8e3bbbdf8f36f94ded34ff908ce74526b94e3da","modified":1582773322782},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"90e24e50c1dc18c22fbb9fa24320bf669e8a6283","modified":1582773322778},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"443c7dd3c3e11c5f1dec6e63f49dee48a2e0f315","modified":1582773322780},{"_id":"source/_posts/测试仪111.md","hash":"9810d6773a3dfdaa835a5426d0226a6f57ddb228","modified":1582768433160},{"_id":"source/_posts/eeee/测试仪.md","hash":"4faba74c8c9903a7e90c1fbcd3fa8ceac43fadba","modified":1582768418424},{"_id":"public/content.json","hash":"cdcc04660f6af4973d954ec07d0b380ec8af719a","modified":1582803960055},{"_id":"public/2020/02/27/测试仪111/index.html","hash":"83fec0184dd378e34c62148d4b612d3696a9ff72","modified":1582773991213},{"_id":"public/2020/02/27/eeee/测试仪/index.html","hash":"e8b9dcdf7b94f448b736d98fb8be4a35377136e7","modified":1582773991213},{"_id":"public/categories/index.html","hash":"d0a6c7e7e4748d361c05035cb62fd9a089069559","modified":1582805617599},{"_id":"public/tags/index.html","hash":"1f2e92279f9134491c2c341b9c2362b94d0fa7eb","modified":1582805617599},{"_id":"public/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1582768446812},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1582768446812},{"_id":"public/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1582768446812},{"_id":"public/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1582768446812},{"_id":"public/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1582768446812},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1582768446812},{"_id":"public/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1582768446812},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1582768446812},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1582768446812},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1582768446812},{"_id":"public/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1582768446812},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1582768446812},{"_id":"public/js/main.js","hash":"9b7063b2faf8cc43e8539d777285e20574011769","modified":1582768446812},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1582768446812},{"_id":"source/_posts/about.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582770177539},{"_id":"public/2020/02/27/about/index.html","hash":"c5ce2f1528a22f958ed65f2d93d15679f1486f2f","modified":1582773991213},{"_id":"source/_posts/Directory/Android Directory.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387698},{"_id":"source/_posts/Directory/Kotlin Directory.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387698},{"_id":"source/_posts/Directory/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387699},{"_id":"source/_posts/Kotlin/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568165387705},{"_id":"source/_posts/Directory/Other Directory.md","hash":"2b907e72131a8d568b572d44651f1b189e013889","modified":1569832122968},{"_id":"source/_posts/Java/README.md","hash":"24b0d9176a16957b14a6a943ed36c4feaac179bb","modified":1569832122977},{"_id":"source/_posts/Directory/Java Directory.md","hash":"13fb0e571c973f7fb389d475b68061b9e6ee8262","modified":1569832122967},{"_id":"source/_posts/Other/函数式编程.md","hash":"516bdceada3fc781b46635a814e9c3496bd3af7b","modified":1568886074781},{"_id":"source/_posts/Other/README.md","hash":"0bd2702af6d56ae251bd7dceb320714de41c59e3","modified":1570515581311},{"_id":"source/_posts/assets/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1569027130122},{"_id":"source/_posts/assets/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1569027130121},{"_id":"source/_posts/assets/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1569027130123},{"_id":"source/_posts/assets/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1569027130121},{"_id":"source/_posts/assets/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1568199763467},{"_id":"source/_posts/assets/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1568199763467},{"_id":"source/_posts/assets/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1569027130123},{"_id":"source/_posts/assets/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1568199763468},{"_id":"source/_posts/assets/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1568199763469},{"_id":"source/_posts/assets/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1568199763469},{"_id":"source/_posts/assets/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1568199763470},{"_id":"source/_posts/Android/README.md","hash":"e9cce8a4603edc9da16cc53229b3c8cf8e5303b8","modified":1570512747924},{"_id":"source/_posts/assets/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1575112472249},{"_id":"source/_posts/assets/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1569027130124},{"_id":"source/_posts/assets/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1568886074783},{"_id":"source/_posts/assets/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1575112472249},{"_id":"source/_posts/assets/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1568199763468},{"_id":"source/_posts/assets/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1575112472249},{"_id":"source/_posts/assets/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1574943623105},{"_id":"source/_posts/Android/Other/Groovy介绍.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569832122958},{"_id":"source/_posts/Android/View/ActionBar和ToolBar的使用.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569832122961},{"_id":"source/_posts/Android/框架/RxJava2.0.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074750},{"_id":"source/_posts/Java/Java基础/Java 输入输出操作.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074768},{"_id":"source/_posts/Java/Java多线程/Java锁机制.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074777},{"_id":"source/_posts/Java/Java虚拟机/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074778},{"_id":"source/_posts/Kotlin/Kotlin基础/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1574943623104},{"_id":"source/_posts/Other/Git/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074780},{"_id":"source/_posts/Other/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568189080930},{"_id":"source/_posts/Android/Android JNI/Android JNI敏感信息保护.md","hash":"8ed1df1c39fae52463680f8ec6c97b5771aa5829","modified":1569027130111},{"_id":"source/_posts/Android/Android JNI/Android Studio JNI引入.md","hash":"add31391ebb33ebab227c43ceaf6d3725d70a05e","modified":1569572634029},{"_id":"source/_posts/Android/Advanced/README.md","hash":"0787c169bc584ddf7052d703cfa85ae052aa7329","modified":1570515581303},{"_id":"source/_posts/Android/Android JNI/README.md","hash":"7e39965fba85355bf46eb5d3a765f3c4b15dfddc","modified":1570515581304},{"_id":"source/_posts/Android/Advanced/应用启动流程.md","hash":"a58fff4d430f4f621334f42b9d5516b05cc97a7c","modified":1569832122949},{"_id":"source/_posts/Android/Android反编译/README.md","hash":"a573239109d5280fe1e2dfbb1e6ab4a38c9972ce","modified":1570515581305},{"_id":"source/_posts/Android/Android基础/Android序列化.md","hash":"306b94cf57b3ed51b14b4e1cee5e114206968f42","modified":1575112472183},{"_id":"source/_posts/Android/Android反编译/Android应用防止二次打包.md","hash":"2e7b9abf111de9139789e381821a93c35a4ba20b","modified":1575112472181},{"_id":"source/_posts/Android/Android基础/Android文件操作.md","hash":"be7f0b0a418b2171365576bf44534c58342ac721","modified":1569832122954},{"_id":"source/_posts/Android/Android基础/README.md","hash":"45c89a28c8786f71bf3f01392c64a8b264205d28","modified":1570515581306},{"_id":"source/_posts/Android/Android基础/Handler Looper介绍.md","hash":"8d223a887d0a52cfa5b39d6d517f694def0b954b","modified":1569832122955},{"_id":"source/_posts/Android/Android基础/getSystemService的使用.md","hash":"99ff57afc3eec0af7400ce4a3ec561e6ea6e4425","modified":1569832122956},{"_id":"source/_posts/Android/Android基础/Android后台任务.md","hash":"c184467607dff62825ed43781d74051b81e5e511","modified":1569832122954},{"_id":"source/_posts/Android/Android基础/异步操作Asynctask.md","hash":"c13b42d8a167b45bc9e896d5156045908b235af0","modified":1569832122957},{"_id":"source/_posts/Android/Ble/README.md","hash":"37bb30d6ecfe7d49adac922e4702102141ebbf9d","modified":1570515581307},{"_id":"source/_posts/Android/Ble/Android ble 4.0.md","hash":"e7f3d5879c4f49a78f98d19eae1ea7b4c38d7eb1","modified":1568886074745},{"_id":"source/_posts/Android/Other/README.md","hash":"6cdf0f2f8e2d43d16030ecae2839d8e040446d84","modified":1570515581307},{"_id":"source/_posts/Android/Other/常用操作.md","hash":"24cdf5e606de40677f384604324c8e75b873bbba","modified":1569832122960},{"_id":"source/_posts/Android/Other/Module的.gradle配置.md","hash":"5ba2bcf9e2eeb98e512290033e5f7e36221ad158","modified":1569832122959},{"_id":"source/_posts/Android/View/CountDownView.md","hash":"34969feb7164adf78ab07cff7163dda1a4bea976","modified":1568886074746},{"_id":"source/_posts/Android/Android基础/Android 6.0动态权限获取.md","hash":"7008ffb8e3729190b796329f63f04a4921da3be4","modified":1575112472182},{"_id":"source/_posts/Android/View/README.md","hash":"f1d8badbf0176eb3355cc3191622ab9d6cd86814","modified":1570515581308},{"_id":"source/_posts/Android/View/Materials Design.md","hash":"20db81d50ec3504c11ff3157c9cc825b0f774a0a","modified":1569832122962},{"_id":"source/_posts/Android/Android基础/数据储存.md","hash":"5290902296e6a6b3d7d085229845e565bb6f7a2f","modified":1575112472183},{"_id":"source/_posts/Android/View/LayoutInflater使用.md","hash":"1f81cd7a8c86ab03baababb5ae1b1f7362e97cdf","modified":1569832122961},{"_id":"source/_posts/Android/View/使用RecyclerView和SearchView实现查找删除.md","hash":"eb84bdcb6a53bbc1057ef874e2f07bb5b4226959","modified":1568886074746},{"_id":"source/_posts/Android/框架/README.md","hash":"7b67d980712bafd19a22f85d907c2818edfc20a9","modified":1575112472190},{"_id":"source/_posts/Android/框架/Retrofit 2.5 框架使用与源码分析.md","hash":"06feb65e9eedf5c88c0f4865d8f4ba02b2003a8c","modified":1575112472190},{"_id":"source/_posts/Android/框架/Dagger2.md","hash":"74838a04cf11a7e2176bcbe03cd112ab4fd834a7","modified":1582697579620},{"_id":"source/_posts/Android/框架/fastjson的使用.md","hash":"9fbf6f1dc654a1fffe925b3bc53a408ffc0258a6","modified":1575112472191},{"_id":"source/_posts/Java/Java基础/Java关键字.md","hash":"2f5e7ba1a0866b1b12a7e83d21a3f18bbbdc4185","modified":1575112472244},{"_id":"source/_posts/Java/Java基础/Java内部类.md","hash":"a1c55ad26f41cbd7267176e857eba2934cb5da0c","modified":1575112472244},{"_id":"source/_posts/Java/Java基础/Java引用.md","hash":"7712fe8cbc67e55eb130d0492a15a0b5646345ce","modified":1575112472244},{"_id":"source/_posts/Java/Java基础/README.md","hash":"2473632a9b8b7929660935a32ac9e52c6aa3773d","modified":1582697581241},{"_id":"source/_posts/Java/Java基础/Java泛型.md","hash":"01bff38ada294b76778b42e02e59f73e609922ec","modified":1569832122970},{"_id":"source/_posts/Java/Java基础/Java集合.md","hash":"09ed16a3dcdaf0888356fb3012ed1ddc9cca6482","modified":1569832122971},{"_id":"source/_posts/Java/Java基础/Lambda表达式.md","hash":"fcf731b1a26c81e12ff02fa5153e1b8613c1ba5f","modified":1575112472245},{"_id":"source/_posts/Java/Java基础/String、StringBuffer、StringBuilder区别.md","hash":"530f3ea4b8d13d60e820fc6035d5d7ee66e3679c","modified":1575112472245},{"_id":"source/_posts/Java/Java基础/加密算法.md","hash":"626f50f19938100a5873d9e89d3f20f6b69f455e","modified":1575112472246},{"_id":"source/_posts/Java/Java多线程/Java多线程与单例模式.md","hash":"33a8651c0045e6cb69d98324a041605759549ec9","modified":1569832122973},{"_id":"source/_posts/Java/Java多线程/Java多线程之间的协作.md","hash":"08f3c6a7a5b09651a8d5fc15a99099b2b3a824a5","modified":1568886074776},{"_id":"source/_posts/Java/Java多线程/Java线程间通信.md","hash":"958844981cc1b7f046f681c8afd34dbc8d3b5a45","modified":1569832122975},{"_id":"source/_posts/Java/Java多线程/README.md","hash":"6e7ea48e601390b974b362e9959faaedd72b7801","modified":1570515581310},{"_id":"source/_posts/Java/Java多线程/Java多线程基础.md","hash":"547ef2a2f9d0e0f837893fd0a379ec13b56a398c","modified":1569832122974},{"_id":"source/_posts/Java/设计模式/README.md","hash":"98205ee0e71ca34d296822574453bcf41a2e575e","modified":1570515581311},{"_id":"source/_posts/Java/设计模式/代理模式.md","hash":"14c279e81c811ea4073c30f5e3de9161592294c7","modified":1575112472246},{"_id":"source/_posts/Java/设计模式/观察者模式.md","hash":"c54c4421f5496dbc0c4beb82a5942fbb9f812d47","modified":1569832122978},{"_id":"source/_posts/Kotlin/Kotlin基础/Lambda表达式.md","hash":"084f4cb3a6eeef13c46f94c04e63dad67b94789e","modified":1575112472247},{"_id":"source/_posts/Other/Git/Git出现问题.md","hash":"f5c0a7e6af607bfedee6f095fc8aaf901f8c698a","modified":1569027130120},{"_id":"source/_posts/Other/Img/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1568199763460},{"_id":"source/_posts/Other/Img/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1568199763460},{"_id":"source/_posts/Other/Img/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1568199763461},{"_id":"source/_posts/Other/Img/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1568199763462},{"_id":"source/_posts/Other/Git/Git.md","hash":"b36ae043f905c612fb7cf148a20b23d2164bcfd8","modified":1575112472247},{"_id":"source/_posts/Other/Img/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1568199763462},{"_id":"source/_posts/Other/Img/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1568199763463},{"_id":"source/_posts/Other/Img/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1568199763461},{"_id":"source/_posts/Other/Img/Image 2 - Copy.png","hash":"be3b346e0fb058b5999f9a096d2a889fc223be47","modified":1568199763464},{"_id":"source/_posts/Other/Img/Image 3 - Copy.png","hash":"84dfcf80bb621bbc32490b6155ac80cefaab1d14","modified":1568199763465},{"_id":"source/_posts/Other/Img/Image 8 - Copy.png","hash":"de3fa169a3a6d8d0f5aac98c94cc837baad495c8","modified":1568199763466},{"_id":"source/_posts/Android/Android JNI/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569027130115},{"_id":"source/_posts/Android/Advanced/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569832122943},{"_id":"source/_posts/Android/Android反编译/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569832122952},{"_id":"source/_posts/Android/Android基础/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074743},{"_id":"source/_posts/Android/框架/AAC/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568886074748},{"_id":"source/_posts/Android/框架/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1575112472188},{"_id":"source/_posts/Java/Java基础/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1569572634079},{"_id":"source/_posts/Java/设计模式/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1574943623102},{"_id":"source/_posts/Other/Img/Image 10 - Copy.png","hash":"6f08a05e55011c24f423d5498fa6b2677d549235","modified":1568199763464},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1569027130113},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1569027130113},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1569027130114},{"_id":"source/_posts/Android/Android JNI/Img/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1569027130115},{"_id":"source/_posts/Android/Android反编译/Img/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1569832122951},{"_id":"source/_posts/Android/Android反编译/Img/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1569832122952},{"_id":"source/_posts/Android/框架/AAC/Android Architecture Components.md","hash":"0d2bf3d9ad21a054f35e8043db9b395b430b52d2","modified":1568886074748},{"_id":"source/_posts/Android/框架/AAC/Android Lifecycle-Aware组件详解.md","hash":"cde60dc864ec69fa4142a46019c53a07ba00c0df","modified":1575112472184},{"_id":"source/_posts/Android/框架/AAC/DataBinding的使用.md","hash":"be22fd962a95158208d175711e4e61a53a29245d","modified":1582697579613},{"_id":"source/_posts/Android/框架/AAC/Android Livedata详解.md","hash":"5ad10e0877968b3a7aa102b5ec21e25e519b08ea","modified":1582697579606},{"_id":"source/_posts/Android/框架/AAC/Lifecycle和Room的使用.md","hash":"08f9c8c79baa6fdf62e64d5e329b76f934b05c0f","modified":1575112472187},{"_id":"source/_posts/Android/框架/AAC/Paging和Room使用.md","hash":"b28ac7c5bf98c6c1b1990af8c53796d0752ddce8","modified":1569832122964},{"_id":"source/_posts/Android/框架/AAC/Room数据库.md","hash":"c95d64e9f7142b4ca96e7481be2c209136836942","modified":1569832122965},{"_id":"source/_posts/Android/框架/AAC/WorkManager介绍.md","hash":"1ab63edfbf3b88d73515e69bab6d54b8033290c8","modified":1569832122965},{"_id":"source/_posts/Android/框架/AAC/Room和Lifecycle构建程序.md","hash":"08f9c8c79baa6fdf62e64d5e329b76f934b05c0f","modified":1568886074749},{"_id":"source/_posts/Java/设计模式/Img/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1574943623103},{"_id":"source/_posts/Android/框架/AAC/Img/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1575112472185},{"_id":"source/_posts/Android/框架/Img/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1575112472188},{"_id":"source/_posts/Java/Java基础/Img/collection.png","hash":"38dfaafd4896d4e584b8508aa9a1a86942170104","modified":1569832122970},{"_id":"source/_posts/Android/框架/AAC/Img/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1575112472186},{"_id":"source/_posts/Android/框架/AAC/Img/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1575112472186},{"_id":"source/_posts/Android/Advanced/Img/application_start.png","hash":"6395d26d20169517eabbbb36f2a4c010a7be6b7f","modified":1569832122947},{"_id":"public/2019/11/30/Android/框架/Retrofit 2.5 框架使用与源码分析/index.html","hash":"a48de5f6dc900d1c1c0102f405b960430b61d91a","modified":1582806711577},{"_id":"public/2019/11/28/Kotlin/Kotlin基础/README/index.html","hash":"2e2ce425f08dd11194bc995452fdbcd5a1ff5f11","modified":1582806711577},{"_id":"public/2019/11/28/Kotlin/Kotlin基础/Lambda表达式/index.html","hash":"cdeb0df4cd7309db04ded913d83c3d81b76a3181","modified":1582806711577},{"_id":"public/2019/11/28/Java/设计模式/Img/README/index.html","hash":"f8180e54d44ca6c258fc5b8d08423b5d0067a52b","modified":1582806711577},{"_id":"public/2019/11/28/Java/Java基础/加密算法/index.html","hash":"f6b218ef4cf279f8d383b594e1ff116bbae9f1ba","modified":1582806711577},{"_id":"public/2019/11/28/Java/Java基础/Java引用/index.html","hash":"2de0ffde8cc80534e546c798d196d44627eb9edf","modified":1582806711577},{"_id":"public/2019/11/28/Android/框架/AAC/Android Livedata详解/index.html","hash":"31afdbff12e257279c7c4bf7a1c8f51795fe0edf","modified":1582806711577},{"_id":"public/2019/11/28/Android/框架/AAC/Android Lifecycle-Aware组件详解/index.html","hash":"f7992d2dd79f440410afbac157d2826ec0fbd8b0","modified":1582806711577},{"_id":"public/2019/11/28/Android/Android基础/数据储存/index.html","hash":"4b63cbfb2d4ecc6915e809a3a530eae03b80b13f","modified":1582806711577},{"_id":"public/2019/11/28/Android/Android基础/Android序列化/index.html","hash":"39bdbaec7fabefe6b3ad4daefbd86c36c3f58bd2","modified":1582806711577},{"_id":"public/2019/11/28/Java/设计模式/代理模式/index.html","hash":"eeb9f4ab6a078b5291088f0edccf8f1dbfcebb87","modified":1582806711577},{"_id":"public/2019/11/28/Java/Java基础/Java内部类/index.html","hash":"f5cc03d2d292841410530e1278e330f41e7f7f4f","modified":1582806711577},{"_id":"public/2019/09/30/Android/Other/常用操作/index.html","hash":"7569fe6879f31f60cd9faf7525b81cc9bbc705dd","modified":1582806711577},{"_id":"public/2019/09/30/Android/Other/Module的.gradle配置/index.html","hash":"44ad8765cf7eb44890c12a885ca57f8bb1797ae4","modified":1582806711577},{"_id":"public/2019/09/30/Android/Other/Groovy介绍/index.html","hash":"b00e615206c76abcbb2f4eb264409b73d0effb61","modified":1582806711577},{"_id":"public/2019/09/30/Android/Android反编译/Android应用防止二次打包/index.html","hash":"bd74224e2e28002933e001d8a6338551d3908fb7","modified":1582806711577},{"_id":"public/2019/09/30/Android/Advanced/应用启动流程/index.html","hash":"4ef880c97e84b258bfc67fb4f5b9852f83f13eb6","modified":1582806711577},{"_id":"public/2019/09/30/Android/Android基础/Android后台任务/index.html","hash":"6f88270e75111456a5ca357b2eeb1ac998ac27d6","modified":1582806711577},{"_id":"public/2019/09/30/Android/框架/AAC/WorkManager介绍/index.html","hash":"9428adda2531f5af0d49edacbc9575216ca02f01","modified":1582806711577},{"_id":"public/2019/09/30/Android/框架/AAC/Room数据库/index.html","hash":"4918b5ca2cc831f6802218194d2443ca341d6dfc","modified":1582806711577},{"_id":"public/2019/09/30/Android/框架/AAC/Paging和Room使用/index.html","hash":"a5b28cfaef5f341b2c207da5b276706afcdb6d4f","modified":1582806711577},{"_id":"public/2019/09/30/Android/框架/AAC/Lifecycle和Room的使用/index.html","hash":"e3a2a71ad001d07c6dafe5cc87543e124159388d","modified":1582806711577},{"_id":"public/2019/09/30/Android/框架/AAC/DataBinding的使用/index.html","hash":"d7116a6289e3ee19884eb60a1c116dce2def9e21","modified":1582806711577},{"_id":"public/2019/09/30/Android/View/Materials Design/index.html","hash":"c4ed7564aed002af93cef85dfb5bb6b6499f881a","modified":1582806711577},{"_id":"public/2019/09/30/Android/View/ActionBar和ToolBar的使用/index.html","hash":"d8cbbf277283e2d977667489004e47d53b5a663e","modified":1582806711577},{"_id":"public/2019/09/30/Android/View/LayoutInflater使用/index.html","hash":"892607bb1a08ca13ca56f2403504cadec24b8f6b","modified":1582806711577},{"_id":"public/2019/09/30/Android/Android基础/异步操作Asynctask/index.html","hash":"e25bb0a244724ccd51996148493bda86ed42f16e","modified":1582806711577},{"_id":"public/2019/09/30/Android/Android基础/Handler Looper介绍/index.html","hash":"339e02bb87e9c623c17d8227d8c217fdad00d00e","modified":1582806711577},{"_id":"public/2019/09/30/Android/Android基础/getSystemService的使用/index.html","hash":"d606e850608c10f291d29db4e5eed372bff2eceb","modified":1582806711577},{"_id":"public/2019/09/27/Java/Java基础/Img/README/index.html","hash":"acfa116d9d2319161a5b80a3974b6906166e0acd","modified":1582806711577},{"_id":"public/2019/09/27/Java/Java基础/Java集合/index.html","hash":"36c60957fa2656b2d027d77c57245d7c015bfbb7","modified":1582806711577},{"_id":"public/2019/09/27/Android/框架/fastjson的使用/index.html","hash":"d6450719a24cddadf3d2aa381d233b532cbd01b8","modified":1582806711577},{"_id":"public/2019/09/21/Android/Android JNI/Android Studio JNI引入/index.html","hash":"0aa09639791dd1902c2c4aed79aa6da6e18d7d4e","modified":1582806711577},{"_id":"public/2019/09/21/Android/Android JNI/Android JNI敏感信息保护/index.html","hash":"1df48358a5ff26d34a90e82948dec5db6bfc2558","modified":1582806711577},{"_id":"public/2019/09/21/Other/Git/Git出现问题/index.html","hash":"3a5d8731eae8b67ff0a414a1afff02a0accbb2f5","modified":1582806711577},{"_id":"public/2019/09/19/Other/Git/README/index.html","hash":"bfb067e718c0816b4912ce90cf55cebcd1f29b8d","modified":1582806711577},{"_id":"public/2019/09/19/Other/Git/Git/index.html","hash":"c0a37fac20705d3c871302d9c4e4eb7b7332d846","modified":1582806711577},{"_id":"public/2019/09/19/Java/设计模式/观察者模式/index.html","hash":"4ea909c75c85ccd57948b2d561d1af7dbbf7f70a","modified":1582806711577},{"_id":"public/2019/09/19/Java/设计模式/README/index.html","hash":"a8eee4649fac8aad11f96427009b5c5dbce43f41","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java虚拟机/README/index.html","hash":"3e00fff71e3460a15e6db588e96c1fc377b48329","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java多线程/Java线程间通信/index.html","hash":"a368b9fa406c38ddf70aa3549c44bac64e8729fb","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java多线程/Java锁机制/index.html","hash":"5ad6c31b8bafb9dabc62031b50c6c8408e1503b2","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java多线程/README/index.html","hash":"9be0310561f00165a41d89f93662e977d05fd677","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java多线程/Java多线程基础/index.html","hash":"d6d5cd6c6664c0ddbe5d72f8b9f926eeb9f864f7","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java多线程/Java多线程之间的协作/index.html","hash":"2bafb8e02a676eb284a18ef9b2dc37f4b44103a2","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java多线程/Java多线程与单例模式/index.html","hash":"c0a3084f445fedcd983768c7eef06a9eb24bf658","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java基础/README/index.html","hash":"cbbf1d0320aba268638386dd56964aee14c6350e","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java基础/String、StringBuffer、StringBuilder区别/index.html","hash":"27d432f5ffc86662c875d8052c7f5bce981036e2","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java基础/Lambda表达式/index.html","hash":"be3fa2ab693972e6e726cd6970466e41ae7ae65e","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java基础/Java泛型/index.html","hash":"b9389aacdd9118c2d8d5e21cc8382fde6f651934","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java基础/Java关键字/index.html","hash":"03e859d332fe506789f08ae153fa79334177dbba","modified":1582806711577},{"_id":"public/2019/09/19/Java/Java基础/Java 输入输出操作/index.html","hash":"3a5f887f8a55803de37b7b19122dc70d95c76f17","modified":1582806711577},{"_id":"public/2019/09/19/Android/框架/AAC/Room和Lifecycle构建程序/index.html","hash":"b5f509e55a899f692872aae0c496146c952a1fc9","modified":1582806711577},{"_id":"public/2019/09/19/Android/框架/AAC/README/index.html","hash":"bfbc4363f91feed78812dc940b593ccc4ee9ec52","modified":1582774541675},{"_id":"public/2019/09/19/Android/框架/AAC/Android Architecture Components/index.html","hash":"b4fc7796c6c25326931930849edb52e97c83d743","modified":1582806711577},{"_id":"public/2019/09/19/Android/View/使用RecyclerView和SearchView实现查找删除/index.html","hash":"6766b07861b2b46c183aa361ae0deffb6c873f39","modified":1582806711577},{"_id":"public/2019/09/19/Android/View/CountDownView/index.html","hash":"a9540d0a7a2838e8c986e77f02fcb36f86cc9de5","modified":1582806711577},{"_id":"public/2019/09/19/Android/Ble/Android ble 4.0/index.html","hash":"0c11e1b945887cc5b3053115ee8ee220985c9911","modified":1582806711577},{"_id":"public/2019/09/19/Other/函数式编程/index.html","hash":"6a691eef40a8bb89ae7b763c11a1a7aca8384d5d","modified":1582806711577},{"_id":"public/2019/09/19/Android/框架/Dagger2/index.html","hash":"10855b1a00c74bd4cff335a74b2e005849a6aab6","modified":1582806711577},{"_id":"public/2019/09/19/Android/框架/README/index.html","hash":"2fdc2811f770c0906b942fa85d248f046d55c1c1","modified":1582774541675},{"_id":"public/2019/09/19/Android/框架/RxJava2.0/index.html","hash":"1861b228798ed33f0ad3ba9d3c5dfe04c51f324d","modified":1582806711577},{"_id":"public/2019/09/19/Android/Android基础/Android文件操作/index.html","hash":"31e3fb670bb370a176e4bb104936cdc9643f5c53","modified":1582806711577},{"_id":"public/2019/09/19/Android/Android基础/Android 6.0动态权限获取/index.html","hash":"3621c8a88c45a72017480522976ad31d2f489384","modified":1582806711577},{"_id":"public/2019/09/11/Directory/Other Directory/index.html","hash":"cae54c29610b8ab084decc9217328ef09a73f12e","modified":1582806711577},{"_id":"public/2019/09/11/Other/README/index.html","hash":"a7f844dd0d12ce953afe77d387c449ed956020db","modified":1582806711577},{"_id":"public/2019/09/11/Other/Img/README/index.html","hash":"ebaa6ae05bb186d49bf4c404560865cab3a24c10","modified":1582806711577},{"_id":"public/2019/09/11/Java/README/index.html","hash":"ff887db9bd2950fa91ebb30932ea0f050e35a438","modified":1582806711577},{"_id":"public/2019/09/11/Kotlin/README/index.html","hash":"95c882a3808265f9e60912f977e4ee0f055e37e9","modified":1582806711577},{"_id":"public/2019/09/11/Directory/README/index.html","hash":"934c006fb6bfaa6202b262583dc7aa4841bda342","modified":1582806711577},{"_id":"public/2019/09/11/Directory/Kotlin Directory/index.html","hash":"c50b4b58bff8b5da86a0a535ea2e0d9b9687be49","modified":1582806711577},{"_id":"public/2019/09/11/Directory/Android Directory/index.html","hash":"90ebe16354054b5aa405e501df63834222a09680","modified":1582806711577},{"_id":"public/2019/09/11/Directory/Java Directory/index.html","hash":"fdbe96c54377847d7cb68cb9e5b514cdfb15f9e9","modified":1582806711577},{"_id":"public/archives/page/2/index.html","hash":"6ad76c6557ceb06b1c84ae7ea54e088c71113ea3","modified":1582805617599},{"_id":"public/archives/page/3/index.html","hash":"142e8cb451b09622ea7336e7790f76d2ce699a06","modified":1582805617599},{"_id":"public/archives/page/4/index.html","hash":"6e32a5f43f063b21f72675da60a3a95f825d9ca6","modified":1582805617599},{"_id":"public/archives/page/5/index.html","hash":"9c6de4f530c7fecb69a03b7474c5535a4784bdc3","modified":1582805617599},{"_id":"public/archives/page/6/index.html","hash":"0436cc72f91d981da0e4c0352893e849ed1eb972","modified":1582805617599},{"_id":"public/archives/page/7/index.html","hash":"2fb93aa6637bf0cbcadde484dae53ed43502fa65","modified":1582805617599},{"_id":"public/archives/page/8/index.html","hash":"a33d59b61c39ed685b0a81c0eb59d19c4d40f522","modified":1582805617599},{"_id":"public/archives/2019/index.html","hash":"ec3909e83724718b4069b771f0def702118b67cc","modified":1582805617599},{"_id":"public/archives/2019/page/2/index.html","hash":"2894ce775f1f78302b54c551238d6e00b72391bf","modified":1582805617599},{"_id":"public/archives/2019/page/3/index.html","hash":"b75459f31a1aa7bc941b84dfcc3c0eb7224a5384","modified":1582805617599},{"_id":"public/archives/2019/page/4/index.html","hash":"dbc6cd7a9a116eaaed695db55ab943eac22c060b","modified":1582805617599},{"_id":"public/archives/2019/page/5/index.html","hash":"4a398b1ff577b86d68982b9f8fbf81b45ccab370","modified":1582805617599},{"_id":"public/archives/2019/page/6/index.html","hash":"272a03a38f4a23131d0095becb2adf308575db18","modified":1582805617599},{"_id":"public/archives/2019/page/7/index.html","hash":"0d9be14554f0e3ac8e8b8ba3f8a2f96b7e3410bb","modified":1582805617599},{"_id":"public/archives/2019/page/8/index.html","hash":"e4a91ada50acf0fc3ea8348d0cc30d81435269d2","modified":1582805617599},{"_id":"public/archives/2019/09/index.html","hash":"32f38ff80b560bd6c72b527062bad27c57185623","modified":1582805617599},{"_id":"public/archives/2019/09/page/2/index.html","hash":"51303466813bbd6293bfa0a3386eaa4d142924d7","modified":1582805617599},{"_id":"public/archives/2019/09/page/3/index.html","hash":"bd85e4a25688db18bb8b2864a7b847c848da8808","modified":1582805617599},{"_id":"public/archives/2019/09/page/4/index.html","hash":"5972352e0d220127870b94df02630e47b3f4fa61","modified":1582805617599},{"_id":"public/archives/2019/09/page/5/index.html","hash":"bf660d757c1d175f40986dc08bb62dd189dd65a8","modified":1582805617599},{"_id":"public/archives/2019/09/page/6/index.html","hash":"b0d7574dd98ac9cac2008807a8470cc46880876f","modified":1582805617599},{"_id":"public/archives/2019/09/page/7/index.html","hash":"88c9388378f105c93d93b71de1affdf946750879","modified":1582774541675},{"_id":"public/archives/2019/11/index.html","hash":"2afc5e8a3e47167785557485f861cc83011620e0","modified":1582805617599},{"_id":"public/archives/2019/11/page/2/index.html","hash":"cc510b93809a2acf4b22d2017fa41766338c2126","modified":1582805617599},{"_id":"public/page/2/index.html","hash":"3c86ac4d642d8688fb5b2edb63ae97791186a0f7","modified":1582805617599},{"_id":"public/page/3/index.html","hash":"82d402461ad63d15f328a0dc0171eed6f43022ae","modified":1582805617599},{"_id":"public/page/4/index.html","hash":"6ff2ab6882f97084aa82ed7dc46761680c398a3e","modified":1582805617599},{"_id":"public/page/5/index.html","hash":"19183c50634304f08f39d31b232757892388b9b5","modified":1582805617599},{"_id":"public/page/6/index.html","hash":"956038467e267698b2cb40f2bded0ce817ab8a51","modified":1582805617599},{"_id":"public/page/7/index.html","hash":"0e14efe1e7feb7b9ed94f3fddf80018fa842c045","modified":1582805617599},{"_id":"public/page/8/index.html","hash":"0ece645dc7d35a1e7af66279756306cdd14bb69d","modified":1582805617599},{"_id":"themes/icarus/include/config.js","hash":"92120c5a1a01b21fc6b7b67597809626d938def4","modified":1582775185315},{"_id":"themes/icarus/include/dependency.js","hash":"239871703ff1d23cd59aa9213c5fa0a0ed2706c0","modified":1582775185315},{"_id":"themes/icarus/include/register.js","hash":"412a74e9e38959232080e17b6ced6b99346ea3c3","modified":1582775185317},{"_id":"themes/icarus/include/generator/category.js","hash":"ab6bd15ded796ea978166da480de56600af14787","modified":1582775185316},{"_id":"themes/icarus/include/generator/insight.js","hash":"58251b0393541836ae40da3ba32a3d6821b74163","modified":1582775185316},{"_id":"themes/icarus/include/schema/config.json","hash":"d330826d82e61311d3f740033569e47fb9b995df","modified":1582775185320},{"_id":"themes/icarus/include/migration/head.js","hash":"c32df32ae70cd5e522de5481cde4e7c416b4dbec","modified":1582775185316},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"9426e6bc533d7c7ce6469f0e9af3116d16f8ebe5","modified":1582775185316},{"_id":"themes/icarus/include/util/console.js","hash":"9bd6d4691b56012ea17146db577e27ae20e0c335","modified":1582775185331},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185320},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185320},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185329},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185317},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"0b5c4a315c0d25f2b296eb44ed14a1d59ccb8613","modified":1582775185328},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"c8e0e97a61c3a02c9736f303c206dd406de95d9a","modified":1582775185328},{"_id":"themes/icarus/include/schema/search/insight.json","hash":"44a26a37e3001c837fb5e700ffbc58200073ea5d","modified":1582775185329},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"994aff115d59827ad6f98d03adf55b1cf1245378","modified":1582775185330},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e79bb7b210946d22bd3a9c710171c548de49a050","modified":1582775185317},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"53feccffe707b127d0dafd734765a3d07a9315f2","modified":1582775185317},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ab5101361da826f8a487bc837b6fa6ed75729568","modified":1582775185318},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"b6036e21a11a5ed0455010ee668e43f165e55254","modified":1582775185318},{"_id":"themes/icarus/include/schema/common/head.json","hash":"f87ff5940319521a77999a1c5ca1813e2df72f4c","modified":1582775185318},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"52a7ae23ebcfb06e8c219be4da1506b824e17715","modified":1582775185318},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"9f16d1dd9bac72ebff4679ff94de64a4a0c232a6","modified":1582775185319},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"5453827e1c267c67102bc983c8d2313865aa64fd","modified":1582775185319},{"_id":"themes/icarus/include/schema/common/search.json","hash":"aa424beb14eac46e2736a6a5ef65a820b770b08d","modified":1582775185319},{"_id":"themes/icarus/include/schema/common/share.json","hash":"da98300e9197fbc717082419652d54636fd118b9","modified":1582775185319},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"5687b24e32bcff12ff7660ff5dc26d74f466a994","modified":1582775185319},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"43a9c4fccaf75418038537e2e49f2457727a21e7","modified":1582775185319},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185334},{"_id":"themes/icarus/layout/common/article.jsx","hash":"5b3d427f8ee749a4eb0bf320f9bd4095596c5229","modified":1582775185334},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"3321f208cface80be066e5eef8365eef39bbe2c9","modified":1582775185335},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"c87954a34ef638b519f2e1ba212b3ea104440bd6","modified":1582775185335},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"583a29899f56f278caf3afbe019a17e1ec7fc027","modified":1582775185335},{"_id":"themes/icarus/layout/common/head.jsx","hash":"5d6b261df80bdc371a5ebf081291f86501533c7d","modified":1582775185335},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"59786a8510709ff43f2af0e01ff9715cdebc26fd","modified":1582775185336},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"47b1cadac0f384a8e7cb12a19d5ff622794ae777","modified":1582775185336},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"a40608473a1674de2ed05c5dc5627ab1d7a12744","modified":1582775185336},{"_id":"themes/icarus/layout/common/search.jsx","hash":"e98937e6b0f050467b2faf66845626c663f26cc7","modified":1582775185337},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"c319ba67d1da52d5f14685a6d60228905948abca","modified":1582775185337},{"_id":"themes/icarus/layout/common/share.jsx","hash":"486c2c71fb7c116c6fb46e23dd30e138d82c25ca","modified":1582775185337},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185337},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185338},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"234df8a62e28f5da60515b61587dd8263cfc0402","modified":1582775185338},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"472c68b06850c0ccaf0706526490b4f410968f46","modified":1582775185338},{"_id":"themes/icarus/layout/search/insight.jsx","hash":"afc76c51550d04023144d78a9f79fda7b0a2bfdd","modified":1582775185343},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582775185347},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"570d873af276553149e19e50c3a3dd67106e5797","modified":1582775185349},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1582775185354},{"_id":"themes/icarus/source/img/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1582775185355},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1582775185358},{"_id":"themes/icarus/source/img/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1582775185358},{"_id":"themes/icarus/source/css/plugin/progressbar.styl","hash":"b564f52e425fa79e6896eb16fb0a8137b2f24b11","modified":1582775185353},{"_id":"themes/icarus/source/css/plugin/back-to-top.styl","hash":"0ccb14694ed4600be149c4861cc5298125494611","modified":1582775185352},{"_id":"themes/icarus/source/img/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1582775185356},{"_id":"themes/icarus/.history/_config_20200227114205.yml","hash":"76e00ecdcf37dbe3ba22ae67a6bd53a28e30c3f8","modified":1582779829323},{"_id":"themes/icarus/.vscode/launch.json","hash":"8b1c9425598f2772e2d7d933ca3b3b3be2c0c9f4","modified":1582780008952},{"_id":"themes/icarus/.history/_config_20200227130349.yml","hash":"499667549c9d67bebb365b52b64c57b139f4614f","modified":1582779829353},{"_id":"public/about/about.html","hash":"347a18e6a6ccdbb500bf4deba7fc202874a569bd","modified":1582806711577},{"_id":"source/about/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1582772035277},{"_id":"public/about/hello-world.html","hash":"9925eb50f3b5d54ce8f30a98a46de2d9db7c8a57","modified":1582783130078},{"_id":"themes/icarus/source/about/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1582772035277},{"_id":"source/about/index.md","hash":"455ea40c1c110303e5d6f24ad0b662c6949ac3c3","modified":1582783703679},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582799939883},{"_id":"themes/icarus/source/images/avatar.jpg","hash":"08eaa857c1a207880486fa8745233d56f624664a","modified":1582799224671},{"_id":"public/images/avatar.jpg","hash":"08eaa857c1a207880486fa8745233d56f624664a","modified":1582803005042},{"_id":"themes/icarus/.history/_config_20200227194552.yml","hash":"49e60500f66cb377a59ce6c4ce4231454413e2bc","modified":1582804191091},{"_id":"themes/icarus/.history/_config_20200227194951.yml","hash":"91cb10160b86b7cfa2a738a968b11b6f04733df3","modified":1582804191984},{"_id":"themes/icarus/.history/_config_20200227195541.yml","hash":"138b95c9765800be88301d088948ce105b00fe24","modified":1582804541465},{"_id":"themes/icarus/source/images/wechat_donate.png","hash":"34177b6a5d7eb05babc4a5fd1b7952daf65056cf","modified":1582804364277},{"_id":"themes/icarus/source/images/alipay_donate.png","hash":"451d6a847df4bd48e0c0217242fe357f4e31e3ff","modified":1582804415019},{"_id":"public/images/wechat_donate.png","hash":"34177b6a5d7eb05babc4a5fd1b7952daf65056cf","modified":1582804546312},{"_id":"public/images/alipay_donate.png","hash":"451d6a847df4bd48e0c0217242fe357f4e31e3ff","modified":1582804546312},{"_id":"themes/icarus/.history/_config_20200227195838.yml","hash":"4885f8887e761fd40f8600aa5600fedc98f8046b","modified":1582804718462},{"_id":"themes/icarus/.history/_config_20200227195840.yml","hash":"4885f8887e761fd40f8600aa5600fedc98f8046b","modified":1582804720478},{"_id":"themes/icarus/.history/_config_20200227195939.yml","hash":"f20297385004473731eb52342b40ee61cabe0fb6","modified":1582804779651},{"_id":"themes/icarus/.history/_config_20200227200018.yml","hash":"efa67d925ad66267a1414d965152ef15a963fe79","modified":1582804818626},{"_id":"themes/icarus/.history/_config_20200227200019.yml","hash":"efa67d925ad66267a1414d965152ef15a963fe79","modified":1582804819481},{"_id":"themes/icarus/.history/_config_20200227200315.yml","hash":"a5bf4608b09b31f68ca4af0ae1432fe9c5727ae7","modified":1582804995211},{"_id":"themes/icarus/.history/_config_20200227200505.yml","hash":"f7647f6778110773dc4bdec40149f40171d00320","modified":1582805105725},{"_id":"themes/icarus/.history/_config_20200227200630.yml","hash":"c4ae62bdef2838372a6647edc7c06a396c4e1c98","modified":1582805190162},{"_id":"themes/icarus/.history/_config_20200227200633.yml","hash":"c4ae62bdef2838372a6647edc7c06a396c4e1c98","modified":1582805193361},{"_id":"themes/icarus/.history/_config_20200227200743.yml","hash":"c4ae62bdef2838372a6647edc7c06a396c4e1c98","modified":1582805263703},{"_id":"themes/icarus/.history/_config_20200227202614.yml","hash":"5971d8f9fb1111375f6308cf3753086ec7a8b7b5","modified":1582806374713},{"_id":"themes/icarus/.history/_config_20200227203141.yml","hash":"6cf43e3ff954246b494d5a86ef2b063dfa2b5487","modified":1582806701176}],"Category":[],"Data":[],"Page":[{"_content":"++++++++++++++++++","source":"about/about.md","raw":"++++++++++++++++++","date":"2020-02-27T05:32:29.270Z","updated":"2020-02-27T05:32:29.270Z","path":"about/about.html","_id":"ck74b9ise000010ui84xthhvw","title":"","comments":1,"layout":"page","content":"<p>++++++++++++++++++</p>\n","site":{"data":{}},"excerpt":"","more":"<p>++++++++++++++++++</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-02-26T12:43:14.002Z","updated":"2020-02-27T02:53:55.277Z","_id":"ck73bdehx0000n0uieuj6eiy6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"_content":"","source":"_posts/Directory/Android Directory.md","raw":"","slug":"Directory/Android Directory","published":1,"date":"2019-09-11T01:29:47.698Z","updated":"2019-09-11T01:29:47.698Z","title":"Directory/Android Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhyo0000kgui7c1r82pg","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Directory/Kotlin Directory.md","raw":"","slug":"Directory/Kotlin Directory","published":1,"date":"2019-09-11T01:29:47.698Z","updated":"2019-09-11T01:29:47.698Z","title":"Directory/Kotlin Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhyy0001kguicdcqbptv","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Directory/README.md","raw":"","slug":"Directory/README","published":1,"date":"2019-09-11T01:29:47.699Z","updated":"2019-09-11T01:29:47.699Z","title":"Directory/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhz00002kgui2msqhot0","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Kotlin/README.md","raw":"","slug":"Kotlin/README","published":1,"date":"2019-09-11T01:29:47.705Z","updated":"2019-09-11T01:29:47.705Z","title":"Kotlin/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhz10003kguib9775vlw","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"\n# 其他文章目录\n\n","source":"_posts/Directory/Other Directory.md","raw":"\n# 其他文章目录\n\n","slug":"Directory/Other Directory","published":1,"date":"2019-09-11T11:02:43.459Z","updated":"2019-09-30T08:28:42.968Z","title":"Directory/Other Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhz20004kguigr5i0zw4","content":"<h1 id=\"其他文章目录\"><a href=\"#其他文章目录\" class=\"headerlink\" title=\"其他文章目录\"></a>其他文章目录</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"其他文章目录\"><a href=\"#其他文章目录\" class=\"headerlink\" title=\"其他文章目录\"></a>其他文章目录</h1>"},{"_content":"# Java目录\n\n* [Java基础](Java基础/README.md)\n* [Java多线程](Java多线程/README.md)\n* [Java虚拟机](Java虚拟机/README.md)\n* [Java设计模式](设计模式/README.md)","source":"_posts/Java/README.md","raw":"# Java目录\n\n* [Java基础](Java基础/README.md)\n* [Java多线程](Java多线程/README.md)\n* [Java虚拟机](Java虚拟机/README.md)\n* [Java设计模式](设计模式/README.md)","slug":"Java/README","published":1,"date":"2019-09-11T01:29:47.705Z","updated":"2019-09-30T08:28:42.977Z","title":"Java/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhz20005kguic00fbf02","content":"<h1 id=\"Java目录\"><a href=\"#Java目录\" class=\"headerlink\" title=\"Java目录\"></a>Java目录</h1><ul>\n<li><a href=\"Java基础/README.md\">Java基础</a></li>\n<li><a href=\"Java多线程/README.md\">Java多线程</a></li>\n<li><a href=\"Java虚拟机/README.md\">Java虚拟机</a></li>\n<li><a href=\"设计模式/README.md\">Java设计模式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java目录\"><a href=\"#Java目录\" class=\"headerlink\" title=\"Java目录\"></a>Java目录</h1><ul>\n<li><a href=\"Java基础/README.md\">Java基础</a></li>\n<li><a href=\"Java多线程/README.md\">Java多线程</a></li>\n<li><a href=\"Java虚拟机/README.md\">Java虚拟机</a></li>\n<li><a href=\"设计模式/README.md\">Java设计模式</a></li>\n</ul>\n"},{"_content":"# Java文章目录\n","source":"_posts/Directory/Java Directory.md","raw":"# Java文章目录\n","slug":"Directory/Java Directory","published":1,"date":"2019-09-11T01:29:47.698Z","updated":"2019-09-30T08:28:42.967Z","title":"Directory/Java Directory","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhz30006kguickdbe4mm","content":"<h1 id=\"Java文章目录\"><a href=\"#Java文章目录\" class=\"headerlink\" title=\"Java文章目录\"></a>Java文章目录</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java文章目录\"><a href=\"#Java文章目录\" class=\"headerlink\" title=\"Java文章目录\"></a>Java文章目录</h1>"},{"_content":"## 函数式编程（FP）\n\n\"函数式编程\", 又称泛函编程, 是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。\n函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","source":"_posts/Other/函数式编程.md","raw":"## 函数式编程（FP）\n\n\"函数式编程\", 又称泛函编程, 是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。\n函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","slug":"Other/函数式编程","published":1,"date":"2019-09-19T09:34:08.500Z","updated":"2019-09-19T09:41:14.781Z","title":"Other/函数式编程","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhz90007kgui1w3b5ku0","content":"<h2 id=\"函数式编程（FP）\"><a href=\"#函数式编程（FP）\" class=\"headerlink\" title=\"函数式编程（FP）\"></a>函数式编程（FP）</h2><p>“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。<br>函数式编程关心数据的映射，命令式编程关心解决问题的步骤；</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数式编程（FP）\"><a href=\"#函数式编程（FP）\" class=\"headerlink\" title=\"函数式编程（FP）\"></a>函数式编程（FP）</h2><p>“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。<br>函数式编程关心数据的映射，命令式编程关心解决问题的步骤；</p>\n"},{"_content":"\n## Other目录\n\n* [Git基础](Git/Git.html)","source":"_posts/Other/README.md","raw":"\n## Other目录\n\n* [Git基础](Git/Git.html)","slug":"Other/README","published":1,"date":"2019-09-11T08:04:40.931Z","updated":"2019-10-08T06:19:41.311Z","title":"Other/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhza0008kguibumv6cst","content":"<h2 id=\"Other目录\"><a href=\"#Other目录\" class=\"headerlink\" title=\"Other目录\"></a>Other目录</h2><ul>\n<li><a href=\"Git/Git.html\">Git基础</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Other目录\"><a href=\"#Other目录\" class=\"headerlink\" title=\"Other目录\"></a>Other目录</h2><ul>\n<li><a href=\"Git/Git.html\">Git基础</a></li>\n</ul>\n"},{"_content":"","source":"_posts/Android/Other/Groovy介绍.md","raw":"","slug":"Android/Other/Groovy介绍","published":1,"date":"2019-09-30T08:28:42.958Z","updated":"2019-09-30T08:28:42.958Z","title":"Android/Other/Groovy介绍","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzb000akgui1zks1p82","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android/View/ActionBar和ToolBar的使用.md","raw":"","slug":"Android/View/ActionBar和ToolBar的使用","published":1,"date":"2019-09-30T07:19:02.841Z","updated":"2019-09-30T08:28:42.961Z","title":"Android/View/ActionBar和ToolBar的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzc000bkguigbkbc09b","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Android/框架/RxJava2.0.md","raw":"","slug":"Android/框架/RxJava2.0","published":1,"date":"2019-09-19T09:34:08.488Z","updated":"2019-09-19T09:41:14.750Z","title":"Android/框架/RxJava2.0","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzc000ckgui6m9ofrjb","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/Java基础/Java 输入输出操作.md","raw":"","slug":"Java/Java基础/Java 输入输出操作","published":1,"date":"2019-09-19T09:41:14.768Z","updated":"2019-09-19T09:41:14.768Z","title":"Java/Java基础/Java 输入输出操作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzd000dkgui1nlw586l","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/Java多线程/Java锁机制.md","raw":"","slug":"Java/Java多线程/Java锁机制","published":1,"date":"2019-09-19T09:41:14.777Z","updated":"2019-09-19T09:41:14.777Z","title":"Java/Java多线程/Java锁机制","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzd000ekguigkdkfodg","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/Java虚拟机/README.md","raw":"","slug":"Java/Java虚拟机/README","published":1,"date":"2019-09-19T09:41:14.778Z","updated":"2019-09-19T09:41:14.778Z","title":"Java/Java虚拟机/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhze000fkguiefalcq1o","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Kotlin/Kotlin基础/README.md","raw":"","slug":"Kotlin/Kotlin基础/README","published":1,"date":"2019-11-28T12:20:23.104Z","updated":"2019-11-28T12:20:23.104Z","title":"Kotlin/Kotlin基础/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhze000gkguiczm63z77","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Other/Git/README.md","raw":"","slug":"Other/Git/README","published":1,"date":"2019-09-19T09:41:14.780Z","updated":"2019-09-19T09:41:14.780Z","title":"Other/Git/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzf000hkguias1oe58t","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Other/Img/README.md","raw":"","slug":"Other/Img/README","published":1,"date":"2019-09-11T08:04:40.930Z","updated":"2019-09-11T08:04:40.930Z","title":"Other/Img/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzz000ikguidg6g4w0v","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"\n\n\n# Android JNI对敏感信息进行保护\n\n## Android反编译\n\n在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。\n\n## 将敏感信息保存使用native代码实现\n\n相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。\n\n\n\n\n\n\n\n","source":"_posts/Android/Android JNI/Android JNI敏感信息保护.md","raw":"\n\n\n# Android JNI对敏感信息进行保护\n\n## Android反编译\n\n在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。\n\n## 将敏感信息保存使用native代码实现\n\n相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。\n\n\n\n\n\n\n\n","slug":"Android/Android JNI/Android JNI敏感信息保护","published":1,"date":"2019-09-21T00:52:10.110Z","updated":"2019-09-21T00:52:10.111Z","title":"Android/Android JNI/Android JNI敏感信息保护","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746lhzz000jkgui1xps95t7","content":"<h1 id=\"Android-JNI对敏感信息进行保护\"><a href=\"#Android-JNI对敏感信息进行保护\" class=\"headerlink\" title=\"Android JNI对敏感信息进行保护\"></a>Android JNI对敏感信息进行保护</h1><h2 id=\"Android反编译\"><a href=\"#Android反编译\" class=\"headerlink\" title=\"Android反编译\"></a>Android反编译</h2><p>在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。</p>\n<h2 id=\"将敏感信息保存使用native代码实现\"><a href=\"#将敏感信息保存使用native代码实现\" class=\"headerlink\" title=\"将敏感信息保存使用native代码实现\"></a>将敏感信息保存使用native代码实现</h2><p>相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-JNI对敏感信息进行保护\"><a href=\"#Android-JNI对敏感信息进行保护\" class=\"headerlink\" title=\"Android JNI对敏感信息进行保护\"></a>Android JNI对敏感信息进行保护</h1><h2 id=\"Android反编译\"><a href=\"#Android反编译\" class=\"headerlink\" title=\"Android反编译\"></a>Android反编译</h2><p>在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。</p>\n<h2 id=\"将敏感信息保存使用native代码实现\"><a href=\"#将敏感信息保存使用native代码实现\" class=\"headerlink\" title=\"将敏感信息保存使用native代码实现\"></a>将敏感信息保存使用native代码实现</h2><p>相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。</p>\n"},{"_content":"1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。\n2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。\n3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。\n4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。\n5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。\n6、AMS通知淘宝绑定Application并启动MainActivity。\n7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。\n\n\n## Android应用启动从Zygote到Activity.onCreate\n\n本文从点击Android应用图标开始介绍Android应用的启动过程\n\n### Android应用有两个方面的特点\n\n**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。\n\n**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;\n\n\n任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。\n\n在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 \n\n\n### Zygote：创建新的进程\n\nAndroid操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。\n\n**init进程会启动Zygote进程**\n\n**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。\n\n**在Zygote之后，init启动运行时的进程？**\n\n紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**\n\n### 用户点击图标通过Launcher启动应用的过程\n\n点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。\n\n* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。\n* 2、目标信心会被存储至intent对象中，避免重复第一步工作；\n* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；\n* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；\n* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。\n\n\n### 在该应用启动流程中有三个不同的阶段\n* 1、进程创建\n* 2、绑定应用\n* 3、启动Activity/Service/调用intent receiver\n\n#### 进程创建\n\nActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id\n\n在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。\n\n#### 应用绑定\n\n下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。\n\n\n#### 启动Activity","source":"_posts/Android/Advanced/应用启动流程.md","raw":"1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。\n2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。\n3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。\n4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。\n5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。\n6、AMS通知淘宝绑定Application并启动MainActivity。\n7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。\n\n\n## Android应用启动从Zygote到Activity.onCreate\n\n本文从点击Android应用图标开始介绍Android应用的启动过程\n\n### Android应用有两个方面的特点\n\n**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。\n\n**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;\n\n\n任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。\n\n在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 \n\n\n### Zygote：创建新的进程\n\nAndroid操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。\n\n**init进程会启动Zygote进程**\n\n**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。\n\n**在Zygote之后，init启动运行时的进程？**\n\n紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**\n\n### 用户点击图标通过Launcher启动应用的过程\n\n点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。\n\n* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。\n* 2、目标信心会被存储至intent对象中，避免重复第一步工作；\n* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；\n* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；\n* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。\n\n\n### 在该应用启动流程中有三个不同的阶段\n* 1、进程创建\n* 2、绑定应用\n* 3、启动Activity/Service/调用intent receiver\n\n#### 进程创建\n\nActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id\n\n在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。\n\n#### 应用绑定\n\n下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。\n\n\n#### 启动Activity","slug":"Android/Advanced/应用启动流程","published":1,"date":"2019-09-30T08:28:42.948Z","updated":"2019-09-30T08:28:42.949Z","title":"Android/Advanced/应用启动流程","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li01000mkguigaui1ldj","content":"<p>1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。<br>2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br>3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。<br>4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。<br>5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。<br>6、AMS通知淘宝绑定Application并启动MainActivity。<br>7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</p>\n<h2 id=\"Android应用启动从Zygote到Activity-onCreate\"><a href=\"#Android应用启动从Zygote到Activity-onCreate\" class=\"headerlink\" title=\"Android应用启动从Zygote到Activity.onCreate\"></a>Android应用启动从Zygote到Activity.onCreate</h2><p>本文从点击Android应用图标开始介绍Android应用的启动过程</p>\n<h3 id=\"Android应用有两个方面的特点\"><a href=\"#Android应用有两个方面的特点\" class=\"headerlink\" title=\"Android应用有两个方面的特点\"></a>Android应用有两个方面的特点</h3><p><strong>特点一：</strong>具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。</p>\n<p><strong>特点二：</strong>自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;</p>\n<p>任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。</p>\n<p>在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 </p>\n<h3 id=\"Zygote：创建新的进程\"><a href=\"#Zygote：创建新的进程\" class=\"headerlink\" title=\"Zygote：创建新的进程\"></a>Zygote：创建新的进程</h3><p>Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。</p>\n<p><strong>init进程会启动Zygote进程</strong></p>\n<p><strong>Zygote</strong>进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。</p>\n<p><strong>在Zygote之后，init启动运行时的进程？</strong></p>\n<p>紧接着Zygote fork并启动一个称为system server的进程，<strong>system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。</strong></p>\n<h3 id=\"用户点击图标通过Launcher启动应用的过程\"><a href=\"#用户点击图标通过Launcher启动应用的过程\" class=\"headerlink\" title=\"用户点击图标通过Launcher启动应用的过程\"></a>用户点击图标通过Launcher启动应用的过程</h3><p>点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。</p>\n<ul>\n<li>1、收集intent的目标的信息，通过调用<code>PackageManager</code>对象中的<code>resolveIntent()</code>方法，默认使用<code>PackageManager.MATCH_DEFAULT_ONLY</code> 和     <code>PackageManager.GET_SHARED_LIBRARY_FILES</code>标志。</li>\n<li>2、目标信心会被存储至intent对象中，避免重复第一步工作；</li>\n<li>3、判断用户是否有权限调用intent中的组件，通过<code>grantUriPermissionLocked()</code>方法执行；</li>\n<li>4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：<code>FLAG_ACTIVITY_NEW_TASK</code> 或者其他flags<code>FLAG_ACTIVITY_CLEAR_TOP</code>；</li>\n<li>5、检查进程的<code>ProcessRecord</code>是否已经存在，如果<code>ProcessRecord</code>为空，ActivityManager需要创建一个新的进程来实例化目标组件。</li>\n</ul>\n<h3 id=\"在该应用启动流程中有三个不同的阶段\"><a href=\"#在该应用启动流程中有三个不同的阶段\" class=\"headerlink\" title=\"在该应用启动流程中有三个不同的阶段\"></a>在该应用启动流程中有三个不同的阶段</h3><ul>\n<li>1、进程创建</li>\n<li>2、绑定应用</li>\n<li>3、启动Activity/Service/调用intent receiver</li>\n</ul>\n<h4 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h4><p>ActivityManagerService通过调用<code>startProcessLocked()</code>方法来创建一个新的进程，<code>startProcessLocked</code>方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用<code>ZygoteInit.main()</code>方法，该方法会创建一个ActivityThread对象，并返回新建进程的id</p>\n<p>在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用<code>Looper.loop()</code>方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用<code>Looper.prepareLoop()</code>再掉用<code>Looper.loop()</code>方法启动message loop。</p>\n<h4 id=\"应用绑定\"><a href=\"#应用绑定\" class=\"headerlink\" title=\"应用绑定\"></a>应用绑定</h4><p>下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的<code>bindApplication()</code>方法来实现。该方法将<code>BIND_APPLICATION</code>信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——<code>handleBindApplication()</code>，该方法调用<code>makeApplication()</code>方法，<code>makeApplication()</code>方法将应用中特定的类加载到内存中执行。</p>\n<h4 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h4>","site":{"data":{}},"excerpt":"","more":"<p>1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。<br>2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br>3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。<br>4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。<br>5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。<br>6、AMS通知淘宝绑定Application并启动MainActivity。<br>7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</p>\n<h2 id=\"Android应用启动从Zygote到Activity-onCreate\"><a href=\"#Android应用启动从Zygote到Activity-onCreate\" class=\"headerlink\" title=\"Android应用启动从Zygote到Activity.onCreate\"></a>Android应用启动从Zygote到Activity.onCreate</h2><p>本文从点击Android应用图标开始介绍Android应用的启动过程</p>\n<h3 id=\"Android应用有两个方面的特点\"><a href=\"#Android应用有两个方面的特点\" class=\"headerlink\" title=\"Android应用有两个方面的特点\"></a>Android应用有两个方面的特点</h3><p><strong>特点一：</strong>具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。</p>\n<p><strong>特点二：</strong>自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;</p>\n<p>任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。</p>\n<p>在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 </p>\n<h3 id=\"Zygote：创建新的进程\"><a href=\"#Zygote：创建新的进程\" class=\"headerlink\" title=\"Zygote：创建新的进程\"></a>Zygote：创建新的进程</h3><p>Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。</p>\n<p><strong>init进程会启动Zygote进程</strong></p>\n<p><strong>Zygote</strong>进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。</p>\n<p><strong>在Zygote之后，init启动运行时的进程？</strong></p>\n<p>紧接着Zygote fork并启动一个称为system server的进程，<strong>system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。</strong></p>\n<h3 id=\"用户点击图标通过Launcher启动应用的过程\"><a href=\"#用户点击图标通过Launcher启动应用的过程\" class=\"headerlink\" title=\"用户点击图标通过Launcher启动应用的过程\"></a>用户点击图标通过Launcher启动应用的过程</h3><p>点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。</p>\n<ul>\n<li>1、收集intent的目标的信息，通过调用<code>PackageManager</code>对象中的<code>resolveIntent()</code>方法，默认使用<code>PackageManager.MATCH_DEFAULT_ONLY</code> 和     <code>PackageManager.GET_SHARED_LIBRARY_FILES</code>标志。</li>\n<li>2、目标信心会被存储至intent对象中，避免重复第一步工作；</li>\n<li>3、判断用户是否有权限调用intent中的组件，通过<code>grantUriPermissionLocked()</code>方法执行；</li>\n<li>4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：<code>FLAG_ACTIVITY_NEW_TASK</code> 或者其他flags<code>FLAG_ACTIVITY_CLEAR_TOP</code>；</li>\n<li>5、检查进程的<code>ProcessRecord</code>是否已经存在，如果<code>ProcessRecord</code>为空，ActivityManager需要创建一个新的进程来实例化目标组件。</li>\n</ul>\n<h3 id=\"在该应用启动流程中有三个不同的阶段\"><a href=\"#在该应用启动流程中有三个不同的阶段\" class=\"headerlink\" title=\"在该应用启动流程中有三个不同的阶段\"></a>在该应用启动流程中有三个不同的阶段</h3><ul>\n<li>1、进程创建</li>\n<li>2、绑定应用</li>\n<li>3、启动Activity/Service/调用intent receiver</li>\n</ul>\n<h4 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h4><p>ActivityManagerService通过调用<code>startProcessLocked()</code>方法来创建一个新的进程，<code>startProcessLocked</code>方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用<code>ZygoteInit.main()</code>方法，该方法会创建一个ActivityThread对象，并返回新建进程的id</p>\n<p>在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用<code>Looper.loop()</code>方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用<code>Looper.prepareLoop()</code>再掉用<code>Looper.loop()</code>方法启动message loop。</p>\n<h4 id=\"应用绑定\"><a href=\"#应用绑定\" class=\"headerlink\" title=\"应用绑定\"></a>应用绑定</h4><p>下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的<code>bindApplication()</code>方法来实现。该方法将<code>BIND_APPLICATION</code>信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——<code>handleBindApplication()</code>，该方法调用<code>makeApplication()</code>方法，<code>makeApplication()</code>方法将应用中特定的类加载到内存中执行。</p>\n<h4 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h4>"},{"_content":"\n## Android序列化\n\nAndroid序列化对象的方法有两种：\n\n* 实现Serializable接口，Java自带\n* 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）","source":"_posts/Android/Android基础/Android序列化.md","raw":"\n## Android序列化\n\nAndroid序列化对象的方法有两种：\n\n* 实现Serializable接口，Java自带\n* 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）","slug":"Android/Android基础/Android序列化","published":1,"date":"2019-11-28T12:20:15.894Z","updated":"2019-11-30T11:14:32.183Z","title":"Android/Android基础/Android序列化","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li02000okguibu4rgkl1","content":"<h2 id=\"Android序列化\"><a href=\"#Android序列化\" class=\"headerlink\" title=\"Android序列化\"></a>Android序列化</h2><p>Android序列化对象的方法有两种：</p>\n<ul>\n<li>实现Serializable接口，Java自带</li>\n<li>实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android序列化\"><a href=\"#Android序列化\" class=\"headerlink\" title=\"Android序列化\"></a>Android序列化</h2><p>Android序列化对象的方法有两种：</p>\n<ul>\n<li>实现Serializable接口，Java自带</li>\n<li>实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）</li>\n</ul>\n"},{"_content":"\nAndroid防止二次打包主要通过对签名文件的验证来进行\n\n### 应用签名文件介绍\n\n在Android Studio2.2之后多了对签名版本的选择`V1(Jar Signature)`和`V2(Full APK Signature)`V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。\n\n#### 签名文件在gradle中配置\n\n    signingConfigs {      \n      debug {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"         \n        keyAlias \"**\"          \n        keyPassword \"******\"          \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }      \n      release {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"          \n        keyAlias \"**\"          \n        keyPassword \"******\"         \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }\n    }\n\n### 应用签名文件查看\n\n* 已有.jks文件\n\n在cmd中输入\n```xml\n\nkeytool -list -v -keystore path/android.jks -storepass password\n\n```\n![](/assets/Android safe.png)\n\n\n* 只有.apk文件\n\n使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入\n```xml\nkeytool -printcert -file path/android.jks\n```\n![](/assets/Android safe1.png)\n\n**两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码**\n\n### 在Java代码中进行验证，通过PackageManager获取签名信息。\n\n使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解\n\n\n### 在native层进行签名验证\n使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。\n\n因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。\n\n### 在服务端对签名文件进行验证\n服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）\n\n\n","source":"_posts/Android/Android反编译/Android应用防止二次打包.md","raw":"\nAndroid防止二次打包主要通过对签名文件的验证来进行\n\n### 应用签名文件介绍\n\n在Android Studio2.2之后多了对签名版本的选择`V1(Jar Signature)`和`V2(Full APK Signature)`V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。\n\n#### 签名文件在gradle中配置\n\n    signingConfigs {      \n      debug {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"         \n        keyAlias \"**\"          \n        keyPassword \"******\"          \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }      \n      release {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"          \n        keyAlias \"**\"          \n        keyPassword \"******\"         \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }\n    }\n\n### 应用签名文件查看\n\n* 已有.jks文件\n\n在cmd中输入\n```xml\n\nkeytool -list -v -keystore path/android.jks -storepass password\n\n```\n![](/assets/Android safe.png)\n\n\n* 只有.apk文件\n\n使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入\n```xml\nkeytool -printcert -file path/android.jks\n```\n![](/assets/Android safe1.png)\n\n**两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码**\n\n### 在Java代码中进行验证，通过PackageManager获取签名信息。\n\n使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解\n\n\n### 在native层进行签名验证\n使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。\n\n因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。\n\n### 在服务端对签名文件进行验证\n服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）\n\n\n","slug":"Android/Android反编译/Android应用防止二次打包","published":1,"date":"2019-09-30T08:28:42.950Z","updated":"2019-11-30T11:14:32.181Z","title":"Android/Android反编译/Android应用防止二次打包","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li03000pkgui0q7s3nkr","content":"<p>Android防止二次打包主要通过对签名文件的验证来进行</p>\n<h3 id=\"应用签名文件介绍\"><a href=\"#应用签名文件介绍\" class=\"headerlink\" title=\"应用签名文件介绍\"></a>应用签名文件介绍</h3><p>在Android Studio2.2之后多了对签名版本的选择<code>V1(Jar Signature)</code>和<code>V2(Full APK Signature)</code>V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。</p>\n<h4 id=\"签名文件在gradle中配置\"><a href=\"#签名文件在gradle中配置\" class=\"headerlink\" title=\"签名文件在gradle中配置\"></a>签名文件在gradle中配置</h4><pre><code>signingConfigs {      \n  debug {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;         \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;          \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }      \n  release {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;          \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;         \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }\n}</code></pre><h3 id=\"应用签名文件查看\"><a href=\"#应用签名文件查看\" class=\"headerlink\" title=\"应用签名文件查看\"></a>应用签名文件查看</h3><ul>\n<li>已有.jks文件</li>\n</ul>\n<p>在cmd中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">keytool -list -v -keystore path/android.jks -storepass password</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe.png)</p>\n<ul>\n<li>只有.apk文件</li>\n</ul>\n<p>使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file path/android.jks</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe1.png)</p>\n<p><strong>两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码</strong></p>\n<h3 id=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"><a href=\"#在Java代码中进行验证，通过PackageManager获取签名信息。\" class=\"headerlink\" title=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"></a>在Java代码中进行验证，通过PackageManager获取签名信息。</h3><p>使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解</p>\n<h3 id=\"在native层进行签名验证\"><a href=\"#在native层进行签名验证\" class=\"headerlink\" title=\"在native层进行签名验证\"></a>在native层进行签名验证</h3><p>使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。</p>\n<p>因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。</p>\n<h3 id=\"在服务端对签名文件进行验证\"><a href=\"#在服务端对签名文件进行验证\" class=\"headerlink\" title=\"在服务端对签名文件进行验证\"></a>在服务端对签名文件进行验证</h3><p>服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android防止二次打包主要通过对签名文件的验证来进行</p>\n<h3 id=\"应用签名文件介绍\"><a href=\"#应用签名文件介绍\" class=\"headerlink\" title=\"应用签名文件介绍\"></a>应用签名文件介绍</h3><p>在Android Studio2.2之后多了对签名版本的选择<code>V1(Jar Signature)</code>和<code>V2(Full APK Signature)</code>V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。</p>\n<h4 id=\"签名文件在gradle中配置\"><a href=\"#签名文件在gradle中配置\" class=\"headerlink\" title=\"签名文件在gradle中配置\"></a>签名文件在gradle中配置</h4><pre><code>signingConfigs {      \n  debug {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;         \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;          \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }      \n  release {          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;          \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;         \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  }\n}</code></pre><h3 id=\"应用签名文件查看\"><a href=\"#应用签名文件查看\" class=\"headerlink\" title=\"应用签名文件查看\"></a>应用签名文件查看</h3><ul>\n<li>已有.jks文件</li>\n</ul>\n<p>在cmd中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">keytool -list -v -keystore path/android.jks -storepass password</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe.png)</p>\n<ul>\n<li>只有.apk文件</li>\n</ul>\n<p>使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file path/android.jks</span><br></pre></td></tr></table></figure>\n<p>![](/assets/Android safe1.png)</p>\n<p><strong>两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码</strong></p>\n<h3 id=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"><a href=\"#在Java代码中进行验证，通过PackageManager获取签名信息。\" class=\"headerlink\" title=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"></a>在Java代码中进行验证，通过PackageManager获取签名信息。</h3><p>使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解</p>\n<h3 id=\"在native层进行签名验证\"><a href=\"#在native层进行签名验证\" class=\"headerlink\" title=\"在native层进行签名验证\"></a>在native层进行签名验证</h3><p>使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。</p>\n<p>因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。</p>\n<h3 id=\"在服务端对签名文件进行验证\"><a href=\"#在服务端对签名文件进行验证\" class=\"headerlink\" title=\"在服务端对签名文件进行验证\"></a>在服务端对签名文件进行验证</h3><p>服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）</p>\n"},{"_content":"## Android文件的读和写\n\n1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；\n2、SD卡中的文件；\n3、数据区(/data/data/..)的文件；\n\n### 资源文件的读写\n\nraw使用InputStream in = getResources().openRawResource(R.raw.test);\nasset使用InputStream in = getResources().getAssets().open(fileName);\n\n### Android应用数据私有目录存储（位于应用功能安装目录下）\n\n该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。\n\n文件类型：\n/data/data/包名/cache ：存放的是APP的缓存信息\n/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码\n/data/data/包名/files ： 存放APP的文件信息\n\n还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。\n\n私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录\n\n`context.getCacheDir()`用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间\n\n\n#### 文件读操作\n\n#### 文件写操作\n\n\n### Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\n\n该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。\n\n\n\n* 首先需要获取权限\n\n```xml\n\n     <!--用于获取文件操作的权限-->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n* 需要确定写入文件目录是否存在，如果不存在，则需要新建目录\n\n\n\n### Android存储公有目录\nAndorid开发公有目录与Context无关，使用Environment进行获取\n\n* Environment.DIRECTORY_PICTURES 图片目录\n* Environment.DIRECTORY_DCIM 相册目录\n* Environment.DIRECTORY_DOCUMENTS 文档目录\n* Environment.DIRECTORY_DOWNLOADS 下载目录\n* Environment.DIRECTORY_MOVIES 视频\n\n```java\n    //有参\n    Environment.getExternalStoragePublicDirectory(String type) ;\n    //无参\n    Environment.getExternalStoragePublicDirectory();\n\n```\n\n\n### Android本地文件选择\n","source":"_posts/Android/Android基础/Android文件操作.md","raw":"## Android文件的读和写\n\n1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；\n2、SD卡中的文件；\n3、数据区(/data/data/..)的文件；\n\n### 资源文件的读写\n\nraw使用InputStream in = getResources().openRawResource(R.raw.test);\nasset使用InputStream in = getResources().getAssets().open(fileName);\n\n### Android应用数据私有目录存储（位于应用功能安装目录下）\n\n该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。\n\n文件类型：\n/data/data/包名/cache ：存放的是APP的缓存信息\n/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码\n/data/data/包名/files ： 存放APP的文件信息\n\n还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。\n\n私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录\n\n`context.getCacheDir()`用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间\n\n\n#### 文件读操作\n\n#### 文件写操作\n\n\n### Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\n\n该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。\n\n\n\n* 首先需要获取权限\n\n```xml\n\n     <!--用于获取文件操作的权限-->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n* 需要确定写入文件目录是否存在，如果不存在，则需要新建目录\n\n\n\n### Android存储公有目录\nAndorid开发公有目录与Context无关，使用Environment进行获取\n\n* Environment.DIRECTORY_PICTURES 图片目录\n* Environment.DIRECTORY_DCIM 相册目录\n* Environment.DIRECTORY_DOCUMENTS 文档目录\n* Environment.DIRECTORY_DOWNLOADS 下载目录\n* Environment.DIRECTORY_MOVIES 视频\n\n```java\n    //有参\n    Environment.getExternalStoragePublicDirectory(String type) ;\n    //无参\n    Environment.getExternalStoragePublicDirectory();\n\n```\n\n\n### Android本地文件选择\n","slug":"Android/Android基础/Android文件操作","published":1,"date":"2019-09-19T09:34:08.482Z","updated":"2019-09-30T08:28:42.954Z","title":"Android/Android基础/Android文件操作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li03000qkgui40wv6mza","content":"<h2 id=\"Android文件的读和写\"><a href=\"#Android文件的读和写\" class=\"headerlink\" title=\"Android文件的读和写\"></a>Android文件的读和写</h2><p>1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；<br>2、SD卡中的文件；<br>3、数据区(/data/data/..)的文件；</p>\n<h3 id=\"资源文件的读写\"><a href=\"#资源文件的读写\" class=\"headerlink\" title=\"资源文件的读写\"></a>资源文件的读写</h3><p>raw使用InputStream in = getResources().openRawResource(R.raw.test);<br>asset使用InputStream in = getResources().getAssets().open(fileName);</p>\n<h3 id=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"><a href=\"#Android应用数据私有目录存储（位于应用功能安装目录下）\" class=\"headerlink\" title=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"></a>Android应用数据私有目录存储（位于应用功能安装目录下）</h3><p>该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。</p>\n<p>文件类型：<br>/data/data/包名/cache ：存放的是APP的缓存信息<br>/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码<br>/data/data/包名/files ： 存放APP的文件信息</p>\n<p>还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。</p>\n<p>私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录</p>\n<p><code>context.getCacheDir()</code>用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间</p>\n<h4 id=\"文件读操作\"><a href=\"#文件读操作\" class=\"headerlink\" title=\"文件读操作\"></a>文件读操作</h4><h4 id=\"文件写操作\"><a href=\"#文件写操作\" class=\"headerlink\" title=\"文件写操作\"></a>文件写操作</h4><h3 id=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"><a href=\"#Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\" class=\"headerlink\" title=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"></a>Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）</h3><p>该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。</p>\n<ul>\n<li>首先需要获取权限</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--用于获取文件操作的权限--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.READ_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.WRITE_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要确定写入文件目录是否存在，如果不存在，则需要新建目录</li>\n</ul>\n<h3 id=\"Android存储公有目录\"><a href=\"#Android存储公有目录\" class=\"headerlink\" title=\"Android存储公有目录\"></a>Android存储公有目录</h3><p>Andorid开发公有目录与Context无关，使用Environment进行获取</p>\n<ul>\n<li>Environment.DIRECTORY_PICTURES 图片目录</li>\n<li>Environment.DIRECTORY_DCIM 相册目录</li>\n<li>Environment.DIRECTORY_DOCUMENTS 文档目录</li>\n<li>Environment.DIRECTORY_DOWNLOADS 下载目录</li>\n<li>Environment.DIRECTORY_MOVIES 视频</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory(String type) ;</span><br><span class=\"line\"><span class=\"comment\">//无参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory();</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Android本地文件选择\"><a href=\"#Android本地文件选择\" class=\"headerlink\" title=\"Android本地文件选择\"></a>Android本地文件选择</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android文件的读和写\"><a href=\"#Android文件的读和写\" class=\"headerlink\" title=\"Android文件的读和写\"></a>Android文件的读和写</h2><p>1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；<br>2、SD卡中的文件；<br>3、数据区(/data/data/..)的文件；</p>\n<h3 id=\"资源文件的读写\"><a href=\"#资源文件的读写\" class=\"headerlink\" title=\"资源文件的读写\"></a>资源文件的读写</h3><p>raw使用InputStream in = getResources().openRawResource(R.raw.test);<br>asset使用InputStream in = getResources().getAssets().open(fileName);</p>\n<h3 id=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"><a href=\"#Android应用数据私有目录存储（位于应用功能安装目录下）\" class=\"headerlink\" title=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"></a>Android应用数据私有目录存储（位于应用功能安装目录下）</h3><p>该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。</p>\n<p>文件类型：<br>/data/data/包名/cache ：存放的是APP的缓存信息<br>/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码<br>/data/data/包名/files ： 存放APP的文件信息</p>\n<p>还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。</p>\n<p>私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录</p>\n<p><code>context.getCacheDir()</code>用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间</p>\n<h4 id=\"文件读操作\"><a href=\"#文件读操作\" class=\"headerlink\" title=\"文件读操作\"></a>文件读操作</h4><h4 id=\"文件写操作\"><a href=\"#文件写操作\" class=\"headerlink\" title=\"文件写操作\"></a>文件写操作</h4><h3 id=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"><a href=\"#Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\" class=\"headerlink\" title=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"></a>Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）</h3><p>该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。</p>\n<ul>\n<li>首先需要获取权限</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--用于获取文件操作的权限--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.READ_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.WRITE_EXTERNAL_STORAGE\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要确定写入文件目录是否存在，如果不存在，则需要新建目录</li>\n</ul>\n<h3 id=\"Android存储公有目录\"><a href=\"#Android存储公有目录\" class=\"headerlink\" title=\"Android存储公有目录\"></a>Android存储公有目录</h3><p>Andorid开发公有目录与Context无关，使用Environment进行获取</p>\n<ul>\n<li>Environment.DIRECTORY_PICTURES 图片目录</li>\n<li>Environment.DIRECTORY_DCIM 相册目录</li>\n<li>Environment.DIRECTORY_DOCUMENTS 文档目录</li>\n<li>Environment.DIRECTORY_DOWNLOADS 下载目录</li>\n<li>Environment.DIRECTORY_MOVIES 视频</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory(String type) ;</span><br><span class=\"line\"><span class=\"comment\">//无参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory();</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Android本地文件选择\"><a href=\"#Android本地文件选择\" class=\"headerlink\" title=\"Android本地文件选择\"></a>Android本地文件选择</h3>"},{"_content":"# Handler介绍\n\nHandler直接继承于Object类\n\nHandler与一个线程的`MessageQueue`进行绑定，可以用于`Message`的发送与处理以及`Runnable`对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的`Message Queue`相绑定，它可以将messages以及runnables对象传递到`Message Queue`，并对`Message Queue`中的messages以及runnables对象进行处理。\n\nHandler使用的两个主要方面：\n1、对messages以及runnables在将来某一个节点执行进行调度；\n2、在非当前线程执行其他操作\n\nHandler对Message的调度通过`post(Runnable)`, `postAtTime(Runnable, long)`, `postDelayed(Runnable, Object, long)`, `sendEmptyMessage(int)`, `sendMessage(Message)`, `sendMessageAtTime(Message, long)`, 以及·、`sendMessageDelayed(Message, long) `等方法进行，`post`方法可以将`Runnable`对象插入到队列中，当消息队列收到`Runnable`对象时，可以执行。`sendMessage`方法可以将`Message`对象（其中包含大量数据）插入到队列中，通过`HandlerMessage`方法进行处理。\n\n当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。\n\n当应用程序创建一个进程之后，它的主线程用于持有的`Message Queue`用于管理“顶级”的应用对象(`Activity` `Broadcast Receiver`等)和他们创建的窗口。当创建自己的线程时，可以通过`Handler`与应用的主线程进行信息交换。\n\n# Looper介绍\n\nLooper直接继承于Object\n\nLooper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的`prepare()`方法来运行一个loop，`loop()`方法用来处理message。\n\n与message loop进行大部分交互都是通过`Handler`类来进行。\n\n下列代码是实现一个`Looper`线程的方式，通过分离开的`prepare()`以及`loop()`方法初始化一个Handler与Looper进行交互。\n\n\n```java\n\n class LooperThread extends Thread {\n  \n      public Handler mHandler;\n\n      public void run() {\n          Looper.prepare();\n\n          mHandler = new Handler() {\n              public void handleMessage(Message msg) {\n                  // process incoming messages here\n              }\n          };\n\n          Looper.loop();\n      }\n  }\n\n```\n\n# MessageQueue介绍\n\nMessageQueue直接继承于Object\n\nMessage不能直接添加至`Message Queue`中，需要通过与`Looper`相关联的`Handler`对象来实现。通过`Looper.myQueue`方法可以从当前线程中获取`MessageQueue`\n\n\n### 从源码角度分析Handler、Looper、MessageQueue三者之间的关系\n\n`Handler`默认构造函数`Handler()`，将自己与当前线程的`Looper`进行绑定，如果当前线程中没有`Looper`对象，会报出异常。\n\n```\n  \n    //Handler源码117行\n    public Handler() {\n        this(null, false);\n    }\n    \n    //Handler源码131行\n      public Handler(Callback callback) {\n        this(callback, false);\n    }\n    \n    \n```\n\n通过`Looper.prepare();`为当前线程设置一个`Looper`\n具体流程：\n其中`prepare()`方法是`Looper`类中的静态方法；在`prepare(boolean quitAllowed)`方法中调用`sThreadLocal.set(new Looper(quitAllowed));`当前线程设置一个新的`Looper`在构造函数`Looper(boolean quitAllowed)`中，该`Looper`创建了一个新的`MessageQueue`(mQueue = new MessageQueue(quitAllowed););\n\n```\n\n    //Looper源码97行\n       public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n    \n    \n    //Looper源码267行\n        private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n```\n\n\n在Handler源码的192行中，通过`mLooper = Looper.myLooper();`来获取当前线程中的`Looper`\n\n```\n\n     //Handler源码192行\n  public Handler(Callback callback, boolean async) {\n      \n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n\n   //Looper71行\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n\n   //Looper97行\n\n   //Looper源码254行\n     public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n\n## Handler发送消息机制\n\nHandler调用` sendMessage(Message msg)`方法最终会一步一步调用`sendMessageAtTime(Message msg, long uptimeMillis)`在该方法中通过`MessageQueue queue = mQueue;`获取到MessageQueue，调用  用`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`方法将`Message`加入到消息队列中\n\n```\n   //Handler源码中的689行\n       public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n## Handler消息处理机制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Handler Looper介绍.md","raw":"# Handler介绍\n\nHandler直接继承于Object类\n\nHandler与一个线程的`MessageQueue`进行绑定，可以用于`Message`的发送与处理以及`Runnable`对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的`Message Queue`相绑定，它可以将messages以及runnables对象传递到`Message Queue`，并对`Message Queue`中的messages以及runnables对象进行处理。\n\nHandler使用的两个主要方面：\n1、对messages以及runnables在将来某一个节点执行进行调度；\n2、在非当前线程执行其他操作\n\nHandler对Message的调度通过`post(Runnable)`, `postAtTime(Runnable, long)`, `postDelayed(Runnable, Object, long)`, `sendEmptyMessage(int)`, `sendMessage(Message)`, `sendMessageAtTime(Message, long)`, 以及·、`sendMessageDelayed(Message, long) `等方法进行，`post`方法可以将`Runnable`对象插入到队列中，当消息队列收到`Runnable`对象时，可以执行。`sendMessage`方法可以将`Message`对象（其中包含大量数据）插入到队列中，通过`HandlerMessage`方法进行处理。\n\n当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。\n\n当应用程序创建一个进程之后，它的主线程用于持有的`Message Queue`用于管理“顶级”的应用对象(`Activity` `Broadcast Receiver`等)和他们创建的窗口。当创建自己的线程时，可以通过`Handler`与应用的主线程进行信息交换。\n\n# Looper介绍\n\nLooper直接继承于Object\n\nLooper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的`prepare()`方法来运行一个loop，`loop()`方法用来处理message。\n\n与message loop进行大部分交互都是通过`Handler`类来进行。\n\n下列代码是实现一个`Looper`线程的方式，通过分离开的`prepare()`以及`loop()`方法初始化一个Handler与Looper进行交互。\n\n\n```java\n\n class LooperThread extends Thread {\n  \n      public Handler mHandler;\n\n      public void run() {\n          Looper.prepare();\n\n          mHandler = new Handler() {\n              public void handleMessage(Message msg) {\n                  // process incoming messages here\n              }\n          };\n\n          Looper.loop();\n      }\n  }\n\n```\n\n# MessageQueue介绍\n\nMessageQueue直接继承于Object\n\nMessage不能直接添加至`Message Queue`中，需要通过与`Looper`相关联的`Handler`对象来实现。通过`Looper.myQueue`方法可以从当前线程中获取`MessageQueue`\n\n\n### 从源码角度分析Handler、Looper、MessageQueue三者之间的关系\n\n`Handler`默认构造函数`Handler()`，将自己与当前线程的`Looper`进行绑定，如果当前线程中没有`Looper`对象，会报出异常。\n\n```\n  \n    //Handler源码117行\n    public Handler() {\n        this(null, false);\n    }\n    \n    //Handler源码131行\n      public Handler(Callback callback) {\n        this(callback, false);\n    }\n    \n    \n```\n\n通过`Looper.prepare();`为当前线程设置一个`Looper`\n具体流程：\n其中`prepare()`方法是`Looper`类中的静态方法；在`prepare(boolean quitAllowed)`方法中调用`sThreadLocal.set(new Looper(quitAllowed));`当前线程设置一个新的`Looper`在构造函数`Looper(boolean quitAllowed)`中，该`Looper`创建了一个新的`MessageQueue`(mQueue = new MessageQueue(quitAllowed););\n\n```\n\n    //Looper源码97行\n       public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n    \n    \n    //Looper源码267行\n        private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n```\n\n\n在Handler源码的192行中，通过`mLooper = Looper.myLooper();`来获取当前线程中的`Looper`\n\n```\n\n     //Handler源码192行\n  public Handler(Callback callback, boolean async) {\n      \n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n\n   //Looper71行\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n\n   //Looper97行\n\n   //Looper源码254行\n     public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n\n## Handler发送消息机制\n\nHandler调用` sendMessage(Message msg)`方法最终会一步一步调用`sendMessageAtTime(Message msg, long uptimeMillis)`在该方法中通过`MessageQueue queue = mQueue;`获取到MessageQueue，调用  用`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`方法将`Message`加入到消息队列中\n\n```\n   //Handler源码中的689行\n       public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n## Handler消息处理机制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android基础/Handler Looper介绍","published":1,"date":"2019-09-30T07:19:02.820Z","updated":"2019-09-30T08:28:42.955Z","title":"Android/Android基础/Handler Looper介绍","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li04000skgui5bb29hcm","content":"<h1 id=\"Handler介绍\"><a href=\"#Handler介绍\" class=\"headerlink\" title=\"Handler介绍\"></a>Handler介绍</h1><p>Handler直接继承于Object类</p>\n<p>Handler与一个线程的<code>MessageQueue</code>进行绑定，可以用于<code>Message</code>的发送与处理以及<code>Runnable</code>对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的<code>Message Queue</code>相绑定，它可以将messages以及runnables对象传递到<code>Message Queue</code>，并对<code>Message Queue</code>中的messages以及runnables对象进行处理。</p>\n<p>Handler使用的两个主要方面：<br>1、对messages以及runnables在将来某一个节点执行进行调度；<br>2、在非当前线程执行其他操作</p>\n<p>Handler对Message的调度通过<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, 以及·、<code>sendMessageDelayed(Message, long)</code>等方法进行，<code>post</code>方法可以将<code>Runnable</code>对象插入到队列中，当消息队列收到<code>Runnable</code>对象时，可以执行。<code>sendMessage</code>方法可以将<code>Message</code>对象（其中包含大量数据）插入到队列中，通过<code>HandlerMessage</code>方法进行处理。</p>\n<p>当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。</p>\n<p>当应用程序创建一个进程之后，它的主线程用于持有的<code>Message Queue</code>用于管理“顶级”的应用对象(<code>Activity</code> <code>Broadcast Receiver</code>等)和他们创建的窗口。当创建自己的线程时，可以通过<code>Handler</code>与应用的主线程进行信息交换。</p>\n<h1 id=\"Looper介绍\"><a href=\"#Looper介绍\" class=\"headerlink\" title=\"Looper介绍\"></a>Looper介绍</h1><p>Looper直接继承于Object</p>\n<p>Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的<code>prepare()</code>方法来运行一个loop，<code>loop()</code>方法用来处理message。</p>\n<p>与message loop进行大部分交互都是通过<code>Handler</code>类来进行。</p>\n<p>下列代码是实现一个<code>Looper</code>线程的方式，通过分离开的<code>prepare()</code>以及<code>loop()</code>方法初始化一个Handler与Looper进行交互。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         Looper.prepare();</span><br><span class=\"line\"></span><br><span class=\"line\">         mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         Looper.loop();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"MessageQueue介绍\"><a href=\"#MessageQueue介绍\" class=\"headerlink\" title=\"MessageQueue介绍\"></a>MessageQueue介绍</h1><p>MessageQueue直接继承于Object</p>\n<p>Message不能直接添加至<code>Message Queue</code>中，需要通过与<code>Looper</code>相关联的<code>Handler</code>对象来实现。通过<code>Looper.myQueue</code>方法可以从当前线程中获取<code>MessageQueue</code></p>\n<h3 id=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"><a href=\"#从源码角度分析Handler、Looper、MessageQueue三者之间的关系\" class=\"headerlink\" title=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"></a>从源码角度分析Handler、Looper、MessageQueue三者之间的关系</h3><p><code>Handler</code>默认构造函数<code>Handler()</code>，将自己与当前线程的<code>Looper</code>进行绑定，如果当前线程中没有<code>Looper</code>对象，会报出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">&#x2F;&#x2F;Handler源码117行</span><br><span class=\"line\">public Handler() &#123;</span><br><span class=\"line\">    this(null, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Handler源码131行</span><br><span class=\"line\">  public Handler(Callback callback) &#123;</span><br><span class=\"line\">    this(callback, false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>Looper.prepare();</code>为当前线程设置一个<code>Looper</code><br>具体流程：<br>其中<code>prepare()</code>方法是<code>Looper</code>类中的静态方法；在<code>prepare(boolean quitAllowed)</code>方法中调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>当前线程设置一个新的<code>Looper</code>在构造函数<code>Looper(boolean quitAllowed)</code>中，该<code>Looper</code>创建了一个新的<code>MessageQueue</code>(mQueue = new MessageQueue(quitAllowed););</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码97行</span><br><span class=\"line\">   public static void prepare() &#123;</span><br><span class=\"line\">    prepare(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void prepare(boolean quitAllowed) &#123;</span><br><span class=\"line\">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class=\"line\">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码267行</span><br><span class=\"line\">    private Looper(boolean quitAllowed) &#123;</span><br><span class=\"line\">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread &#x3D; Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在Handler源码的192行中，通过<code>mLooper = Looper.myLooper();</code>来获取当前线程中的<code>Looper</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;Handler源码192行</span><br><span class=\"line\">public Handler(Callback callback, boolean async) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      mLooper &#x3D; Looper.myLooper();</span><br><span class=\"line\">      if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(</span><br><span class=\"line\">              &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class=\"line\">                      + &quot; that has not called Looper.prepare()&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mQueue &#x3D; mLooper.mQueue;</span><br><span class=\"line\">      mCallback &#x3D; callback;</span><br><span class=\"line\">      mAsynchronous &#x3D; async;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper71行</span><br><span class=\"line\">  static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper97行</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper源码254行</span><br><span class=\"line\">   public static @Nullable Looper myLooper() &#123;</span><br><span class=\"line\">      return sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Handler发送消息机制\"><a href=\"#Handler发送消息机制\" class=\"headerlink\" title=\"Handler发送消息机制\"></a>Handler发送消息机制</h2><p>Handler调用<code>sendMessage(Message msg)</code>方法最终会一步一步调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>在该方法中通过<code>MessageQueue queue = mQueue;</code>获取到MessageQueue，调用  用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>方法将<code>Message</code>加入到消息队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Handler源码中的689行</span><br><span class=\"line\">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">     MessageQueue queue &#x3D; mQueue;</span><br><span class=\"line\">     if (queue &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">         RuntimeException e &#x3D; new RuntimeException(</span><br><span class=\"line\">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Handler消息处理机制\"><a href=\"#Handler消息处理机制\" class=\"headerlink\" title=\"Handler消息处理机制\"></a>Handler消息处理机制</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Handler介绍\"><a href=\"#Handler介绍\" class=\"headerlink\" title=\"Handler介绍\"></a>Handler介绍</h1><p>Handler直接继承于Object类</p>\n<p>Handler与一个线程的<code>MessageQueue</code>进行绑定，可以用于<code>Message</code>的发送与处理以及<code>Runnable</code>对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的<code>Message Queue</code>相绑定，它可以将messages以及runnables对象传递到<code>Message Queue</code>，并对<code>Message Queue</code>中的messages以及runnables对象进行处理。</p>\n<p>Handler使用的两个主要方面：<br>1、对messages以及runnables在将来某一个节点执行进行调度；<br>2、在非当前线程执行其他操作</p>\n<p>Handler对Message的调度通过<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, 以及·、<code>sendMessageDelayed(Message, long)</code>等方法进行，<code>post</code>方法可以将<code>Runnable</code>对象插入到队列中，当消息队列收到<code>Runnable</code>对象时，可以执行。<code>sendMessage</code>方法可以将<code>Message</code>对象（其中包含大量数据）插入到队列中，通过<code>HandlerMessage</code>方法进行处理。</p>\n<p>当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。</p>\n<p>当应用程序创建一个进程之后，它的主线程用于持有的<code>Message Queue</code>用于管理“顶级”的应用对象(<code>Activity</code> <code>Broadcast Receiver</code>等)和他们创建的窗口。当创建自己的线程时，可以通过<code>Handler</code>与应用的主线程进行信息交换。</p>\n<h1 id=\"Looper介绍\"><a href=\"#Looper介绍\" class=\"headerlink\" title=\"Looper介绍\"></a>Looper介绍</h1><p>Looper直接继承于Object</p>\n<p>Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的<code>prepare()</code>方法来运行一个loop，<code>loop()</code>方法用来处理message。</p>\n<p>与message loop进行大部分交互都是通过<code>Handler</code>类来进行。</p>\n<p>下列代码是实现一个<code>Looper</code>线程的方式，通过分离开的<code>prepare()</code>以及<code>loop()</code>方法初始化一个Handler与Looper进行交互。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         Looper.prepare();</span><br><span class=\"line\"></span><br><span class=\"line\">         mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         Looper.loop();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"MessageQueue介绍\"><a href=\"#MessageQueue介绍\" class=\"headerlink\" title=\"MessageQueue介绍\"></a>MessageQueue介绍</h1><p>MessageQueue直接继承于Object</p>\n<p>Message不能直接添加至<code>Message Queue</code>中，需要通过与<code>Looper</code>相关联的<code>Handler</code>对象来实现。通过<code>Looper.myQueue</code>方法可以从当前线程中获取<code>MessageQueue</code></p>\n<h3 id=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"><a href=\"#从源码角度分析Handler、Looper、MessageQueue三者之间的关系\" class=\"headerlink\" title=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"></a>从源码角度分析Handler、Looper、MessageQueue三者之间的关系</h3><p><code>Handler</code>默认构造函数<code>Handler()</code>，将自己与当前线程的<code>Looper</code>进行绑定，如果当前线程中没有<code>Looper</code>对象，会报出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">&#x2F;&#x2F;Handler源码117行</span><br><span class=\"line\">public Handler() &#123;</span><br><span class=\"line\">    this(null, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Handler源码131行</span><br><span class=\"line\">  public Handler(Callback callback) &#123;</span><br><span class=\"line\">    this(callback, false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>Looper.prepare();</code>为当前线程设置一个<code>Looper</code><br>具体流程：<br>其中<code>prepare()</code>方法是<code>Looper</code>类中的静态方法；在<code>prepare(boolean quitAllowed)</code>方法中调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>当前线程设置一个新的<code>Looper</code>在构造函数<code>Looper(boolean quitAllowed)</code>中，该<code>Looper</code>创建了一个新的<code>MessageQueue</code>(mQueue = new MessageQueue(quitAllowed););</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码97行</span><br><span class=\"line\">   public static void prepare() &#123;</span><br><span class=\"line\">    prepare(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void prepare(boolean quitAllowed) &#123;</span><br><span class=\"line\">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class=\"line\">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码267行</span><br><span class=\"line\">    private Looper(boolean quitAllowed) &#123;</span><br><span class=\"line\">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread &#x3D; Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在Handler源码的192行中，通过<code>mLooper = Looper.myLooper();</code>来获取当前线程中的<code>Looper</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;Handler源码192行</span><br><span class=\"line\">public Handler(Callback callback, boolean async) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      mLooper &#x3D; Looper.myLooper();</span><br><span class=\"line\">      if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(</span><br><span class=\"line\">              &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class=\"line\">                      + &quot; that has not called Looper.prepare()&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mQueue &#x3D; mLooper.mQueue;</span><br><span class=\"line\">      mCallback &#x3D; callback;</span><br><span class=\"line\">      mAsynchronous &#x3D; async;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper71行</span><br><span class=\"line\">  static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper97行</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper源码254行</span><br><span class=\"line\">   public static @Nullable Looper myLooper() &#123;</span><br><span class=\"line\">      return sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Handler发送消息机制\"><a href=\"#Handler发送消息机制\" class=\"headerlink\" title=\"Handler发送消息机制\"></a>Handler发送消息机制</h2><p>Handler调用<code>sendMessage(Message msg)</code>方法最终会一步一步调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>在该方法中通过<code>MessageQueue queue = mQueue;</code>获取到MessageQueue，调用  用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>方法将<code>Message</code>加入到消息队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Handler源码中的689行</span><br><span class=\"line\">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">     MessageQueue queue &#x3D; mQueue;</span><br><span class=\"line\">     if (queue &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">         RuntimeException e &#x3D; new RuntimeException(</span><br><span class=\"line\">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Handler消息处理机制\"><a href=\"#Handler消息处理机制\" class=\"headerlink\" title=\"Handler消息处理机制\"></a>Handler消息处理机制</h2>"},{"_content":"getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；\n\n|传入的Name|返回的对象|说明|\n|------|------|------|\n|WINDOW_SERVICE|WindowManager|管理打开的窗口程序|\n|LAYOUT_INFLATER_SERVICE|\tLayoutInflater\t|取得xml里定义的view\n|ACTIVITY_SERVICE\t|ActivityManager\t|管理应用程序的系统状态\n|POWER_SERVICE\t|PowerManger\t|电源的服务\n|ALARM_SERVICE\t|AlarmManager|\t闹钟的服务\n|NOTIFICATION_SERVICE\t|NotificationManager\t|状态栏的服务\n|KEYGUARD_SERVICE\t|KeyguardManager\t|键盘锁的服务\n|LOCATION_SERVICE\t|LocationManager\t|位置的服务，如GPS\n|SEARCH_SERVICE\t|SearchManager\t|搜索的服务\n|VEBRATOR_SERVICE|\tVebrator|\t手机震动的服务\n|CONNECTIVITY_SERVICE\t|Connectivity\t|网络连接的服务\n|WIFI_SERVICE\t|WifiManager\t|Wi-Fi服务\n|TELEPHONY_SERVICE\t|TeleponyManager\t|电话服务","source":"_posts/Android/Android基础/getSystemService的使用.md","raw":"getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；\n\n|传入的Name|返回的对象|说明|\n|------|------|------|\n|WINDOW_SERVICE|WindowManager|管理打开的窗口程序|\n|LAYOUT_INFLATER_SERVICE|\tLayoutInflater\t|取得xml里定义的view\n|ACTIVITY_SERVICE\t|ActivityManager\t|管理应用程序的系统状态\n|POWER_SERVICE\t|PowerManger\t|电源的服务\n|ALARM_SERVICE\t|AlarmManager|\t闹钟的服务\n|NOTIFICATION_SERVICE\t|NotificationManager\t|状态栏的服务\n|KEYGUARD_SERVICE\t|KeyguardManager\t|键盘锁的服务\n|LOCATION_SERVICE\t|LocationManager\t|位置的服务，如GPS\n|SEARCH_SERVICE\t|SearchManager\t|搜索的服务\n|VEBRATOR_SERVICE|\tVebrator|\t手机震动的服务\n|CONNECTIVITY_SERVICE\t|Connectivity\t|网络连接的服务\n|WIFI_SERVICE\t|WifiManager\t|Wi-Fi服务\n|TELEPHONY_SERVICE\t|TeleponyManager\t|电话服务","slug":"Android/Android基础/getSystemService的使用","published":1,"date":"2019-09-30T07:19:02.815Z","updated":"2019-09-30T08:28:42.956Z","title":"Android/Android基础/getSystemService的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li05000tkguievcucrhs","content":"<p>getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；</p>\n<table>\n<thead>\n<tr>\n<th>传入的Name</th>\n<th>返回的对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WINDOW_SERVICE</td>\n<td>WindowManager</td>\n<td>管理打开的窗口程序</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td>LayoutInflater</td>\n<td>取得xml里定义的view</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td>ActivityManager</td>\n<td>管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td>PowerManger</td>\n<td>电源的服务</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td>AlarmManager</td>\n<td>闹钟的服务</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td>NotificationManager</td>\n<td>状态栏的服务</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td>KeyguardManager</td>\n<td>键盘锁的服务</td>\n</tr>\n<tr>\n<td>LOCATION_SERVICE</td>\n<td>LocationManager</td>\n<td>位置的服务，如GPS</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td>SearchManager</td>\n<td>搜索的服务</td>\n</tr>\n<tr>\n<td>VEBRATOR_SERVICE</td>\n<td>Vebrator</td>\n<td>手机震动的服务</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td>Connectivity</td>\n<td>网络连接的服务</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td>WifiManager</td>\n<td>Wi-Fi服务</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td>TeleponyManager</td>\n<td>电话服务</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；</p>\n<table>\n<thead>\n<tr>\n<th>传入的Name</th>\n<th>返回的对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WINDOW_SERVICE</td>\n<td>WindowManager</td>\n<td>管理打开的窗口程序</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td>LayoutInflater</td>\n<td>取得xml里定义的view</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td>ActivityManager</td>\n<td>管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td>PowerManger</td>\n<td>电源的服务</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td>AlarmManager</td>\n<td>闹钟的服务</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td>NotificationManager</td>\n<td>状态栏的服务</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td>KeyguardManager</td>\n<td>键盘锁的服务</td>\n</tr>\n<tr>\n<td>LOCATION_SERVICE</td>\n<td>LocationManager</td>\n<td>位置的服务，如GPS</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td>SearchManager</td>\n<td>搜索的服务</td>\n</tr>\n<tr>\n<td>VEBRATOR_SERVICE</td>\n<td>Vebrator</td>\n<td>手机震动的服务</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td>Connectivity</td>\n<td>网络连接的服务</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td>WifiManager</td>\n<td>Wi-Fi服务</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td>TeleponyManager</td>\n<td>电话服务</td>\n</tr>\n</tbody></table>\n"},{"_content":"# Android后台处理介绍\n\nAndroid手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。\n\n## 推荐在后台进行处理的三种情况\n\n### App处理操作是否可以滞后进行，或者需要实时处理\n\n例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行\n\n### App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\n\n例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。\n\n### App操作处理是否是由系统进行触发\n\n系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。\n\n#### 加一个选择策略图片\n\n## 线程池\n\n对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。\n\n* 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁\n\n## Foreground Service操作\n\n对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。\n\n## Workmanager\n\n对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0\\(API 23\\)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。\n\n## 后台进程操作的限制\n\n为了最大化利用电池以及更好的App使用体验，Android会限制App\\(或者一个forceground service notification\\)，当其对用户不可见时。\n\n* Android 6.0\\(Api 23\\)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。\n* Android 7.0\\(Api 24\\)限制隐式广播。\n* Android 8.0\\(Api 26\\)限制更多的后台操作，包括后台获取地址信息以及释放缓存。\n\n","source":"_posts/Android/Android基础/Android后台任务.md","raw":"# Android后台处理介绍\n\nAndroid手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。\n\n## 推荐在后台进行处理的三种情况\n\n### App处理操作是否可以滞后进行，或者需要实时处理\n\n例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行\n\n### App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\n\n例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。\n\n### App操作处理是否是由系统进行触发\n\n系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。\n\n#### 加一个选择策略图片\n\n## 线程池\n\n对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。\n\n* 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁\n\n## Foreground Service操作\n\n对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。\n\n## Workmanager\n\n对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0\\(API 23\\)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。\n\n## 后台进程操作的限制\n\n为了最大化利用电池以及更好的App使用体验，Android会限制App\\(或者一个forceground service notification\\)，当其对用户不可见时。\n\n* Android 6.0\\(Api 23\\)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。\n* Android 7.0\\(Api 24\\)限制隐式广播。\n* Android 8.0\\(Api 26\\)限制更多的后台操作，包括后台获取地址信息以及释放缓存。\n\n","slug":"Android/Android基础/Android后台任务","published":1,"date":"2019-09-30T08:26:59.176Z","updated":"2019-09-30T08:28:42.954Z","title":"Android/Android基础/Android后台任务","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li05000ukguif9qe2otm","content":"<h1 id=\"Android后台处理介绍\"><a href=\"#Android后台处理介绍\" class=\"headerlink\" title=\"Android后台处理介绍\"></a>Android后台处理介绍</h1><p>Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。</p>\n<h2 id=\"推荐在后台进行处理的三种情况\"><a href=\"#推荐在后台进行处理的三种情况\" class=\"headerlink\" title=\"推荐在后台进行处理的三种情况\"></a>推荐在后台进行处理的三种情况</h2><h3 id=\"App处理操作是否可以滞后进行，或者需要实时处理\"><a href=\"#App处理操作是否可以滞后进行，或者需要实时处理\" class=\"headerlink\" title=\"App处理操作是否可以滞后进行，或者需要实时处理\"></a>App处理操作是否可以滞后进行，或者需要实时处理</h3><p>例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行</p>\n<h3 id=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\"><a href=\"#App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\" class=\"headerlink\" title=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\"></a>App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理</h3><p>例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。</p>\n<h3 id=\"App操作处理是否是由系统进行触发\"><a href=\"#App操作处理是否是由系统进行触发\" class=\"headerlink\" title=\"App操作处理是否是由系统进行触发\"></a>App操作处理是否是由系统进行触发</h3><p>系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。</p>\n<h4 id=\"加一个选择策略图片\"><a href=\"#加一个选择策略图片\" class=\"headerlink\" title=\"加一个选择策略图片\"></a>加一个选择策略图片</h4><h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。</p>\n<ul>\n<li>注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁</li>\n</ul>\n<h2 id=\"Foreground-Service操作\"><a href=\"#Foreground-Service操作\" class=\"headerlink\" title=\"Foreground Service操作\"></a>Foreground Service操作</h2><p>对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。</p>\n<h2 id=\"Workmanager\"><a href=\"#Workmanager\" class=\"headerlink\" title=\"Workmanager\"></a>Workmanager</h2><p>对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。</p>\n<h2 id=\"后台进程操作的限制\"><a href=\"#后台进程操作的限制\" class=\"headerlink\" title=\"后台进程操作的限制\"></a>后台进程操作的限制</h2><p>为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。</p>\n<ul>\n<li>Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。</li>\n<li>Android 7.0(Api 24)限制隐式广播。</li>\n<li>Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android后台处理介绍\"><a href=\"#Android后台处理介绍\" class=\"headerlink\" title=\"Android后台处理介绍\"></a>Android后台处理介绍</h1><p>Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。</p>\n<h2 id=\"推荐在后台进行处理的三种情况\"><a href=\"#推荐在后台进行处理的三种情况\" class=\"headerlink\" title=\"推荐在后台进行处理的三种情况\"></a>推荐在后台进行处理的三种情况</h2><h3 id=\"App处理操作是否可以滞后进行，或者需要实时处理\"><a href=\"#App处理操作是否可以滞后进行，或者需要实时处理\" class=\"headerlink\" title=\"App处理操作是否可以滞后进行，或者需要实时处理\"></a>App处理操作是否可以滞后进行，或者需要实时处理</h3><p>例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行</p>\n<h3 id=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\"><a href=\"#App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\" class=\"headerlink\" title=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\"></a>App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理</h3><p>例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。</p>\n<h3 id=\"App操作处理是否是由系统进行触发\"><a href=\"#App操作处理是否是由系统进行触发\" class=\"headerlink\" title=\"App操作处理是否是由系统进行触发\"></a>App操作处理是否是由系统进行触发</h3><p>系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。</p>\n<h4 id=\"加一个选择策略图片\"><a href=\"#加一个选择策略图片\" class=\"headerlink\" title=\"加一个选择策略图片\"></a>加一个选择策略图片</h4><h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。</p>\n<ul>\n<li>注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁</li>\n</ul>\n<h2 id=\"Foreground-Service操作\"><a href=\"#Foreground-Service操作\" class=\"headerlink\" title=\"Foreground Service操作\"></a>Foreground Service操作</h2><p>对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。</p>\n<h2 id=\"Workmanager\"><a href=\"#Workmanager\" class=\"headerlink\" title=\"Workmanager\"></a>Workmanager</h2><p>对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。</p>\n<h2 id=\"后台进程操作的限制\"><a href=\"#后台进程操作的限制\" class=\"headerlink\" title=\"后台进程操作的限制\"></a>后台进程操作的限制</h2><p>为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。</p>\n<ul>\n<li>Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。</li>\n<li>Android 7.0(Api 24)限制隐式广播。</li>\n<li>Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。</li>\n</ul>\n"},{"_content":"\n\n**知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor**\n\n一个AsyncTask对象被创建出来后,就只能执行一个异步任务。\n\n\nAsyncTask<Params,Progress,Result>是一个抽象类，继承AsyncTask需要指定三个泛型参数\n* Params：启动任务时输入的参数类型\n* Progress：后台任务执行中返回进度值的类型\n* Result：后台任务执行完成后返回结果类型\n\nAsyncTask中三个重要函数\n\n* doInBackground：异步执行后台线程要完成的任务在此方法中进行\n* onPreExecute：执行后台耗时操作前调用，通常用于初始化操作\n* onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI\n* onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。\n","source":"_posts/Android/Android基础/异步操作Asynctask.md","raw":"\n\n**知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor**\n\n一个AsyncTask对象被创建出来后,就只能执行一个异步任务。\n\n\nAsyncTask<Params,Progress,Result>是一个抽象类，继承AsyncTask需要指定三个泛型参数\n* Params：启动任务时输入的参数类型\n* Progress：后台任务执行中返回进度值的类型\n* Result：后台任务执行完成后返回结果类型\n\nAsyncTask中三个重要函数\n\n* doInBackground：异步执行后台线程要完成的任务在此方法中进行\n* onPreExecute：执行后台耗时操作前调用，通常用于初始化操作\n* onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI\n* onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。\n","slug":"Android/Android基础/异步操作Asynctask","published":1,"date":"2019-09-30T07:19:02.827Z","updated":"2019-09-30T08:28:42.957Z","title":"Android/Android基础/异步操作Asynctask","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li06000vkgui534ga1dg","content":"<p><strong>知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor</strong></p>\n<p>一个AsyncTask对象被创建出来后,就只能执行一个异步任务。</p>\n<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数</p>\n<ul>\n<li>Params：启动任务时输入的参数类型</li>\n<li>Progress：后台任务执行中返回进度值的类型</li>\n<li>Result：后台任务执行完成后返回结果类型</li>\n</ul>\n<p>AsyncTask中三个重要函数</p>\n<ul>\n<li>doInBackground：异步执行后台线程要完成的任务在此方法中进行</li>\n<li>onPreExecute：执行后台耗时操作前调用，通常用于初始化操作</li>\n<li>onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI</li>\n<li>onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor</strong></p>\n<p>一个AsyncTask对象被创建出来后,就只能执行一个异步任务。</p>\n<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数</p>\n<ul>\n<li>Params：启动任务时输入的参数类型</li>\n<li>Progress：后台任务执行中返回进度值的类型</li>\n<li>Result：后台任务执行完成后返回结果类型</li>\n</ul>\n<p>AsyncTask中三个重要函数</p>\n<ul>\n<li>doInBackground：异步执行后台线程要完成的任务在此方法中进行</li>\n<li>onPreExecute：执行后台耗时操作前调用，通常用于初始化操作</li>\n<li>onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI</li>\n<li>onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。</li>\n</ul>\n"},{"_content":"### 查看签名文件信息\n\n密码是password\n\n```\n    keytool -list -v -keystore application.jks -storepass password\n```","source":"_posts/Android/Other/常用操作.md","raw":"### 查看签名文件信息\n\n密码是password\n\n```\n    keytool -list -v -keystore application.jks -storepass password\n```","slug":"Android/Other/常用操作","published":1,"date":"2019-09-30T08:28:42.959Z","updated":"2019-09-30T08:28:42.960Z","title":"Android/Other/常用操作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0a000zkguihj8x14dm","content":"<h3 id=\"查看签名文件信息\"><a href=\"#查看签名文件信息\" class=\"headerlink\" title=\"查看签名文件信息\"></a>查看签名文件信息</h3><p>密码是password</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -v -keystore application.jks -storepass password</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"查看签名文件信息\"><a href=\"#查看签名文件信息\" class=\"headerlink\" title=\"查看签名文件信息\"></a>查看签名文件信息</h3><p>密码是password</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -v -keystore application.jks -storepass password</span><br></pre></td></tr></table></figure>"},{"_content":"# 使用自定义View实现倒计时功能\n\n当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。\n\n## 倒计时控件实现的功能\n\n* 显示时间进度\n* 计时结束后将会自动跳转到下一个Activity中\n\n实现效果如图所示\n\n在本篇博客中的代码会有部分缺省，源码链接\n\n## 对自定义View的尺寸进行测量并绘制中间的大圆\n\nView在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。\n\n```text\npublic class CountDownView extends android.support.v7.widget.AppCompatTextView {\n\n    private int circleRadius;\n\n    private int circleColor=0xff33b5e5;\n\n    private Paint circlePaint;\n    private Rect bounds;\n\n    private int centerX;\n    private int centerY;\n\n    public CountDownView(Context context) {\n        super(context);\n        init();\n    }\n\n    public void init(){\n        circlePaint=new Paint();\n        bounds=new Rect();\n\n    }\n\n    public CountDownView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n\n        circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;\n        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        getDrawingRect(bounds);      //获取控件的边界\n\n        centerX=bounds.centerX();\n        centerY=bounds.centerY();\n\n        //绘制中间的大圆的背景\n        circlePaint.setAntiAlias(true);\n        circlePaint.setStyle(Paint.Style.FILL);\n        circlePaint.setColor(circleColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);\n\n    }\n}\n```\n\n在activity\\_main.xml中添加自定义控件\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    tools:context=\".MainActivity\">\n\n    <com.example.wyw.countdowndemo.CountDownView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        />\n\n</LinearLayout>\n```\n\n运行结果\n\n## 绘制进度边框\n\n```text\n    private int cirlceBoundColor=0xff00ddff;\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setStyle(Paint.Style.STROKE);\n        circlePaint.setStrokeWidth(5);\n        circlePaint.setColor(cirlceBoundColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);\n\n    }\n```\n\n## 绘制进度条的一条弧线\n\n进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线\n\n```text\n    private RectF arcRectF;\n    private int processColor=0xff99cc00;\n\n    public void init(){\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setColor(processColor);\n        //设置线冒样式\n        circlePaint.setStrokeCap(Paint.Cap.ROUND);\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,40,false,circlePaint);\n\n    }\n```\n\n## 进度条按照通过Timer不断控制绘制角度的增加\n\n```text\n    private int currentDrawTime;    //已经绘制的次数\n    private Timer timer;\n\n    public void init(){\n        timer=new Timer();\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);\n\n    }\n\n    public void drawProcess(){\n\n        currentDrawTime=0;\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n               postInvalidate();\n               currentDrawTime++;\n               if (currentDrawTime==8)\n                   timer.cancel();\n            }\n        },500,500);\n\n    }\n```\n\n## 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\n\n```text\n    @Override\n    protected void onDraw(Canvas canvas) {\n     Paint paint = getPaint();\n        float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;\n        paint.setAntiAlias(true);  //防锯齿\n        paint.setColor(Color.WHITE);\n        paint.setTextAlign(Paint.Align.CENTER);\n        canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint);\n\n    }\n```\n\n","source":"_posts/Android/View/CountDownView.md","raw":"# 使用自定义View实现倒计时功能\n\n当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。\n\n## 倒计时控件实现的功能\n\n* 显示时间进度\n* 计时结束后将会自动跳转到下一个Activity中\n\n实现效果如图所示\n\n在本篇博客中的代码会有部分缺省，源码链接\n\n## 对自定义View的尺寸进行测量并绘制中间的大圆\n\nView在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。\n\n```text\npublic class CountDownView extends android.support.v7.widget.AppCompatTextView {\n\n    private int circleRadius;\n\n    private int circleColor=0xff33b5e5;\n\n    private Paint circlePaint;\n    private Rect bounds;\n\n    private int centerX;\n    private int centerY;\n\n    public CountDownView(Context context) {\n        super(context);\n        init();\n    }\n\n    public void init(){\n        circlePaint=new Paint();\n        bounds=new Rect();\n\n    }\n\n    public CountDownView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n\n        circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;\n        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        getDrawingRect(bounds);      //获取控件的边界\n\n        centerX=bounds.centerX();\n        centerY=bounds.centerY();\n\n        //绘制中间的大圆的背景\n        circlePaint.setAntiAlias(true);\n        circlePaint.setStyle(Paint.Style.FILL);\n        circlePaint.setColor(circleColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);\n\n    }\n}\n```\n\n在activity\\_main.xml中添加自定义控件\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    tools:context=\".MainActivity\">\n\n    <com.example.wyw.countdowndemo.CountDownView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        />\n\n</LinearLayout>\n```\n\n运行结果\n\n## 绘制进度边框\n\n```text\n    private int cirlceBoundColor=0xff00ddff;\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setStyle(Paint.Style.STROKE);\n        circlePaint.setStrokeWidth(5);\n        circlePaint.setColor(cirlceBoundColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);\n\n    }\n```\n\n## 绘制进度条的一条弧线\n\n进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线\n\n```text\n    private RectF arcRectF;\n    private int processColor=0xff99cc00;\n\n    public void init(){\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setColor(processColor);\n        //设置线冒样式\n        circlePaint.setStrokeCap(Paint.Cap.ROUND);\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,40,false,circlePaint);\n\n    }\n```\n\n## 进度条按照通过Timer不断控制绘制角度的增加\n\n```text\n    private int currentDrawTime;    //已经绘制的次数\n    private Timer timer;\n\n    public void init(){\n        timer=new Timer();\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);\n\n    }\n\n    public void drawProcess(){\n\n        currentDrawTime=0;\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n               postInvalidate();\n               currentDrawTime++;\n               if (currentDrawTime==8)\n                   timer.cancel();\n            }\n        },500,500);\n\n    }\n```\n\n## 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\n\n```text\n    @Override\n    protected void onDraw(Canvas canvas) {\n     Paint paint = getPaint();\n        float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;\n        paint.setAntiAlias(true);  //防锯齿\n        paint.setColor(Color.WHITE);\n        paint.setTextAlign(Paint.Align.CENTER);\n        canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint);\n\n    }\n```\n\n","slug":"Android/View/CountDownView","published":1,"date":"2019-09-19T09:41:14.745Z","updated":"2019-09-19T09:41:14.746Z","title":"Android/View/CountDownView","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0b0010kguicodw7tzf","content":"<h1 id=\"使用自定义View实现倒计时功能\"><a href=\"#使用自定义View实现倒计时功能\" class=\"headerlink\" title=\"使用自定义View实现倒计时功能\"></a>使用自定义View实现倒计时功能</h1><p>当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。</p>\n<h2 id=\"倒计时控件实现的功能\"><a href=\"#倒计时控件实现的功能\" class=\"headerlink\" title=\"倒计时控件实现的功能\"></a>倒计时控件实现的功能</h2><ul>\n<li>显示时间进度</li>\n<li>计时结束后将会自动跳转到下一个Activity中</li>\n</ul>\n<p>实现效果如图所示</p>\n<p>在本篇博客中的代码会有部分缺省，源码链接</p>\n<h2 id=\"对自定义View的尺寸进行测量并绘制中间的大圆\"><a href=\"#对自定义View的尺寸进行测量并绘制中间的大圆\" class=\"headerlink\" title=\"对自定义View的尺寸进行测量并绘制中间的大圆\"></a>对自定义View的尺寸进行测量并绘制中间的大圆</h2><p>View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CountDownView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleColor&#x3D;0xff33b5e5;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Paint circlePaint;</span><br><span class=\"line\">    private Rect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int centerX;</span><br><span class=\"line\">    private int centerY;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        circlePaint&#x3D;new Paint();</span><br><span class=\"line\">        bounds&#x3D;new Rect();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        super.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        circleRadius&#x3D;getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()&#x2F;2:getMeasuredWidth()&#x2F;2;</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\">        getDrawingRect(bounds);      &#x2F;&#x2F;获取控件的边界</span><br><span class=\"line\"></span><br><span class=\"line\">        centerX&#x3D;bounds.centerX();</span><br><span class=\"line\">        centerY&#x3D;bounds.centerY();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;绘制中间的大圆的背景</span><br><span class=\"line\">        circlePaint.setAntiAlias(true);</span><br><span class=\"line\">        circlePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        circlePaint.setColor(circleColor);</span><br><span class=\"line\">        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在activity_main.xml中添加自定义控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.example.wyw.countdowndemo.CountDownView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<h2 id=\"绘制进度边框\"><a href=\"#绘制进度边框\" class=\"headerlink\" title=\"绘制进度边框\"></a>绘制进度边框</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int cirlceBoundColor&#x3D;0xff00ddff;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">    circlePaint.setStrokeWidth(5);</span><br><span class=\"line\">    circlePaint.setColor(cirlceBoundColor);</span><br><span class=\"line\">    canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绘制进度条的一条弧线\"><a href=\"#绘制进度条的一条弧线\" class=\"headerlink\" title=\"绘制进度条的一条弧线\"></a>绘制进度条的一条弧线</h2><p>进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private RectF arcRectF;</span><br><span class=\"line\">private int processColor&#x3D;0xff99cc00;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setColor(processColor);</span><br><span class=\"line\">    &#x2F;&#x2F;设置线冒样式</span><br><span class=\"line\">    circlePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,40,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进度条按照通过Timer不断控制绘制角度的增加\"><a href=\"#进度条按照通过Timer不断控制绘制角度的增加\" class=\"headerlink\" title=\"进度条按照通过Timer不断控制绘制角度的增加\"></a>进度条按照通过Timer不断控制绘制角度的增加</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int currentDrawTime;    &#x2F;&#x2F;已经绘制的次数</span><br><span class=\"line\">private Timer timer;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    timer&#x3D;new Timer();</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void drawProcess()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentDrawTime&#x3D;0;</span><br><span class=\"line\">    timer.schedule(new TimerTask() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">           currentDrawTime++;</span><br><span class=\"line\">           if (currentDrawTime&#x3D;&#x3D;8)</span><br><span class=\"line\">               timer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,500,500);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"><a href=\"#倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\" class=\"headerlink\" title=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"></a>倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"> Paint paint &#x3D; getPaint();</span><br><span class=\"line\">    float textY &#x3D; centerY - (circlePaint.descent() + circlePaint.ascent()) &#x2F; 2;</span><br><span class=\"line\">    paint.setAntiAlias(true);  &#x2F;&#x2F;防锯齿</span><br><span class=\"line\">    paint.setColor(Color.WHITE);</span><br><span class=\"line\">    paint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\">    canvas.drawText((4000-500*currentDrawTime)&#x2F;500+&quot;s&quot;,centerY,textY,paint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用自定义View实现倒计时功能\"><a href=\"#使用自定义View实现倒计时功能\" class=\"headerlink\" title=\"使用自定义View实现倒计时功能\"></a>使用自定义View实现倒计时功能</h1><p>当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。</p>\n<h2 id=\"倒计时控件实现的功能\"><a href=\"#倒计时控件实现的功能\" class=\"headerlink\" title=\"倒计时控件实现的功能\"></a>倒计时控件实现的功能</h2><ul>\n<li>显示时间进度</li>\n<li>计时结束后将会自动跳转到下一个Activity中</li>\n</ul>\n<p>实现效果如图所示</p>\n<p>在本篇博客中的代码会有部分缺省，源码链接</p>\n<h2 id=\"对自定义View的尺寸进行测量并绘制中间的大圆\"><a href=\"#对自定义View的尺寸进行测量并绘制中间的大圆\" class=\"headerlink\" title=\"对自定义View的尺寸进行测量并绘制中间的大圆\"></a>对自定义View的尺寸进行测量并绘制中间的大圆</h2><p>View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CountDownView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleColor&#x3D;0xff33b5e5;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Paint circlePaint;</span><br><span class=\"line\">    private Rect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int centerX;</span><br><span class=\"line\">    private int centerY;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        circlePaint&#x3D;new Paint();</span><br><span class=\"line\">        bounds&#x3D;new Rect();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        super.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        circleRadius&#x3D;getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()&#x2F;2:getMeasuredWidth()&#x2F;2;</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\">        getDrawingRect(bounds);      &#x2F;&#x2F;获取控件的边界</span><br><span class=\"line\"></span><br><span class=\"line\">        centerX&#x3D;bounds.centerX();</span><br><span class=\"line\">        centerY&#x3D;bounds.centerY();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;绘制中间的大圆的背景</span><br><span class=\"line\">        circlePaint.setAntiAlias(true);</span><br><span class=\"line\">        circlePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        circlePaint.setColor(circleColor);</span><br><span class=\"line\">        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在activity_main.xml中添加自定义控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">    tools:context&#x3D;&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.example.wyw.countdowndemo.CountDownView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;100dp&quot;</span><br><span class=\"line\">        &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<h2 id=\"绘制进度边框\"><a href=\"#绘制进度边框\" class=\"headerlink\" title=\"绘制进度边框\"></a>绘制进度边框</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int cirlceBoundColor&#x3D;0xff00ddff;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">    circlePaint.setStrokeWidth(5);</span><br><span class=\"line\">    circlePaint.setColor(cirlceBoundColor);</span><br><span class=\"line\">    canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绘制进度条的一条弧线\"><a href=\"#绘制进度条的一条弧线\" class=\"headerlink\" title=\"绘制进度条的一条弧线\"></a>绘制进度条的一条弧线</h2><p>进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private RectF arcRectF;</span><br><span class=\"line\">private int processColor&#x3D;0xff99cc00;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setColor(processColor);</span><br><span class=\"line\">    &#x2F;&#x2F;设置线冒样式</span><br><span class=\"line\">    circlePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,40,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进度条按照通过Timer不断控制绘制角度的增加\"><a href=\"#进度条按照通过Timer不断控制绘制角度的增加\" class=\"headerlink\" title=\"进度条按照通过Timer不断控制绘制角度的增加\"></a>进度条按照通过Timer不断控制绘制角度的增加</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int currentDrawTime;    &#x2F;&#x2F;已经绘制的次数</span><br><span class=\"line\">private Timer timer;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    timer&#x3D;new Timer();</span><br><span class=\"line\">    arcRectF&#x3D;new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void drawProcess()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentDrawTime&#x3D;0;</span><br><span class=\"line\">    timer.schedule(new TimerTask() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">           currentDrawTime++;</span><br><span class=\"line\">           if (currentDrawTime&#x3D;&#x3D;8)</span><br><span class=\"line\">               timer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,500,500);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"><a href=\"#倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\" class=\"headerlink\" title=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"></a>倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"> Paint paint &#x3D; getPaint();</span><br><span class=\"line\">    float textY &#x3D; centerY - (circlePaint.descent() + circlePaint.ascent()) &#x2F; 2;</span><br><span class=\"line\">    paint.setAntiAlias(true);  &#x2F;&#x2F;防锯齿</span><br><span class=\"line\">    paint.setColor(Color.WHITE);</span><br><span class=\"line\">    paint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\">    canvas.drawText((4000-500*currentDrawTime)&#x2F;500+&quot;s&quot;,centerY,textY,paint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"## 在Android 6.0及以上需要对手机权限进行动态获取\n\n如果手机版本为Android 6.0(API 23)或更高版本，以及app的`targetSdkVersion`为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。\n\n**同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。** *同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如`Manifest.permission.BLUETOOTH`在动态申请时同样不会出现权限申请对话框，但会回调*\n\nAndroid动态权限的申请仅对下图中的9大权限组进行申请\n![](/assets/android_basis_permission.png)\n\n### 一、对于可选硬件功能权限的获取\n\n使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加`<uses-feature> `\n```html\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n```\n当声明为`android:required=\"false\"`时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要`PackageManager.hasSystemFeature()`来确定该设备是否存在；当声明为`android:required=\"true\"`时，需要手机上具有该设备，否则不能进行安装操作。\n\n### 二、代码实现\n\n```java\n\n    String[] permissions = {Manifest.permission.BLUETOOTH};\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //只有系统API大于23时，才需要判断权限是否需要获取\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            //用于判断权限是否已经获取\n            int i = ContextCompat.checkSelfPermission(this, permissions[0]);\n            //权限是否已经获取 GRANTED--授权 DINED--拒绝\n            if (i != PackageManager.PERMISSION_GRANTED) {\n                //如果没有被授予该权限，提示用户请求该权限\n                ActivityCompat.requestPermissions(this, permissions, 1);\n            }else {\n                Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                           @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode==1){\n            //未获取到权限\n            if (grantResults[0] != PackageManager.PERMISSION_GRANTED) {\n                //判断用户是否点击了不再提醒；检测该权限是否还可以再申请\n                boolean result = this.shouldShowRequestPermissionRationale(permissions[0]);\n                //如果不可以再申请\n                if (!result) {\n                    //用户需要继续使用App\n                    //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示\n                    LogUtils.printInfo(\"请到设置界面开启相应权限\");\n                }else {\n                    //如果可以再申请\n                    Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show();\n                }\n            }\n        }\n    }\n```\n\n### 三、连续多次申请权限出现问题\n在进行连续多次申请时，在回调函数`onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)`的`permissions`数组会返回长度为零的数组，因为在Activity的`requestPermissions()`方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行`onRequestPermissionsResult`方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；\n\n```java\n    //Activity源码\n    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {\n        //省略部分代码\n        if (mHasCurrentPermissionsRequest) {\n            Log.w(TAG, \"Can request only one set of permissions at a time\");\n            // Dispatch the callback with empty arrays which means a cancellation.\n            onRequestPermissionsResult(requestCode, new String[0], new int[0]);\n            return;\n        }\n        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);\n        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);\n        mHasCurrentPermissionsRequest = true;\n    }\n```\n\n\n### 四、其他\n\n有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。\n```xml\n\n```\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Android 6.0动态权限获取.md","raw":"## 在Android 6.0及以上需要对手机权限进行动态获取\n\n如果手机版本为Android 6.0(API 23)或更高版本，以及app的`targetSdkVersion`为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。\n\n**同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。** *同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如`Manifest.permission.BLUETOOTH`在动态申请时同样不会出现权限申请对话框，但会回调*\n\nAndroid动态权限的申请仅对下图中的9大权限组进行申请\n![](/assets/android_basis_permission.png)\n\n### 一、对于可选硬件功能权限的获取\n\n使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加`<uses-feature> `\n```html\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n```\n当声明为`android:required=\"false\"`时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要`PackageManager.hasSystemFeature()`来确定该设备是否存在；当声明为`android:required=\"true\"`时，需要手机上具有该设备，否则不能进行安装操作。\n\n### 二、代码实现\n\n```java\n\n    String[] permissions = {Manifest.permission.BLUETOOTH};\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //只有系统API大于23时，才需要判断权限是否需要获取\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            //用于判断权限是否已经获取\n            int i = ContextCompat.checkSelfPermission(this, permissions[0]);\n            //权限是否已经获取 GRANTED--授权 DINED--拒绝\n            if (i != PackageManager.PERMISSION_GRANTED) {\n                //如果没有被授予该权限，提示用户请求该权限\n                ActivityCompat.requestPermissions(this, permissions, 1);\n            }else {\n                Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                           @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode==1){\n            //未获取到权限\n            if (grantResults[0] != PackageManager.PERMISSION_GRANTED) {\n                //判断用户是否点击了不再提醒；检测该权限是否还可以再申请\n                boolean result = this.shouldShowRequestPermissionRationale(permissions[0]);\n                //如果不可以再申请\n                if (!result) {\n                    //用户需要继续使用App\n                    //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示\n                    LogUtils.printInfo(\"请到设置界面开启相应权限\");\n                }else {\n                    //如果可以再申请\n                    Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show();\n                }\n            }\n        }\n    }\n```\n\n### 三、连续多次申请权限出现问题\n在进行连续多次申请时，在回调函数`onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)`的`permissions`数组会返回长度为零的数组，因为在Activity的`requestPermissions()`方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行`onRequestPermissionsResult`方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；\n\n```java\n    //Activity源码\n    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {\n        //省略部分代码\n        if (mHasCurrentPermissionsRequest) {\n            Log.w(TAG, \"Can request only one set of permissions at a time\");\n            // Dispatch the callback with empty arrays which means a cancellation.\n            onRequestPermissionsResult(requestCode, new String[0], new int[0]);\n            return;\n        }\n        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);\n        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);\n        mHasCurrentPermissionsRequest = true;\n    }\n```\n\n\n### 四、其他\n\n有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。\n```xml\n\n```\n\n\n\n\n\n\n\n\n","slug":"Android/Android基础/Android 6.0动态权限获取","published":1,"date":"2019-09-19T09:34:08.480Z","updated":"2019-11-30T11:14:32.182Z","title":"Android/Android基础/Android 6.0动态权限获取","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0c0011kgui6plt67cc","content":"<h2 id=\"在Android-6-0及以上需要对手机权限进行动态获取\"><a href=\"#在Android-6-0及以上需要对手机权限进行动态获取\" class=\"headerlink\" title=\"在Android 6.0及以上需要对手机权限进行动态获取\"></a>在Android 6.0及以上需要对手机权限进行动态获取</h2><p>如果手机版本为Android 6.0(API 23)或更高版本，以及app的<code>targetSdkVersion</code>为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。</p>\n<p><strong>同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。</strong> <em>同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如<code>Manifest.permission.BLUETOOTH</code>在动态申请时同样不会出现权限申请对话框，但会回调</em></p>\n<p>Android动态权限的申请仅对下图中的9大权限组进行申请<br><img src=\"/assets/android_basis_permission.png\" alt=\"\"></p>\n<h3 id=\"一、对于可选硬件功能权限的获取\"><a href=\"#一、对于可选硬件功能权限的获取\" class=\"headerlink\" title=\"一、对于可选硬件功能权限的获取\"></a>一、对于可选硬件功能权限的获取</h3><p>使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加<code>&lt;uses-feature&gt;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-feature</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.hardware.camera\"</span> <span class=\"attr\">android:required</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当声明为<code>android:required=&quot;false&quot;</code>时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要<code>PackageManager.hasSystemFeature()</code>来确定该设备是否存在；当声明为<code>android:required=&quot;true&quot;</code>时，需要手机上具有该设备，否则不能进行安装操作。</p>\n<h3 id=\"二、代码实现\"><a href=\"#二、代码实现\" class=\"headerlink\" title=\"二、代码实现\"></a>二、代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String[] permissions = &#123;Manifest.permission.BLUETOOTH&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    <span class=\"comment\">//只有系统API大于23时，才需要判断权限是否需要获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断权限是否已经获取</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = ContextCompat.checkSelfPermission(<span class=\"keyword\">this</span>, permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//权限是否已经获取 GRANTED--授权 DINED--拒绝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有被授予该权限，提示用户请求该权限</span></span><br><span class=\"line\">            ActivityCompat.requestPermissions(<span class=\"keyword\">this</span>, permissions, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"权限已获取\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, @NonNull String[] permissions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//未获取到权限</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grantResults[<span class=\"number\">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断用户是否点击了不再提醒；检测该权限是否还可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.shouldShowRequestPermissionRationale(permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//如果不可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用户需要继续使用App</span></span><br><span class=\"line\">                <span class=\"comment\">//提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示</span></span><br><span class=\"line\">                LogUtils.printInfo(<span class=\"string\">\"请到设置界面开启相应权限\"</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果可以再申请</span></span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"请开启权限权限\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、连续多次申请权限出现问题\"><a href=\"#三、连续多次申请权限出现问题\" class=\"headerlink\" title=\"三、连续多次申请权限出现问题\"></a>三、连续多次申请权限出现问题</h3><p>在进行连续多次申请时，在回调函数<code>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)</code>的<code>permissions</code>数组会返回长度为零的数组，因为在Activity的<code>requestPermissions()</code>方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行<code>onRequestPermissionsResult</code>方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">requestPermissions</span><span class=\"params\">(@NonNull String[] permissions, <span class=\"keyword\">int</span> requestCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">\"Can request only one set of permissions at a time\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class=\"line\">        onRequestPermissionsResult(requestCode, <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class=\"line\">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mHasCurrentPermissionsRequest = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"四、其他\"><a href=\"#四、其他\" class=\"headerlink\" title=\"四、其他\"></a>四、其他</h3><p>有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"在Android-6-0及以上需要对手机权限进行动态获取\"><a href=\"#在Android-6-0及以上需要对手机权限进行动态获取\" class=\"headerlink\" title=\"在Android 6.0及以上需要对手机权限进行动态获取\"></a>在Android 6.0及以上需要对手机权限进行动态获取</h2><p>如果手机版本为Android 6.0(API 23)或更高版本，以及app的<code>targetSdkVersion</code>为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。</p>\n<p><strong>同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。</strong> <em>同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如<code>Manifest.permission.BLUETOOTH</code>在动态申请时同样不会出现权限申请对话框，但会回调</em></p>\n<p>Android动态权限的申请仅对下图中的9大权限组进行申请<br><img src=\"/assets/android_basis_permission.png\" alt=\"\"></p>\n<h3 id=\"一、对于可选硬件功能权限的获取\"><a href=\"#一、对于可选硬件功能权限的获取\" class=\"headerlink\" title=\"一、对于可选硬件功能权限的获取\"></a>一、对于可选硬件功能权限的获取</h3><p>使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加<code>&lt;uses-feature&gt;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-feature</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.hardware.camera\"</span> <span class=\"attr\">android:required</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当声明为<code>android:required=&quot;false&quot;</code>时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要<code>PackageManager.hasSystemFeature()</code>来确定该设备是否存在；当声明为<code>android:required=&quot;true&quot;</code>时，需要手机上具有该设备，否则不能进行安装操作。</p>\n<h3 id=\"二、代码实现\"><a href=\"#二、代码实现\" class=\"headerlink\" title=\"二、代码实现\"></a>二、代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String[] permissions = &#123;Manifest.permission.BLUETOOTH&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    <span class=\"comment\">//只有系统API大于23时，才需要判断权限是否需要获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断权限是否已经获取</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = ContextCompat.checkSelfPermission(<span class=\"keyword\">this</span>, permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//权限是否已经获取 GRANTED--授权 DINED--拒绝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有被授予该权限，提示用户请求该权限</span></span><br><span class=\"line\">            ActivityCompat.requestPermissions(<span class=\"keyword\">this</span>, permissions, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"权限已获取\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, @NonNull String[] permissions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       @NonNull <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//未获取到权限</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grantResults[<span class=\"number\">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断用户是否点击了不再提醒；检测该权限是否还可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.shouldShowRequestPermissionRationale(permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//如果不可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用户需要继续使用App</span></span><br><span class=\"line\">                <span class=\"comment\">//提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示</span></span><br><span class=\"line\">                LogUtils.printInfo(<span class=\"string\">\"请到设置界面开启相应权限\"</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果可以再申请</span></span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">\"请开启权限权限\"</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、连续多次申请权限出现问题\"><a href=\"#三、连续多次申请权限出现问题\" class=\"headerlink\" title=\"三、连续多次申请权限出现问题\"></a>三、连续多次申请权限出现问题</h3><p>在进行连续多次申请时，在回调函数<code>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)</code>的<code>permissions</code>数组会返回长度为零的数组，因为在Activity的<code>requestPermissions()</code>方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行<code>onRequestPermissionsResult</code>方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">requestPermissions</span><span class=\"params\">(@NonNull String[] permissions, <span class=\"keyword\">int</span> requestCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">\"Can request only one set of permissions at a time\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class=\"line\">        onRequestPermissionsResult(requestCode, <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class=\"line\">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mHasCurrentPermissionsRequest = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"四、其他\"><a href=\"#四、其他\" class=\"headerlink\" title=\"四、其他\"></a>四、其他</h3><p>有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n"},{"_content":" ## CoordinatorLayout\n CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。\n \n CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar\n \n **CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用**\n \n ## AppBarLayout\n \n AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。\n \n AppBarLayout有五种滚动标识：\n * scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部\n * enterAlways：让任意向下的滚动都会导致该view变为可见\n * enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。\n * exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠\n * snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开\n \n ## CollapsingToolbarLayout\n CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，\n \n ## Behavior\n \n Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。\n \n \n# SnackBar\nSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。\n\n如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；\n\n###SnackBar的使用方式\n```\n\n```\n\n\n# Toast\nToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，\n\n\n### SnackBar和Toast之间的对比\n\n|不同|Toast|SnackBar|\n|---|-----|-----|\n|1|Toast从API1就存在|SnackBar在API23添加|\n|2|不需要Activity，可以显示在Android Home或者其他应用才|只能显示在某一个Activity中|\n|3|不能根据用户的操作执行Action|可以根据用户的操作执行Action|\n|4|在用户滑动时不能消失|在用户滑动时可以消失| ","source":"_posts/Android/View/Materials Design.md","raw":" ## CoordinatorLayout\n CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。\n \n CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar\n \n **CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用**\n \n ## AppBarLayout\n \n AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。\n \n AppBarLayout有五种滚动标识：\n * scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部\n * enterAlways：让任意向下的滚动都会导致该view变为可见\n * enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。\n * exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠\n * snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开\n \n ## CollapsingToolbarLayout\n CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，\n \n ## Behavior\n \n Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。\n \n \n# SnackBar\nSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。\n\n如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；\n\n###SnackBar的使用方式\n```\n\n```\n\n\n# Toast\nToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，\n\n\n### SnackBar和Toast之间的对比\n\n|不同|Toast|SnackBar|\n|---|-----|-----|\n|1|Toast从API1就存在|SnackBar在API23添加|\n|2|不需要Activity，可以显示在Android Home或者其他应用才|只能显示在某一个Activity中|\n|3|不能根据用户的操作执行Action|可以根据用户的操作执行Action|\n|4|在用户滑动时不能消失|在用户滑动时可以消失| ","slug":"Android/View/Materials Design","published":1,"date":"2019-09-30T07:19:02.847Z","updated":"2019-09-30T08:28:42.962Z","title":"Android/View/Materials Design","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0c0013kguigxjp5xc6","content":"<h2 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h2><p> CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。</p>\n<p> CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar</p>\n<p> <strong>CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用</strong></p>\n<h2 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h2><p> AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。</p>\n<p> AppBarLayout有五种滚动标识：</p>\n<ul>\n<li><p>scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部</p>\n</li>\n<li><p>enterAlways：让任意向下的滚动都会导致该view变为可见</p>\n</li>\n<li><p>enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。</p>\n</li>\n<li><p>exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠</p>\n</li>\n<li><p>snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开</p>\n<h2 id=\"CollapsingToolbarLayout\"><a href=\"#CollapsingToolbarLayout\" class=\"headerlink\" title=\"CollapsingToolbarLayout\"></a>CollapsingToolbarLayout</h2><p>CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，</p>\n<h2 id=\"Behavior\"><a href=\"#Behavior\" class=\"headerlink\" title=\"Behavior\"></a>Behavior</h2><p>Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。</p>\n</li>\n</ul>\n<h1 id=\"SnackBar\"><a href=\"#SnackBar\" class=\"headerlink\" title=\"SnackBar\"></a>SnackBar</h1><p>SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。</p>\n<p>如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；</p>\n<p>###SnackBar的使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Toast\"><a href=\"#Toast\" class=\"headerlink\" title=\"Toast\"></a>Toast</h1><p>Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，</p>\n<h3 id=\"SnackBar和Toast之间的对比\"><a href=\"#SnackBar和Toast之间的对比\" class=\"headerlink\" title=\"SnackBar和Toast之间的对比\"></a>SnackBar和Toast之间的对比</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>Toast</th>\n<th>SnackBar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Toast从API1就存在</td>\n<td>SnackBar在API23添加</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不需要Activity，可以显示在Android Home或者其他应用才</td>\n<td>只能显示在某一个Activity中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不能根据用户的操作执行Action</td>\n<td>可以根据用户的操作执行Action</td>\n</tr>\n<tr>\n<td>4</td>\n<td>在用户滑动时不能消失</td>\n<td>在用户滑动时可以消失</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h2><p> CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。</p>\n<p> CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar</p>\n<p> <strong>CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用</strong></p>\n<h2 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h2><p> AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。</p>\n<p> AppBarLayout有五种滚动标识：</p>\n<ul>\n<li><p>scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部</p>\n</li>\n<li><p>enterAlways：让任意向下的滚动都会导致该view变为可见</p>\n</li>\n<li><p>enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。</p>\n</li>\n<li><p>exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠</p>\n</li>\n<li><p>snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开</p>\n<h2 id=\"CollapsingToolbarLayout\"><a href=\"#CollapsingToolbarLayout\" class=\"headerlink\" title=\"CollapsingToolbarLayout\"></a>CollapsingToolbarLayout</h2><p>CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，</p>\n<h2 id=\"Behavior\"><a href=\"#Behavior\" class=\"headerlink\" title=\"Behavior\"></a>Behavior</h2><p>Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。</p>\n</li>\n</ul>\n<h1 id=\"SnackBar\"><a href=\"#SnackBar\" class=\"headerlink\" title=\"SnackBar\"></a>SnackBar</h1><p>SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。</p>\n<p>如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；</p>\n<p>###SnackBar的使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Toast\"><a href=\"#Toast\" class=\"headerlink\" title=\"Toast\"></a>Toast</h1><p>Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，</p>\n<h3 id=\"SnackBar和Toast之间的对比\"><a href=\"#SnackBar和Toast之间的对比\" class=\"headerlink\" title=\"SnackBar和Toast之间的对比\"></a>SnackBar和Toast之间的对比</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>Toast</th>\n<th>SnackBar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Toast从API1就存在</td>\n<td>SnackBar在API23添加</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不需要Activity，可以显示在Android Home或者其他应用才</td>\n<td>只能显示在某一个Activity中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不能根据用户的操作执行Action</td>\n<td>可以根据用户的操作执行Action</td>\n</tr>\n<tr>\n<td>4</td>\n<td>在用户滑动时不能消失</td>\n<td>在用户滑动时可以消失</td>\n</tr>\n</tbody></table>\n"},{"_content":"\n\n## SharedPreference的使用\n\n### 保存数据\n\n### 读取数据","source":"_posts/Android/Android基础/数据储存.md","raw":"\n\n## SharedPreference的使用\n\n### 保存数据\n\n### 读取数据","slug":"Android/Android基础/数据储存","published":1,"date":"2019-11-28T12:20:15.895Z","updated":"2019-11-30T11:14:32.183Z","title":"Android/Android基础/数据储存","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0d0014kgui89no9x73","content":"<h2 id=\"SharedPreference的使用\"><a href=\"#SharedPreference的使用\" class=\"headerlink\" title=\"SharedPreference的使用\"></a>SharedPreference的使用</h2><h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><h3 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SharedPreference的使用\"><a href=\"#SharedPreference的使用\" class=\"headerlink\" title=\"SharedPreference的使用\"></a>SharedPreference的使用</h2><h3 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h3><h3 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h3>"},{"_content":"\nLayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。\n\n* LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。\n\n* findViewById用于已载入的界面，使用findViewById来获取其中的界面元素\n\n\n## 获取LayoutInflater实例的方法\n\n* 1、通过系统服务获取布局加载器\n```\n    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n```\n* 2、通过activity中的getLayoutInflater()方法\n```\n    LayoutInflater inflater = getLayoutInflater();\n```\n\n* 3、通过LayoutInflater的from静态方法\n\n```\n    LayoutInflater inflater = LayoutInflater.from(this)\n```\n\n**这三种方式本质都是调用Context.getSystemService()**\n\n## 使用inflate方法加载布局\n\nLayoutInflater提供四种加载布局的方法\n\n* public View inflate (int resource, ViewGroup root)\n* public View inflate (int resource, ViewGroup root, boolean attachToRoot)\n* public View inflate (XmlPullParser parser, ViewGroup root)\n* public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)\n\n\n**ViewGroup root：指实例的布局所要放入的根视图**\n**boolean attachToToot：指是否附加到传入的根视图**\n\n\n1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。\n2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。\n3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。\n\n**即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View**\n\n### 示例：将button布局添加到LinearLayout上\n\n```\n    <Button xmlns:android=”http://schemas.android.com/apk/res/android\"\n     android:layout_width=”match_parent”\n     android:layout_height=”wrap_content”\n     android:text=”@string/action_attach_to_root_true”\n     android:id=”@+id/button_ok”>\n    </Button>\n```\nButton的layout params类型是LinearLayout.LayoutParams\n\n**将attachRoot设置为true**\n\n```\n    inflater.inflate(R.layout.view_button, mLinearLayout, true);\n```\n**将attachRoot设置为false**\n当attachRoot设置为false后，\n\n```\n    Button btn = (Button)inflater.inflate\n                    (R.layout.view_button,parent,false);\n    parent.addView(btn);\n```\n\n同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    \n\n**在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可**\n\n\n\n\n\n","source":"_posts/Android/View/LayoutInflater使用.md","raw":"\nLayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。\n\n* LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。\n\n* findViewById用于已载入的界面，使用findViewById来获取其中的界面元素\n\n\n## 获取LayoutInflater实例的方法\n\n* 1、通过系统服务获取布局加载器\n```\n    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n```\n* 2、通过activity中的getLayoutInflater()方法\n```\n    LayoutInflater inflater = getLayoutInflater();\n```\n\n* 3、通过LayoutInflater的from静态方法\n\n```\n    LayoutInflater inflater = LayoutInflater.from(this)\n```\n\n**这三种方式本质都是调用Context.getSystemService()**\n\n## 使用inflate方法加载布局\n\nLayoutInflater提供四种加载布局的方法\n\n* public View inflate (int resource, ViewGroup root)\n* public View inflate (int resource, ViewGroup root, boolean attachToRoot)\n* public View inflate (XmlPullParser parser, ViewGroup root)\n* public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)\n\n\n**ViewGroup root：指实例的布局所要放入的根视图**\n**boolean attachToToot：指是否附加到传入的根视图**\n\n\n1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。\n2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。\n3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。\n\n**即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View**\n\n### 示例：将button布局添加到LinearLayout上\n\n```\n    <Button xmlns:android=”http://schemas.android.com/apk/res/android\"\n     android:layout_width=”match_parent”\n     android:layout_height=”wrap_content”\n     android:text=”@string/action_attach_to_root_true”\n     android:id=”@+id/button_ok”>\n    </Button>\n```\nButton的layout params类型是LinearLayout.LayoutParams\n\n**将attachRoot设置为true**\n\n```\n    inflater.inflate(R.layout.view_button, mLinearLayout, true);\n```\n**将attachRoot设置为false**\n当attachRoot设置为false后，\n\n```\n    Button btn = (Button)inflater.inflate\n                    (R.layout.view_button,parent,false);\n    parent.addView(btn);\n```\n\n同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    \n\n**在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可**\n\n\n\n\n\n","slug":"Android/View/LayoutInflater使用","published":1,"date":"2019-09-30T07:19:02.841Z","updated":"2019-09-30T08:28:42.961Z","title":"Android/View/LayoutInflater使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0d0015kgui7kfbhiwl","content":"<p>LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。</p>\n<ul>\n<li><p>LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。</p>\n</li>\n<li><p>findViewById用于已载入的界面，使用findViewById来获取其中的界面元素</p>\n</li>\n</ul>\n<h2 id=\"获取LayoutInflater实例的方法\"><a href=\"#获取LayoutInflater实例的方法\" class=\"headerlink\" title=\"获取LayoutInflater实例的方法\"></a>获取LayoutInflater实例的方法</h2><ul>\n<li><p>1、通过系统服务获取布局加载器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li>\n<li><p>2、通过activity中的getLayoutInflater()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; getLayoutInflater();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3、通过LayoutInflater的from静态方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; LayoutInflater.from(this)</span><br></pre></td></tr></table></figure>\n\n<p><strong>这三种方式本质都是调用Context.getSystemService()</strong></p>\n<h2 id=\"使用inflate方法加载布局\"><a href=\"#使用inflate方法加载布局\" class=\"headerlink\" title=\"使用inflate方法加载布局\"></a>使用inflate方法加载布局</h2><p>LayoutInflater提供四种加载布局的方法</p>\n<ul>\n<li>public View inflate (int resource, ViewGroup root)</li>\n<li>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)</li>\n</ul>\n<p><strong>ViewGroup root：指实例的布局所要放入的根视图</strong><br><strong>boolean attachToToot：指是否附加到传入的根视图</strong></p>\n<p>1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。<br>2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。<br>3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。</p>\n<p><strong>即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View</strong></p>\n<h3 id=\"示例：将button布局添加到LinearLayout上\"><a href=\"#示例：将button布局添加到LinearLayout上\" class=\"headerlink\" title=\"示例：将button布局添加到LinearLayout上\"></a>示例：将button布局添加到LinearLayout上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button xmlns:android&#x3D;”http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\"> android:layout_width&#x3D;”match_parent”</span><br><span class=\"line\"> android:layout_height&#x3D;”wrap_content”</span><br><span class=\"line\"> android:text&#x3D;”@string&#x2F;action_attach_to_root_true”</span><br><span class=\"line\"> android:id&#x3D;”@+id&#x2F;button_ok”&gt;</span><br><span class=\"line\">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>\n<p>Button的layout params类型是LinearLayout.LayoutParams</p>\n<p><strong>将attachRoot设置为true</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.view_button, mLinearLayout, true);</span><br></pre></td></tr></table></figure>\n<p><strong>将attachRoot设置为false</strong><br>当attachRoot设置为false后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button btn &#x3D; (Button)inflater.inflate</span><br><span class=\"line\">                (R.layout.view_button,parent,false);</span><br><span class=\"line\">parent.addView(btn);</span><br></pre></td></tr></table></figure>\n\n<p>同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    </p>\n<p><strong>在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。</p>\n<ul>\n<li><p>LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。</p>\n</li>\n<li><p>findViewById用于已载入的界面，使用findViewById来获取其中的界面元素</p>\n</li>\n</ul>\n<h2 id=\"获取LayoutInflater实例的方法\"><a href=\"#获取LayoutInflater实例的方法\" class=\"headerlink\" title=\"获取LayoutInflater实例的方法\"></a>获取LayoutInflater实例的方法</h2><ul>\n<li><p>1、通过系统服务获取布局加载器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li>\n<li><p>2、通过activity中的getLayoutInflater()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; getLayoutInflater();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3、通过LayoutInflater的from静态方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; LayoutInflater.from(this)</span><br></pre></td></tr></table></figure>\n\n<p><strong>这三种方式本质都是调用Context.getSystemService()</strong></p>\n<h2 id=\"使用inflate方法加载布局\"><a href=\"#使用inflate方法加载布局\" class=\"headerlink\" title=\"使用inflate方法加载布局\"></a>使用inflate方法加载布局</h2><p>LayoutInflater提供四种加载布局的方法</p>\n<ul>\n<li>public View inflate (int resource, ViewGroup root)</li>\n<li>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)</li>\n</ul>\n<p><strong>ViewGroup root：指实例的布局所要放入的根视图</strong><br><strong>boolean attachToToot：指是否附加到传入的根视图</strong></p>\n<p>1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。<br>2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。<br>3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。</p>\n<p><strong>即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View</strong></p>\n<h3 id=\"示例：将button布局添加到LinearLayout上\"><a href=\"#示例：将button布局添加到LinearLayout上\" class=\"headerlink\" title=\"示例：将button布局添加到LinearLayout上\"></a>示例：将button布局添加到LinearLayout上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button xmlns:android&#x3D;”http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\"> android:layout_width&#x3D;”match_parent”</span><br><span class=\"line\"> android:layout_height&#x3D;”wrap_content”</span><br><span class=\"line\"> android:text&#x3D;”@string&#x2F;action_attach_to_root_true”</span><br><span class=\"line\"> android:id&#x3D;”@+id&#x2F;button_ok”&gt;</span><br><span class=\"line\">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>\n<p>Button的layout params类型是LinearLayout.LayoutParams</p>\n<p><strong>将attachRoot设置为true</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.view_button, mLinearLayout, true);</span><br></pre></td></tr></table></figure>\n<p><strong>将attachRoot设置为false</strong><br>当attachRoot设置为false后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button btn &#x3D; (Button)inflater.inflate</span><br><span class=\"line\">                (R.layout.view_button,parent,false);</span><br><span class=\"line\">parent.addView(btn);</span><br></pre></td></tr></table></figure>\n\n<p>同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    </p>\n<p><strong>在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可</strong></p>\n"},{"_content":"# 使用SearchView以及RecyclerView实现条目删选\n\n\\#\\# 使用SearchView以及RecyclerView实现条目删选\n\n## SearchView介绍\n\nSearchView继承图 ![SearchView&#x7EE7;&#x627F;&#x56FE;](https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表\n\n## RecyclerView介绍\n\nRecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。\n\n## 代码实现\n\n### 搜索框的添加\n\n1、在res/menu文件夹下添加menu\\_main，即MainActivity的菜单栏\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_search\"\n        android:icon=\"@android:drawable/ic_menu_search\"\n        android:title=\"@string/action_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always|collapseActionView\" />\n\n</menu>\n```\n\n2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件\n\n注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView\n\n```text\n java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView\n```\n\nMainActivity中的代码\n\n```java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.menu_main,menu);\n        MenuItem menuItem=menu.findItem(R.id.action_search);\n        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);\n        searchView.setOnQueryTextListener(this);\n        return true;\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        return false;\n    }\n}\n```\n\n显示效果如图所示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### RecylerViewAdapter编写\n\n1、在build.gradle\\(Module:app\\)中添加依赖\n\n```text\ndependencies {\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n}\n```\n\n2、RecyclerView列表中每一个item布局文件item\\_recyclerview的编写\n\n```markup\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <android.support.v7.widget.CardView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:cardCornerRadius=\"5dp\">\n\n        <TextView\n            android:id=\"@+id/word_tv\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:layout_gravity=\"center\"\n            android:text=\"word\"\n            android:textSize=\"25sp\" />\n    </android.support.v7.widget.CardView>\n</LinearLayout>\n```\n\n3、RecylerViewAdapter编写\n\n```text\npublic class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder>{\n\n    private List<String>strings;\n\n    public RecyclerViewAdapter(List<String>strings) {\n        this.strings=strings;\n    }\n\n\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);\n        ViewHolder viewHolder=new ViewHolder(view);\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        ((ViewHolder)holder).words.setText(strings.get(position));\n    }\n\n    @Override\n    public int getItemCount() {\n        return strings.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder{\n\n        TextView words;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            words=(TextView)itemView.findViewById(R.id.word_tv);\n        }\n    }\n\n}\n```\n\n### 在MainActivity中添加RecyclerView布局\n\n1、在布局文件activity\\_main中添加RecyclerView布局\n\n```text\n<android.support.v7.widget.RecyclerView\n    android:id=\"@+id/main_recyclerview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n</android.support.v7.widget.RecyclerView>\n```\n\n2、在MainActivity中为RecyclerView添加适配器\n\n```text\n    //省略部分代码\n\n    private RecyclerView recyclerView;\n    private RecyclerViewAdapter recyclerViewAdapter;\n\n    private List<String>words;\n\n    private RecyclerView.LayoutManager layoutManager;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        recyclerView=findViewById(R.id.main_recyclerview);\n        layoutManager=new LinearLayoutManager(MainActivity.this);\n        words=new ArrayList<>();\n        words.add(\"abc\");\n        words.add(\"abc\");\n        words.add(\"abc\");\n        recyclerViewAdapter=new RecyclerViewAdapter(words);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setAdapter(recyclerViewAdapter);\n\n    }\n```\n\n结果显示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### 在MainActivity中添加筛选方法\n\n```text\n    private List<String>filter(List<String>strings,String text){\n        filterString=new ArrayList<>();\n\n        for (String word:words){\n            if (word.contains(text))\n                filterString.add(word);\n        }\n        return filterString;\n    }\n```\n\n### 在RecyclerViewAdapter中设置筛选后的单词的显示\n\n```text\n   //省略部分代码\n public void setFilter(List<String>filterWords){\n        words=filterWords;\n        notifyDataSetChanged();\n    }\n```\n\n### 当检测到SearchView中输入变化时进行单词筛选\n\n```text\n    @Override\n    public boolean onQueryTextChange(String newText) {\n\n        filterString=filter(words,newText);\n        recyclerViewAdapter.setFilter(filterString);\n        return true;\n    }\n```\n\n## 运行结果\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n[源码地址](https://download.csdn.net/download/qq_36422743/10468538%20源码地址)\n\n","source":"_posts/Android/View/使用RecyclerView和SearchView实现查找删除.md","raw":"# 使用SearchView以及RecyclerView实现条目删选\n\n\\#\\# 使用SearchView以及RecyclerView实现条目删选\n\n## SearchView介绍\n\nSearchView继承图 ![SearchView&#x7EE7;&#x627F;&#x56FE;](https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表\n\n## RecyclerView介绍\n\nRecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。\n\n## 代码实现\n\n### 搜索框的添加\n\n1、在res/menu文件夹下添加menu\\_main，即MainActivity的菜单栏\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_search\"\n        android:icon=\"@android:drawable/ic_menu_search\"\n        android:title=\"@string/action_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always|collapseActionView\" />\n\n</menu>\n```\n\n2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件\n\n注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView\n\n```text\n java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView\n```\n\nMainActivity中的代码\n\n```java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.menu_main,menu);\n        MenuItem menuItem=menu.findItem(R.id.action_search);\n        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);\n        searchView.setOnQueryTextListener(this);\n        return true;\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        return false;\n    }\n}\n```\n\n显示效果如图所示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### RecylerViewAdapter编写\n\n1、在build.gradle\\(Module:app\\)中添加依赖\n\n```text\ndependencies {\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n}\n```\n\n2、RecyclerView列表中每一个item布局文件item\\_recyclerview的编写\n\n```markup\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <android.support.v7.widget.CardView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:cardCornerRadius=\"5dp\">\n\n        <TextView\n            android:id=\"@+id/word_tv\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:layout_gravity=\"center\"\n            android:text=\"word\"\n            android:textSize=\"25sp\" />\n    </android.support.v7.widget.CardView>\n</LinearLayout>\n```\n\n3、RecylerViewAdapter编写\n\n```text\npublic class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder>{\n\n    private List<String>strings;\n\n    public RecyclerViewAdapter(List<String>strings) {\n        this.strings=strings;\n    }\n\n\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);\n        ViewHolder viewHolder=new ViewHolder(view);\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        ((ViewHolder)holder).words.setText(strings.get(position));\n    }\n\n    @Override\n    public int getItemCount() {\n        return strings.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder{\n\n        TextView words;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            words=(TextView)itemView.findViewById(R.id.word_tv);\n        }\n    }\n\n}\n```\n\n### 在MainActivity中添加RecyclerView布局\n\n1、在布局文件activity\\_main中添加RecyclerView布局\n\n```text\n<android.support.v7.widget.RecyclerView\n    android:id=\"@+id/main_recyclerview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n</android.support.v7.widget.RecyclerView>\n```\n\n2、在MainActivity中为RecyclerView添加适配器\n\n```text\n    //省略部分代码\n\n    private RecyclerView recyclerView;\n    private RecyclerViewAdapter recyclerViewAdapter;\n\n    private List<String>words;\n\n    private RecyclerView.LayoutManager layoutManager;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        recyclerView=findViewById(R.id.main_recyclerview);\n        layoutManager=new LinearLayoutManager(MainActivity.this);\n        words=new ArrayList<>();\n        words.add(\"abc\");\n        words.add(\"abc\");\n        words.add(\"abc\");\n        recyclerViewAdapter=new RecyclerViewAdapter(words);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setAdapter(recyclerViewAdapter);\n\n    }\n```\n\n结果显示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### 在MainActivity中添加筛选方法\n\n```text\n    private List<String>filter(List<String>strings,String text){\n        filterString=new ArrayList<>();\n\n        for (String word:words){\n            if (word.contains(text))\n                filterString.add(word);\n        }\n        return filterString;\n    }\n```\n\n### 在RecyclerViewAdapter中设置筛选后的单词的显示\n\n```text\n   //省略部分代码\n public void setFilter(List<String>filterWords){\n        words=filterWords;\n        notifyDataSetChanged();\n    }\n```\n\n### 当检测到SearchView中输入变化时进行单词筛选\n\n```text\n    @Override\n    public boolean onQueryTextChange(String newText) {\n\n        filterString=filter(words,newText);\n        recyclerViewAdapter.setFilter(filterString);\n        return true;\n    }\n```\n\n## 运行结果\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n[源码地址](https://download.csdn.net/download/qq_36422743/10468538%20源码地址)\n\n","slug":"Android/View/使用RecyclerView和SearchView实现查找删除","published":1,"date":"2019-09-19T09:41:14.746Z","updated":"2019-09-19T09:41:14.746Z","title":"Android/View/使用RecyclerView和SearchView实现查找删除","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0e0016kguig3tabfw5","content":"<h1 id=\"使用SearchView以及RecyclerView实现条目删选\"><a href=\"#使用SearchView以及RecyclerView实现条目删选\" class=\"headerlink\" title=\"使用SearchView以及RecyclerView实现条目删选\"></a>使用SearchView以及RecyclerView实现条目删选</h1><p>## 使用SearchView以及RecyclerView实现条目删选</p>\n<h2 id=\"SearchView介绍\"><a href=\"#SearchView介绍\" class=\"headerlink\" title=\"SearchView介绍\"></a>SearchView介绍</h2><p>SearchView继承图 <img src=\"https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"SearchView&#x7EE7;&#x627F;&#x56FE;\"> SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表</p>\n<h2 id=\"RecyclerView介绍\"><a href=\"#RecyclerView介绍\" class=\"headerlink\" title=\"RecyclerView介绍\"></a>RecyclerView介绍</h2><p>RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"搜索框的添加\"><a href=\"#搜索框的添加\" class=\"headerlink\" title=\"搜索框的添加\"></a>搜索框的添加</h3><p>1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id&#x3D;&quot;@+id&#x2F;action_search&quot;</span><br><span class=\"line\">        android:icon&#x3D;&quot;@android:drawable&#x2F;ic_menu_search&quot;</span><br><span class=\"line\">        android:title&#x3D;&quot;@string&#x2F;action_search&quot;</span><br><span class=\"line\">        app:actionViewClass&#x3D;&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction&#x3D;&quot;always|collapseActionView&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件</p>\n<p>注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView</span><br></pre></td></tr></table></figure>\n\n<p>MainActivity中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SearchView</span>.<span class=\"title\">OnQueryTextListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        getMenuInflater().inflate(R.menu.menu_main,menu);</span><br><span class=\"line\">        MenuItem menuItem=menu.findItem(R.id.action_search);</span><br><span class=\"line\">        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);</span><br><span class=\"line\">        searchView.setOnQueryTextListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextSubmit</span><span class=\"params\">(String query)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextChange</span><span class=\"params\">(String newText)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如图所示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"RecylerViewAdapter编写\"><a href=\"#RecylerViewAdapter编写\" class=\"headerlink\" title=\"RecylerViewAdapter编写\"></a>RecylerViewAdapter编写</h3><p>1、在build.gradle(Module:app)中添加依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、RecyclerView列表中每一个item布局文件item_recyclerview的编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v7.widget.CardView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class=\"line\">        app:cardCornerRadius&#x3D;&quot;5dp&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:id&#x3D;&quot;@+id&#x2F;word_tv&quot;</span><br><span class=\"line\">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">            android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:text&#x3D;&quot;word&quot;</span><br><span class=\"line\">            android:textSize&#x3D;&quot;25sp&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3、RecylerViewAdapter编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt;strings;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RecyclerViewAdapter(List&lt;String&gt;strings) &#123;</span><br><span class=\"line\">        this.strings&#x3D;strings;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">        View view &#x3D; LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);</span><br><span class=\"line\">        ViewHolder viewHolder&#x3D;new ViewHolder(view);</span><br><span class=\"line\">        return viewHolder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;</span><br><span class=\"line\">        ((ViewHolder)holder).words.setText(strings.get(position));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemCount() &#123;</span><br><span class=\"line\">        return strings.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        TextView words;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ViewHolder(View itemView) &#123;</span><br><span class=\"line\">            super(itemView);</span><br><span class=\"line\">            words&#x3D;(TextView)itemView.findViewById(R.id.word_tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在MainActivity中添加RecyclerView布局\"><a href=\"#在MainActivity中添加RecyclerView布局\" class=\"headerlink\" title=\"在MainActivity中添加RecyclerView布局\"></a>在MainActivity中添加RecyclerView布局</h3><p>1、在布局文件activity_main中添加RecyclerView布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;main_recyclerview&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;android.support.v7.widget.RecyclerView&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中为RecyclerView添加适配器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;省略部分代码</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView recyclerView;</span><br><span class=\"line\">private RecyclerViewAdapter recyclerViewAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">private List&lt;String&gt;words;</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView.LayoutManager layoutManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    recyclerView&#x3D;findViewById(R.id.main_recyclerview);</span><br><span class=\"line\">    layoutManager&#x3D;new LinearLayoutManager(MainActivity.this);</span><br><span class=\"line\">    words&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    recyclerViewAdapter&#x3D;new RecyclerViewAdapter(words);</span><br><span class=\"line\">    recyclerView.setLayoutManager(layoutManager);</span><br><span class=\"line\">    recyclerView.setAdapter(recyclerViewAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果显示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"在MainActivity中添加筛选方法\"><a href=\"#在MainActivity中添加筛选方法\" class=\"headerlink\" title=\"在MainActivity中添加筛选方法\"></a>在MainActivity中添加筛选方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;String&gt;filter(List&lt;String&gt;strings,String text)&#123;</span><br><span class=\"line\">    filterString&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (String word:words)&#123;</span><br><span class=\"line\">        if (word.contains(text))</span><br><span class=\"line\">            filterString.add(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return filterString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"><a href=\"#在RecyclerViewAdapter中设置筛选后的单词的显示\" class=\"headerlink\" title=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"></a>在RecyclerViewAdapter中设置筛选后的单词的显示</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &#x2F;&#x2F;省略部分代码</span><br><span class=\"line\">public void setFilter(List&lt;String&gt;filterWords)&#123;</span><br><span class=\"line\">       words&#x3D;filterWords;</span><br><span class=\"line\">       notifyDataSetChanged();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"当检测到SearchView中输入变化时进行单词筛选\"><a href=\"#当检测到SearchView中输入变化时进行单词筛选\" class=\"headerlink\" title=\"当检测到SearchView中输入变化时进行单词筛选\"></a>当检测到SearchView中输入变化时进行单词筛选</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onQueryTextChange(String newText) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    filterString&#x3D;filter(words,newText);</span><br><span class=\"line\">    recyclerViewAdapter.setFilter(filterString);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<p><a href=\"https://download.csdn.net/download/qq_36422743/10468538%20源码地址\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用SearchView以及RecyclerView实现条目删选\"><a href=\"#使用SearchView以及RecyclerView实现条目删选\" class=\"headerlink\" title=\"使用SearchView以及RecyclerView实现条目删选\"></a>使用SearchView以及RecyclerView实现条目删选</h1><p>## 使用SearchView以及RecyclerView实现条目删选</p>\n<h2 id=\"SearchView介绍\"><a href=\"#SearchView介绍\" class=\"headerlink\" title=\"SearchView介绍\"></a>SearchView介绍</h2><p>SearchView继承图 <img src=\"https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"SearchView&#x7EE7;&#x627F;&#x56FE;\"> SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表</p>\n<h2 id=\"RecyclerView介绍\"><a href=\"#RecyclerView介绍\" class=\"headerlink\" title=\"RecyclerView介绍\"></a>RecyclerView介绍</h2><p>RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"搜索框的添加\"><a href=\"#搜索框的添加\" class=\"headerlink\" title=\"搜索框的添加\"></a>搜索框的添加</h3><p>1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id&#x3D;&quot;@+id&#x2F;action_search&quot;</span><br><span class=\"line\">        android:icon&#x3D;&quot;@android:drawable&#x2F;ic_menu_search&quot;</span><br><span class=\"line\">        android:title&#x3D;&quot;@string&#x2F;action_search&quot;</span><br><span class=\"line\">        app:actionViewClass&#x3D;&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction&#x3D;&quot;always|collapseActionView&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件</p>\n<p>注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView</span><br></pre></td></tr></table></figure>\n\n<p>MainActivity中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SearchView</span>.<span class=\"title\">OnQueryTextListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        getMenuInflater().inflate(R.menu.menu_main,menu);</span><br><span class=\"line\">        MenuItem menuItem=menu.findItem(R.id.action_search);</span><br><span class=\"line\">        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);</span><br><span class=\"line\">        searchView.setOnQueryTextListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextSubmit</span><span class=\"params\">(String query)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextChange</span><span class=\"params\">(String newText)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如图所示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"RecylerViewAdapter编写\"><a href=\"#RecylerViewAdapter编写\" class=\"headerlink\" title=\"RecylerViewAdapter编写\"></a>RecylerViewAdapter编写</h3><p>1、在build.gradle(Module:app)中添加依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、RecyclerView列表中每一个item布局文件item_recyclerview的编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v7.widget.CardView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class=\"line\">        app:cardCornerRadius&#x3D;&quot;5dp&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:id&#x3D;&quot;@+id&#x2F;word_tv&quot;</span><br><span class=\"line\">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">            android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:text&#x3D;&quot;word&quot;</span><br><span class=\"line\">            android:textSize&#x3D;&quot;25sp&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3、RecylerViewAdapter编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt;strings;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RecyclerViewAdapter(List&lt;String&gt;strings) &#123;</span><br><span class=\"line\">        this.strings&#x3D;strings;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">        View view &#x3D; LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);</span><br><span class=\"line\">        ViewHolder viewHolder&#x3D;new ViewHolder(view);</span><br><span class=\"line\">        return viewHolder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;</span><br><span class=\"line\">        ((ViewHolder)holder).words.setText(strings.get(position));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemCount() &#123;</span><br><span class=\"line\">        return strings.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        TextView words;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ViewHolder(View itemView) &#123;</span><br><span class=\"line\">            super(itemView);</span><br><span class=\"line\">            words&#x3D;(TextView)itemView.findViewById(R.id.word_tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在MainActivity中添加RecyclerView布局\"><a href=\"#在MainActivity中添加RecyclerView布局\" class=\"headerlink\" title=\"在MainActivity中添加RecyclerView布局\"></a>在MainActivity中添加RecyclerView布局</h3><p>1、在布局文件activity_main中添加RecyclerView布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;main_recyclerview&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;android.support.v7.widget.RecyclerView&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2、在MainActivity中为RecyclerView添加适配器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;省略部分代码</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView recyclerView;</span><br><span class=\"line\">private RecyclerViewAdapter recyclerViewAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">private List&lt;String&gt;words;</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView.LayoutManager layoutManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    recyclerView&#x3D;findViewById(R.id.main_recyclerview);</span><br><span class=\"line\">    layoutManager&#x3D;new LinearLayoutManager(MainActivity.this);</span><br><span class=\"line\">    words&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    recyclerViewAdapter&#x3D;new RecyclerViewAdapter(words);</span><br><span class=\"line\">    recyclerView.setLayoutManager(layoutManager);</span><br><span class=\"line\">    recyclerView.setAdapter(recyclerViewAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果显示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"在MainActivity中添加筛选方法\"><a href=\"#在MainActivity中添加筛选方法\" class=\"headerlink\" title=\"在MainActivity中添加筛选方法\"></a>在MainActivity中添加筛选方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;String&gt;filter(List&lt;String&gt;strings,String text)&#123;</span><br><span class=\"line\">    filterString&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (String word:words)&#123;</span><br><span class=\"line\">        if (word.contains(text))</span><br><span class=\"line\">            filterString.add(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return filterString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"><a href=\"#在RecyclerViewAdapter中设置筛选后的单词的显示\" class=\"headerlink\" title=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"></a>在RecyclerViewAdapter中设置筛选后的单词的显示</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &#x2F;&#x2F;省略部分代码</span><br><span class=\"line\">public void setFilter(List&lt;String&gt;filterWords)&#123;</span><br><span class=\"line\">       words&#x3D;filterWords;</span><br><span class=\"line\">       notifyDataSetChanged();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"当检测到SearchView中输入变化时进行单词筛选\"><a href=\"#当检测到SearchView中输入变化时进行单词筛选\" class=\"headerlink\" title=\"当检测到SearchView中输入变化时进行单词筛选\"></a>当检测到SearchView中输入变化时进行单词筛选</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onQueryTextChange(String newText) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    filterString&#x3D;filter(words,newText);</span><br><span class=\"line\">    recyclerViewAdapter.setFilter(filterString);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\\">https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<p><a href=\"https://download.csdn.net/download/qq_36422743/10468538%20源码地址\">源码地址</a></p>\n"},{"_content":"# 在Android中使用Dagger2\n\n## Dagger2介绍\n\n### 为什么我们需要注解依赖注入？\n\nDependency Injection\\(注解依赖\\)是在IOC\\(Inversion of cnontrol\\)的基础上实现的，为了将类的实例的实现与类进行分离。\n\n如果一个类使用`new`操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。\n\n### 注入模式\n\n* 构造函数注入：以传递参数的方式\n* 字段注入：以变量的方式\n* 方法注入：\n\n“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”\n\n* Dependency provider:使用注解`@Module`表示的类，用于提供可以进行注入的对象。类中的方法使用注解`@Providers`表示该方法的返回对象可以被依赖注入。`@Moudle`可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用`@Inject`即可\n* Dependency consumer：注解`@Inject`用于定义一个依赖。\n* Connection consumer and producer：使用注解`@Component`的接口定义module对象中`provider`与依赖对象之间的连接，接口的实现类由Dagger自动生成。\n\n## Dagger2的局限性\n\n* Dagger2不能自动注入域\n* Dagger2不能注入private类型\n* Dagger2\n\n## 工程结构图\n\n假装有图\n\n","source":"_posts/Android/框架/Dagger2.md","raw":"# 在Android中使用Dagger2\n\n## Dagger2介绍\n\n### 为什么我们需要注解依赖注入？\n\nDependency Injection\\(注解依赖\\)是在IOC\\(Inversion of cnontrol\\)的基础上实现的，为了将类的实例的实现与类进行分离。\n\n如果一个类使用`new`操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。\n\n### 注入模式\n\n* 构造函数注入：以传递参数的方式\n* 字段注入：以变量的方式\n* 方法注入：\n\n“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”\n\n* Dependency provider:使用注解`@Module`表示的类，用于提供可以进行注入的对象。类中的方法使用注解`@Providers`表示该方法的返回对象可以被依赖注入。`@Moudle`可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用`@Inject`即可\n* Dependency consumer：注解`@Inject`用于定义一个依赖。\n* Connection consumer and producer：使用注解`@Component`的接口定义module对象中`provider`与依赖对象之间的连接，接口的实现类由Dagger自动生成。\n\n## Dagger2的局限性\n\n* Dagger2不能自动注入域\n* Dagger2不能注入private类型\n* Dagger2\n\n## 工程结构图\n\n假装有图\n\n","slug":"Android/框架/Dagger2","published":1,"date":"2019-09-19T09:34:08.488Z","updated":"2020-02-26T06:12:59.620Z","title":"Android/框架/Dagger2","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0g0018kgui1aen9twx","content":"<h1 id=\"在Android中使用Dagger2\"><a href=\"#在Android中使用Dagger2\" class=\"headerlink\" title=\"在Android中使用Dagger2\"></a>在Android中使用Dagger2</h1><h2 id=\"Dagger2介绍\"><a href=\"#Dagger2介绍\" class=\"headerlink\" title=\"Dagger2介绍\"></a>Dagger2介绍</h2><h3 id=\"为什么我们需要注解依赖注入？\"><a href=\"#为什么我们需要注解依赖注入？\" class=\"headerlink\" title=\"为什么我们需要注解依赖注入？\"></a>为什么我们需要注解依赖注入？</h3><p>Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。</p>\n<p>如果一个类使用<code>new</code>操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。</p>\n<h3 id=\"注入模式\"><a href=\"#注入模式\" class=\"headerlink\" title=\"注入模式\"></a>注入模式</h3><ul>\n<li>构造函数注入：以传递参数的方式</li>\n<li>字段注入：以变量的方式</li>\n<li>方法注入：</li>\n</ul>\n<p>“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”</p>\n<ul>\n<li>Dependency provider:使用注解<code>@Module</code>表示的类，用于提供可以进行注入的对象。类中的方法使用注解<code>@Providers</code>表示该方法的返回对象可以被依赖注入。<code>@Moudle</code>可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用<code>@Inject</code>即可</li>\n<li>Dependency consumer：注解<code>@Inject</code>用于定义一个依赖。</li>\n<li>Connection consumer and producer：使用注解<code>@Component</code>的接口定义module对象中<code>provider</code>与依赖对象之间的连接，接口的实现类由Dagger自动生成。</li>\n</ul>\n<h2 id=\"Dagger2的局限性\"><a href=\"#Dagger2的局限性\" class=\"headerlink\" title=\"Dagger2的局限性\"></a>Dagger2的局限性</h2><ul>\n<li>Dagger2不能自动注入域</li>\n<li>Dagger2不能注入private类型</li>\n<li>Dagger2</li>\n</ul>\n<h2 id=\"工程结构图\"><a href=\"#工程结构图\" class=\"headerlink\" title=\"工程结构图\"></a>工程结构图</h2><p>假装有图</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在Android中使用Dagger2\"><a href=\"#在Android中使用Dagger2\" class=\"headerlink\" title=\"在Android中使用Dagger2\"></a>在Android中使用Dagger2</h1><h2 id=\"Dagger2介绍\"><a href=\"#Dagger2介绍\" class=\"headerlink\" title=\"Dagger2介绍\"></a>Dagger2介绍</h2><h3 id=\"为什么我们需要注解依赖注入？\"><a href=\"#为什么我们需要注解依赖注入？\" class=\"headerlink\" title=\"为什么我们需要注解依赖注入？\"></a>为什么我们需要注解依赖注入？</h3><p>Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。</p>\n<p>如果一个类使用<code>new</code>操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。</p>\n<h3 id=\"注入模式\"><a href=\"#注入模式\" class=\"headerlink\" title=\"注入模式\"></a>注入模式</h3><ul>\n<li>构造函数注入：以传递参数的方式</li>\n<li>字段注入：以变量的方式</li>\n<li>方法注入：</li>\n</ul>\n<p>“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”</p>\n<ul>\n<li>Dependency provider:使用注解<code>@Module</code>表示的类，用于提供可以进行注入的对象。类中的方法使用注解<code>@Providers</code>表示该方法的返回对象可以被依赖注入。<code>@Moudle</code>可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用<code>@Inject</code>即可</li>\n<li>Dependency consumer：注解<code>@Inject</code>用于定义一个依赖。</li>\n<li>Connection consumer and producer：使用注解<code>@Component</code>的接口定义module对象中<code>provider</code>与依赖对象之间的连接，接口的实现类由Dagger自动生成。</li>\n</ul>\n<h2 id=\"Dagger2的局限性\"><a href=\"#Dagger2的局限性\" class=\"headerlink\" title=\"Dagger2的局限性\"></a>Dagger2的局限性</h2><ul>\n<li>Dagger2不能自动注入域</li>\n<li>Dagger2不能注入private类型</li>\n<li>Dagger2</li>\n</ul>\n<h2 id=\"工程结构图\"><a href=\"#工程结构图\" class=\"headerlink\" title=\"工程结构图\"></a>工程结构图</h2><p>假装有图</p>\n"},{"_content":"\n\n#### JSONString与HashMap之间的转换\n\n* HashMap转换为JsonString\n\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    String JSONString=JSON.toJSONString(hashMap);\n```\n\n\n* JsonString转换为HashMap\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap= JSON.parseObject(JSONString, Map.class);\n    \n    //错误方式\n    hashMap= (Map<String, String>) JSON.parse(JSONString);\n```\n\n**注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**\n\n\n#### 知识点\n\n* 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败\n","source":"_posts/Android/框架/fastjson的使用.md","raw":"\n\n#### JSONString与HashMap之间的转换\n\n* HashMap转换为JsonString\n\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    String JSONString=JSON.toJSONString(hashMap);\n```\n\n\n* JsonString转换为HashMap\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap= JSON.parseObject(JSONString, Map.class);\n    \n    //错误方式\n    hashMap= (Map<String, String>) JSON.parse(JSONString);\n```\n\n**注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**\n\n\n#### 知识点\n\n* 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败\n","slug":"Android/框架/fastjson的使用","published":1,"date":"2019-09-27T08:23:54.030Z","updated":"2019-11-30T11:14:32.191Z","title":"Android/框架/fastjson的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0g0019kguigake2wk2","content":"<h4 id=\"JSONString与HashMap之间的转换\"><a href=\"#JSONString与HashMap之间的转换\" class=\"headerlink\" title=\"JSONString与HashMap之间的转换\"></a>JSONString与HashMap之间的转换</h4><ul>\n<li>HashMap转换为JsonString</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String JSONString=JSON.toJSONString(hashMap);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>JsonString转换为HashMap<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap= JSON.parseObject(JSONString, Map<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误方式</span></span><br><span class=\"line\">hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据</strong></p>\n<h4 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h4><ul>\n<li>在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JSONString与HashMap之间的转换\"><a href=\"#JSONString与HashMap之间的转换\" class=\"headerlink\" title=\"JSONString与HashMap之间的转换\"></a>JSONString与HashMap之间的转换</h4><ul>\n<li>HashMap转换为JsonString</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String JSONString=JSON.toJSONString(hashMap);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>JsonString转换为HashMap<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap= JSON.parseObject(JSONString, Map<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误方式</span></span><br><span class=\"line\">hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据</strong></p>\n<h4 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h4><ul>\n<li>在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败</li>\n</ul>\n"},{"_content":"## Java关键字介绍\n\n### static\n\n### volatile\n\n\n\n\n### final\nfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；\n\n#### 在数据中使用final\n一个数据不可改变有两种原因：\n* 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。\n* 在运行时赋初值后不可改变；\n\n当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。\n\n\n#### 在方法中使用final\n final作为方法参数使用时，表示该引用不能被修改；\n \n final直接修饰方法时，有两个原因\n * 防止子类修改该方法，避免该方法被重写(overridden)\n * 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）\n \n\n\n#### 在类中使用final\n\n禁止该类被继承\n\n### transient\n\n### long关键字\n\n在Java开发过程中，如果需要long类型的变量，需要在变量后加`l`\n\n```\n     long a=1000000000000l;\n     //long b=1000000000000;        //会报出Integer number too large\n     //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large\n     //long b1=100*1000*1000*1000;  //b1会输出一个奇怪的值 1215752192\n     //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围\n     //long b1=(long)(100*1000*1000*1000);;  //使用功强制类型转换，b1会输出一个奇怪的值 1215752192\n     long b1=100l*1000l*1000l*1000l;   //正确写法\n     //long b1=100*1000*1000l*1000l;     //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果\n   \n\n```","source":"_posts/Java/Java基础/Java关键字.md","raw":"## Java关键字介绍\n\n### static\n\n### volatile\n\n\n\n\n### final\nfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；\n\n#### 在数据中使用final\n一个数据不可改变有两种原因：\n* 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。\n* 在运行时赋初值后不可改变；\n\n当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。\n\n\n#### 在方法中使用final\n final作为方法参数使用时，表示该引用不能被修改；\n \n final直接修饰方法时，有两个原因\n * 防止子类修改该方法，避免该方法被重写(overridden)\n * 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）\n \n\n\n#### 在类中使用final\n\n禁止该类被继承\n\n### transient\n\n### long关键字\n\n在Java开发过程中，如果需要long类型的变量，需要在变量后加`l`\n\n```\n     long a=1000000000000l;\n     //long b=1000000000000;        //会报出Integer number too large\n     //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large\n     //long b1=100*1000*1000*1000;  //b1会输出一个奇怪的值 1215752192\n     //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围\n     //long b1=(long)(100*1000*1000*1000);;  //使用功强制类型转换，b1会输出一个奇怪的值 1215752192\n     long b1=100l*1000l*1000l*1000l;   //正确写法\n     //long b1=100*1000*1000l*1000l;     //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果\n   \n\n```","slug":"Java/Java基础/Java关键字","published":1,"date":"2019-09-19T09:41:14.769Z","updated":"2019-11-30T11:14:32.244Z","title":"Java/Java基础/Java关键字","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0i001akgui8n7m7myr","content":"<h2 id=\"Java关键字介绍\"><a href=\"#Java关键字介绍\" class=\"headerlink\" title=\"Java关键字介绍\"></a>Java关键字介绍</h2><h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；</p>\n<h4 id=\"在数据中使用final\"><a href=\"#在数据中使用final\" class=\"headerlink\" title=\"在数据中使用final\"></a>在数据中使用final</h4><p>一个数据不可改变有两种原因：</p>\n<ul>\n<li>在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。</li>\n<li>在运行时赋初值后不可改变；</li>\n</ul>\n<p>当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。</p>\n<h4 id=\"在方法中使用final\"><a href=\"#在方法中使用final\" class=\"headerlink\" title=\"在方法中使用final\"></a>在方法中使用final</h4><p> final作为方法参数使用时，表示该引用不能被修改；</p>\n<p> final直接修饰方法时，有两个原因</p>\n<ul>\n<li>防止子类修改该方法，避免该方法被重写(overridden)</li>\n<li>在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）</li>\n</ul>\n<h4 id=\"在类中使用final\"><a href=\"#在类中使用final\" class=\"headerlink\" title=\"在类中使用final\"></a>在类中使用final</h4><p>禁止该类被继承</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><h3 id=\"long关键字\"><a href=\"#long关键字\" class=\"headerlink\" title=\"long关键字\"></a>long关键字</h3><p>在Java开发过程中，如果需要long类型的变量，需要在变量后加<code>l</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a&#x3D;1000000000000l;</span><br><span class=\"line\">&#x2F;&#x2F;long b&#x3D;1000000000000;        &#x2F;&#x2F;会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b &#x3D; (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000*1000;  &#x2F;&#x2F;b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">&#x2F;&#x2F;这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;(long)(100*1000*1000*1000);;  &#x2F;&#x2F;使用功强制类型转换，b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">long b1&#x3D;100l*1000l*1000l*1000l;   &#x2F;&#x2F;正确写法</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000l*1000l;     &#x2F;&#x2F;可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java关键字介绍\"><a href=\"#Java关键字介绍\" class=\"headerlink\" title=\"Java关键字介绍\"></a>Java关键字介绍</h2><h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；</p>\n<h4 id=\"在数据中使用final\"><a href=\"#在数据中使用final\" class=\"headerlink\" title=\"在数据中使用final\"></a>在数据中使用final</h4><p>一个数据不可改变有两种原因：</p>\n<ul>\n<li>在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。</li>\n<li>在运行时赋初值后不可改变；</li>\n</ul>\n<p>当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。</p>\n<h4 id=\"在方法中使用final\"><a href=\"#在方法中使用final\" class=\"headerlink\" title=\"在方法中使用final\"></a>在方法中使用final</h4><p> final作为方法参数使用时，表示该引用不能被修改；</p>\n<p> final直接修饰方法时，有两个原因</p>\n<ul>\n<li>防止子类修改该方法，避免该方法被重写(overridden)</li>\n<li>在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）</li>\n</ul>\n<h4 id=\"在类中使用final\"><a href=\"#在类中使用final\" class=\"headerlink\" title=\"在类中使用final\"></a>在类中使用final</h4><p>禁止该类被继承</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><h3 id=\"long关键字\"><a href=\"#long关键字\" class=\"headerlink\" title=\"long关键字\"></a>long关键字</h3><p>在Java开发过程中，如果需要long类型的变量，需要在变量后加<code>l</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a&#x3D;1000000000000l;</span><br><span class=\"line\">&#x2F;&#x2F;long b&#x3D;1000000000000;        &#x2F;&#x2F;会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b &#x3D; (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000*1000;  &#x2F;&#x2F;b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">&#x2F;&#x2F;这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;(long)(100*1000*1000*1000);;  &#x2F;&#x2F;使用功强制类型转换，b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">long b1&#x3D;100l*1000l*1000l*1000l;   &#x2F;&#x2F;正确写法</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000l*1000l;     &#x2F;&#x2F;可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果</span><br></pre></td></tr></table></figure>"},{"_content":"### java 内部类\n\n内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。\n\n\n### 内部类的作用\n\n实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。\n\n内部类可以同时用多个实例，每个实例都有自己的状态信息；\n\n内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；\n\n\n### 内部类分类\n\n#### 局部内部类\n\n嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。\n\n#### 静态内部类\n\n静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式\n\n \n```java\n    public class Singleton {  \n        private static class SingletonHolder {  \n            private static final Singleton INSTANCE = new Singleton();  \n        }  \n        private Singleton (){}  \n        public static final Singleton getInstance() {  \n            return SingletonHolder.INSTANCE; \n        }  \n    }\n \n```   \n\n#### 匿名内部类\n\n匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型\n\n```java\n\n    new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello\");\n            }\n        }).start();\n\n\n```\n\n\n#### 内部类与闭包\n\n内部类会包含对外部类的引用，形成闭包\n\n```java\n        \n    public class Outer{\n        private int a=1;\n        \n        public class Inner{\n            private int b=2;\n            public int multi(){\n            return a*b;\n        }\n    }\n        \n\n```\n\n\n","source":"_posts/Java/Java基础/Java内部类.md","raw":"### java 内部类\n\n内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。\n\n\n### 内部类的作用\n\n实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。\n\n内部类可以同时用多个实例，每个实例都有自己的状态信息；\n\n内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；\n\n\n### 内部类分类\n\n#### 局部内部类\n\n嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。\n\n#### 静态内部类\n\n静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式\n\n \n```java\n    public class Singleton {  \n        private static class SingletonHolder {  \n            private static final Singleton INSTANCE = new Singleton();  \n        }  \n        private Singleton (){}  \n        public static final Singleton getInstance() {  \n            return SingletonHolder.INSTANCE; \n        }  \n    }\n \n```   \n\n#### 匿名内部类\n\n匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型\n\n```java\n\n    new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello\");\n            }\n        }).start();\n\n\n```\n\n\n#### 内部类与闭包\n\n内部类会包含对外部类的引用，形成闭包\n\n```java\n        \n    public class Outer{\n        private int a=1;\n        \n        public class Inner{\n            private int b=2;\n            public int multi(){\n            return a*b;\n        }\n    }\n        \n\n```\n\n\n","slug":"Java/Java基础/Java内部类","published":1,"date":"2019-11-28T12:18:36.245Z","updated":"2019-11-30T11:14:32.244Z","title":"Java/Java基础/Java内部类","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0j001bkgui8yii775x","content":"<h3 id=\"java-内部类\"><a href=\"#java-内部类\" class=\"headerlink\" title=\"java 内部类\"></a>java 内部类</h3><p>内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。</p>\n<h3 id=\"内部类的作用\"><a href=\"#内部类的作用\" class=\"headerlink\" title=\"内部类的作用\"></a>内部类的作用</h3><p>实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。</p>\n<p>内部类可以同时用多个实例，每个实例都有自己的状态信息；</p>\n<p>内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；</p>\n<h3 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h3><h4 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h4><p>嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">#### 匿名内部类</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为<span class=\"keyword\">final</span>类型</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"内部类与闭包\"><a href=\"#内部类与闭包\" class=\"headerlink\" title=\"内部类与闭包\"></a>内部类与闭包</h4><p>内部类会包含对外部类的引用，形成闭包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"java-内部类\"><a href=\"#java-内部类\" class=\"headerlink\" title=\"java 内部类\"></a>java 内部类</h3><p>内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。</p>\n<h3 id=\"内部类的作用\"><a href=\"#内部类的作用\" class=\"headerlink\" title=\"内部类的作用\"></a>内部类的作用</h3><p>实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。</p>\n<p>内部类可以同时用多个实例，每个实例都有自己的状态信息；</p>\n<p>内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；</p>\n<h3 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h3><h4 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h4><p>嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">#### 匿名内部类</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为<span class=\"keyword\">final</span>类型</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"内部类与闭包\"><a href=\"#内部类与闭包\" class=\"headerlink\" title=\"内部类与闭包\"></a>内部类与闭包</h4><p>内部类会包含对外部类的引用，形成闭包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"\n\n\n## Java引用\n\n在`java.lang.ref`包中有一系列可以辅助GC灵活进行处理的类；抽象类`Reference`有三个子类`SoftReference`(软引用),`WeakReference`(弱引用),和`PhantomReference`(虚引用)，三个子类的可达性依次减弱。\n\n当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用`Reference`，如果GC发现一个Object是可达的，那么不会回收该对象。\n\n\n|引用类型 |GC回收时间 |用途 |生存时间|\n|-|-|-|-|\n|HardReference|从不|对象的一般状态|JVM停止运行时|\n|SoftReference|内存不足时|对象缓存|内存不足时停止|\n|WeakReference|GC时|对象缓存|GC后终止|\n|PhantomReference|unknown|unknown|unknown|\n\n`SoftReference`和`WeakReference`可以选择是否将其放入`ReferenceQueue`，而`PhantomReference`必须放入`ReferenceQueue`中。\n\n注：`ReferenceQueue`用于`PhantomReference`的清理\n\n\n\n### Java基本类型与引用类型\n\n注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。","source":"_posts/Java/Java基础/Java引用.md","raw":"\n\n\n## Java引用\n\n在`java.lang.ref`包中有一系列可以辅助GC灵活进行处理的类；抽象类`Reference`有三个子类`SoftReference`(软引用),`WeakReference`(弱引用),和`PhantomReference`(虚引用)，三个子类的可达性依次减弱。\n\n当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用`Reference`，如果GC发现一个Object是可达的，那么不会回收该对象。\n\n\n|引用类型 |GC回收时间 |用途 |生存时间|\n|-|-|-|-|\n|HardReference|从不|对象的一般状态|JVM停止运行时|\n|SoftReference|内存不足时|对象缓存|内存不足时停止|\n|WeakReference|GC时|对象缓存|GC后终止|\n|PhantomReference|unknown|unknown|unknown|\n\n`SoftReference`和`WeakReference`可以选择是否将其放入`ReferenceQueue`，而`PhantomReference`必须放入`ReferenceQueue`中。\n\n注：`ReferenceQueue`用于`PhantomReference`的清理\n\n\n\n### Java基本类型与引用类型\n\n注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。","slug":"Java/Java基础/Java引用","published":1,"date":"2019-11-28T12:20:15.918Z","updated":"2019-11-30T11:14:32.244Z","title":"Java/Java基础/Java引用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0j001ckguiexktc76r","content":"<h2 id=\"Java引用\"><a href=\"#Java引用\" class=\"headerlink\" title=\"Java引用\"></a>Java引用</h2><p>在<code>java.lang.ref</code>包中有一系列可以辅助GC灵活进行处理的类；抽象类<code>Reference</code>有三个子类<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),和<code>PhantomReference</code>(虚引用)，三个子类的可达性依次减弱。</p>\n<p>当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用<code>Reference</code>，如果GC发现一个Object是可达的，那么不会回收该对象。</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>GC回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HardReference</td>\n<td>从不</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时停止</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>GC时</td>\n<td>对象缓存</td>\n<td>GC后终止</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>unknown</td>\n<td>unknown</td>\n<td>unknown</td>\n</tr>\n</tbody></table>\n<p><code>SoftReference</code>和<code>WeakReference</code>可以选择是否将其放入<code>ReferenceQueue</code>，而<code>PhantomReference</code>必须放入<code>ReferenceQueue</code>中。</p>\n<p>注：<code>ReferenceQueue</code>用于<code>PhantomReference</code>的清理</p>\n<h3 id=\"Java基本类型与引用类型\"><a href=\"#Java基本类型与引用类型\" class=\"headerlink\" title=\"Java基本类型与引用类型\"></a>Java基本类型与引用类型</h3><p>注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java引用\"><a href=\"#Java引用\" class=\"headerlink\" title=\"Java引用\"></a>Java引用</h2><p>在<code>java.lang.ref</code>包中有一系列可以辅助GC灵活进行处理的类；抽象类<code>Reference</code>有三个子类<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),和<code>PhantomReference</code>(虚引用)，三个子类的可达性依次减弱。</p>\n<p>当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用<code>Reference</code>，如果GC发现一个Object是可达的，那么不会回收该对象。</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>GC回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HardReference</td>\n<td>从不</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时停止</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>GC时</td>\n<td>对象缓存</td>\n<td>GC后终止</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>unknown</td>\n<td>unknown</td>\n<td>unknown</td>\n</tr>\n</tbody></table>\n<p><code>SoftReference</code>和<code>WeakReference</code>可以选择是否将其放入<code>ReferenceQueue</code>，而<code>PhantomReference</code>必须放入<code>ReferenceQueue</code>中。</p>\n<p>注：<code>ReferenceQueue</code>用于<code>PhantomReference</code>的清理</p>\n<h3 id=\"Java基本类型与引用类型\"><a href=\"#Java基本类型与引用类型\" class=\"headerlink\" title=\"Java基本类型与引用类型\"></a>Java基本类型与引用类型</h3><p>注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。</p>\n"},{"_content":"\n## Java基础目录\n\n* [Java输入输出操作](Java输入输出操作.html)\n* [Java关键字](Java关键字.html)\n* [Java泛型](Java泛型.html)\n* [Java集合](Java集合.html)\n* [Java Lambda表达式](Lambda表达式.html)\n* [String、StringBuffer、StringBuilder的区别](String、StringBuffer、StringBuilder区别.html)\n","source":"_posts/Java/Java基础/README.md","raw":"\n## Java基础目录\n\n* [Java输入输出操作](Java输入输出操作.html)\n* [Java关键字](Java关键字.html)\n* [Java泛型](Java泛型.html)\n* [Java集合](Java集合.html)\n* [Java Lambda表达式](Lambda表达式.html)\n* [String、StringBuffer、StringBuilder的区别](String、StringBuffer、StringBuilder区别.html)\n","slug":"Java/Java基础/README","published":1,"date":"2019-09-19T09:41:14.774Z","updated":"2020-02-26T06:13:01.241Z","title":"Java/Java基础/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0k001dkgui7ntr3j3y","content":"<h2 id=\"Java基础目录\"><a href=\"#Java基础目录\" class=\"headerlink\" title=\"Java基础目录\"></a>Java基础目录</h2><ul>\n<li><a href=\"Java输入输出操作.html\">Java输入输出操作</a></li>\n<li><a href=\"Java关键字.html\">Java关键字</a></li>\n<li><a href=\"Java泛型.html\">Java泛型</a></li>\n<li><a href=\"Java集合.html\">Java集合</a></li>\n<li><a href=\"Lambda表达式.html\">Java Lambda表达式</a></li>\n<li><a href=\"String、StringBuffer、StringBuilder区别.html\">String、StringBuffer、StringBuilder的区别</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java基础目录\"><a href=\"#Java基础目录\" class=\"headerlink\" title=\"Java基础目录\"></a>Java基础目录</h2><ul>\n<li><a href=\"Java输入输出操作.html\">Java输入输出操作</a></li>\n<li><a href=\"Java关键字.html\">Java关键字</a></li>\n<li><a href=\"Java泛型.html\">Java泛型</a></li>\n<li><a href=\"Java集合.html\">Java集合</a></li>\n<li><a href=\"Lambda表达式.html\">Java Lambda表达式</a></li>\n<li><a href=\"String、StringBuffer、StringBuilder区别.html\">String、StringBuffer、StringBuilder的区别</a></li>\n</ul>\n"},{"_content":"## Queue 接口\n\n# Collection的使用方法\n\n接口`Collection`继承自`Iterable`接口    \n\n用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。\n\n### BlockingQueue接口\n实现类 \n* ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小\n* DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口\n* LinkedBlockingQueue 内部以链表的形式实现\n* PriorityBlockingQueue 无界并发队列\n* SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；\n\n方法\n* add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常\n* remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* offer  添加一个元素并返回true，如果队列已满，则返回false\n* poll  移除并返问队列头部的元素，，如果队列为空，则返回null\n* peek  返回队列头部的元素，如果队列为空，则返回null\n* put  添加一个元素，如果队列满，则阻塞\n* take 移除并返回队列头部的元素，如果队列为空，则阻塞\n\n \n\n## List接口：实现类 ArrayList LinkedList Vector\n### ArrayList\n\nArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；\n\nArrayList在循环中删除元素可能会出现问题：\n1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏\n2、使用for-each进行删除，实际是调用它的迭代器来实现，\n\n### LinkedList\nLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） \n\n### Vector\n\nVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；\n\n    \n    \n**Java Doc里建议用Deque替代Stack接口完成栈的功能**\n\n\n## Set接口：实现类 Hashset、TreeSet\n\n*  Hashset：按照哈希算法存取集合中的对象，存取速度快\n*  TreeSet：实现Sorted接口，能够对集合中的对象进行排序\n\n## Map接口\n\n\n\n### HashMap遍历\n\n\n\n##  Iterable和Iterator(迭代器)\n\n\n\n\n\n\n","source":"_posts/Java/Java基础/Java集合.md","raw":"## Queue 接口\n\n# Collection的使用方法\n\n接口`Collection`继承自`Iterable`接口    \n\n用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。\n\n### BlockingQueue接口\n实现类 \n* ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小\n* DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口\n* LinkedBlockingQueue 内部以链表的形式实现\n* PriorityBlockingQueue 无界并发队列\n* SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；\n\n方法\n* add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常\n* remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* offer  添加一个元素并返回true，如果队列已满，则返回false\n* poll  移除并返问队列头部的元素，，如果队列为空，则返回null\n* peek  返回队列头部的元素，如果队列为空，则返回null\n* put  添加一个元素，如果队列满，则阻塞\n* take 移除并返回队列头部的元素，如果队列为空，则阻塞\n\n \n\n## List接口：实现类 ArrayList LinkedList Vector\n### ArrayList\n\nArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；\n\nArrayList在循环中删除元素可能会出现问题：\n1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏\n2、使用for-each进行删除，实际是调用它的迭代器来实现，\n\n### LinkedList\nLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） \n\n### Vector\n\nVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；\n\n    \n    \n**Java Doc里建议用Deque替代Stack接口完成栈的功能**\n\n\n## Set接口：实现类 Hashset、TreeSet\n\n*  Hashset：按照哈希算法存取集合中的对象，存取速度快\n*  TreeSet：实现Sorted接口，能够对集合中的对象进行排序\n\n## Map接口\n\n\n\n### HashMap遍历\n\n\n\n##  Iterable和Iterator(迭代器)\n\n\n\n\n\n\n","slug":"Java/Java基础/Java集合","published":1,"date":"2019-09-27T08:23:54.079Z","updated":"2019-09-30T08:28:42.971Z","title":"Java/Java基础/Java集合","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0l001ekgui7ybw4o9q","content":"<h2 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h2><h1 id=\"Collection的使用方法\"><a href=\"#Collection的使用方法\" class=\"headerlink\" title=\"Collection的使用方法\"></a>Collection的使用方法</h1><p>接口<code>Collection</code>继承自<code>Iterable</code>接口    </p>\n<p>用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。</p>\n<h3 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h3><p>实现类 </p>\n<ul>\n<li>ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小</li>\n<li>DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口</li>\n<li>LinkedBlockingQueue 内部以链表的形式实现</li>\n<li>PriorityBlockingQueue 无界并发队列</li>\n<li>SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li>\n<li>remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>offer  添加一个元素并返回true，如果队列已满，则返回false</li>\n<li>poll  移除并返问队列头部的元素，，如果队列为空，则返回null</li>\n<li>peek  返回队列头部的元素，如果队列为空，则返回null</li>\n<li>put  添加一个元素，如果队列满，则阻塞</li>\n<li>take 移除并返回队列头部的元素，如果队列为空，则阻塞</li>\n</ul>\n<h2 id=\"List接口：实现类-ArrayList-LinkedList-Vector\"><a href=\"#List接口：实现类-ArrayList-LinkedList-Vector\" class=\"headerlink\" title=\"List接口：实现类 ArrayList LinkedList Vector\"></a>List接口：实现类 ArrayList LinkedList Vector</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；</p>\n<p>ArrayList在循环中删除元素可能会出现问题：<br>1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏<br>2、使用for-each进行删除，实际是调用它的迭代器来实现，</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） </p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；</p>\n<p><strong>Java Doc里建议用Deque替代Stack接口完成栈的功能</strong></p>\n<h2 id=\"Set接口：实现类-Hashset、TreeSet\"><a href=\"#Set接口：实现类-Hashset、TreeSet\" class=\"headerlink\" title=\"Set接口：实现类 Hashset、TreeSet\"></a>Set接口：实现类 Hashset、TreeSet</h2><ul>\n<li>Hashset：按照哈希算法存取集合中的对象，存取速度快</li>\n<li>TreeSet：实现Sorted接口，能够对集合中的对象进行排序</li>\n</ul>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap遍历\"><a href=\"#HashMap遍历\" class=\"headerlink\" title=\"HashMap遍历\"></a>HashMap遍历</h3><h2 id=\"Iterable和Iterator-迭代器\"><a href=\"#Iterable和Iterator-迭代器\" class=\"headerlink\" title=\"Iterable和Iterator(迭代器)\"></a>Iterable和Iterator(迭代器)</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h2><h1 id=\"Collection的使用方法\"><a href=\"#Collection的使用方法\" class=\"headerlink\" title=\"Collection的使用方法\"></a>Collection的使用方法</h1><p>接口<code>Collection</code>继承自<code>Iterable</code>接口    </p>\n<p>用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。</p>\n<h3 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h3><p>实现类 </p>\n<ul>\n<li>ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小</li>\n<li>DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口</li>\n<li>LinkedBlockingQueue 内部以链表的形式实现</li>\n<li>PriorityBlockingQueue 无界并发队列</li>\n<li>SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li>\n<li>remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>offer  添加一个元素并返回true，如果队列已满，则返回false</li>\n<li>poll  移除并返问队列头部的元素，，如果队列为空，则返回null</li>\n<li>peek  返回队列头部的元素，如果队列为空，则返回null</li>\n<li>put  添加一个元素，如果队列满，则阻塞</li>\n<li>take 移除并返回队列头部的元素，如果队列为空，则阻塞</li>\n</ul>\n<h2 id=\"List接口：实现类-ArrayList-LinkedList-Vector\"><a href=\"#List接口：实现类-ArrayList-LinkedList-Vector\" class=\"headerlink\" title=\"List接口：实现类 ArrayList LinkedList Vector\"></a>List接口：实现类 ArrayList LinkedList Vector</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；</p>\n<p>ArrayList在循环中删除元素可能会出现问题：<br>1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏<br>2、使用for-each进行删除，实际是调用它的迭代器来实现，</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） </p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；</p>\n<p><strong>Java Doc里建议用Deque替代Stack接口完成栈的功能</strong></p>\n<h2 id=\"Set接口：实现类-Hashset、TreeSet\"><a href=\"#Set接口：实现类-Hashset、TreeSet\" class=\"headerlink\" title=\"Set接口：实现类 Hashset、TreeSet\"></a>Set接口：实现类 Hashset、TreeSet</h2><ul>\n<li>Hashset：按照哈希算法存取集合中的对象，存取速度快</li>\n<li>TreeSet：实现Sorted接口，能够对集合中的对象进行排序</li>\n</ul>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap遍历\"><a href=\"#HashMap遍历\" class=\"headerlink\" title=\"HashMap遍历\"></a>HashMap遍历</h3><h2 id=\"Iterable和Iterator-迭代器\"><a href=\"#Iterable和Iterator-迭代器\" class=\"headerlink\" title=\"Iterable和Iterator(迭代器)\"></a>Iterable和Iterator(迭代器)</h2>"},{"_content":"\n\n### Lambda介绍\nLambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的**；\n\n\n\n### Java Lambda表达式的写法\n\nJava中的Lambda表达式通常用`(argument)->(body)`的语法表示\n\n```java\n    (arg1, arg2...) -> { body }\n    (type1 arg1, type2 arg2...) -> { body }\n```\n\n* 一个Lambda表达式可以有零个或多个参数；\n* Lambda表达式的主体可以包括零条或多条语句；\n* 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。\n\n\n### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface），`java.lang.Runnable`接口是只有一个`run()`方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建`Runnable`接口引用如下：\n\n```java\n    Runnable r=()->Log.i(\"测试\",\"Hello Word\");\n    //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口\n    new Thread(()->Log.i(\"测试\",\"Hello Word\")).start();\n \n```\n\n###  Lambda表达式与匿名类的区别\n\n* 对于关键字的使用：对于匿名类，关键字`this`解读为匿名类，而对于Lambda表达式，关键字`this`解读为Lambda的外部类\n\n* Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。\n\n\n### 使用Lambda表达式将List中的元素按照长度进行排序\n\n```java\n    \n    //采用匿名内部类写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, new Comparator<String>(){\n        @Override\n        public int compare(String s1, String s2){\n            return s1.length()-s2.length();\n        }\n    });\n    \n    //采用Lambda写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, (s1, s2) ->{\n        return s1.length()-s2.length();\n    });\n            \n```\n\n### 使用Lambda将List中的每个值平方，并计算和\n\n`java.util.stream.Stream`接口，在Java8引入，必须使用Lambda表达式作为参数，`map()`将input stream的元素，映射成out stream；`reduce()`方法用于将stream元素组合起来。\n\n```java\n    \n    //常用写法\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = 0;\n    for(Integer tmp : list) {\n        int x = tmp +tmp;\n        sum = sum + x;\n    }\n    System.out.println(sum);\n\n    // 使用Lambda写法，\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();\n    System.out.println(sum);\n\n\n```\n\n\n\n\n\n\n<<<<<<< HEAD\n=======\n#### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface）\n\n\n#### Lambda表达式使用注意事项\n\n在Lambda表达式中不能有指向其自己的引用，关键字`this`指向的是闭包，而在匿名内部类中`this`关键字指向的是匿名函数自己，\n\n\n### Lambda表达式的常用方法\n\n#### 使用lambda表达式替换匿名类\n使用lambda表达式替换匿名类，需要用到函数式接口,如`Runnable接口`；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。\n\n``` java\n    //使用匿名内部类表达式方法\n    new Thread(new Runnable(){\n        @Override\n        public void run() {\n        System.out.println(\"Test Runnable 1\");\n    }\n    \n    ).start();\n    \n    //使用匿名内部类的方式\n    new Thread( () -> System.out.println(\"Test Runnable 2\") ).start();\n\n```\n\n在使用lambda表达式进行排序时，`Comparator<String>`中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    \n\n\n```java\n    //使用匿名内部类方式对list进行排序\n    Collections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n        }\n    });\n    //使用lambda表达式方式对list进行排序\n    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n\n```\n\n\n\n#### 使用Lambda表达式进行点击事件处理\n\n```java\n    //非lambda表达式方法\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n        Log.i(\"info\",\"点击\");\n        }\n    });\n\n    //使用lambda表达式方式\n    button.setOnClickListener((e)->{\n        Log.i(\"info\",\"点击\");\n    });\n\n\n```\n\n但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，`setOnClickListener()`方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式\n\n```\n        hello.setOnClickListener(object : View.OnClickListener {\n            override fun onClick(v: View?) {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n        })\n        \n        //或者\n       hello.setOnClickListener{\n          Log.i(\"info\",\"点击\");\n        }\n\n\n```\n\n\n#### 在Java中使用lambda表达式和函数式接口Predicate\n\n在`java.util.function`包中，包含多个类用于支持Java的函数式编程，使用`java.util.function.Predicate`函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为\n\n\n\n\n\n\n\n>>>>>>> EditBranch\n","source":"_posts/Java/Java基础/Lambda表达式.md","raw":"\n\n### Lambda介绍\nLambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的**；\n\n\n\n### Java Lambda表达式的写法\n\nJava中的Lambda表达式通常用`(argument)->(body)`的语法表示\n\n```java\n    (arg1, arg2...) -> { body }\n    (type1 arg1, type2 arg2...) -> { body }\n```\n\n* 一个Lambda表达式可以有零个或多个参数；\n* Lambda表达式的主体可以包括零条或多条语句；\n* 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。\n\n\n### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface），`java.lang.Runnable`接口是只有一个`run()`方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建`Runnable`接口引用如下：\n\n```java\n    Runnable r=()->Log.i(\"测试\",\"Hello Word\");\n    //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口\n    new Thread(()->Log.i(\"测试\",\"Hello Word\")).start();\n \n```\n\n###  Lambda表达式与匿名类的区别\n\n* 对于关键字的使用：对于匿名类，关键字`this`解读为匿名类，而对于Lambda表达式，关键字`this`解读为Lambda的外部类\n\n* Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。\n\n\n### 使用Lambda表达式将List中的元素按照长度进行排序\n\n```java\n    \n    //采用匿名内部类写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, new Comparator<String>(){\n        @Override\n        public int compare(String s1, String s2){\n            return s1.length()-s2.length();\n        }\n    });\n    \n    //采用Lambda写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, (s1, s2) ->{\n        return s1.length()-s2.length();\n    });\n            \n```\n\n### 使用Lambda将List中的每个值平方，并计算和\n\n`java.util.stream.Stream`接口，在Java8引入，必须使用Lambda表达式作为参数，`map()`将input stream的元素，映射成out stream；`reduce()`方法用于将stream元素组合起来。\n\n```java\n    \n    //常用写法\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = 0;\n    for(Integer tmp : list) {\n        int x = tmp +tmp;\n        sum = sum + x;\n    }\n    System.out.println(sum);\n\n    // 使用Lambda写法，\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();\n    System.out.println(sum);\n\n\n```\n\n\n\n\n\n\n<<<<<<< HEAD\n=======\n#### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface）\n\n\n#### Lambda表达式使用注意事项\n\n在Lambda表达式中不能有指向其自己的引用，关键字`this`指向的是闭包，而在匿名内部类中`this`关键字指向的是匿名函数自己，\n\n\n### Lambda表达式的常用方法\n\n#### 使用lambda表达式替换匿名类\n使用lambda表达式替换匿名类，需要用到函数式接口,如`Runnable接口`；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。\n\n``` java\n    //使用匿名内部类表达式方法\n    new Thread(new Runnable(){\n        @Override\n        public void run() {\n        System.out.println(\"Test Runnable 1\");\n    }\n    \n    ).start();\n    \n    //使用匿名内部类的方式\n    new Thread( () -> System.out.println(\"Test Runnable 2\") ).start();\n\n```\n\n在使用lambda表达式进行排序时，`Comparator<String>`中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    \n\n\n```java\n    //使用匿名内部类方式对list进行排序\n    Collections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n        }\n    });\n    //使用lambda表达式方式对list进行排序\n    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n\n```\n\n\n\n#### 使用Lambda表达式进行点击事件处理\n\n```java\n    //非lambda表达式方法\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n        Log.i(\"info\",\"点击\");\n        }\n    });\n\n    //使用lambda表达式方式\n    button.setOnClickListener((e)->{\n        Log.i(\"info\",\"点击\");\n    });\n\n\n```\n\n但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，`setOnClickListener()`方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式\n\n```\n        hello.setOnClickListener(object : View.OnClickListener {\n            override fun onClick(v: View?) {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n        })\n        \n        //或者\n       hello.setOnClickListener{\n          Log.i(\"info\",\"点击\");\n        }\n\n\n```\n\n\n#### 在Java中使用lambda表达式和函数式接口Predicate\n\n在`java.util.function`包中，包含多个类用于支持Java的函数式编程，使用`java.util.function.Predicate`函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为\n\n\n\n\n\n\n\n>>>>>>> EditBranch\n","slug":"Java/Java基础/Lambda表达式","published":1,"date":"2019-09-19T09:41:14.773Z","updated":"2019-11-30T11:14:32.245Z","title":"Java/Java基础/Lambda表达式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0n001fkguidcny5jkf","content":"<h3 id=\"Lambda介绍\"><a href=\"#Lambda介绍\" class=\"headerlink\" title=\"Lambda介绍\"></a>Lambda介绍</h3><p>Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<strong>在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的</strong>；</p>\n<h3 id=\"Java-Lambda表达式的写法\"><a href=\"#Java-Lambda表达式的写法\" class=\"headerlink\" title=\"Java Lambda表达式的写法\"></a>Java Lambda表达式的写法</h3><p>Java中的Lambda表达式通常用<code>(argument)-&gt;(body)</code>的语法表示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class=\"line\">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个Lambda表达式可以有零个或多个参数；</li>\n<li>Lambda表达式的主体可以包括零条或多条语句；</li>\n<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。</li>\n</ul>\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>把只有一个抽象方法的接口叫做函数式接口（functional interface），<code>java.lang.Runnable</code>接口是只有一个<code>run()</code>方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建<code>Runnable</code>接口引用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r=()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>)).start();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lambda表达式与匿名类的区别\"><a href=\"#Lambda表达式与匿名类的区别\" class=\"headerlink\" title=\"Lambda表达式与匿名类的区别\"></a>Lambda表达式与匿名类的区别</h3><ul>\n<li><p>对于关键字的使用：对于匿名类，关键字<code>this</code>解读为匿名类，而对于Lambda表达式，关键字<code>this</code>解读为Lambda的外部类</p>\n</li>\n<li><p>Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。</p>\n</li>\n</ul>\n<h3 id=\"使用Lambda表达式将List中的元素按照长度进行排序\"><a href=\"#使用Lambda表达式将List中的元素按照长度进行排序\" class=\"headerlink\" title=\"使用Lambda表达式将List中的元素按照长度进行排序\"></a>使用Lambda表达式将List中的元素按照长度进行排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用Lambda写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Lambda将List中的每个值平方，并计算和\"><a href=\"#使用Lambda将List中的每个值平方，并计算和\" class=\"headerlink\" title=\"使用Lambda将List中的每个值平方，并计算和\"></a>使用Lambda将List中的每个值平方，并计算和</h3><p><code>java.util.stream.Stream</code>接口，在Java8引入，必须使用Lambda表达式作为参数，<code>map()</code>将input stream的元素，映射成out stream；<code>reduce()</code>方法用于将stream元素组合起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常用写法</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer tmp : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = tmp +tmp;</span><br><span class=\"line\">    sum = sum + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Lambda写法，</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h4 id=\"函数式接口-1\"><a href=\"#函数式接口-1\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h4><p>把只有一个抽象方法的接口叫做函数式接口（functional interface）</p>\n<h4 id=\"Lambda表达式使用注意事项\"><a href=\"#Lambda表达式使用注意事项\" class=\"headerlink\" title=\"Lambda表达式使用注意事项\"></a>Lambda表达式使用注意事项</h4><p>在Lambda表达式中不能有指向其自己的引用，关键字<code>this</code>指向的是闭包，而在匿名内部类中<code>this</code>关键字指向的是匿名函数自己，</p>\n<h3 id=\"Lambda表达式的常用方法\"><a href=\"#Lambda表达式的常用方法\" class=\"headerlink\" title=\"Lambda表达式的常用方法\"></a>Lambda表达式的常用方法</h3><h4 id=\"使用lambda表达式替换匿名类\"><a href=\"#使用lambda表达式替换匿名类\" class=\"headerlink\" title=\"使用lambda表达式替换匿名类\"></a>使用lambda表达式替换匿名类</h4><p>使用lambda表达式替换匿名类，需要用到函数式接口,如<code>Runnable接口</code>；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类表达式方法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Test Runnable 1\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用匿名内部类的方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread( () -&gt; System.out.println(<span class=\"string\">\"Test Runnable 2\"</span>) ).start();</span><br></pre></td></tr></table></figure>\n\n<p>在使用lambda表达式进行排序时，<code>Comparator&lt;String&gt;</code>中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"使用Lambda表达式进行点击事件处理\"><a href=\"#使用Lambda表达式进行点击事件处理\" class=\"headerlink\" title=\"使用Lambda表达式进行点击事件处理\"></a>使用Lambda表达式进行点击事件处理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非lambda表达式方法</span></span><br><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式</span></span><br><span class=\"line\">button.setOnClickListener((e)-&gt;&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，<code>setOnClickListener()</code>方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> hello.setOnClickListener(object : View.OnClickListener &#123;</span><br><span class=\"line\">     override fun onClick(v: View?) &#123;</span><br><span class=\"line\">         TODO(&quot;not implemented&quot;) &#x2F;&#x2F;To change body of created functions use File | Settings | File Templates.</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> &#x2F;&#x2F;或者</span><br><span class=\"line\">hello.setOnClickListener&#123;</span><br><span class=\"line\">   Log.i(&quot;info&quot;,&quot;点击&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"在Java中使用lambda表达式和函数式接口Predicate\"><a href=\"#在Java中使用lambda表达式和函数式接口Predicate\" class=\"headerlink\" title=\"在Java中使用lambda表达式和函数式接口Predicate\"></a>在Java中使用lambda表达式和函数式接口Predicate</h4><p>在<code>java.util.function</code>包中，包含多个类用于支持Java的函数式编程，使用<code>java.util.function.Predicate</code>函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>EditBranch</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Lambda介绍\"><a href=\"#Lambda介绍\" class=\"headerlink\" title=\"Lambda介绍\"></a>Lambda介绍</h3><p>Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<strong>在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的</strong>；</p>\n<h3 id=\"Java-Lambda表达式的写法\"><a href=\"#Java-Lambda表达式的写法\" class=\"headerlink\" title=\"Java Lambda表达式的写法\"></a>Java Lambda表达式的写法</h3><p>Java中的Lambda表达式通常用<code>(argument)-&gt;(body)</code>的语法表示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class=\"line\">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个Lambda表达式可以有零个或多个参数；</li>\n<li>Lambda表达式的主体可以包括零条或多条语句；</li>\n<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。</li>\n</ul>\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>把只有一个抽象方法的接口叫做函数式接口（functional interface），<code>java.lang.Runnable</code>接口是只有一个<code>run()</code>方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建<code>Runnable</code>接口引用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r=()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;Log.i(<span class=\"string\">\"测试\"</span>,<span class=\"string\">\"Hello Word\"</span>)).start();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lambda表达式与匿名类的区别\"><a href=\"#Lambda表达式与匿名类的区别\" class=\"headerlink\" title=\"Lambda表达式与匿名类的区别\"></a>Lambda表达式与匿名类的区别</h3><ul>\n<li><p>对于关键字的使用：对于匿名类，关键字<code>this</code>解读为匿名类，而对于Lambda表达式，关键字<code>this</code>解读为Lambda的外部类</p>\n</li>\n<li><p>Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。</p>\n</li>\n</ul>\n<h3 id=\"使用Lambda表达式将List中的元素按照长度进行排序\"><a href=\"#使用Lambda表达式将List中的元素按照长度进行排序\" class=\"headerlink\" title=\"使用Lambda表达式将List中的元素按照长度进行排序\"></a>使用Lambda表达式将List中的元素按照长度进行排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用Lambda写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"out\"</span>, <span class=\"string\">\"println\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Lambda将List中的每个值平方，并计算和\"><a href=\"#使用Lambda将List中的每个值平方，并计算和\" class=\"headerlink\" title=\"使用Lambda将List中的每个值平方，并计算和\"></a>使用Lambda将List中的每个值平方，并计算和</h3><p><code>java.util.stream.Stream</code>接口，在Java8引入，必须使用Lambda表达式作为参数，<code>map()</code>将input stream的元素，映射成out stream；<code>reduce()</code>方法用于将stream元素组合起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常用写法</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer tmp : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = tmp +tmp;</span><br><span class=\"line\">    sum = sum + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Lambda写法，</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class=\"line\">System.out.println(sum);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h4 id=\"函数式接口-1\"><a href=\"#函数式接口-1\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h4><p>把只有一个抽象方法的接口叫做函数式接口（functional interface）</p>\n<h4 id=\"Lambda表达式使用注意事项\"><a href=\"#Lambda表达式使用注意事项\" class=\"headerlink\" title=\"Lambda表达式使用注意事项\"></a>Lambda表达式使用注意事项</h4><p>在Lambda表达式中不能有指向其自己的引用，关键字<code>this</code>指向的是闭包，而在匿名内部类中<code>this</code>关键字指向的是匿名函数自己，</p>\n<h3 id=\"Lambda表达式的常用方法\"><a href=\"#Lambda表达式的常用方法\" class=\"headerlink\" title=\"Lambda表达式的常用方法\"></a>Lambda表达式的常用方法</h3><h4 id=\"使用lambda表达式替换匿名类\"><a href=\"#使用lambda表达式替换匿名类\" class=\"headerlink\" title=\"使用lambda表达式替换匿名类\"></a>使用lambda表达式替换匿名类</h4><p>使用lambda表达式替换匿名类，需要用到函数式接口,如<code>Runnable接口</code>；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类表达式方法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Test Runnable 1\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用匿名内部类的方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread( () -&gt; System.out.println(<span class=\"string\">\"Test Runnable 2\"</span>) ).start();</span><br></pre></td></tr></table></figure>\n\n<p>在使用lambda表达式进行排序时，<code>Comparator&lt;String&gt;</code>中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"使用Lambda表达式进行点击事件处理\"><a href=\"#使用Lambda表达式进行点击事件处理\" class=\"headerlink\" title=\"使用Lambda表达式进行点击事件处理\"></a>使用Lambda表达式进行点击事件处理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非lambda表达式方法</span></span><br><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式</span></span><br><span class=\"line\">button.setOnClickListener((e)-&gt;&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">\"info\"</span>,<span class=\"string\">\"点击\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，<code>setOnClickListener()</code>方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> hello.setOnClickListener(object : View.OnClickListener &#123;</span><br><span class=\"line\">     override fun onClick(v: View?) &#123;</span><br><span class=\"line\">         TODO(&quot;not implemented&quot;) &#x2F;&#x2F;To change body of created functions use File | Settings | File Templates.</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> &#x2F;&#x2F;或者</span><br><span class=\"line\">hello.setOnClickListener&#123;</span><br><span class=\"line\">   Log.i(&quot;info&quot;,&quot;点击&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"在Java中使用lambda表达式和函数式接口Predicate\"><a href=\"#在Java中使用lambda表达式和函数式接口Predicate\" class=\"headerlink\" title=\"在Java中使用lambda表达式和函数式接口Predicate\"></a>在Java中使用lambda表达式和函数式接口Predicate</h4><p>在<code>java.util.function</code>包中，包含多个类用于支持Java的函数式编程，使用<code>java.util.function.Predicate</code>函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>EditBranch</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n"},{"_content":"### String、StringBuffer、StringBuilder\n\n`String`类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的`String`对象；\n\n`StringBuffer`和`StringBuilder`对象是可以改变的，变化时基于原来的对象基础上机型改变。\n\n### StringBuffer VS. String Builder\n\nStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。\n\n### '+' VS. StringBuilder\n\n\n\n### byte[]和String类型相互转化\n\nbyte[]转换为String,如果是非法值，可能转换不成功\n\n```\n    //用于测试String和byte之间的相互转化\n    String testString=\"1234566789\";\n    byte[] testByte=testString.getBytes();\n    try {\n        String string=new String(testByte, \"UTF-8\");\n        System.out.println(string);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n```","source":"_posts/Java/Java基础/String、StringBuffer、StringBuilder区别.md","raw":"### String、StringBuffer、StringBuilder\n\n`String`类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的`String`对象；\n\n`StringBuffer`和`StringBuilder`对象是可以改变的，变化时基于原来的对象基础上机型改变。\n\n### StringBuffer VS. String Builder\n\nStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。\n\n### '+' VS. StringBuilder\n\n\n\n### byte[]和String类型相互转化\n\nbyte[]转换为String,如果是非法值，可能转换不成功\n\n```\n    //用于测试String和byte之间的相互转化\n    String testString=\"1234566789\";\n    byte[] testByte=testString.getBytes();\n    try {\n        String string=new String(testByte, \"UTF-8\");\n        System.out.println(string);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n```","slug":"Java/Java基础/String、StringBuffer、StringBuilder区别","published":1,"date":"2019-09-19T09:41:14.774Z","updated":"2019-11-30T11:14:32.245Z","title":"Java/Java基础/String、StringBuffer、StringBuilder区别","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0n001gkguif8h0ax7p","content":"<h3 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h3><p><code>String</code>类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的<code>String</code>对象；</p>\n<p><code>StringBuffer</code>和<code>StringBuilder</code>对象是可以改变的，变化时基于原来的对象基础上机型改变。</p>\n<h3 id=\"StringBuffer-VS-String-Builder\"><a href=\"#StringBuffer-VS-String-Builder\" class=\"headerlink\" title=\"StringBuffer VS. String Builder\"></a>StringBuffer VS. String Builder</h3><p>StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。</p>\n<h3 id=\"‘-’-VS-StringBuilder\"><a href=\"#‘-’-VS-StringBuilder\" class=\"headerlink\" title=\"‘+’ VS. StringBuilder\"></a>‘+’ VS. StringBuilder</h3><h3 id=\"byte-和String类型相互转化\"><a href=\"#byte-和String类型相互转化\" class=\"headerlink\" title=\"byte[]和String类型相互转化\"></a>byte[]和String类型相互转化</h3><p>byte[]转换为String,如果是非法值，可能转换不成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用于测试String和byte之间的相互转化</span><br><span class=\"line\">String testString&#x3D;&quot;1234566789&quot;;</span><br><span class=\"line\">byte[] testByte&#x3D;testString.getBytes();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    String string&#x3D;new String(testByte, &quot;UTF-8&quot;);</span><br><span class=\"line\">    System.out.println(string);</span><br><span class=\"line\">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h3><p><code>String</code>类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的<code>String</code>对象；</p>\n<p><code>StringBuffer</code>和<code>StringBuilder</code>对象是可以改变的，变化时基于原来的对象基础上机型改变。</p>\n<h3 id=\"StringBuffer-VS-String-Builder\"><a href=\"#StringBuffer-VS-String-Builder\" class=\"headerlink\" title=\"StringBuffer VS. String Builder\"></a>StringBuffer VS. String Builder</h3><p>StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。</p>\n<h3 id=\"‘-’-VS-StringBuilder\"><a href=\"#‘-’-VS-StringBuilder\" class=\"headerlink\" title=\"‘+’ VS. StringBuilder\"></a>‘+’ VS. StringBuilder</h3><h3 id=\"byte-和String类型相互转化\"><a href=\"#byte-和String类型相互转化\" class=\"headerlink\" title=\"byte[]和String类型相互转化\"></a>byte[]和String类型相互转化</h3><p>byte[]转换为String,如果是非法值，可能转换不成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用于测试String和byte之间的相互转化</span><br><span class=\"line\">String testString&#x3D;&quot;1234566789&quot;;</span><br><span class=\"line\">byte[] testByte&#x3D;testString.getBytes();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    String string&#x3D;new String(testByte, &quot;UTF-8&quot;);</span><br><span class=\"line\">    System.out.println(string);</span><br><span class=\"line\">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"\n\n## AES加密\n\n AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，\n \n  \n### AES在Java中的使用\n\n JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。\n Java中的加解密由Cipher组件提供。\n \n**注：**\n* Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding \n* Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)\n\n#### 生成秘钥\n\n```\n     KeyGenerator generator=KeyGenerator.getInstance(\"AES/ECB/PKCS5PADDING\");\n     //用于指定秘钥长度\n     generator.init(Secret_Key_Size);\n\n     SecretKey secretKey=generator.generateKey();\n\n```","source":"_posts/Java/Java基础/加密算法.md","raw":"\n\n## AES加密\n\n AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，\n \n  \n### AES在Java中的使用\n\n JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。\n Java中的加解密由Cipher组件提供。\n \n**注：**\n* Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding \n* Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)\n\n#### 生成秘钥\n\n```\n     KeyGenerator generator=KeyGenerator.getInstance(\"AES/ECB/PKCS5PADDING\");\n     //用于指定秘钥长度\n     generator.init(Secret_Key_Size);\n\n     SecretKey secretKey=generator.generateKey();\n\n```","slug":"Java/Java基础/加密算法","published":1,"date":"2019-11-28T12:20:15.919Z","updated":"2019-11-30T11:14:32.246Z","title":"Java/Java基础/加密算法","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0o001hkguid8vi2u6l","content":"<h2 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h2><p> AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，</p>\n<h3 id=\"AES在Java中的使用\"><a href=\"#AES在Java中的使用\" class=\"headerlink\" title=\"AES在Java中的使用\"></a>AES在Java中的使用</h3><p> JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。<br> Java中的加解密由Cipher组件提供。</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding </li>\n<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)</li>\n</ul>\n<h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeyGenerator generator&#x3D;KeyGenerator.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5PADDING&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;用于指定秘钥长度</span><br><span class=\"line\">generator.init(Secret_Key_Size);</span><br><span class=\"line\"></span><br><span class=\"line\">SecretKey secretKey&#x3D;generator.generateKey();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h2><p> AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，</p>\n<h3 id=\"AES在Java中的使用\"><a href=\"#AES在Java中的使用\" class=\"headerlink\" title=\"AES在Java中的使用\"></a>AES在Java中的使用</h3><p> JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。<br> Java中的加解密由Cipher组件提供。</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding </li>\n<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)</li>\n</ul>\n<h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeyGenerator generator&#x3D;KeyGenerator.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5PADDING&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;用于指定秘钥长度</span><br><span class=\"line\">generator.init(Secret_Key_Size);</span><br><span class=\"line\"></span><br><span class=\"line\">SecretKey secretKey&#x3D;generator.generateKey();</span><br></pre></td></tr></table></figure>"},{"_content":"### 不同单例模式在多线程下的特点\n\n* 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；\n\n```java\n\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton (){}\n\n    public static Singleton getInstance() {\n     if (instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n    }\n}\n```\n\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。\n\n```java\n\npublic static synchronized Singleton getInstance() {\n    if (instance == null) {\n        instance = new Singleton();\n    }\n    return instance;\n}\n\n```\n* 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。\n\n```java\npublic static Singleton getSingleton() {\n    if (instance == null) {                         //Single Checked\n        synchronized (Singleton.class) {\n            if (instance == null) {                 //Double Checked\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance ;\n}\n\n```\n**在使用`synchronized`关键字之后，每次只有一个线程可以进入到该方法中，但是使用`synchronized`关键字会造成开销过大**\n\n于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。\n\n1、给 instance 分配内存\n2、调用 Singleton 的构造函数来初始化成员变量\n3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。\n\n```java\n\npublic class Singleton {\n    private volatile static Singleton instance; //声明成 volatile\n    private Singleton (){}\n\n    public static Singleton getSingleton() {\n        if (instance == null) {                         \n            synchronized (Singleton.class) {\n                if (instance == null) {       \n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n   \n}\n\n```\n`volatile`具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）\n\n\n* 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\n\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n* 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n\n```\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java多线程/Java多线程与单例模式.md","raw":"### 不同单例模式在多线程下的特点\n\n* 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；\n\n```java\n\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton (){}\n\n    public static Singleton getInstance() {\n     if (instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n    }\n}\n```\n\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。\n\n```java\n\npublic static synchronized Singleton getInstance() {\n    if (instance == null) {\n        instance = new Singleton();\n    }\n    return instance;\n}\n\n```\n* 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。\n\n```java\npublic static Singleton getSingleton() {\n    if (instance == null) {                         //Single Checked\n        synchronized (Singleton.class) {\n            if (instance == null) {                 //Double Checked\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance ;\n}\n\n```\n**在使用`synchronized`关键字之后，每次只有一个线程可以进入到该方法中，但是使用`synchronized`关键字会造成开销过大**\n\n于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。\n\n1、给 instance 分配内存\n2、调用 Singleton 的构造函数来初始化成员变量\n3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。\n\n```java\n\npublic class Singleton {\n    private volatile static Singleton instance; //声明成 volatile\n    private Singleton (){}\n\n    public static Singleton getSingleton() {\n        if (instance == null) {                         \n            synchronized (Singleton.class) {\n                if (instance == null) {       \n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n   \n}\n\n```\n`volatile`具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）\n\n\n* 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\n\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n* 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n\n```\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/Java多线程/Java多线程与单例模式","published":1,"date":"2019-09-19T09:41:14.775Z","updated":"2019-09-30T08:28:42.973Z","title":"Java/Java多线程/Java多线程与单例模式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0p001ikgui6w8ohz32","content":"<h3 id=\"不同单例模式在多线程下的特点\"><a href=\"#不同单例模式在多线程下的特点\" class=\"headerlink\" title=\"不同单例模式在多线程下的特点\"></a>不同单例模式在多线程下的特点</h3><ul>\n<li>懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         <span class=\"comment\">//Single Checked</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                 <span class=\"comment\">//Double Checked</span></span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>synchronized</code>关键字之后，每次只有一个线程可以进入到该方法中，但是使用<code>synchronized</code>关键字会造成开销过大</strong></p>\n<p>于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。</p>\n<p>1、给 instance 分配内存<br>2、调用 Singleton 的构造函数来初始化成员变量<br>3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance; <span class=\"comment\">//声明成 volatile</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;       </span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）</p>\n<ul>\n<li>饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<ul>\n<li>静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"不同单例模式在多线程下的特点\"><a href=\"#不同单例模式在多线程下的特点\" class=\"headerlink\" title=\"不同单例模式在多线程下的特点\"></a>不同单例模式在多线程下的特点</h3><ul>\n<li>懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         <span class=\"comment\">//Single Checked</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                 <span class=\"comment\">//Double Checked</span></span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>synchronized</code>关键字之后，每次只有一个线程可以进入到该方法中，但是使用<code>synchronized</code>关键字会造成开销过大</strong></p>\n<p>于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。</p>\n<p>1、给 instance 分配内存<br>2、调用 Singleton 的构造函数来初始化成员变量<br>3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance; <span class=\"comment\">//声明成 volatile</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;       </span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）</p>\n<ul>\n<li>饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<ul>\n<li>静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n"},{"_content":"## Java多线程协作\n\nJava多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在`Object`对象中有`wait()`和`notifyAll()`方法，在Java  SE 5多任务库中添加`Condition`类，其中有`await()`和`singal()`方法。\n\n\n### join\n\n当一个在线程**m**中调用`t.join()`，**m**线程会被挂起，直至**t**执行结束(`t.isAlive`为false)；如果**t**线程调用`t.interrupt()`(在**m**线程之外)，则线程**m**中会继续执行任务。\n\n\n","source":"_posts/Java/Java多线程/Java多线程之间的协作.md","raw":"## Java多线程协作\n\nJava多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在`Object`对象中有`wait()`和`notifyAll()`方法，在Java  SE 5多任务库中添加`Condition`类，其中有`await()`和`singal()`方法。\n\n\n### join\n\n当一个在线程**m**中调用`t.join()`，**m**线程会被挂起，直至**t**执行结束(`t.isAlive`为false)；如果**t**线程调用`t.interrupt()`(在**m**线程之外)，则线程**m**中会继续执行任务。\n\n\n","slug":"Java/Java多线程/Java多线程之间的协作","published":1,"date":"2019-09-19T09:41:14.776Z","updated":"2019-09-19T09:41:14.776Z","title":"Java/Java多线程/Java多线程之间的协作","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0p001jkgui110c6gah","content":"<h2 id=\"Java多线程协作\"><a href=\"#Java多线程协作\" class=\"headerlink\" title=\"Java多线程协作\"></a>Java多线程协作</h2><p>Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在<code>Object</code>对象中有<code>wait()</code>和<code>notifyAll()</code>方法，在Java  SE 5多任务库中添加<code>Condition</code>类，其中有<code>await()</code>和<code>singal()</code>方法。</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>当一个在线程<strong>m</strong>中调用<code>t.join()</code>，<strong>m</strong>线程会被挂起，直至<strong>t</strong>执行结束(<code>t.isAlive</code>为false)；如果<strong>t</strong>线程调用<code>t.interrupt()</code>(在<strong>m</strong>线程之外)，则线程<strong>m</strong>中会继续执行任务。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java多线程协作\"><a href=\"#Java多线程协作\" class=\"headerlink\" title=\"Java多线程协作\"></a>Java多线程协作</h2><p>Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在<code>Object</code>对象中有<code>wait()</code>和<code>notifyAll()</code>方法，在Java  SE 5多任务库中添加<code>Condition</code>类，其中有<code>await()</code>和<code>singal()</code>方法。</p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>当一个在线程<strong>m</strong>中调用<code>t.join()</code>，<strong>m</strong>线程会被挂起，直至<strong>t</strong>执行结束(<code>t.isAlive</code>为false)；如果<strong>t</strong>线程调用<code>t.interrupt()</code>(在<strong>m</strong>线程之外)，则线程<strong>m</strong>中会继续执行任务。</p>\n"},{"_content":"\n##Java多线程目录\n\n* [Java多线程与单例模式](Java多线程与单例模式.html)\n* [Java多线程基础](Java多线程基础.html)\n* [Java多线程间通信](Java多线程间通信.html)\n* [Java锁机制](Java锁机制.html)","source":"_posts/Java/Java多线程/README.md","raw":"\n##Java多线程目录\n\n* [Java多线程与单例模式](Java多线程与单例模式.html)\n* [Java多线程基础](Java多线程基础.html)\n* [Java多线程间通信](Java多线程间通信.html)\n* [Java锁机制](Java锁机制.html)","slug":"Java/Java多线程/README","published":1,"date":"2019-09-19T09:41:14.777Z","updated":"2019-10-08T06:19:41.310Z","title":"Java/Java多线程/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0q001kkguie3bl0vkx","content":"<p>##Java多线程目录</p>\n<ul>\n<li><a href=\"Java多线程与单例模式.html\">Java多线程与单例模式</a></li>\n<li><a href=\"Java多线程基础.html\">Java多线程基础</a></li>\n<li><a href=\"Java多线程间通信.html\">Java多线程间通信</a></li>\n<li><a href=\"Java锁机制.html\">Java锁机制</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>##Java多线程目录</p>\n<ul>\n<li><a href=\"Java多线程与单例模式.html\">Java多线程与单例模式</a></li>\n<li><a href=\"Java多线程基础.html\">Java多线程基础</a></li>\n<li><a href=\"Java多线程间通信.html\">Java多线程间通信</a></li>\n<li><a href=\"Java锁机制.html\">Java锁机制</a></li>\n</ul>\n"},{"_content":"\n## Java设计模式目录\n\n* [观察者模式](观察者模式.html)\n\n\n","source":"_posts/Java/设计模式/README.md","raw":"\n## Java设计模式目录\n\n* [观察者模式](观察者模式.html)\n\n\n","slug":"Java/设计模式/README","published":1,"date":"2019-09-19T09:41:14.778Z","updated":"2019-10-08T06:19:41.311Z","title":"Java/设计模式/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0q001lkgui5pog5vc9","content":"<h2 id=\"Java设计模式目录\"><a href=\"#Java设计模式目录\" class=\"headerlink\" title=\"Java设计模式目录\"></a>Java设计模式目录</h2><ul>\n<li><a href=\"观察者模式.html\">观察者模式</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java设计模式目录\"><a href=\"#Java设计模式目录\" class=\"headerlink\" title=\"Java设计模式目录\"></a>Java设计模式目录</h2><ul>\n<li><a href=\"观察者模式.html\">观察者模式</a></li>\n</ul>\n"},{"_content":"# 代理模式\n\n### 代理模式介绍\n\n代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。\n\n代理模式主要由三部分组成：\n* Subject：一个将方法暴露给client的接口\n* Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类\n* Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。\n\n代理模式的结构\n![](/assets/proxy-design-pattern.jpg)\n\n\n### 静态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyTest extends RealSubject {\n        @Override\n        public void doSomething() {\n            System.out.println(\"proxy输出\");\n            super.doSomething();\n        }\n    }\n```\n测试类client\n```java\n    public class Client {\n\n        public static void main(String[] args) {\n            RealSubject proxy=new ProxyTest();\n            proxy.doSomething();\n        }\n    }\n    \n    //输出\n    //proxy输出\n    //RealSubject 输出\n\n```\n\n### 动态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyHandler implements InvocationHandler {\n\n        private Object tar;\n\n        //绑定委托对象，并返回代理类\n        public Object bind(Object tar){\n            this.tar=tar;\n            return                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this);\n        }\n\n        @Override\n        public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        \n            Object result=null;\n            //这里可以进行所谓的AOP编程\n            //在调用具体函数方法项之前，执行功能处理\n            result=method.invoke(tar,objects);\n            //在调用具体函数方法项之后，执行功能处理\n            return result;\n        }\n    }\n\n```\n\nClient\n```java\n    public class Client {\n\n    public static void main(String[] args) {\n\n        ProxyHandler proxyHandler=new ProxyHandler();\n        //绑定该类实现的所有接口\n        Subject sub=(Subject)proxyHandler.bind(new RealSubject());\n        sub.doSomething();\n        }\n    }\n```\n\n#### 动态代理模式详解\n\n#### InvocationHandler接口介绍\nInvocationHandler 源码\n```java\n    public interface InvocationHandler {\n        Object invoke(Object var1, Method var2, Object[] var3) throws     Throwable;\n    }\n```\nInvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。\n\n`invoke(Object var1, Method var2, Object[] var3)`方法中有三个参数：\n* Object var1：指代代理的真实对象\n* Method method：指代真实对象调用的方法\n* Object[] args：指代真实对象调用方法时的参数\n\n\n\n#### Proxy 类介绍\n\nProxy用来动态创建一个代理对象的类，\n`newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2)`方法中的参数\n\n* ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区\n* Class<?>[] var1：给代理对象提供的接口类型\n* InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法\n\n源码\n\n```java\n    public class Proxy implements Serializable {\n\n        public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) throws IllegalArgumentException {\n            Objects.requireNonNull(var2);\n            Class[] var3 = (Class[])var1.clone();                //用于将传入的Class进行复制       \n            SecurityManager var4 = System.getSecurityManager();\n            if (var4 != null) {\n                checkProxyAccess(Reflection.getCallerClass(), var0, var3);\n            }\n            //调用 getProxyClass0() 方法\n            Class var5 = getProxyClass0(var0, var3);\n\n            try {\n                if (var4 != null) {\n                    checkNewProxyPermission(Reflection.getCallerClass(), var5);\n                }\n                final Constructor var6 = var5.getConstructor(constructorParams);  //通过反射类中的Constructor获取构造函数\n                if (!Modifier.isPublic(var5.getModifiers())) {\n                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        var6.setAccessible(true);\n                        return null;\n                        }\n                    });\n                }\n               // 通过Constructor返回代理类的实例\n                return var6.newInstance(var2);\n            } //catch省略\n        }\n\n\n```\n`getProxyClass0()`源码，从缓存中获取代理类对象\n\n```java\n    public class Proxy implements Serializable {\n       //proxyClassCache对象定义\n        private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n        \n        //......\n        private static Class<?> getProxyClass0(ClassLoader var0, Class<?>... var1) {\n        if (var1.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        } else {\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        //......\n    }\n\n```java\n\n\n\n\n\n\n\n\n","source":"_posts/Java/设计模式/代理模式.md","raw":"# 代理模式\n\n### 代理模式介绍\n\n代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。\n\n代理模式主要由三部分组成：\n* Subject：一个将方法暴露给client的接口\n* Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类\n* Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。\n\n代理模式的结构\n![](/assets/proxy-design-pattern.jpg)\n\n\n### 静态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyTest extends RealSubject {\n        @Override\n        public void doSomething() {\n            System.out.println(\"proxy输出\");\n            super.doSomething();\n        }\n    }\n```\n测试类client\n```java\n    public class Client {\n\n        public static void main(String[] args) {\n            RealSubject proxy=new ProxyTest();\n            proxy.doSomething();\n        }\n    }\n    \n    //输出\n    //proxy输出\n    //RealSubject 输出\n\n```\n\n### 动态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyHandler implements InvocationHandler {\n\n        private Object tar;\n\n        //绑定委托对象，并返回代理类\n        public Object bind(Object tar){\n            this.tar=tar;\n            return                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this);\n        }\n\n        @Override\n        public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        \n            Object result=null;\n            //这里可以进行所谓的AOP编程\n            //在调用具体函数方法项之前，执行功能处理\n            result=method.invoke(tar,objects);\n            //在调用具体函数方法项之后，执行功能处理\n            return result;\n        }\n    }\n\n```\n\nClient\n```java\n    public class Client {\n\n    public static void main(String[] args) {\n\n        ProxyHandler proxyHandler=new ProxyHandler();\n        //绑定该类实现的所有接口\n        Subject sub=(Subject)proxyHandler.bind(new RealSubject());\n        sub.doSomething();\n        }\n    }\n```\n\n#### 动态代理模式详解\n\n#### InvocationHandler接口介绍\nInvocationHandler 源码\n```java\n    public interface InvocationHandler {\n        Object invoke(Object var1, Method var2, Object[] var3) throws     Throwable;\n    }\n```\nInvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。\n\n`invoke(Object var1, Method var2, Object[] var3)`方法中有三个参数：\n* Object var1：指代代理的真实对象\n* Method method：指代真实对象调用的方法\n* Object[] args：指代真实对象调用方法时的参数\n\n\n\n#### Proxy 类介绍\n\nProxy用来动态创建一个代理对象的类，\n`newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2)`方法中的参数\n\n* ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区\n* Class<?>[] var1：给代理对象提供的接口类型\n* InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法\n\n源码\n\n```java\n    public class Proxy implements Serializable {\n\n        public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) throws IllegalArgumentException {\n            Objects.requireNonNull(var2);\n            Class[] var3 = (Class[])var1.clone();                //用于将传入的Class进行复制       \n            SecurityManager var4 = System.getSecurityManager();\n            if (var4 != null) {\n                checkProxyAccess(Reflection.getCallerClass(), var0, var3);\n            }\n            //调用 getProxyClass0() 方法\n            Class var5 = getProxyClass0(var0, var3);\n\n            try {\n                if (var4 != null) {\n                    checkNewProxyPermission(Reflection.getCallerClass(), var5);\n                }\n                final Constructor var6 = var5.getConstructor(constructorParams);  //通过反射类中的Constructor获取构造函数\n                if (!Modifier.isPublic(var5.getModifiers())) {\n                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        var6.setAccessible(true);\n                        return null;\n                        }\n                    });\n                }\n               // 通过Constructor返回代理类的实例\n                return var6.newInstance(var2);\n            } //catch省略\n        }\n\n\n```\n`getProxyClass0()`源码，从缓存中获取代理类对象\n\n```java\n    public class Proxy implements Serializable {\n       //proxyClassCache对象定义\n        private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n        \n        //......\n        private static Class<?> getProxyClass0(ClassLoader var0, Class<?>... var1) {\n        if (var1.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        } else {\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        //......\n    }\n\n```java\n\n\n\n\n\n\n\n\n","slug":"Java/设计模式/代理模式","published":1,"date":"2019-11-28T12:18:36.264Z","updated":"2019-11-30T11:14:32.246Z","title":"Java/设计模式/代理模式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0q001mkgui9esjea5c","content":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"代理模式介绍\"><a href=\"#代理模式介绍\" class=\"headerlink\" title=\"代理模式介绍\"></a>代理模式介绍</h3><p>代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。</p>\n<p>代理模式主要由三部分组成：</p>\n<ul>\n<li>Subject：一个将方法暴露给client的接口</li>\n<li>Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类</li>\n<li>Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。</li>\n</ul>\n<p>代理模式的结构<br><img src=\"/assets/proxy-design-pattern.jpg\" alt=\"\"></p>\n<h3 id=\"静态代理实现方式\"><a href=\"#静态代理实现方式\" class=\"headerlink\" title=\"静态代理实现方式\"></a>静态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RealSubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"proxy输出\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RealSubject proxy=<span class=\"keyword\">new</span> ProxyTest();</span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//proxy输出</span></span><br><span class=\"line\"><span class=\"comment\">//RealSubject 输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态代理实现方式\"><a href=\"#动态代理实现方式\" class=\"headerlink\" title=\"动态代理实现方式\"></a>动态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object tar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定委托对象，并返回代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tar=tar;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Object result=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里可以进行所谓的AOP编程</span></span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之前，执行功能处理</span></span><br><span class=\"line\">        result=method.invoke(tar,objects);</span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之后，执行功能处理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyHandler proxyHandler=<span class=\"keyword\">new</span> ProxyHandler();</span><br><span class=\"line\">    <span class=\"comment\">//绑定该类实现的所有接口</span></span><br><span class=\"line\">    Subject sub=(Subject)proxyHandler.bind(<span class=\"keyword\">new</span> RealSubject());</span><br><span class=\"line\">    sub.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态代理模式详解\"><a href=\"#动态代理模式详解\" class=\"headerlink\" title=\"动态代理模式详解\"></a>动态代理模式详解</h4><h4 id=\"InvocationHandler接口介绍\"><a href=\"#InvocationHandler接口介绍\" class=\"headerlink\" title=\"InvocationHandler接口介绍\"></a>InvocationHandler接口介绍</h4><p>InvocationHandler 源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Method var2, Object[] var3)</span> <span class=\"keyword\">throws</span>     Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>\n<p><code>invoke(Object var1, Method var2, Object[] var3)</code>方法中有三个参数：</p>\n<ul>\n<li>Object var1：指代代理的真实对象</li>\n<li>Method method：指代真实对象调用的方法</li>\n<li>Object[] args：指代真实对象调用方法时的参数</li>\n</ul>\n<h4 id=\"Proxy-类介绍\"><a href=\"#Proxy-类介绍\" class=\"headerlink\" title=\"Proxy 类介绍\"></a>Proxy 类介绍</h4><p>Proxy用来动态创建一个代理对象的类，<br><code>newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</code>方法中的参数</p>\n<ul>\n<li>ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区</li>\n<li>Class&lt;?&gt;[] var1：给代理对象提供的接口类型</li>\n<li>InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法</li>\n</ul>\n<p>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(var2);</span><br><span class=\"line\">        Class[] var3 = (Class[])var1.clone();                <span class=\"comment\">//用于将传入的Class进行复制       </span></span><br><span class=\"line\">        SecurityManager var4 = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), var0, var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用 getProxyClass0() 方法</span></span><br><span class=\"line\">        Class var5 = getProxyClass0(var0, var3);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), var5);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor var6 = var5.getConstructor(constructorParams);  <span class=\"comment\">//通过反射类中的Constructor获取构造函数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(var5.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    var6.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 通过Constructor返回代理类的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> var6.newInstance(var2);</span><br><span class=\"line\">        &#125; <span class=\"comment\">//catch省略</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>getProxyClass0()</code>源码，从缓存中获取代理类对象</p>\n<pre><code class=\"java\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>{\n       <span class=\"comment\">//proxyClassCache对象定义</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class=\"keyword\">new</span> WeakCache(<span class=\"keyword\">new</span> Proxy.KeyFactory(), <span class=\"keyword\">new</span> Proxy.ProxyClassFactory());\n\n        <span class=\"comment\">//......</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) {\n        <span class=\"keyword\">if</span> (var1.length &gt; <span class=\"number\">65535</span>) {\n            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"interface limit exceeded\"</span>);\n        } <span class=\"keyword\">else</span> {\n            <span class=\"comment\">// proxyClassCache 来做一个中间的缓存</span>\n            <span class=\"keyword\">return</span> (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        <span class=\"comment\">//......</span>\n    }\n\n```java\n\n\n\n\n\n\n\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"代理模式介绍\"><a href=\"#代理模式介绍\" class=\"headerlink\" title=\"代理模式介绍\"></a>代理模式介绍</h3><p>代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。</p>\n<p>代理模式主要由三部分组成：</p>\n<ul>\n<li>Subject：一个将方法暴露给client的接口</li>\n<li>Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类</li>\n<li>Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。</li>\n</ul>\n<p>代理模式的结构<br><img src=\"/assets/proxy-design-pattern.jpg\" alt=\"\"></p>\n<h3 id=\"静态代理实现方式\"><a href=\"#静态代理实现方式\" class=\"headerlink\" title=\"静态代理实现方式\"></a>静态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RealSubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"proxy输出\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RealSubject proxy=<span class=\"keyword\">new</span> ProxyTest();</span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//proxy输出</span></span><br><span class=\"line\"><span class=\"comment\">//RealSubject 输出</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态代理实现方式\"><a href=\"#动态代理实现方式\" class=\"headerlink\" title=\"动态代理实现方式\"></a>动态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"RealSubject 输出\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object tar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定委托对象，并返回代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tar=tar;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Object result=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里可以进行所谓的AOP编程</span></span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之前，执行功能处理</span></span><br><span class=\"line\">        result=method.invoke(tar,objects);</span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之后，执行功能处理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyHandler proxyHandler=<span class=\"keyword\">new</span> ProxyHandler();</span><br><span class=\"line\">    <span class=\"comment\">//绑定该类实现的所有接口</span></span><br><span class=\"line\">    Subject sub=(Subject)proxyHandler.bind(<span class=\"keyword\">new</span> RealSubject());</span><br><span class=\"line\">    sub.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动态代理模式详解\"><a href=\"#动态代理模式详解\" class=\"headerlink\" title=\"动态代理模式详解\"></a>动态代理模式详解</h4><h4 id=\"InvocationHandler接口介绍\"><a href=\"#InvocationHandler接口介绍\" class=\"headerlink\" title=\"InvocationHandler接口介绍\"></a>InvocationHandler接口介绍</h4><p>InvocationHandler 源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Method var2, Object[] var3)</span> <span class=\"keyword\">throws</span>     Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>\n<p><code>invoke(Object var1, Method var2, Object[] var3)</code>方法中有三个参数：</p>\n<ul>\n<li>Object var1：指代代理的真实对象</li>\n<li>Method method：指代真实对象调用的方法</li>\n<li>Object[] args：指代真实对象调用方法时的参数</li>\n</ul>\n<h4 id=\"Proxy-类介绍\"><a href=\"#Proxy-类介绍\" class=\"headerlink\" title=\"Proxy 类介绍\"></a>Proxy 类介绍</h4><p>Proxy用来动态创建一个代理对象的类，<br><code>newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</code>方法中的参数</p>\n<ul>\n<li>ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区</li>\n<li>Class&lt;?&gt;[] var1：给代理对象提供的接口类型</li>\n<li>InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法</li>\n</ul>\n<p>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(var2);</span><br><span class=\"line\">        Class[] var3 = (Class[])var1.clone();                <span class=\"comment\">//用于将传入的Class进行复制       </span></span><br><span class=\"line\">        SecurityManager var4 = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), var0, var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用 getProxyClass0() 方法</span></span><br><span class=\"line\">        Class var5 = getProxyClass0(var0, var3);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), var5);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor var6 = var5.getConstructor(constructorParams);  <span class=\"comment\">//通过反射类中的Constructor获取构造函数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(var5.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    var6.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 通过Constructor返回代理类的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> var6.newInstance(var2);</span><br><span class=\"line\">        &#125; <span class=\"comment\">//catch省略</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>getProxyClass0()</code>源码，从缓存中获取代理类对象</p>\n<pre><code class=\"java\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>{\n       <span class=\"comment\">//proxyClassCache对象定义</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class=\"keyword\">new</span> WeakCache(<span class=\"keyword\">new</span> Proxy.KeyFactory(), <span class=\"keyword\">new</span> Proxy.ProxyClassFactory());\n\n        <span class=\"comment\">//......</span>\n        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) {\n        <span class=\"keyword\">if</span> (var1.length &gt; <span class=\"number\">65535</span>) {\n            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"interface limit exceeded\"</span>);\n        } <span class=\"keyword\">else</span> {\n            <span class=\"comment\">// proxyClassCache 来做一个中间的缓存</span>\n            <span class=\"keyword\">return</span> (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        <span class=\"comment\">//......</span>\n    }\n\n```java\n\n\n\n\n\n\n\n</code></pre>\n"},{"_content":"\n## 观察者模式、订阅者模式、回调函数对比\n\n在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；\n\n在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心\n\n在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”\n\n\n### 本篇观察者模式主要在Android中实现\n\n\n\n\n\n### 在Java提供了Observer接口和Observable类方便快速实现观察者模式\n\n","source":"_posts/Java/设计模式/观察者模式.md","raw":"\n## 观察者模式、订阅者模式、回调函数对比\n\n在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；\n\n在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心\n\n在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”\n\n\n### 本篇观察者模式主要在Android中实现\n\n\n\n\n\n### 在Java提供了Observer接口和Observable类方便快速实现观察者模式\n\n","slug":"Java/设计模式/观察者模式","published":1,"date":"2019-09-19T09:41:14.779Z","updated":"2019-09-30T08:28:42.978Z","title":"Java/设计模式/观察者模式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0r001nkguiavwv8xbb","content":"<h2 id=\"观察者模式、订阅者模式、回调函数对比\"><a href=\"#观察者模式、订阅者模式、回调函数对比\" class=\"headerlink\" title=\"观察者模式、订阅者模式、回调函数对比\"></a>观察者模式、订阅者模式、回调函数对比</h2><p>在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；</p>\n<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心</p>\n<p>在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”</p>\n<h3 id=\"本篇观察者模式主要在Android中实现\"><a href=\"#本篇观察者模式主要在Android中实现\" class=\"headerlink\" title=\"本篇观察者模式主要在Android中实现\"></a>本篇观察者模式主要在Android中实现</h3><h3 id=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"><a href=\"#在Java提供了Observer接口和Observable类方便快速实现观察者模式\" class=\"headerlink\" title=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"></a>在Java提供了Observer接口和Observable类方便快速实现观察者模式</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"观察者模式、订阅者模式、回调函数对比\"><a href=\"#观察者模式、订阅者模式、回调函数对比\" class=\"headerlink\" title=\"观察者模式、订阅者模式、回调函数对比\"></a>观察者模式、订阅者模式、回调函数对比</h2><p>在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；</p>\n<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心</p>\n<p>在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”</p>\n<h3 id=\"本篇观察者模式主要在Android中实现\"><a href=\"#本篇观察者模式主要在Android中实现\" class=\"headerlink\" title=\"本篇观察者模式主要在Android中实现\"></a>本篇观察者模式主要在Android中实现</h3><h3 id=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"><a href=\"#在Java提供了Observer接口和Observable类方便快速实现观察者模式\" class=\"headerlink\" title=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"></a>在Java提供了Observer接口和Observable类方便快速实现观察者模式</h3>"},{"_content":"\n\n### 使用Lambda表达式遍历数组\n\n```kotlin\n    //val\n    stringArrays.forEach({\n        it->println(it)\n     })\n\n```\n\nKotlin中Array的`forEach()`函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；`action: (T) -> Unit`中`(T) -> Unit`是lambda表达式的类型，即函数的类型，此函数参数类型为`T`返回值为`Unit`\n\n```kotlin\n\n    public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n        for (element in this) action(element)\n    }\n```\n\nlambda表达式作为形参的类型\n\n```kotlin\n    ()->Int          //无参数，返回Int类型\n    (Int,Int)->Int   //两个整型参数，返回Int\n    (()->Unit,Int)->Int //一个lambda表达式参数，一个整型参数，返回Int \n\n```\n\n\n在kotlin中，可以把函数的最后一个lambda表达式移到括号外\n\n```kotlin\n    stringArrays.forEach(){\n        it->println(it)\n    }\n\n```\n\n如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用\n\n```kotlin\n    stringArrays.forEach(::println)\n\n```\n\n使用标签从Lambda表达式中返回,其中`forEachItem`为自定义标签，`@forEachItem`与return之间不能存在空格\n```kotlin\n    stringArrays.forEach forEachItem@{\n            if (it==1) return@forEachItem\n    }\n```\n\n\n\n在Lambda中最后一个表达式的值是默认的返回值\n\n\n\n#### 高阶函数\n\n高阶函数是将函数用作参数或返回值的函数\n","source":"_posts/Kotlin/Kotlin基础/Lambda表达式.md","raw":"\n\n### 使用Lambda表达式遍历数组\n\n```kotlin\n    //val\n    stringArrays.forEach({\n        it->println(it)\n     })\n\n```\n\nKotlin中Array的`forEach()`函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；`action: (T) -> Unit`中`(T) -> Unit`是lambda表达式的类型，即函数的类型，此函数参数类型为`T`返回值为`Unit`\n\n```kotlin\n\n    public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n        for (element in this) action(element)\n    }\n```\n\nlambda表达式作为形参的类型\n\n```kotlin\n    ()->Int          //无参数，返回Int类型\n    (Int,Int)->Int   //两个整型参数，返回Int\n    (()->Unit,Int)->Int //一个lambda表达式参数，一个整型参数，返回Int \n\n```\n\n\n在kotlin中，可以把函数的最后一个lambda表达式移到括号外\n\n```kotlin\n    stringArrays.forEach(){\n        it->println(it)\n    }\n\n```\n\n如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用\n\n```kotlin\n    stringArrays.forEach(::println)\n\n```\n\n使用标签从Lambda表达式中返回,其中`forEachItem`为自定义标签，`@forEachItem`与return之间不能存在空格\n```kotlin\n    stringArrays.forEach forEachItem@{\n            if (it==1) return@forEachItem\n    }\n```\n\n\n\n在Lambda中最后一个表达式的值是默认的返回值\n\n\n\n#### 高阶函数\n\n高阶函数是将函数用作参数或返回值的函数\n","slug":"Kotlin/Kotlin基础/Lambda表达式","published":1,"date":"2019-11-28T12:20:23.103Z","updated":"2019-11-30T11:14:32.247Z","title":"Kotlin/Kotlin基础/Lambda表达式","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0s001okguiey496bf4","content":"<h3 id=\"使用Lambda表达式遍历数组\"><a href=\"#使用Lambda表达式遍历数组\" class=\"headerlink\" title=\"使用Lambda表达式遍历数组\"></a>使用Lambda表达式遍历数组</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//val</span></span><br><span class=\"line\">stringArrays.forEach(&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Kotlin中Array的<code>forEach()</code>函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；<code>action: (T) -&gt; Unit</code>中<code>(T) -&gt; Unit</code>是lambda表达式的类型，即函数的类型，此函数参数类型为<code>T</code>返回值为<code>Unit</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lambda表达式作为形参的类型</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">()-&gt;<span class=\"built_in\">Int</span>          <span class=\"comment\">//无参数，返回Int类型</span></span><br><span class=\"line\">(<span class=\"built_in\">Int</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span>   <span class=\"comment\">//两个整型参数，返回Int</span></span><br><span class=\"line\">(()-&gt;<span class=\"built_in\">Unit</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span> <span class=\"comment\">//一个lambda表达式参数，一个整型参数，返回Int</span></span><br></pre></td></tr></table></figure>\n\n\n<p>在kotlin中，可以把函数的最后一个lambda表达式移到括号外</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach()&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach(::println)</span><br></pre></td></tr></table></figure>\n\n<p>使用标签从Lambda表达式中返回,其中<code>forEachItem</code>为自定义标签，<code>@forEachItem</code>与return之间不能存在空格</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach <span class=\"symbol\">forEachItem@</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it==<span class=\"number\">1</span>) <span class=\"keyword\">return</span><span class=\"symbol\">@forEachItem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在Lambda中最后一个表达式的值是默认的返回值</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>高阶函数是将函数用作参数或返回值的函数</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用Lambda表达式遍历数组\"><a href=\"#使用Lambda表达式遍历数组\" class=\"headerlink\" title=\"使用Lambda表达式遍历数组\"></a>使用Lambda表达式遍历数组</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//val</span></span><br><span class=\"line\">stringArrays.forEach(&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Kotlin中Array的<code>forEach()</code>函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；<code>action: (T) -&gt; Unit</code>中<code>(T) -&gt; Unit</code>是lambda表达式的类型，即函数的类型，此函数参数类型为<code>T</code>返回值为<code>Unit</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lambda表达式作为形参的类型</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">()-&gt;<span class=\"built_in\">Int</span>          <span class=\"comment\">//无参数，返回Int类型</span></span><br><span class=\"line\">(<span class=\"built_in\">Int</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span>   <span class=\"comment\">//两个整型参数，返回Int</span></span><br><span class=\"line\">(()-&gt;<span class=\"built_in\">Unit</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span> <span class=\"comment\">//一个lambda表达式参数，一个整型参数，返回Int</span></span><br></pre></td></tr></table></figure>\n\n\n<p>在kotlin中，可以把函数的最后一个lambda表达式移到括号外</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach()&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach(::println)</span><br></pre></td></tr></table></figure>\n\n<p>使用标签从Lambda表达式中返回,其中<code>forEachItem</code>为自定义标签，<code>@forEachItem</code>与return之间不能存在空格</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach <span class=\"symbol\">forEachItem@</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it==<span class=\"number\">1</span>) <span class=\"keyword\">return</span><span class=\"symbol\">@forEachItem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在Lambda中最后一个表达式的值是默认的返回值</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>高阶函数是将函数用作参数或返回值的函数</p>\n"},{"_content":"### fatal: unable to access 'https://github.com/LuciusCS/AndroidProject.git/': Empty reply from server\n\n","source":"_posts/Other/Git/Git出现问题.md","raw":"### fatal: unable to access 'https://github.com/LuciusCS/AndroidProject.git/': Empty reply from server\n\n","slug":"Other/Git/Git出现问题","published":1,"date":"2019-09-21T00:51:16.731Z","updated":"2019-09-21T00:52:10.120Z","title":"Other/Git/Git出现问题","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0s001pkgui6ayn5qjp","content":"<h3 id=\"fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\"><a href=\"#fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\" class=\"headerlink\" title=\"fatal: unable to access ‘https://github.com/LuciusCS/AndroidProject.git/&#39;: Empty reply from server\"></a>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/AndroidProject.git/&#39;\">https://github.com/LuciusCS/AndroidProject.git/&#39;</a>: Empty reply from server</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\"><a href=\"#fatal-unable-to-access-‘https-github-com-LuciusCS-AndroidProject-git-39-Empty-reply-from-server\" class=\"headerlink\" title=\"fatal: unable to access ‘https://github.com/LuciusCS/AndroidProject.git/&#39;: Empty reply from server\"></a>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/AndroidProject.git/&#39;\">https://github.com/LuciusCS/AndroidProject.git/&#39;</a>: Empty reply from server</h3>"},{"_content":"## 常用Git操作\n\n### 一、将本地已有仓库推送到远程仓库\n\n* 1、将本地仓库与远程仓库建立关联\n```\n   git remote add github git@github.com:Lucius/GitTest.git\n```\n    查看本地仓库与远程仓库关联情况\n```\ngit remote -v\n```\n    删除与远程仓库关联 \n```\n git remote rm origin\n```\n\n* 2、设置用户名和密码\n```\ngit config -global user.name \"\"\ngit config -global user.email \"\"\n```\n* 3、设置SSH Key,\n    生成SSH Key\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n** -t 指定密钥类型，默认是 rsa ，可以省略。 **\n** -C 设置注释文字，比如邮箱。 **\n** -f 指定密钥文件存储文件名。 ** \n![](/assets/GitImg1.png)\n   在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中\n  ![](/assets/GitImg2.png)\n* 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg3.png)\n    当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现`fatal: refusing to merge unrelated histories`错误，需要使用下面命令：\n```\ngit pull origin master --allow-unrelated-histories\n```\n* 5、将本地仓库推送至远端\n```\n  git push -u origin master \n```\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误\n![](/assets/GitImg4.png)\n推送正常\n![](/assets/GitImg5.png)\n\n### 二、将本地分支提交到远程\n\n* 1、建立本地到上游（远端）仓的链接\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg6.png)\n\n* 2、拉取远程分支内容\n```\ngit pull --allow-unrelated-histories\n```\n* 3、将本地分支推送至远程\n```\ngit push origin EditBranch\n```\n![](/assets/GitImg7.png)\n\n\n### 三、合并多次提交\n\n```\ngit rebase -i HEAD~3\n```\n\n如果在合并的过程中出现冲突需要先解决冲突，再进行合并\n```\ngit rebase --continue  \n```\n\n如果放弃本次合并，使用\n```\ngit rebase --abort \n```\n### 四、Git多用户进行管理\n\n需要为每一个仓库设置user、email\n\n* 第一步：取消git的global用户以及邮箱\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n\n```\n\n\n* 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。\n\n```\ngit config  user.email \"xxxx@xx.com\"\ngit config  user.name \"xxxx\"\n\n```\n\n### 五、git reset --hard --soft与git revert\n\n`git reset --hard HEAD~1`修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。\n\n`git reset --soft HEAD~1`修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。\n\n#### `git revert`与`git reset`区别\n* `git reset`指向原地或者向前移动指针,直接删除commit，`git revert`创建一个逆向commit来覆盖之前commit,指针向后移动。\n*  在后续合并旧版本时，`git revert`的部分不再出现；而`git reset`在合并旧版本时，这些被回滚的提交还会再次被引入。\n\n#### 撤销 git reset\n\n`git reflog` 查看操作历史，找到之前 HEAD 的 hash 值，然后 `git reset --hard` 到那个 hash 即可\n\n\n### 六、`git cherry-pick`使用方法\n\n将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。\n\n```\ngit cherry-pick <commit id>:单独合并一个提交\ngit cherry-pick -x <commit id>：同上，不同点：保留原提交者信息。\n\ngit cherry-pick <start-commit-id>..<end-commit-id>：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支\n```\n\n\n### 七、修改git urls的路径方式\n\n#### 将urls由SSH模式修改为Https模式\n\n#### 将usrls由Https模式修改为SSH模式\n\n\n### 八、建立本地分支，并推送至远程\n\n\n### 九、更新fork的代码\n在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，\n\n\n\n\n\n\n","source":"_posts/Other/Git/Git.md","raw":"## 常用Git操作\n\n### 一、将本地已有仓库推送到远程仓库\n\n* 1、将本地仓库与远程仓库建立关联\n```\n   git remote add github git@github.com:Lucius/GitTest.git\n```\n    查看本地仓库与远程仓库关联情况\n```\ngit remote -v\n```\n    删除与远程仓库关联 \n```\n git remote rm origin\n```\n\n* 2、设置用户名和密码\n```\ngit config -global user.name \"\"\ngit config -global user.email \"\"\n```\n* 3、设置SSH Key,\n    生成SSH Key\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n** -t 指定密钥类型，默认是 rsa ，可以省略。 **\n** -C 设置注释文字，比如邮箱。 **\n** -f 指定密钥文件存储文件名。 ** \n![](/assets/GitImg1.png)\n   在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中\n  ![](/assets/GitImg2.png)\n* 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg3.png)\n    当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现`fatal: refusing to merge unrelated histories`错误，需要使用下面命令：\n```\ngit pull origin master --allow-unrelated-histories\n```\n* 5、将本地仓库推送至远端\n```\n  git push -u origin master \n```\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误\n![](/assets/GitImg4.png)\n推送正常\n![](/assets/GitImg5.png)\n\n### 二、将本地分支提交到远程\n\n* 1、建立本地到上游（远端）仓的链接\n```\ngit branch --set-upstream-to=origin\n```\n![](/assets/GitImg6.png)\n\n* 2、拉取远程分支内容\n```\ngit pull --allow-unrelated-histories\n```\n* 3、将本地分支推送至远程\n```\ngit push origin EditBranch\n```\n![](/assets/GitImg7.png)\n\n\n### 三、合并多次提交\n\n```\ngit rebase -i HEAD~3\n```\n\n如果在合并的过程中出现冲突需要先解决冲突，再进行合并\n```\ngit rebase --continue  \n```\n\n如果放弃本次合并，使用\n```\ngit rebase --abort \n```\n### 四、Git多用户进行管理\n\n需要为每一个仓库设置user、email\n\n* 第一步：取消git的global用户以及邮箱\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n\n```\n\n\n* 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。\n\n```\ngit config  user.email \"xxxx@xx.com\"\ngit config  user.name \"xxxx\"\n\n```\n\n### 五、git reset --hard --soft与git revert\n\n`git reset --hard HEAD~1`修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。\n\n`git reset --soft HEAD~1`修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。\n\n#### `git revert`与`git reset`区别\n* `git reset`指向原地或者向前移动指针,直接删除commit，`git revert`创建一个逆向commit来覆盖之前commit,指针向后移动。\n*  在后续合并旧版本时，`git revert`的部分不再出现；而`git reset`在合并旧版本时，这些被回滚的提交还会再次被引入。\n\n#### 撤销 git reset\n\n`git reflog` 查看操作历史，找到之前 HEAD 的 hash 值，然后 `git reset --hard` 到那个 hash 即可\n\n\n### 六、`git cherry-pick`使用方法\n\n将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。\n\n```\ngit cherry-pick <commit id>:单独合并一个提交\ngit cherry-pick -x <commit id>：同上，不同点：保留原提交者信息。\n\ngit cherry-pick <start-commit-id>..<end-commit-id>：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支\n```\n\n\n### 七、修改git urls的路径方式\n\n#### 将urls由SSH模式修改为Https模式\n\n#### 将usrls由Https模式修改为SSH模式\n\n\n### 八、建立本地分支，并推送至远程\n\n\n### 九、更新fork的代码\n在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，\n\n\n\n\n\n\n","slug":"Other/Git/Git","published":1,"date":"2019-09-19T09:41:14.780Z","updated":"2019-11-30T11:14:32.247Z","title":"Other/Git/Git","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0u001qkguie1w65cww","content":"<h2 id=\"常用Git操作\"><a href=\"#常用Git操作\" class=\"headerlink\" title=\"常用Git操作\"></a>常用Git操作</h2><h3 id=\"一、将本地已有仓库推送到远程仓库\"><a href=\"#一、将本地已有仓库推送到远程仓库\" class=\"headerlink\" title=\"一、将本地已有仓库推送到远程仓库\"></a>一、将本地已有仓库推送到远程仓库</h3><ul>\n<li><p>1、将本地仓库与远程仓库建立关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:Lucius&#x2F;GitTest.git</span><br></pre></td></tr></table></figure>\n<p>  查看本地仓库与远程仓库关联情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p>  删除与远程仓库关联 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2、设置用户名和密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -global user.name &quot;&quot;</span><br><span class=\"line\">git config -global user.email &quot;&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>3、设置SSH Key,<br>  生成SSH Key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li>\n<li><ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-C 设置注释文字，比如邮箱。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-f 指定密钥文件存储文件名。 **<br><img src=\"/assets/GitImg1.png\" alt=\"\"><br>在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中<br><img src=\"/assets/GitImg2.png\" alt=\"\"></li>\n</ul>\n</li>\n<li><p>4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg3.png\" alt=\"\"><br>  当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现<code>fatal: refusing to merge unrelated histories</code>错误，需要使用下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>5、将本地仓库推送至远端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误<br><img src=\"/assets/GitImg4.png\" alt=\"\"><br>推送正常<br><img src=\"/assets/GitImg5.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"二、将本地分支提交到远程\"><a href=\"#二、将本地分支提交到远程\" class=\"headerlink\" title=\"二、将本地分支提交到远程\"></a>二、将本地分支提交到远程</h3><ul>\n<li><p>1、建立本地到上游（远端）仓的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg6.png\" alt=\"\"></p>\n</li>\n<li><p>2、拉取远程分支内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>3、将本地分支推送至远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin EditBranch</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg7.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"三、合并多次提交\"><a href=\"#三、合并多次提交\" class=\"headerlink\" title=\"三、合并多次提交\"></a>三、合并多次提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n\n<p>如果在合并的过程中出现冲突需要先解决冲突，再进行合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --continue</span><br></pre></td></tr></table></figure>\n\n<p>如果放弃本次合并，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --abort</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、Git多用户进行管理\"><a href=\"#四、Git多用户进行管理\" class=\"headerlink\" title=\"四、Git多用户进行管理\"></a>四、Git多用户进行管理</h3><p>需要为每一个仓库设置user、email</p>\n<ul>\n<li>第一步：取消git的global用户以及邮箱</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset user.name</span><br><span class=\"line\">git config --global --unset user.email</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config  user.email &quot;xxxx@xx.com&quot;</span><br><span class=\"line\">git config  user.name &quot;xxxx&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git-reset-–hard-–soft与git-revert\"><a href=\"#五、git-reset-–hard-–soft与git-revert\" class=\"headerlink\" title=\"五、git reset –hard –soft与git revert\"></a>五、git reset –hard –soft与git revert</h3><p><code>git reset --hard HEAD~1</code>修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。</p>\n<p><code>git reset --soft HEAD~1</code>修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。</p>\n<h4 id=\"git-revert与git-reset区别\"><a href=\"#git-revert与git-reset区别\" class=\"headerlink\" title=\"git revert与git reset区别\"></a><code>git revert</code>与<code>git reset</code>区别</h4><ul>\n<li><code>git reset</code>指向原地或者向前移动指针,直接删除commit，<code>git revert</code>创建一个逆向commit来覆盖之前commit,指针向后移动。</li>\n<li>在后续合并旧版本时，<code>git revert</code>的部分不再出现；而<code>git reset</code>在合并旧版本时，这些被回滚的提交还会再次被引入。</li>\n</ul>\n<h4 id=\"撤销-git-reset\"><a href=\"#撤销-git-reset\" class=\"headerlink\" title=\"撤销 git reset\"></a>撤销 git reset</h4><p><code>git reflog</code> 查看操作历史，找到之前 HEAD 的 hash 值，然后 <code>git reset --hard</code> 到那个 hash 即可</p>\n<h3 id=\"六、git-cherry-pick使用方法\"><a href=\"#六、git-cherry-pick使用方法\" class=\"headerlink\" title=\"六、git cherry-pick使用方法\"></a>六、<code>git cherry-pick</code>使用方法</h3><p>将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;commit id&gt;:单独合并一个提交</span><br><span class=\"line\">git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。</span><br><span class=\"line\"></span><br><span class=\"line\">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"七、修改git-urls的路径方式\"><a href=\"#七、修改git-urls的路径方式\" class=\"headerlink\" title=\"七、修改git urls的路径方式\"></a>七、修改git urls的路径方式</h3><h4 id=\"将urls由SSH模式修改为Https模式\"><a href=\"#将urls由SSH模式修改为Https模式\" class=\"headerlink\" title=\"将urls由SSH模式修改为Https模式\"></a>将urls由SSH模式修改为Https模式</h4><h4 id=\"将usrls由Https模式修改为SSH模式\"><a href=\"#将usrls由Https模式修改为SSH模式\" class=\"headerlink\" title=\"将usrls由Https模式修改为SSH模式\"></a>将usrls由Https模式修改为SSH模式</h4><h3 id=\"八、建立本地分支，并推送至远程\"><a href=\"#八、建立本地分支，并推送至远程\" class=\"headerlink\" title=\"八、建立本地分支，并推送至远程\"></a>八、建立本地分支，并推送至远程</h3><h3 id=\"九、更新fork的代码\"><a href=\"#九、更新fork的代码\" class=\"headerlink\" title=\"九、更新fork的代码\"></a>九、更新fork的代码</h3><p>在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用Git操作\"><a href=\"#常用Git操作\" class=\"headerlink\" title=\"常用Git操作\"></a>常用Git操作</h2><h3 id=\"一、将本地已有仓库推送到远程仓库\"><a href=\"#一、将本地已有仓库推送到远程仓库\" class=\"headerlink\" title=\"一、将本地已有仓库推送到远程仓库\"></a>一、将本地已有仓库推送到远程仓库</h3><ul>\n<li><p>1、将本地仓库与远程仓库建立关联</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:Lucius&#x2F;GitTest.git</span><br></pre></td></tr></table></figure>\n<p>  查看本地仓库与远程仓库关联情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<p>  删除与远程仓库关联 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2、设置用户名和密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -global user.name &quot;&quot;</span><br><span class=\"line\">git config -global user.email &quot;&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>3、设置SSH Key,<br>  生成SSH Key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li>\n<li><ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-C 设置注释文字，比如邮箱。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-f 指定密钥文件存储文件名。 **<br><img src=\"/assets/GitImg1.png\" alt=\"\"><br>在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中<br><img src=\"/assets/GitImg2.png\" alt=\"\"></li>\n</ul>\n</li>\n<li><p>4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg3.png\" alt=\"\"><br>  当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现<code>fatal: refusing to merge unrelated histories</code>错误，需要使用下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>5、将本地仓库推送至远端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误<br><img src=\"/assets/GitImg4.png\" alt=\"\"><br>推送正常<br><img src=\"/assets/GitImg5.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"二、将本地分支提交到远程\"><a href=\"#二、将本地分支提交到远程\" class=\"headerlink\" title=\"二、将本地分支提交到远程\"></a>二、将本地分支提交到远程</h3><ul>\n<li><p>1、建立本地到上游（远端）仓的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg6.png\" alt=\"\"></p>\n</li>\n<li><p>2、拉取远程分支内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>3、将本地分支推送至远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin EditBranch</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/GitImg7.png\" alt=\"\"></p>\n</li>\n</ul>\n<h3 id=\"三、合并多次提交\"><a href=\"#三、合并多次提交\" class=\"headerlink\" title=\"三、合并多次提交\"></a>三、合并多次提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n\n<p>如果在合并的过程中出现冲突需要先解决冲突，再进行合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --continue</span><br></pre></td></tr></table></figure>\n\n<p>如果放弃本次合并，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --abort</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、Git多用户进行管理\"><a href=\"#四、Git多用户进行管理\" class=\"headerlink\" title=\"四、Git多用户进行管理\"></a>四、Git多用户进行管理</h3><p>需要为每一个仓库设置user、email</p>\n<ul>\n<li>第一步：取消git的global用户以及邮箱</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset user.name</span><br><span class=\"line\">git config --global --unset user.email</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config  user.email &quot;xxxx@xx.com&quot;</span><br><span class=\"line\">git config  user.name &quot;xxxx&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、git-reset-–hard-–soft与git-revert\"><a href=\"#五、git-reset-–hard-–soft与git-revert\" class=\"headerlink\" title=\"五、git reset –hard –soft与git revert\"></a>五、git reset –hard –soft与git revert</h3><p><code>git reset --hard HEAD~1</code>修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。</p>\n<p><code>git reset --soft HEAD~1</code>修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。</p>\n<h4 id=\"git-revert与git-reset区别\"><a href=\"#git-revert与git-reset区别\" class=\"headerlink\" title=\"git revert与git reset区别\"></a><code>git revert</code>与<code>git reset</code>区别</h4><ul>\n<li><code>git reset</code>指向原地或者向前移动指针,直接删除commit，<code>git revert</code>创建一个逆向commit来覆盖之前commit,指针向后移动。</li>\n<li>在后续合并旧版本时，<code>git revert</code>的部分不再出现；而<code>git reset</code>在合并旧版本时，这些被回滚的提交还会再次被引入。</li>\n</ul>\n<h4 id=\"撤销-git-reset\"><a href=\"#撤销-git-reset\" class=\"headerlink\" title=\"撤销 git reset\"></a>撤销 git reset</h4><p><code>git reflog</code> 查看操作历史，找到之前 HEAD 的 hash 值，然后 <code>git reset --hard</code> 到那个 hash 即可</p>\n<h3 id=\"六、git-cherry-pick使用方法\"><a href=\"#六、git-cherry-pick使用方法\" class=\"headerlink\" title=\"六、git cherry-pick使用方法\"></a>六、<code>git cherry-pick</code>使用方法</h3><p>将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;commit id&gt;:单独合并一个提交</span><br><span class=\"line\">git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。</span><br><span class=\"line\"></span><br><span class=\"line\">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"七、修改git-urls的路径方式\"><a href=\"#七、修改git-urls的路径方式\" class=\"headerlink\" title=\"七、修改git urls的路径方式\"></a>七、修改git urls的路径方式</h3><h4 id=\"将urls由SSH模式修改为Https模式\"><a href=\"#将urls由SSH模式修改为Https模式\" class=\"headerlink\" title=\"将urls由SSH模式修改为Https模式\"></a>将urls由SSH模式修改为Https模式</h4><h4 id=\"将usrls由Https模式修改为SSH模式\"><a href=\"#将usrls由Https模式修改为SSH模式\" class=\"headerlink\" title=\"将usrls由Https模式修改为SSH模式\"></a>将usrls由Https模式修改为SSH模式</h4><h3 id=\"八、建立本地分支，并推送至远程\"><a href=\"#八、建立本地分支，并推送至远程\" class=\"headerlink\" title=\"八、建立本地分支，并推送至远程\"></a>八、建立本地分支，并推送至远程</h3><h3 id=\"九、更新fork的代码\"><a href=\"#九、更新fork的代码\" class=\"headerlink\" title=\"九、更新fork的代码\"></a>九、更新fork的代码</h3><p>在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，</p>\n"},{"_content":"\n\n## Android 在已有的项目中引入JNI 最简方式\n\n### JNI与NDK\n\nJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；\nNDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；\n\n            \n### 下载NDK和编译工具\n* NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。\n* CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。\n* LLDB：Android Studio 用于调试原生代码的调试程序。 \n\n安装方式：\n\nAndroid Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载\n\n![](/assets/Android JNI.png)\n\n在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置\n![](/assets/Android JNI1.png)\n\n\n\n### 添加CMakeLists.txt和native-lib-cpp文件\n\n现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码\n```xml\n\n     # 设置cmake的最低版本\n     cmake_minimum_required(VERSION 3.4.1)\n\n    # 设置生成的so库的信息\n    add_library( \n        #生成的so库的名字\n        native-lib\n        # 生成的so库的类型，类型分为两种：\n        #  STATIC：静态库，为目标文件的归档文件\n        #  SHARED：动态库，会被动态链接，在运行时被加载\n        SHARED\n        # 设置源文件的位置，可以是很多个源文件，都需要添加进去\n        native-lib.cpp)\n    # 从系统里查找依赖库，可添加多个\n    find_library(\n        log-lib\n        # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest\n        log)\n     # 配置目标库的链接，即相互依赖关系\n  target_link_libraries(\n        # 目标库（最终生成的库）\n        native-lib\n        # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用\n        # 如果是第三方库，可以直接引用\n        # 每行引用一个库\n        ${log-lib})\n\n\n```\n\n在Andorid的Module下，右键选择 **Link C++ Project with Gradle**，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码\n\n```xml\n    android {\n      …\n      externalNativeBuild {\n        cmake {\n            path file('src/main/cpp/CMakeLists.txt')\n        }\n    }\n```\n\n在native-lib.cpp添加如下代码，方法名命名规则`Java_demo_lucius_baselib_MainActivity_stringFromJNI`，以`Java`作为开头,`demo_lucius_baselib_MainActivity`是“包名+调用类名”，`stringFromJNI`方法名。即` Java_{package_and_classname}_{function_name}(JNI_arguments)`，包名的`.`被下划线替代。\n\n```c++\n    #include <jni.h>\n    #include <string>\n    extern \"C\" JNIEXPORT jstring JNICALL\n    Java_demo_lucius_baselib_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n        std::string text = \"String from C++\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n```\n在上述函数`JNI_arguments`有`JNIEnv*`和`jobject`\n* JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。\n* jobject，指向Java对象的`object`。\n\n`extern \"C\"`只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。\n\n\n在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\"\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    static {\n        //用于在运行时加载本地库\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        System.out.println(stringFromJNI());\n        }\n\n    public native String stringFromJNI();\n\n\n```\n\n### 在JNI中使用C语言，新建helloJIN.c文件\n\n```c\n    #include <jni.h>        // JNI header provided by JDK\n    #include <stdio.h>      // C Standard IO Header\n\n    // Implementation of the native method sayHello()\n    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {\n       printf(\"Hello World!\\n\");\n       return;\n    }\n\n```\n\n\n### JNI基础类型介绍\n\n在`jni.h`文件中定义了预编译类型，区分Java、C++以及C\n\n```c\n\n/* Primitive types that match up with Java equivalents. */\ntypedef uint8_t  jboolean; /* unsigned 8 bits */\ntypedef int8_t   jbyte;    /* signed 8 bits */\ntypedef uint16_t jchar;    /* unsigned 16 bits */\ntypedef int16_t  jshort;   /* signed 16 bits */\ntypedef int32_t  jint;     /* signed 32 bits */\ntypedef int64_t  jlong;    /* signed 64 bits */\ntypedef float    jfloat;   /* 32-bit IEEE 754 */\ntypedef double   jdouble;  /* 64-bit IEEE 754 */\n\n/* \"cardinal indices and sizes\" */\ntypedef jint     jsize;\n\n#ifdef __cplusplus\n/*\n * Reference types, in C++\n */\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n\ntypedef _jobject*       jobject;\ntypedef _jclass*        jclass;\ntypedef _jstring*       jstring;\ntypedef _jarray*        jarray;\ntypedef _jobjectArray*  jobjectArray;\ntypedef _jbooleanArray* jbooleanArray;\ntypedef _jbyteArray*    jbyteArray;\ntypedef _jcharArray*    jcharArray;\ntypedef _jshortArray*   jshortArray;\ntypedef _jintArray*     jintArray;\ntypedef _jlongArray*    jlongArray;\ntypedef _jfloatArray*   jfloatArray;\ntypedef _jdoubleArray*  jdoubleArray;\ntypedef _jthrowable*    jthrowable;\ntypedef _jobject*       jweak;\n\n\n#else /* not __cplusplus */\n\n/*\n * Reference types, in C.\n */\ntypedef void*           jobject;\ntypedef jobject         jclass;\ntypedef jobject         jstring;\ntypedef jobject         jarray;\ntypedef jarray          jobjectArray;\ntypedef jarray          jbooleanArray;\ntypedef jarray          jbyteArray;\ntypedef jarray          jcharArray;\ntypedef jarray          jshortArray;\ntypedef jarray          jintArray;\ntypedef jarray          jlongArray;\ntypedef jarray          jfloatArray;\ntypedef jarray          jdoubleArray;\ntypedef jobject         jthrowable;\ntypedef jobject         jweak;\n\n#endif /* not __cplusplus */\n\n```\n\n\n#### Java基本数据类型与Native层中的数据对应关系\n这些基本数据类型可以在Native层直接使用。\n\n![](/assets/Android JNI2.png)\n\n#### Java引用数据类型与Native层中的数据对应关系\nJava引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为`jobjectArray`类型进行使用。    \n\n![](/assets/Android JNI3.png)\n\n在JNI中二维数组的使用\n```java\n     //获取一维数组的引用，即jintArray类型\n     jclass intArrayClass=env->FindClass(\"[I\");  \n     //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize\n     jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null);\n     \n```\n\n#### jfieldID 和jmethodID\n\n当Native层需要调用Java的某个方法时，需用`jmethodID`表示，变量则用`jfieldID`表示。`jni.h`中对jfieldID和jmethodID的定义\n\n```c++\n    struct _jfieldID;                       /* opaque structure */\n    typedef struct _jfieldID* jfieldID;     /* field IDs */\n\n    struct _jmethodID;                      /* opaque structure */\n    typedef struct _jmethodID* jmethodID;   /* method IDs */\n```\n\n在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。\n\n```c++\n    //获取jfieldID\n      jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetFieldID(this, clazz, name, sig); }\n\n    //获取jmethodID\n     jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetMethodID(this, clazz, name, sig); }\n\n```\n以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用\n\n\n\n\n\n\n\n#### JavaVM介绍\n\nJavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。`jni.h`的定义中，在C++模式下，`JavaVM`是一个结构体；在C语言模式下`JavaVM`是是一个指向方法接口指针的指针。\n\n#### JNIEnv介绍\n\nJNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。`jni.h`的定义中，在C++模式下，`JNIEnv`是一个结构体；在C语言模式下`JNIEnv`是是一个指向方法接口指针的指针。\n\n**作用：**\n* 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;\n* 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;\n\n```c++\n\n    #if defined(__cplusplus)\n    typedef _JNIEnv JNIEnv;\n    typedef _JavaVM JavaVM;\n    #else\n    typedef const struct JNINativeInterface* JNIEnv;\n    typedef const struct JNIInvokeInterface* JavaVM;\n    #endif\n\n```\n\n\n\n#### JNIEnv和JavaVM调用方法\n\n* 对于C语言\n\n```\n    (*env)->方法名(env,参数列表)\n    (*vm)->方法名(vm,参数列表)\n\n```\n* 对于C++\n\n```\n    env->方法名(参数列表)\n    vm->方法名(参数列表)\n\n```\n\n### 在\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android JNI/Android Studio JNI引入.md","raw":"\n\n## Android 在已有的项目中引入JNI 最简方式\n\n### JNI与NDK\n\nJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；\nNDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；\n\n            \n### 下载NDK和编译工具\n* NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。\n* CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。\n* LLDB：Android Studio 用于调试原生代码的调试程序。 \n\n安装方式：\n\nAndroid Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载\n\n![](/assets/Android JNI.png)\n\n在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置\n![](/assets/Android JNI1.png)\n\n\n\n### 添加CMakeLists.txt和native-lib-cpp文件\n\n现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码\n```xml\n\n     # 设置cmake的最低版本\n     cmake_minimum_required(VERSION 3.4.1)\n\n    # 设置生成的so库的信息\n    add_library( \n        #生成的so库的名字\n        native-lib\n        # 生成的so库的类型，类型分为两种：\n        #  STATIC：静态库，为目标文件的归档文件\n        #  SHARED：动态库，会被动态链接，在运行时被加载\n        SHARED\n        # 设置源文件的位置，可以是很多个源文件，都需要添加进去\n        native-lib.cpp)\n    # 从系统里查找依赖库，可添加多个\n    find_library(\n        log-lib\n        # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest\n        log)\n     # 配置目标库的链接，即相互依赖关系\n  target_link_libraries(\n        # 目标库（最终生成的库）\n        native-lib\n        # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用\n        # 如果是第三方库，可以直接引用\n        # 每行引用一个库\n        ${log-lib})\n\n\n```\n\n在Andorid的Module下，右键选择 **Link C++ Project with Gradle**，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码\n\n```xml\n    android {\n      …\n      externalNativeBuild {\n        cmake {\n            path file('src/main/cpp/CMakeLists.txt')\n        }\n    }\n```\n\n在native-lib.cpp添加如下代码，方法名命名规则`Java_demo_lucius_baselib_MainActivity_stringFromJNI`，以`Java`作为开头,`demo_lucius_baselib_MainActivity`是“包名+调用类名”，`stringFromJNI`方法名。即` Java_{package_and_classname}_{function_name}(JNI_arguments)`，包名的`.`被下划线替代。\n\n```c++\n    #include <jni.h>\n    #include <string>\n    extern \"C\" JNIEXPORT jstring JNICALL\n    Java_demo_lucius_baselib_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n        std::string text = \"String from C++\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n```\n在上述函数`JNI_arguments`有`JNIEnv*`和`jobject`\n* JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。\n* jobject，指向Java对象的`object`。\n\n`extern \"C\"`只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。\n\n\n在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\"\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    static {\n        //用于在运行时加载本地库\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        System.out.println(stringFromJNI());\n        }\n\n    public native String stringFromJNI();\n\n\n```\n\n### 在JNI中使用C语言，新建helloJIN.c文件\n\n```c\n    #include <jni.h>        // JNI header provided by JDK\n    #include <stdio.h>      // C Standard IO Header\n\n    // Implementation of the native method sayHello()\n    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {\n       printf(\"Hello World!\\n\");\n       return;\n    }\n\n```\n\n\n### JNI基础类型介绍\n\n在`jni.h`文件中定义了预编译类型，区分Java、C++以及C\n\n```c\n\n/* Primitive types that match up with Java equivalents. */\ntypedef uint8_t  jboolean; /* unsigned 8 bits */\ntypedef int8_t   jbyte;    /* signed 8 bits */\ntypedef uint16_t jchar;    /* unsigned 16 bits */\ntypedef int16_t  jshort;   /* signed 16 bits */\ntypedef int32_t  jint;     /* signed 32 bits */\ntypedef int64_t  jlong;    /* signed 64 bits */\ntypedef float    jfloat;   /* 32-bit IEEE 754 */\ntypedef double   jdouble;  /* 64-bit IEEE 754 */\n\n/* \"cardinal indices and sizes\" */\ntypedef jint     jsize;\n\n#ifdef __cplusplus\n/*\n * Reference types, in C++\n */\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n\ntypedef _jobject*       jobject;\ntypedef _jclass*        jclass;\ntypedef _jstring*       jstring;\ntypedef _jarray*        jarray;\ntypedef _jobjectArray*  jobjectArray;\ntypedef _jbooleanArray* jbooleanArray;\ntypedef _jbyteArray*    jbyteArray;\ntypedef _jcharArray*    jcharArray;\ntypedef _jshortArray*   jshortArray;\ntypedef _jintArray*     jintArray;\ntypedef _jlongArray*    jlongArray;\ntypedef _jfloatArray*   jfloatArray;\ntypedef _jdoubleArray*  jdoubleArray;\ntypedef _jthrowable*    jthrowable;\ntypedef _jobject*       jweak;\n\n\n#else /* not __cplusplus */\n\n/*\n * Reference types, in C.\n */\ntypedef void*           jobject;\ntypedef jobject         jclass;\ntypedef jobject         jstring;\ntypedef jobject         jarray;\ntypedef jarray          jobjectArray;\ntypedef jarray          jbooleanArray;\ntypedef jarray          jbyteArray;\ntypedef jarray          jcharArray;\ntypedef jarray          jshortArray;\ntypedef jarray          jintArray;\ntypedef jarray          jlongArray;\ntypedef jarray          jfloatArray;\ntypedef jarray          jdoubleArray;\ntypedef jobject         jthrowable;\ntypedef jobject         jweak;\n\n#endif /* not __cplusplus */\n\n```\n\n\n#### Java基本数据类型与Native层中的数据对应关系\n这些基本数据类型可以在Native层直接使用。\n\n![](/assets/Android JNI2.png)\n\n#### Java引用数据类型与Native层中的数据对应关系\nJava引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为`jobjectArray`类型进行使用。    \n\n![](/assets/Android JNI3.png)\n\n在JNI中二维数组的使用\n```java\n     //获取一维数组的引用，即jintArray类型\n     jclass intArrayClass=env->FindClass(\"[I\");  \n     //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize\n     jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null);\n     \n```\n\n#### jfieldID 和jmethodID\n\n当Native层需要调用Java的某个方法时，需用`jmethodID`表示，变量则用`jfieldID`表示。`jni.h`中对jfieldID和jmethodID的定义\n\n```c++\n    struct _jfieldID;                       /* opaque structure */\n    typedef struct _jfieldID* jfieldID;     /* field IDs */\n\n    struct _jmethodID;                      /* opaque structure */\n    typedef struct _jmethodID* jmethodID;   /* method IDs */\n```\n\n在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。\n\n```c++\n    //获取jfieldID\n      jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetFieldID(this, clazz, name, sig); }\n\n    //获取jmethodID\n     jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetMethodID(this, clazz, name, sig); }\n\n```\n以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用\n\n\n\n\n\n\n\n#### JavaVM介绍\n\nJavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。`jni.h`的定义中，在C++模式下，`JavaVM`是一个结构体；在C语言模式下`JavaVM`是是一个指向方法接口指针的指针。\n\n#### JNIEnv介绍\n\nJNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。`jni.h`的定义中，在C++模式下，`JNIEnv`是一个结构体；在C语言模式下`JNIEnv`是是一个指向方法接口指针的指针。\n\n**作用：**\n* 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;\n* 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;\n\n```c++\n\n    #if defined(__cplusplus)\n    typedef _JNIEnv JNIEnv;\n    typedef _JavaVM JavaVM;\n    #else\n    typedef const struct JNINativeInterface* JNIEnv;\n    typedef const struct JNIInvokeInterface* JavaVM;\n    #endif\n\n```\n\n\n\n#### JNIEnv和JavaVM调用方法\n\n* 对于C语言\n\n```\n    (*env)->方法名(env,参数列表)\n    (*vm)->方法名(vm,参数列表)\n\n```\n* 对于C++\n\n```\n    env->方法名(参数列表)\n    vm->方法名(参数列表)\n\n```\n\n### 在\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android JNI/Android Studio JNI引入","published":1,"date":"2019-09-21T00:52:10.111Z","updated":"2019-09-27T08:23:54.029Z","title":"Android/Android JNI/Android Studio JNI引入","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0v001rkguihe8t8v4u","content":"<h2 id=\"Android-在已有的项目中引入JNI-最简方式\"><a href=\"#Android-在已有的项目中引入JNI-最简方式\" class=\"headerlink\" title=\"Android 在已有的项目中引入JNI 最简方式\"></a>Android 在已有的项目中引入JNI 最简方式</h2><h3 id=\"JNI与NDK\"><a href=\"#JNI与NDK\" class=\"headerlink\" title=\"JNI与NDK\"></a>JNI与NDK</h3><p>JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；<br>NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；</p>\n<h3 id=\"下载NDK和编译工具\"><a href=\"#下载NDK和编译工具\" class=\"headerlink\" title=\"下载NDK和编译工具\"></a>下载NDK和编译工具</h3><ul>\n<li>NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。</li>\n<li>CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。</li>\n<li>LLDB：Android Studio 用于调试原生代码的调试程序。 </li>\n</ul>\n<p>安装方式：</p>\n<p>Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载</p>\n<p>![](/assets/Android JNI.png)</p>\n<p>在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置<br>![](/assets/Android JNI1.png)</p>\n<h3 id=\"添加CMakeLists-txt和native-lib-cpp文件\"><a href=\"#添加CMakeLists-txt和native-lib-cpp文件\" class=\"headerlink\" title=\"添加CMakeLists.txt和native-lib-cpp文件\"></a>添加CMakeLists.txt和native-lib-cpp文件</h3><p>现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   # 设置cmake的最低版本</span><br><span class=\"line\">   cmake_minimum_required(VERSION 3.4.1)</span><br><span class=\"line\"></span><br><span class=\"line\">  # 设置生成的so库的信息</span><br><span class=\"line\">  add_library( </span><br><span class=\"line\">      #生成的so库的名字</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 生成的so库的类型，类型分为两种：</span><br><span class=\"line\">      #  STATIC：静态库，为目标文件的归档文件</span><br><span class=\"line\">      #  SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class=\"line\">      SHARED</span><br><span class=\"line\">      # 设置源文件的位置，可以是很多个源文件，都需要添加进去</span><br><span class=\"line\">      native-lib.cpp)</span><br><span class=\"line\">  # 从系统里查找依赖库，可添加多个</span><br><span class=\"line\">  find_library(</span><br><span class=\"line\">      log-lib</span><br><span class=\"line\">      # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest</span><br><span class=\"line\">      log)</span><br><span class=\"line\">   # 配置目标库的链接，即相互依赖关系</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">      # 目标库（最终生成的库）</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加$&#123;&#125;进行引用</span><br><span class=\"line\">      # 如果是第三方库，可以直接引用</span><br><span class=\"line\">      # 每行引用一个库</span><br><span class=\"line\">      $&#123;log-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在Andorid的Module下，右键选择 <strong>Link C++ Project with Gradle</strong>，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  …</span><br><span class=\"line\">  externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path file('src/main/cpp/CMakeLists.txt')</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在native-lib.cpp添加如下代码，方法名命名规则<code>Java_demo_lucius_baselib_MainActivity_stringFromJNI</code>，以<code>Java</code>作为开头,<code>demo_lucius_baselib_MainActivity</code>是“包名+调用类名”，<code>stringFromJNI</code>方法名。即<code>Java_{package_and_classname}_{function_name}(JNI_arguments)</code>，包名的<code>.</code>被下划线替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_demo_lucius_baselib_MainActivity_stringFromJNI(</span><br><span class=\"line\">    JNIEnv *env,</span><br><span class=\"line\">    jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"built_in\">text</span> = <span class=\"string\">\"String from C++\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述函数<code>JNI_arguments</code>有<code>JNIEnv*</code>和<code>jobject</code></p>\n<ul>\n<li>JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。</li>\n<li>jobject，指向Java对象的<code>object</code>。</li>\n</ul>\n<p><code>extern &quot;C&quot;</code>只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。</p>\n<p>在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于在运行时加载本地库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">\"native-lib\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringFromJNI());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在JNI中使用C语言，新建helloJIN-c文件\"><a href=\"#在JNI中使用C语言，新建helloJIN-c文件\" class=\"headerlink\" title=\"在JNI中使用C语言，新建helloJIN.c文件\"></a>在JNI中使用C语言，新建helloJIN.c文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;        // JNI header provided by JDK</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;      // C Standard IO Header</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation of the native method sayHello()</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_HelloJNI_sayHello</span><span class=\"params\">(JNIEnv *env, jobject thisObj)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"JNI基础类型介绍\"><a href=\"#JNI基础类型介绍\" class=\"headerlink\" title=\"JNI基础类型介绍\"></a>JNI基础类型介绍</h3><p>在<code>jni.h</code>文件中定义了预编译类型，区分Java、C++以及C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Primitive types that match up with Java equivalents. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint8_t</span>  jboolean; <span class=\"comment\">/* unsigned 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int8_t</span>   jbyte;    <span class=\"comment\">/* signed 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint16_t</span> jchar;    <span class=\"comment\">/* unsigned 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int16_t</span>  jshort;   <span class=\"comment\">/* signed 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int32_t</span>  jint;     <span class=\"comment\">/* signed 32 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int64_t</span>  jlong;    <span class=\"comment\">/* signed 64 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">float</span>    jfloat;   <span class=\"comment\">/* 32-bit IEEE 754 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span>   jdouble;  <span class=\"comment\">/* 64-bit IEEE 754 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* \"cardinal indices and sizes\" */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jint     jsize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C++</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobject</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jclass</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jstring</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jarray</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobjectArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbooleanArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbyteArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jcharArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jshortArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jintArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jlongArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jfloatArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jdoubleArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jthrowable</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass*        jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jstring*       jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jarray*        jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jcharArray*    jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jshortArray*   jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jintArray*     jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jlongArray*    jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jthrowable*    jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>*           jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Java基本数据类型与Native层中的数据对应关系\"><a href=\"#Java基本数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java基本数据类型与Native层中的数据对应关系\"></a>Java基本数据类型与Native层中的数据对应关系</h4><p>这些基本数据类型可以在Native层直接使用。</p>\n<p>![](/assets/Android JNI2.png)</p>\n<h4 id=\"Java引用数据类型与Native层中的数据对应关系\"><a href=\"#Java引用数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java引用数据类型与Native层中的数据对应关系\"></a>Java引用数据类型与Native层中的数据对应关系</h4><p>Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为<code>jobjectArray</code>类型进行使用。    </p>\n<p>![](/assets/Android JNI3.png)</p>\n<p>在JNI中二维数组的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一维数组的引用，即jintArray类型</span></span><br><span class=\"line\">jclass intArrayClass=env-&gt;FindClass(<span class=\"string\">\"[I\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize</span></span><br><span class=\"line\">jobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"jfieldID-和jmethodID\"><a href=\"#jfieldID-和jmethodID\" class=\"headerlink\" title=\"jfieldID 和jmethodID\"></a>jfieldID 和jmethodID</h4><p>当Native层需要调用Java的某个方法时，需用<code>jmethodID</code>表示，变量则用<code>jfieldID</code>表示。<code>jni.h</code>中对jfieldID和jmethodID的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>                       <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>* <span class=\"title\">jfieldID</span>;</span>     <span class=\"comment\">/* field IDs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>                      <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>* <span class=\"title\">jmethodID</span>;</span>   <span class=\"comment\">/* method IDs */</span></span><br></pre></td></tr></table></figure>\n\n<p>在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取jfieldID</span></span><br><span class=\"line\">  <span class=\"function\">jfieldID <span class=\"title\">GetFieldID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetFieldID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取jmethodID</span></span><br><span class=\"line\"> <span class=\"function\">jmethodID <span class=\"title\">GetMethodID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetMethodID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br></pre></td></tr></table></figure>\n<p>以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用</p>\n<h4 id=\"JavaVM介绍\"><a href=\"#JavaVM介绍\" class=\"headerlink\" title=\"JavaVM介绍\"></a>JavaVM介绍</h4><p>JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。<code>jni.h</code>的定义中，在C++模式下，<code>JavaVM</code>是一个结构体；在C语言模式下<code>JavaVM</code>是是一个指向方法接口指针的指针。</p>\n<h4 id=\"JNIEnv介绍\"><a href=\"#JNIEnv介绍\" class=\"headerlink\" title=\"JNIEnv介绍\"></a>JNIEnv介绍</h4><p>JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。<code>jni.h</code>的定义中，在C++模式下，<code>JNIEnv</code>是一个结构体；在C语言模式下<code>JNIEnv</code>是是一个指向方法接口指针的指针。</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;</li>\n<li>操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(__cplusplus)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JNIEnv JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JavaVM JavaVM;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span>* <span class=\"title\">JNIEnv</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"JNIEnv和JavaVM调用方法\"><a href=\"#JNIEnv和JavaVM调用方法\" class=\"headerlink\" title=\"JNIEnv和JavaVM调用方法\"></a>JNIEnv和JavaVM调用方法</h4><ul>\n<li>对于C语言</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;方法名(env,参数列表)</span><br><span class=\"line\">(*vm)-&gt;方法名(vm,参数列表)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于C++</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env-&gt;方法名(参数列表)</span><br><span class=\"line\">vm-&gt;方法名(参数列表)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在\"><a href=\"#在\" class=\"headerlink\" title=\"在\"></a>在</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-在已有的项目中引入JNI-最简方式\"><a href=\"#Android-在已有的项目中引入JNI-最简方式\" class=\"headerlink\" title=\"Android 在已有的项目中引入JNI 最简方式\"></a>Android 在已有的项目中引入JNI 最简方式</h2><h3 id=\"JNI与NDK\"><a href=\"#JNI与NDK\" class=\"headerlink\" title=\"JNI与NDK\"></a>JNI与NDK</h3><p>JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；<br>NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；</p>\n<h3 id=\"下载NDK和编译工具\"><a href=\"#下载NDK和编译工具\" class=\"headerlink\" title=\"下载NDK和编译工具\"></a>下载NDK和编译工具</h3><ul>\n<li>NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。</li>\n<li>CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。</li>\n<li>LLDB：Android Studio 用于调试原生代码的调试程序。 </li>\n</ul>\n<p>安装方式：</p>\n<p>Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载</p>\n<p>![](/assets/Android JNI.png)</p>\n<p>在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置<br>![](/assets/Android JNI1.png)</p>\n<h3 id=\"添加CMakeLists-txt和native-lib-cpp文件\"><a href=\"#添加CMakeLists-txt和native-lib-cpp文件\" class=\"headerlink\" title=\"添加CMakeLists.txt和native-lib-cpp文件\"></a>添加CMakeLists.txt和native-lib-cpp文件</h3><p>现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   # 设置cmake的最低版本</span><br><span class=\"line\">   cmake_minimum_required(VERSION 3.4.1)</span><br><span class=\"line\"></span><br><span class=\"line\">  # 设置生成的so库的信息</span><br><span class=\"line\">  add_library( </span><br><span class=\"line\">      #生成的so库的名字</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 生成的so库的类型，类型分为两种：</span><br><span class=\"line\">      #  STATIC：静态库，为目标文件的归档文件</span><br><span class=\"line\">      #  SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class=\"line\">      SHARED</span><br><span class=\"line\">      # 设置源文件的位置，可以是很多个源文件，都需要添加进去</span><br><span class=\"line\">      native-lib.cpp)</span><br><span class=\"line\">  # 从系统里查找依赖库，可添加多个</span><br><span class=\"line\">  find_library(</span><br><span class=\"line\">      log-lib</span><br><span class=\"line\">      # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest</span><br><span class=\"line\">      log)</span><br><span class=\"line\">   # 配置目标库的链接，即相互依赖关系</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">      # 目标库（最终生成的库）</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加$&#123;&#125;进行引用</span><br><span class=\"line\">      # 如果是第三方库，可以直接引用</span><br><span class=\"line\">      # 每行引用一个库</span><br><span class=\"line\">      $&#123;log-lib&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在Andorid的Module下，右键选择 <strong>Link C++ Project with Gradle</strong>，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  …</span><br><span class=\"line\">  externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path file('src/main/cpp/CMakeLists.txt')</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在native-lib.cpp添加如下代码，方法名命名规则<code>Java_demo_lucius_baselib_MainActivity_stringFromJNI</code>，以<code>Java</code>作为开头,<code>demo_lucius_baselib_MainActivity</code>是“包名+调用类名”，<code>stringFromJNI</code>方法名。即<code>Java_{package_and_classname}_{function_name}(JNI_arguments)</code>，包名的<code>.</code>被下划线替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_demo_lucius_baselib_MainActivity_stringFromJNI(</span><br><span class=\"line\">    JNIEnv *env,</span><br><span class=\"line\">    jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"built_in\">text</span> = <span class=\"string\">\"String from C++\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述函数<code>JNI_arguments</code>有<code>JNIEnv*</code>和<code>jobject</code></p>\n<ul>\n<li>JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。</li>\n<li>jobject，指向Java对象的<code>object</code>。</li>\n</ul>\n<p><code>extern &quot;C&quot;</code>只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。</p>\n<p>在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于在运行时加载本地库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">\"native-lib\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringFromJNI());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在JNI中使用C语言，新建helloJIN-c文件\"><a href=\"#在JNI中使用C语言，新建helloJIN-c文件\" class=\"headerlink\" title=\"在JNI中使用C语言，新建helloJIN.c文件\"></a>在JNI中使用C语言，新建helloJIN.c文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;        // JNI header provided by JDK</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;      // C Standard IO Header</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation of the native method sayHello()</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_HelloJNI_sayHello</span><span class=\"params\">(JNIEnv *env, jobject thisObj)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"JNI基础类型介绍\"><a href=\"#JNI基础类型介绍\" class=\"headerlink\" title=\"JNI基础类型介绍\"></a>JNI基础类型介绍</h3><p>在<code>jni.h</code>文件中定义了预编译类型，区分Java、C++以及C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Primitive types that match up with Java equivalents. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint8_t</span>  jboolean; <span class=\"comment\">/* unsigned 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int8_t</span>   jbyte;    <span class=\"comment\">/* signed 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint16_t</span> jchar;    <span class=\"comment\">/* unsigned 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int16_t</span>  jshort;   <span class=\"comment\">/* signed 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int32_t</span>  jint;     <span class=\"comment\">/* signed 32 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int64_t</span>  jlong;    <span class=\"comment\">/* signed 64 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">float</span>    jfloat;   <span class=\"comment\">/* 32-bit IEEE 754 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span>   jdouble;  <span class=\"comment\">/* 64-bit IEEE 754 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* \"cardinal indices and sizes\" */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jint     jsize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C++</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobject</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jclass</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jstring</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jarray</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobjectArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbooleanArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbyteArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jcharArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jshortArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jintArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jlongArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jfloatArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jdoubleArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jthrowable</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass*        jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jstring*       jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jarray*        jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jcharArray*    jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jshortArray*   jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jintArray*     jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jlongArray*    jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jthrowable*    jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>*           jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Java基本数据类型与Native层中的数据对应关系\"><a href=\"#Java基本数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java基本数据类型与Native层中的数据对应关系\"></a>Java基本数据类型与Native层中的数据对应关系</h4><p>这些基本数据类型可以在Native层直接使用。</p>\n<p>![](/assets/Android JNI2.png)</p>\n<h4 id=\"Java引用数据类型与Native层中的数据对应关系\"><a href=\"#Java引用数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java引用数据类型与Native层中的数据对应关系\"></a>Java引用数据类型与Native层中的数据对应关系</h4><p>Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为<code>jobjectArray</code>类型进行使用。    </p>\n<p>![](/assets/Android JNI3.png)</p>\n<p>在JNI中二维数组的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一维数组的引用，即jintArray类型</span></span><br><span class=\"line\">jclass intArrayClass=env-&gt;FindClass(<span class=\"string\">\"[I\"</span>);  </span><br><span class=\"line\"><span class=\"comment\">//构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize</span></span><br><span class=\"line\">jobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"jfieldID-和jmethodID\"><a href=\"#jfieldID-和jmethodID\" class=\"headerlink\" title=\"jfieldID 和jmethodID\"></a>jfieldID 和jmethodID</h4><p>当Native层需要调用Java的某个方法时，需用<code>jmethodID</code>表示，变量则用<code>jfieldID</code>表示。<code>jni.h</code>中对jfieldID和jmethodID的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>                       <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>* <span class=\"title\">jfieldID</span>;</span>     <span class=\"comment\">/* field IDs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>                      <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>* <span class=\"title\">jmethodID</span>;</span>   <span class=\"comment\">/* method IDs */</span></span><br></pre></td></tr></table></figure>\n\n<p>在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取jfieldID</span></span><br><span class=\"line\">  <span class=\"function\">jfieldID <span class=\"title\">GetFieldID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetFieldID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取jmethodID</span></span><br><span class=\"line\"> <span class=\"function\">jmethodID <span class=\"title\">GetMethodID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetMethodID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br></pre></td></tr></table></figure>\n<p>以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用</p>\n<h4 id=\"JavaVM介绍\"><a href=\"#JavaVM介绍\" class=\"headerlink\" title=\"JavaVM介绍\"></a>JavaVM介绍</h4><p>JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。<code>jni.h</code>的定义中，在C++模式下，<code>JavaVM</code>是一个结构体；在C语言模式下<code>JavaVM</code>是是一个指向方法接口指针的指针。</p>\n<h4 id=\"JNIEnv介绍\"><a href=\"#JNIEnv介绍\" class=\"headerlink\" title=\"JNIEnv介绍\"></a>JNIEnv介绍</h4><p>JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。<code>jni.h</code>的定义中，在C++模式下，<code>JNIEnv</code>是一个结构体；在C语言模式下<code>JNIEnv</code>是是一个指向方法接口指针的指针。</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;</li>\n<li>操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(__cplusplus)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JNIEnv JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JavaVM JavaVM;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span>* <span class=\"title\">JNIEnv</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"JNIEnv和JavaVM调用方法\"><a href=\"#JNIEnv和JavaVM调用方法\" class=\"headerlink\" title=\"JNIEnv和JavaVM调用方法\"></a>JNIEnv和JavaVM调用方法</h4><ul>\n<li>对于C语言</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;方法名(env,参数列表)</span><br><span class=\"line\">(*vm)-&gt;方法名(vm,参数列表)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于C++</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env-&gt;方法名(参数列表)</span><br><span class=\"line\">vm-&gt;方法名(参数列表)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在\"><a href=\"#在\" class=\"headerlink\" title=\"在\"></a>在</h3>"},{"_content":"\n### gradle介绍\n\ngradle和make以及ant不同，它基于Groovy语言，而非一种配置；\n\nGradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，\n\n\n\n#### 在Moudle的build.gradle中添加依赖包\n\n```java\n    android { ... }\n\n    dependencies {\n        // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`\n        implementation project(\":mylibrary\")\n\n        // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 \n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n        // 依赖于远程库\n        implementation 'com.example.android:app-magic:12.3'\n    }\n\n```\n\n依赖包的配置有以下类型：`implementation`、`api`、`compileOnly`、`runtimeOnly`、`annotationProcessor`、`lintChecks`、`lintPublish`\n在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。\n\n```java\n    dependencies {\n        freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n    }\n\n```\n如果需要将依赖作为变量，与flavor和build type进行结合，要在`configurations`代码块中进行初始化。\n```java\n    configurations {\n        //初始化只与freeDebugRuntimeOnly相关的依赖\n        freeDebugRuntimeOnly {}\n    }\n\n    dependencies {\n        freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n```\n\n\n### 在Debug模式下使用正式签名\n\n在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错`ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.`\n\n```java\n\n    android{\n           ...\n        signingConfigs {\n            release {\n                //.jks文件放在项目目录（app目录）\n                storeFile file(\"app.jks\")//签名文件名\n                storePassword \"password\"//密码\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"//密码\n                }\n\n            debug {\n                storeFile file(\"app.jks\")\n                storePassword\"password\"\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"\n            }\n        }   \n           \n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n                signingConfig signingConfigs.release\n            }\n            debug {\n            signingConfig signingConfigs.release\n            }\n        }\n\n       ....\n    }\n```\n\n### 加速项目的构建速度\n\n#### 优化项目配置\n有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个`dev`flavor和`prod`flavor(发布版本)。\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n  productFlavors {\n    //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；\n    dev {\n      \n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n    }\n\n    prod {\n      // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。\n      \n    }\n  }\n}\n\n```\n\n可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出`devDemo`和`prodFull`\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n\n  // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度\n  flavorDimensions \"stage\", \"mode\"\n\n  productFlavors {\n    dev {\n      dimension \"stage\"\n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n      \n      //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片\n      resConfigs \"en\", \"xxhdpi\"\n      ...\n    }\n\n    prod {\n      dimension \"stage\"\n      ...\n    }\n\n    demo {\n      dimension \"mode\"\n      ...\n    }\n\n    full {\n      dimension \"mode\"\n      ...\n    }\n  }\n}\n\n```\n#### 编译类型配置\n\n```java\n    android {\n      ...\n      buildTypes {\n        debug {\n          //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`\n          ext.enableCrashlytics = false\n          //防止Crashlytics 每次更新编译的id\n          ext.alwaysUpdateBuildId = false\n        }\n}\n\n```\n#### 在Debug版本构建的过程中使用静态常量\n在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。\n\n```java\n\nint MILLIS_IN_MINUTE = 1000 * 60\nint minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE\n\nandroid {\n    ...\n    defaultConfig {\n  \n        //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk\n        versionCode 1\n        versionName \"1.0\"\n        ...\n    }\n\n    //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。\n    //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理\n    applicationVariants.all { variant ->\n        if (variant.buildType.name == \"release\") {\n            variant.mergedFlavor.versionCode = minutesSinceEpoch;\n            variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName;\n        }\n    }\n}\n\n```\n\n#### 使用增量注解处理（incremental annotation processors）\nAndroid Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。\n\n```xml\n     android.enableSeparateAnnotationProcessing = true\n```\n\n\n#### 其他方式\n\n* 使用确定的依赖，避免使用`+`，如：'com.android.tools.build:gradle:2.+'\n* 使用离线模式进行编译\n* 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。\n* 创建自定义编译任务\n* 将图片转换为WebP\n   \n   WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。\n* 禁用PNG压缩\n\n  ```java\n  \n  android {\n    buildTypes {\n        release {\n            //禁用PNG压缩\n            crunchPngs false\n        }\n    }\n\n    // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩\n    //  aaptOptions {\n    //      cruncherEnabled false\n    //  }\n}\n  ```\n  \n* 使用编译缓存\n在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，`clean build`会变得更快，因为其会调用缓存中的文件，而非重新生成。\n在gradle.gradle.properties 中指定编译缓存的路径，默认路径为`<user-home>/.android/build-cache/`\n\n```xml\n    // 执行绝对路径或者相对路径\n    android.buildCacheDir=<path-to-directory>\n    android.enableBuildCache=true\n```\n\n#### 打包编译多个版本的apk，待续\n\n\n\n\n","source":"_posts/Android/Other/Module的.gradle配置.md","raw":"\n### gradle介绍\n\ngradle和make以及ant不同，它基于Groovy语言，而非一种配置；\n\nGradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，\n\n\n\n#### 在Moudle的build.gradle中添加依赖包\n\n```java\n    android { ... }\n\n    dependencies {\n        // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`\n        implementation project(\":mylibrary\")\n\n        // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 \n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n        // 依赖于远程库\n        implementation 'com.example.android:app-magic:12.3'\n    }\n\n```\n\n依赖包的配置有以下类型：`implementation`、`api`、`compileOnly`、`runtimeOnly`、`annotationProcessor`、`lintChecks`、`lintPublish`\n在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。\n\n```java\n    dependencies {\n        freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n    }\n\n```\n如果需要将依赖作为变量，与flavor和build type进行结合，要在`configurations`代码块中进行初始化。\n```java\n    configurations {\n        //初始化只与freeDebugRuntimeOnly相关的依赖\n        freeDebugRuntimeOnly {}\n    }\n\n    dependencies {\n        freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n```\n\n\n### 在Debug模式下使用正式签名\n\n在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错`ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.`\n\n```java\n\n    android{\n           ...\n        signingConfigs {\n            release {\n                //.jks文件放在项目目录（app目录）\n                storeFile file(\"app.jks\")//签名文件名\n                storePassword \"password\"//密码\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"//密码\n                }\n\n            debug {\n                storeFile file(\"app.jks\")\n                storePassword\"password\"\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"\n            }\n        }   \n           \n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n                signingConfig signingConfigs.release\n            }\n            debug {\n            signingConfig signingConfigs.release\n            }\n        }\n\n       ....\n    }\n```\n\n### 加速项目的构建速度\n\n#### 优化项目配置\n有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个`dev`flavor和`prod`flavor(发布版本)。\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n  productFlavors {\n    //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；\n    dev {\n      \n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n    }\n\n    prod {\n      // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。\n      \n    }\n  }\n}\n\n```\n\n可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出`devDemo`和`prodFull`\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n\n  // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度\n  flavorDimensions \"stage\", \"mode\"\n\n  productFlavors {\n    dev {\n      dimension \"stage\"\n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n      \n      //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片\n      resConfigs \"en\", \"xxhdpi\"\n      ...\n    }\n\n    prod {\n      dimension \"stage\"\n      ...\n    }\n\n    demo {\n      dimension \"mode\"\n      ...\n    }\n\n    full {\n      dimension \"mode\"\n      ...\n    }\n  }\n}\n\n```\n#### 编译类型配置\n\n```java\n    android {\n      ...\n      buildTypes {\n        debug {\n          //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`\n          ext.enableCrashlytics = false\n          //防止Crashlytics 每次更新编译的id\n          ext.alwaysUpdateBuildId = false\n        }\n}\n\n```\n#### 在Debug版本构建的过程中使用静态常量\n在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。\n\n```java\n\nint MILLIS_IN_MINUTE = 1000 * 60\nint minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE\n\nandroid {\n    ...\n    defaultConfig {\n  \n        //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk\n        versionCode 1\n        versionName \"1.0\"\n        ...\n    }\n\n    //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。\n    //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理\n    applicationVariants.all { variant ->\n        if (variant.buildType.name == \"release\") {\n            variant.mergedFlavor.versionCode = minutesSinceEpoch;\n            variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName;\n        }\n    }\n}\n\n```\n\n#### 使用增量注解处理（incremental annotation processors）\nAndroid Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。\n\n```xml\n     android.enableSeparateAnnotationProcessing = true\n```\n\n\n#### 其他方式\n\n* 使用确定的依赖，避免使用`+`，如：'com.android.tools.build:gradle:2.+'\n* 使用离线模式进行编译\n* 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。\n* 创建自定义编译任务\n* 将图片转换为WebP\n   \n   WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。\n* 禁用PNG压缩\n\n  ```java\n  \n  android {\n    buildTypes {\n        release {\n            //禁用PNG压缩\n            crunchPngs false\n        }\n    }\n\n    // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩\n    //  aaptOptions {\n    //      cruncherEnabled false\n    //  }\n}\n  ```\n  \n* 使用编译缓存\n在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，`clean build`会变得更快，因为其会调用缓存中的文件，而非重新生成。\n在gradle.gradle.properties 中指定编译缓存的路径，默认路径为`<user-home>/.android/build-cache/`\n\n```xml\n    // 执行绝对路径或者相对路径\n    android.buildCacheDir=<path-to-directory>\n    android.enableBuildCache=true\n```\n\n#### 打包编译多个版本的apk，待续\n\n\n\n\n","slug":"Android/Other/Module的.gradle配置","published":1,"date":"2019-09-30T08:28:42.959Z","updated":"2019-09-30T08:28:42.959Z","title":"Android/Other/Module的.gradle配置","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0v001skguihpmq9o23","content":"<h3 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h3><p>gradle和make以及ant不同，它基于Groovy语言，而非一种配置；</p>\n<p>Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，</p>\n<h4 id=\"在Moudle的build-gradle中添加依赖包\"><a href=\"#在Moudle的build-gradle中添加依赖包\" class=\"headerlink\" title=\"在Moudle的build.gradle中添加依赖包\"></a>在Moudle的build.gradle中添加依赖包</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`</span></span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">\":mylibrary\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 </span></span></span><br><span class=\"line\"><span class=\"function\">    implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于远程库</span></span></span><br><span class=\"line\"><span class=\"function\">    implementation 'com.example.android:app-magic:12.3'</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>依赖包的配置有以下类型：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code>、<code>annotationProcessor</code>、<code>lintChecks</code>、<code>lintPublish</code><br>在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    freeImplementation <span class=\"string\">'com.google.firebase:firebase-ads:9.8.0'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要将依赖作为变量，与flavor和build type进行结合，要在<code>configurations</code>代码块中进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化只与freeDebugRuntimeOnly相关的依赖</span></span><br><span class=\"line\">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">freeDebugRuntimeOnly <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"在Debug模式下使用正式签名\"><a href=\"#在Debug模式下使用正式签名\" class=\"headerlink\" title=\"在Debug模式下使用正式签名\"></a>在Debug模式下使用正式签名</h3><p>在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错<code>ERROR: Could not get unknown property &#39;release&#39; for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//.jks文件放在项目目录（app目录）</span></span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span><span class=\"comment\">//签名文件名</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword \"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;   </span></span><br><span class=\"line\"><span class=\"function\">       </span></span><br><span class=\"line\"><span class=\"function\">    buildTypes </span>&#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class=\"line\"><span class=\"function\">            signingConfig signingConfigs.release</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">        signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加速项目的构建速度\"><a href=\"#加速项目的构建速度\" class=\"headerlink\" title=\"加速项目的构建速度\"></a>加速项目的构建速度</h3><h4 id=\"优化项目配置\"><a href=\"#优化项目配置\" class=\"headerlink\" title=\"优化项目配置\"></a>优化项目配置</h4><p>有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个<code>dev</code>flavor和<code>prod</code>flavor(发布版本)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；</span></span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出<code>devDemo</code>和<code>prodFull</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度</span></span><br><span class=\"line\">  flavorDimensions <span class=\"string\">\"stage\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片</span></span><br><span class=\"line\">      resConfigs <span class=\"string\">\"en\"</span>, <span class=\"string\">\"xxhdpi\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    demo &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    full &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译类型配置\"><a href=\"#编译类型配置\" class=\"headerlink\" title=\"编译类型配置\"></a>编译类型配置</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    android &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      buildTypes &#123;</span><br><span class=\"line\">        debug &#123;</span><br><span class=\"line\">          <span class=\"comment\">//如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`</span></span><br><span class=\"line\">          ext.enableCrashlytics = <span class=\"keyword\">false</span></span><br><span class=\"line\">          <span class=\"comment\">//防止Crashlytics 每次更新编译的id</span></span><br><span class=\"line\">          ext.alwaysUpdateBuildId = <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Debug版本构建的过程中使用静态常量\"><a href=\"#在Debug版本构建的过程中使用静态常量\" class=\"headerlink\" title=\"在Debug版本构建的过程中使用静态常量\"></a>在Debug版本构建的过程中使用静态常量</h4><p>在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MILLIS_IN_MINUTE = <span class=\"number\">1000</span> * <span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理</span></span><br><span class=\"line\">    applicationVariants.all &#123; variant -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variant.buildType.name == <span class=\"string\">\"release\"</span>) &#123;</span><br><span class=\"line\">            variant.mergedFlavor.versionCode = minutesSinceEpoch;</span><br><span class=\"line\">            variant.mergedFlavor.versionName = minutesSinceEpoch + <span class=\"string\">\"-\"</span> + variant.flavorName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用增量注解处理（incremental-annotation-processors）\"><a href=\"#使用增量注解处理（incremental-annotation-processors）\" class=\"headerlink\" title=\"使用增量注解处理（incremental annotation processors）\"></a>使用增量注解处理（incremental annotation processors）</h4><p>Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.enableSeparateAnnotationProcessing = true</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h4><ul>\n<li><p>使用确定的依赖，避免使用<code>+</code>，如：’com.android.tools.build:gradle:2.+’</p>\n</li>\n<li><p>使用离线模式进行编译</p>\n</li>\n<li><p>创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。</p>\n</li>\n<li><p>创建自定义编译任务</p>\n</li>\n<li><p>将图片转换为WebP</p>\n<p> WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。</p>\n</li>\n<li><p>禁用PNG压缩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//禁用PNG压缩</span></span><br><span class=\"line\">            crunchPngs <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩</span></span><br><span class=\"line\">    <span class=\"comment\">//  aaptOptions &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      cruncherEnabled false</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用编译缓存<br>在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，<code>clean build</code>会变得更快，因为其会调用缓存中的文件，而非重新生成。<br>在gradle.gradle.properties 中指定编译缓存的路径，默认路径为<code>&lt;user-home&gt;/.android/build-cache/</code></p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 执行绝对路径或者相对路径</span><br><span class=\"line\">android.buildCacheDir=<span class=\"tag\">&lt;<span class=\"name\">path-to-directory</span>&gt;</span></span><br><span class=\"line\">android.enableBuildCache=true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打包编译多个版本的apk，待续\"><a href=\"#打包编译多个版本的apk，待续\" class=\"headerlink\" title=\"打包编译多个版本的apk，待续\"></a>打包编译多个版本的apk，待续</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h3><p>gradle和make以及ant不同，它基于Groovy语言，而非一种配置；</p>\n<p>Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，</p>\n<h4 id=\"在Moudle的build-gradle中添加依赖包\"><a href=\"#在Moudle的build-gradle中添加依赖包\" class=\"headerlink\" title=\"在Moudle的build.gradle中添加依赖包\"></a>在Moudle的build.gradle中添加依赖包</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`</span></span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">\":mylibrary\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 </span></span></span><br><span class=\"line\"><span class=\"function\">    implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于远程库</span></span></span><br><span class=\"line\"><span class=\"function\">    implementation 'com.example.android:app-magic:12.3'</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>依赖包的配置有以下类型：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code>、<code>annotationProcessor</code>、<code>lintChecks</code>、<code>lintPublish</code><br>在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    freeImplementation <span class=\"string\">'com.google.firebase:firebase-ads:9.8.0'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要将依赖作为变量，与flavor和build type进行结合，要在<code>configurations</code>代码块中进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化只与freeDebugRuntimeOnly相关的依赖</span></span><br><span class=\"line\">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">freeDebugRuntimeOnly <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">'libs'</span>, include: [<span class=\"string\">'*.jar'</span>])</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"在Debug模式下使用正式签名\"><a href=\"#在Debug模式下使用正式签名\" class=\"headerlink\" title=\"在Debug模式下使用正式签名\"></a>在Debug模式下使用正式签名</h3><p>在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错<code>ERROR: Could not get unknown property &#39;release&#39; for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//.jks文件放在项目目录（app目录）</span></span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span><span class=\"comment\">//签名文件名</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword \"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">\"app.jks\"</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">            keyAlias\"key0\"<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword\"password\"</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;   </span></span><br><span class=\"line\"><span class=\"function\">       </span></span><br><span class=\"line\"><span class=\"function\">    buildTypes </span>&#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class=\"line\"><span class=\"function\">            signingConfig signingConfigs.release</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">        signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加速项目的构建速度\"><a href=\"#加速项目的构建速度\" class=\"headerlink\" title=\"加速项目的构建速度\"></a>加速项目的构建速度</h3><h4 id=\"优化项目配置\"><a href=\"#优化项目配置\" class=\"headerlink\" title=\"优化项目配置\"></a>优化项目配置</h4><p>有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个<code>dev</code>flavor和<code>prod</code>flavor(发布版本)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；</span></span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出<code>devDemo</code>和<code>prodFull</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度</span></span><br><span class=\"line\">  flavorDimensions <span class=\"string\">\"stage\"</span>, <span class=\"string\">\"mode\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">\"-dev\"</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">'.dev'</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片</span></span><br><span class=\"line\">      resConfigs <span class=\"string\">\"en\"</span>, <span class=\"string\">\"xxhdpi\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"stage\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    demo &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    full &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">\"mode\"</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译类型配置\"><a href=\"#编译类型配置\" class=\"headerlink\" title=\"编译类型配置\"></a>编译类型配置</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    android &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      buildTypes &#123;</span><br><span class=\"line\">        debug &#123;</span><br><span class=\"line\">          <span class=\"comment\">//如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`</span></span><br><span class=\"line\">          ext.enableCrashlytics = <span class=\"keyword\">false</span></span><br><span class=\"line\">          <span class=\"comment\">//防止Crashlytics 每次更新编译的id</span></span><br><span class=\"line\">          ext.alwaysUpdateBuildId = <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Debug版本构建的过程中使用静态常量\"><a href=\"#在Debug版本构建的过程中使用静态常量\" class=\"headerlink\" title=\"在Debug版本构建的过程中使用静态常量\"></a>在Debug版本构建的过程中使用静态常量</h4><p>在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MILLIS_IN_MINUTE = <span class=\"number\">1000</span> * <span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理</span></span><br><span class=\"line\">    applicationVariants.all &#123; variant -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variant.buildType.name == <span class=\"string\">\"release\"</span>) &#123;</span><br><span class=\"line\">            variant.mergedFlavor.versionCode = minutesSinceEpoch;</span><br><span class=\"line\">            variant.mergedFlavor.versionName = minutesSinceEpoch + <span class=\"string\">\"-\"</span> + variant.flavorName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用增量注解处理（incremental-annotation-processors）\"><a href=\"#使用增量注解处理（incremental-annotation-processors）\" class=\"headerlink\" title=\"使用增量注解处理（incremental annotation processors）\"></a>使用增量注解处理（incremental annotation processors）</h4><p>Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.enableSeparateAnnotationProcessing = true</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h4><ul>\n<li><p>使用确定的依赖，避免使用<code>+</code>，如：’com.android.tools.build:gradle:2.+’</p>\n</li>\n<li><p>使用离线模式进行编译</p>\n</li>\n<li><p>创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。</p>\n</li>\n<li><p>创建自定义编译任务</p>\n</li>\n<li><p>将图片转换为WebP</p>\n<p> WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。</p>\n</li>\n<li><p>禁用PNG压缩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//禁用PNG压缩</span></span><br><span class=\"line\">            crunchPngs <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩</span></span><br><span class=\"line\">    <span class=\"comment\">//  aaptOptions &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      cruncherEnabled false</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用编译缓存<br>在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，<code>clean build</code>会变得更快，因为其会调用缓存中的文件，而非重新生成。<br>在gradle.gradle.properties 中指定编译缓存的路径，默认路径为<code>&lt;user-home&gt;/.android/build-cache/</code></p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 执行绝对路径或者相对路径</span><br><span class=\"line\">android.buildCacheDir=<span class=\"tag\">&lt;<span class=\"name\">path-to-directory</span>&gt;</span></span><br><span class=\"line\">android.enableBuildCache=true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打包编译多个版本的apk，待续\"><a href=\"#打包编译多个版本的apk，待续\" class=\"headerlink\" title=\"打包编译多个版本的apk，待续\"></a>打包编译多个版本的apk，待续</h4>"},{"_content":"# Generics(泛型)\n\n一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。\n\nGeneric Programming\\(泛型编程\\)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming\\(泛型编程\\)可以使得对象\\(object\\)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。\n\n如果没有泛型，参数的类型会被忽略，\n\n\n\n## 装箱和拆箱\n\n在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。\n\n将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，**会返回之前缓存的对象**，\n\n```java\n    \n    int a=100;\n    int b=100;\n    int c=200;\n    int d=200;\n    System.out.println(a==b);\n    System.out.println(c==d);\n\n```\n输出结果为\n\n```java\n    true;\n    false;\n```\n\nJava通过泛型可以自动进行装箱与拆箱。\n\n```java\n\n    Integer i=new Integer(xx);\n\n```\n**会触发自动装箱**\n\n```java\n    Integer i=xx;\n```\n**不会触发自动装箱**\n\n**注意：**操作符`==` 在基础类型中以及引用类型中采用不同的定义方式，在`int`类型中，`==`用于通过值的大小定义的，而在`Integer`中是通过对象定义的。在比较两个类对象时应使用euqal\n\n\n\n## 遍历循环\n\nfor循环可以被用于实现Iterable<E>接口的任何类中，\n\n```java\n    List<Integer>ints=Arrays.asList(1,2,3);\n    int s=0;\n    for(int n:ints){\n       s+=n;\n    }\n```\n等价于\n\n```java\n    for(Iterators<Integer>it=ints.iterator();it.hasNext();){\n       int n=it.next();\n       s+=n;\n    }\n```\n\n\n## Iterable<E>接口\n\n所有的`Collection`都实现了Iterable<E>接口\n\n\n## 泛型方法和可变参数(Generic Methods and Varargs)\n\n将任意类型的array转换成List\n\n```java\n    class List{\n       public static<T> List<T> toList(T[] arr){\n           List<T>list=new ArrayList<T>();\n           for(T elt:arr)list.add(elt);\n           return list;\n       }\n    }\n```\n\n将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将`T[]`使用`T...`来替代。\n\n```java\n\nclass Lists{\n        public static<T>List<T>toList(T...arr){\n            List<T>list=new ArrayList<T>();\n            for(T elt:arr)list.add(elt);\n            return list;\n        }\n}\n```\n调用方式\n\n```java\n     List<Integer> ints = Lists.toList(1, 2, 3); \n     List<String> words = Lists.toList(\"hello\", \"world\");\n```\n\n### 子类型和通配符(SubTyping and Wildcards)\n\n**子类型和替换原则**\n\n子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。\n\n```java\n    List<Number>nums=new ArrayList<Number>();\n    nums.add(2);\n    nums.add(3.14);\n```\n\n根据替换规则可以在Number的List中添加`Integer`和`Double`类型的对象。\n\n\n```java\n    List<Integer>ints=new ArrayList<Integer>();\n    ints.add(2);\n    ints.add(3);\n    List<Number>nums=ints;    //在编译时报错\n    nums.add(3.14);\n\n```\n\n报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用`List<? extends Number>nums=ints`，因为List<Integer>是List<? extends Number>的子类型。\n\n### 带有extends的通配符\n\n以Collection接口中的addAll方法为例\n\n```java\n    interface Collection<E>{\n     \n     ...\n     public boolean addAll(Collection<? extends E>c);\n     ...\n    \n    }\n```\n\n`? extends E`表示可以使用E的子类型作为参数添加到Collection中\n\n```java\n\n    List<Number>nums=new ArrayList<Number>();\n    List<Integer>ints=Array.asList(1,2);\n    List<Double>dbls=Array.asList(2.23,3.55);\n    nums.addAll(ints);\n    nums.addAll(dbls);\n```\n在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection<? extends Number>的子类型。如果addAll(Collection<? extends E>c)中没有通配符，那么上面的语句在编译时会报错。\n\n### 带有super的通配符\n\n将一个List拷贝到另外一个List\n\n```java\n\n    public static <T>void copy(List<? super T>dst,List<? extend T>src)\n    {\n       for(int i=0;i<src.size();i++){\n           dst.set(i,src.get(i));\n       }\n    }\n\n```\n\n`? super T`的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;\n典型例子\n\n```java\n    List<Object>objs=Array.<Object>asList(2,3,\"four\");\n    List<Integer>ints=Array.asList(5,6);\n    Collection.copy(objs,ints);\n    Collection.<Object>copy(objs,ints);\n    Collection.<Number>copy(objs,ints);\n    Collection.<Integer>copy(objs,ints);\n    \n```\n\n通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。\n\n### Get和Put原则\n？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的\n\n### 数组\n\n在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。\n```java\n    \n    Integer[] ints=new Integer[]{1,2,3};\n    Number[] nums=ints;\n    num[2]=3.14;  //运行时错误\n\n```\n\nInteger[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。\n\n与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List<? extends T>的子类型。\n\n```java\n    List<Integer>ints=Array.asList(1,2,3);\n    List<Number nums>=ints;      //在编译时会报错\n    List<? extends Number>nums1=ints; //编译通过\n    nums1.set(2,3.14)           //编译错误\n\n```\n\n第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。\n\n\n在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List<? super T>的子类型，数组不支持子类型的逆变。\n\nArrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。\n\n### 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\n\n* 使用通配符判断Collection中是否有指定的对象\n\n```java\n    interface Collection<E>{\n        ...\n        public boolean contains(Object o);\n        public boolean containsAll(Collection<?>c);\n        ...\n    }\n    \n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);\n    ints.containsAll(objs);\n    ...\n```\n\n在`containsAll(Collection<?>c)`方法中 `Collection<?>c`是`Collection<?>c`的缩写(abbreviation)，继承Object是通配符常用的方式。\n\n* 类型参数\n可以通过类型参数来替换通配符的编码方式\n\n```java\n\n    interface Collection<E>{\n        ...\n        public boolean contains(E o);\n        public boolean containsAll(Collection<? extend E>c);\n        ...\n    }\n    \n\n\n```\n\n但实际在编译的过程中使用\n\n```java\n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);     //编译时报错\n    ints.containsAll(objs); //编译时报错\n    ...\n```\n\n两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。\n\n### \n\n\n\n\n\n\n\n","source":"_posts/Java/Java基础/Java泛型.md","raw":"# Generics(泛型)\n\n一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。\n\nGeneric Programming\\(泛型编程\\)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming\\(泛型编程\\)可以使得对象\\(object\\)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。\n\n如果没有泛型，参数的类型会被忽略，\n\n\n\n## 装箱和拆箱\n\n在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。\n\n将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，**会返回之前缓存的对象**，\n\n```java\n    \n    int a=100;\n    int b=100;\n    int c=200;\n    int d=200;\n    System.out.println(a==b);\n    System.out.println(c==d);\n\n```\n输出结果为\n\n```java\n    true;\n    false;\n```\n\nJava通过泛型可以自动进行装箱与拆箱。\n\n```java\n\n    Integer i=new Integer(xx);\n\n```\n**会触发自动装箱**\n\n```java\n    Integer i=xx;\n```\n**不会触发自动装箱**\n\n**注意：**操作符`==` 在基础类型中以及引用类型中采用不同的定义方式，在`int`类型中，`==`用于通过值的大小定义的，而在`Integer`中是通过对象定义的。在比较两个类对象时应使用euqal\n\n\n\n## 遍历循环\n\nfor循环可以被用于实现Iterable<E>接口的任何类中，\n\n```java\n    List<Integer>ints=Arrays.asList(1,2,3);\n    int s=0;\n    for(int n:ints){\n       s+=n;\n    }\n```\n等价于\n\n```java\n    for(Iterators<Integer>it=ints.iterator();it.hasNext();){\n       int n=it.next();\n       s+=n;\n    }\n```\n\n\n## Iterable<E>接口\n\n所有的`Collection`都实现了Iterable<E>接口\n\n\n## 泛型方法和可变参数(Generic Methods and Varargs)\n\n将任意类型的array转换成List\n\n```java\n    class List{\n       public static<T> List<T> toList(T[] arr){\n           List<T>list=new ArrayList<T>();\n           for(T elt:arr)list.add(elt);\n           return list;\n       }\n    }\n```\n\n将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将`T[]`使用`T...`来替代。\n\n```java\n\nclass Lists{\n        public static<T>List<T>toList(T...arr){\n            List<T>list=new ArrayList<T>();\n            for(T elt:arr)list.add(elt);\n            return list;\n        }\n}\n```\n调用方式\n\n```java\n     List<Integer> ints = Lists.toList(1, 2, 3); \n     List<String> words = Lists.toList(\"hello\", \"world\");\n```\n\n### 子类型和通配符(SubTyping and Wildcards)\n\n**子类型和替换原则**\n\n子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。\n\n```java\n    List<Number>nums=new ArrayList<Number>();\n    nums.add(2);\n    nums.add(3.14);\n```\n\n根据替换规则可以在Number的List中添加`Integer`和`Double`类型的对象。\n\n\n```java\n    List<Integer>ints=new ArrayList<Integer>();\n    ints.add(2);\n    ints.add(3);\n    List<Number>nums=ints;    //在编译时报错\n    nums.add(3.14);\n\n```\n\n报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用`List<? extends Number>nums=ints`，因为List<Integer>是List<? extends Number>的子类型。\n\n### 带有extends的通配符\n\n以Collection接口中的addAll方法为例\n\n```java\n    interface Collection<E>{\n     \n     ...\n     public boolean addAll(Collection<? extends E>c);\n     ...\n    \n    }\n```\n\n`? extends E`表示可以使用E的子类型作为参数添加到Collection中\n\n```java\n\n    List<Number>nums=new ArrayList<Number>();\n    List<Integer>ints=Array.asList(1,2);\n    List<Double>dbls=Array.asList(2.23,3.55);\n    nums.addAll(ints);\n    nums.addAll(dbls);\n```\n在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection<? extends Number>的子类型。如果addAll(Collection<? extends E>c)中没有通配符，那么上面的语句在编译时会报错。\n\n### 带有super的通配符\n\n将一个List拷贝到另外一个List\n\n```java\n\n    public static <T>void copy(List<? super T>dst,List<? extend T>src)\n    {\n       for(int i=0;i<src.size();i++){\n           dst.set(i,src.get(i));\n       }\n    }\n\n```\n\n`? super T`的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;\n典型例子\n\n```java\n    List<Object>objs=Array.<Object>asList(2,3,\"four\");\n    List<Integer>ints=Array.asList(5,6);\n    Collection.copy(objs,ints);\n    Collection.<Object>copy(objs,ints);\n    Collection.<Number>copy(objs,ints);\n    Collection.<Integer>copy(objs,ints);\n    \n```\n\n通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。\n\n### Get和Put原则\n？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的\n\n### 数组\n\n在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。\n```java\n    \n    Integer[] ints=new Integer[]{1,2,3};\n    Number[] nums=ints;\n    num[2]=3.14;  //运行时错误\n\n```\n\nInteger[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。\n\n与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List<? extends T>的子类型。\n\n```java\n    List<Integer>ints=Array.asList(1,2,3);\n    List<Number nums>=ints;      //在编译时会报错\n    List<? extends Number>nums1=ints; //编译通过\n    nums1.set(2,3.14)           //编译错误\n\n```\n\n第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。\n\n\n在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List<? super T>的子类型，数组不支持子类型的逆变。\n\nArrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。\n\n### 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\n\n* 使用通配符判断Collection中是否有指定的对象\n\n```java\n    interface Collection<E>{\n        ...\n        public boolean contains(Object o);\n        public boolean containsAll(Collection<?>c);\n        ...\n    }\n    \n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);\n    ints.containsAll(objs);\n    ...\n```\n\n在`containsAll(Collection<?>c)`方法中 `Collection<?>c`是`Collection<?>c`的缩写(abbreviation)，继承Object是通配符常用的方式。\n\n* 类型参数\n可以通过类型参数来替换通配符的编码方式\n\n```java\n\n    interface Collection<E>{\n        ...\n        public boolean contains(E o);\n        public boolean containsAll(Collection<? extend E>c);\n        ...\n    }\n    \n\n\n```\n\n但实际在编译的过程中使用\n\n```java\n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);     //编译时报错\n    ints.containsAll(objs); //编译时报错\n    ...\n```\n\n两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。\n\n### \n\n\n\n\n\n\n\n","slug":"Java/Java基础/Java泛型","published":1,"date":"2019-09-19T09:41:14.772Z","updated":"2019-09-30T08:28:42.970Z","title":"Java/Java基础/Java泛型","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0v001tkgui5h5lhwvn","content":"<h1 id=\"Generics-泛型\"><a href=\"#Generics-泛型\" class=\"headerlink\" title=\"Generics(泛型)\"></a>Generics(泛型)</h1><p>一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。</p>\n<p>Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。</p>\n<p>如果没有泛型，参数的类型会被忽略，</p>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><p>在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。</p>\n<p>将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，<strong>会返回之前缓存的对象</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c=<span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d=<span class=\"number\">200</span>;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Java通过泛型可以自动进行装箱与拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer i=<span class=\"keyword\">new</span> Integer(xx);</span><br></pre></td></tr></table></figure>\n<p><strong>会触发自动装箱</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i=xx;</span><br></pre></td></tr></table></figure>\n<p><strong>不会触发自动装箱</strong></p>\n<p><strong>注意：</strong>操作符<code>==</code> 在基础类型中以及引用类型中采用不同的定义方式，在<code>int</code>类型中，<code>==</code>用于通过值的大小定义的，而在<code>Integer</code>中是通过对象定义的。在比较两个类对象时应使用euqal</p>\n<h2 id=\"遍历循环\"><a href=\"#遍历循环\" class=\"headerlink\" title=\"遍历循环\"></a>遍历循环</h2><p>for循环可以被用于实现Iterable<E>接口的任何类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n:ints)&#123;</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n=it.next();</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable<E>接口</h2><p>所有的<code>Collection</code>都实现了Iterable<E>接口</p>\n<h2 id=\"泛型方法和可变参数-Generic-Methods-and-Varargs\"><a href=\"#泛型方法和可变参数-Generic-Methods-and-Varargs\" class=\"headerlink\" title=\"泛型方法和可变参数(Generic Methods and Varargs)\"></a>泛型方法和可变参数(Generic Methods and Varargs)</h2><p>将任意类型的array转换成List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; List&lt;T&gt; <span class=\"title\">toList</span><span class=\"params\">(T[] arr)</span></span>&#123;</span><br><span class=\"line\">       List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将<code>T[]</code>使用<code>T...</code>来替代。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lists</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt;List&lt;T&gt;toList(T...arr)&#123;</span><br><span class=\"line\">            List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ints = Lists.toList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">List&lt;String&gt; words = Lists.toList(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子类型和通配符-SubTyping-and-Wildcards\"><a href=\"#子类型和通配符-SubTyping-and-Wildcards\" class=\"headerlink\" title=\"子类型和通配符(SubTyping and Wildcards)\"></a>子类型和通配符(SubTyping and Wildcards)</h3><p><strong>子类型和替换原则</strong></p>\n<p>子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据替换规则可以在Number的List中添加<code>Integer</code>和<code>Double</code>类型的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">ints.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">ints.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number&gt;nums=ints;    <span class=\"comment\">//在编译时报错</span></span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用<code>List&lt;? extends Number&gt;nums=ints</code>，因为List<Integer>是List&lt;? extends Number&gt;的子类型。</p>\n<h3 id=\"带有extends的通配符\"><a href=\"#带有extends的通配符\" class=\"headerlink\" title=\"带有extends的通配符\"></a>带有extends的通配符</h3><p>以Collection接口中的addAll方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt;c)</span></span>;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? extends E</code>表示可以使用E的子类型作为参数添加到Collection中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">List&lt;Double&gt;dbls=Array.asList(<span class=\"number\">2.23</span>,<span class=\"number\">3.55</span>);</span><br><span class=\"line\">nums.addAll(ints);</span><br><span class=\"line\">nums.addAll(dbls);</span><br></pre></td></tr></table></figure>\n<p>在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。</p>\n<h3 id=\"带有super的通配符\"><a href=\"#带有super的通配符\" class=\"headerlink\" title=\"带有super的通配符\"></a>带有super的通配符</h3><p>将一个List拷贝到另外一个List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt;dst,List&lt;? extend T&gt;src)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;src.size();i++)&#123;</span><br><span class=\"line\">       dst.set(i,src.get(i));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? super T</code>的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;<br>典型例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">Collection.copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Object&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Number&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Integer&gt;copy(objs,ints);</span><br></pre></td></tr></table></figure>\n\n<p>通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。</p>\n<h3 id=\"Get和Put原则\"><a href=\"#Get和Put原则\" class=\"headerlink\" title=\"Get和Put原则\"></a>Get和Put原则</h3><p>？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer[] ints=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Number[] nums=ints;</span><br><span class=\"line\">num[<span class=\"number\">2</span>]=<span class=\"number\">3.14</span>;  <span class=\"comment\">//运行时错误</span></span><br></pre></td></tr></table></figure>\n\n<p>Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。</p>\n<p>与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List&lt;? extends T&gt;的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number nums&gt;=ints;      <span class=\"comment\">//在编译时会报错</span></span><br><span class=\"line\">List&lt;? extends Number&gt;nums1=ints; <span class=\"comment\">//编译通过</span></span><br><span class=\"line\">nums1.set(<span class=\"number\">2</span>,<span class=\"number\">3.14</span>)           <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。</p>\n<p>在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。</p>\n<p>Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。</p>\n<h3 id=\"通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\"><a href=\"#通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\" class=\"headerlink\" title=\"通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\"></a>通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）</h3><ul>\n<li>使用通配符判断Collection中是否有指定的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);</span><br><span class=\"line\">ints.containsAll(objs);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在<code>containsAll(Collection&lt;?&gt;c)</code>方法中 <code>Collection&lt;?&gt;c</code>是<code>Collection&lt;?&gt;c</code>的缩写(abbreviation)，继承Object是通配符常用的方式。</p>\n<ul>\n<li>类型参数<br>可以通过类型参数来替换通配符的编码方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(E o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;? extend E&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但实际在编译的过程中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);     <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">ints.containsAll(objs); <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Generics-泛型\"><a href=\"#Generics-泛型\" class=\"headerlink\" title=\"Generics(泛型)\"></a>Generics(泛型)</h1><p>一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。</p>\n<p>Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。</p>\n<p>如果没有泛型，参数的类型会被忽略，</p>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><p>在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。</p>\n<p>将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，<strong>会返回之前缓存的对象</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c=<span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d=<span class=\"number\">200</span>;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Java通过泛型可以自动进行装箱与拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer i=<span class=\"keyword\">new</span> Integer(xx);</span><br></pre></td></tr></table></figure>\n<p><strong>会触发自动装箱</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i=xx;</span><br></pre></td></tr></table></figure>\n<p><strong>不会触发自动装箱</strong></p>\n<p><strong>注意：</strong>操作符<code>==</code> 在基础类型中以及引用类型中采用不同的定义方式，在<code>int</code>类型中，<code>==</code>用于通过值的大小定义的，而在<code>Integer</code>中是通过对象定义的。在比较两个类对象时应使用euqal</p>\n<h2 id=\"遍历循环\"><a href=\"#遍历循环\" class=\"headerlink\" title=\"遍历循环\"></a>遍历循环</h2><p>for循环可以被用于实现Iterable<E>接口的任何类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n:ints)&#123;</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n=it.next();</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable<E>接口</h2><p>所有的<code>Collection</code>都实现了Iterable<E>接口</p>\n<h2 id=\"泛型方法和可变参数-Generic-Methods-and-Varargs\"><a href=\"#泛型方法和可变参数-Generic-Methods-and-Varargs\" class=\"headerlink\" title=\"泛型方法和可变参数(Generic Methods and Varargs)\"></a>泛型方法和可变参数(Generic Methods and Varargs)</h2><p>将任意类型的array转换成List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; List&lt;T&gt; <span class=\"title\">toList</span><span class=\"params\">(T[] arr)</span></span>&#123;</span><br><span class=\"line\">       List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将<code>T[]</code>使用<code>T...</code>来替代。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lists</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt;List&lt;T&gt;toList(T...arr)&#123;</span><br><span class=\"line\">            List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ints = Lists.toList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">List&lt;String&gt; words = Lists.toList(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子类型和通配符-SubTyping-and-Wildcards\"><a href=\"#子类型和通配符-SubTyping-and-Wildcards\" class=\"headerlink\" title=\"子类型和通配符(SubTyping and Wildcards)\"></a>子类型和通配符(SubTyping and Wildcards)</h3><p><strong>子类型和替换原则</strong></p>\n<p>子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>根据替换规则可以在Number的List中添加<code>Integer</code>和<code>Double</code>类型的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">ints.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">ints.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number&gt;nums=ints;    <span class=\"comment\">//在编译时报错</span></span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n\n<p>报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用<code>List&lt;? extends Number&gt;nums=ints</code>，因为List<Integer>是List&lt;? extends Number&gt;的子类型。</p>\n<h3 id=\"带有extends的通配符\"><a href=\"#带有extends的通配符\" class=\"headerlink\" title=\"带有extends的通配符\"></a>带有extends的通配符</h3><p>以Collection接口中的addAll方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt;c)</span></span>;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? extends E</code>表示可以使用E的子类型作为参数添加到Collection中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">List&lt;Double&gt;dbls=Array.asList(<span class=\"number\">2.23</span>,<span class=\"number\">3.55</span>);</span><br><span class=\"line\">nums.addAll(ints);</span><br><span class=\"line\">nums.addAll(dbls);</span><br></pre></td></tr></table></figure>\n<p>在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。</p>\n<h3 id=\"带有super的通配符\"><a href=\"#带有super的通配符\" class=\"headerlink\" title=\"带有super的通配符\"></a>带有super的通配符</h3><p>将一个List拷贝到另外一个List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt;dst,List&lt;? extend T&gt;src)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;src.size();i++)&#123;</span><br><span class=\"line\">       dst.set(i,src.get(i));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>? super T</code>的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;<br>典型例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">Collection.copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Object&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Number&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Integer&gt;copy(objs,ints);</span><br></pre></td></tr></table></figure>\n\n<p>通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。</p>\n<h3 id=\"Get和Put原则\"><a href=\"#Get和Put原则\" class=\"headerlink\" title=\"Get和Put原则\"></a>Get和Put原则</h3><p>？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer[] ints=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Number[] nums=ints;</span><br><span class=\"line\">num[<span class=\"number\">2</span>]=<span class=\"number\">3.14</span>;  <span class=\"comment\">//运行时错误</span></span><br></pre></td></tr></table></figure>\n\n<p>Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。</p>\n<p>与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List&lt;? extends T&gt;的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number nums&gt;=ints;      <span class=\"comment\">//在编译时会报错</span></span><br><span class=\"line\">List&lt;? extends Number&gt;nums1=ints; <span class=\"comment\">//编译通过</span></span><br><span class=\"line\">nums1.set(<span class=\"number\">2</span>,<span class=\"number\">3.14</span>)           <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。</p>\n<p>在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。</p>\n<p>Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。</p>\n<h3 id=\"通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\"><a href=\"#通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\" class=\"headerlink\" title=\"通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\"></a>通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）</h3><ul>\n<li>使用通配符判断Collection中是否有指定的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);</span><br><span class=\"line\">ints.containsAll(objs);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在<code>containsAll(Collection&lt;?&gt;c)</code>方法中 <code>Collection&lt;?&gt;c</code>是<code>Collection&lt;?&gt;c</code>的缩写(abbreviation)，继承Object是通配符常用的方式。</p>\n<ul>\n<li>类型参数<br>可以通过类型参数来替换通配符的编码方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(E o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;? extend E&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但实际在编译的过程中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">\"one\"</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">\"one\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);     <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">ints.containsAll(objs); <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>"},{"_content":"# 线程间通信\n\n* 使用单向管道（Pipe）传递数据\n* 共享内存（Shared Memory）通信\n* 使用阻塞队列（Blocking Queue）实现生产者-消费者模式\n* 处理消息队列（Message Queue）\n\n\n## wait/notify机制\n\n等待/通知机制主要由Object类中的三个方法进行保证\n\n1、wait()；notify();notifyAll()\n上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；`wait();notify();notifyAll()`只有在被`synchronized `修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出`IllegalMonitorStateException`异常。\n\n1)wait()\n让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用`notify()`或者`notifyAll()`时唤醒当前线程。`wait()`也可以作为任务同步的一种方式。\n\n**注：调用`sleep()`和`yield()`方法不能释放当前的对象锁**\n`wait()`方法有两种用法：\n* ` wait(long timeout)`等待一定的时间，但与`sleep()`方法不同，其会释放对象锁\n* 使用`wait()`等待`notify()`或者`notifyAll()`唤醒。 \n\n\n2)notify()\n唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；\n\n3)notifyAll()\n唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过`synchronized(x)`来获取对象锁。\n\n```java\n     synchronized(x) { \n       x.notifyAll();\n     }\n\n```\n\n\n2、方法调用与线程状态关系\n\n每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列\n\n## Condition\n\nCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；\n\n对应关系\n\n* Condition中的await()对应Object的wait()\n* Condition中的signal()对应Object的notify()\n* Condition中的signalAll()对应Object中的notifyAll();\n\n**Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同**\n\n### 生产者消费者模型\n\n线程锁控制代码\n```java\npublic class Service {\n\n    //线程锁\n    private ReentrantLock lock=new ReentrantLock();\n    //生产者线程控制\n    private Condition conditionCustomer=lock.newCondition();\n    //消费者线程控制\n    private Condition conditionProducer=lock.newCondition();\n    //用于表示需要生产\n    private boolean hasValue=false;\n    //用于随机消费时间；\n    private static Random rand = new Random(2000);\n\n    //用于生产者\n    public void produce(){\n        try {\n            lock.lock();\n            while (hasValue){\n                System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionCustomer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\");\n            Thread.sleep(rand.nextInt(500));\n            hasValue=true;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的消费者线程\n            conditionProducer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //用于消费者\n    public void custome(){\n        try{\n            lock.lock();\n            while (!hasValue){\n                System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionProducer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\");\n            Thread.sleep(rand.nextInt(4000));\n            hasValue=false;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的生产者线程\n            conditionCustomer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n消费者线程\n\n```java\npublic class CustomerThread extends Thread {\n\n    private Service service;\n    public CustomerThread(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        while (true){\n            service.custome();\n        }\n    }\n}\n\n```\n测试代码\n```java\n\npublic class Customer_ServiceMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n        CustomerThread[] customerThread=new CustomerThread[10];\n        ProducerThread[] producerThreads=new ProducerThread[10];\n        for (int i=0;i<3;i++){\n            customerThread[i]=new CustomerThread(service);\n            customerThread[i].setName(\"生产者Thread：\"+i);\n            producerThreads[i]=new ProducerThread(service);\n            producerThreads[i].setName(\"消费者Thread：\"+i);\n            customerThread[i].start();\n            producerThreads[i].start();\n\n        }\n    }\n    }\n\n```\n\n运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。\n\n```xml\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：2await\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：2await\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n\n```\n\n\n### 线程间通信管道模式\n\n#### CountDownLatch的使用\n\n用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。\n\n任务执行线程\n```java\n    public class Task extends Thread {\n\n    private static Random random = new Random(100);\n\n    private final CountDownLatch latch;\n\n    //使用CountDownLatch会被自动要求加上此构造函数\n    public Task(CountDownLatch latch, String name) {\n        this.latch = latch;\n        this.setName(name);\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            doWork();\n            //用于倒数技术\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doWork() throws InterruptedException {\n        //random.nextInt(2000)在Java中是线程安全的来自TIJ\n        TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));\n        System.out.println(this.getName() + \"completed\");\n    }\n}\n```\n等待任务执行完毕，需要唤醒的线程\n```java\n  public class WaitingTask implements Runnable {\n    \n    private final CountDownLatch latch;\n\n    public WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            latch.await();\n            System.out.println(\"Latch阻塞运行至waiting class\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n\n```\n测试代码\n```java\npublic class TestCountDown {\n\n    static final int SIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n\n        ExecutorService exec = Executors.newFixedThreadPool(5);\n        //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数\n        CountDownLatch latch = new CountDownLatch(SIZE);\n      // for (int i=0;i<10;i++){   //可以有多个等待线程\n        exec.execute(new WaitingTask(latch));\n      // }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new Task(latch,\"线程\"+i));\n        }\n        System.out.println(\"启动所有任务\");\n        exec.shutdown();  //任务只有在执行完毕后才会结束\n    }\n}\n\n```\n任务执行结果\n```xml\n启动所有任务\n线程0completed\n线程4completed\n线程1completed\n线程2completed\n线程3completed\nLatch阻塞运行至waiting class\n\nProcess finished with exit code 0\n\n```\n\n\n#### CyclicBarrier的使用\n\n`CyclicBarrier`类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于`join`)，与`CountDownLatch`类的使用类似，`CountDownLatch`类只能执行一次，而`CyclicBarrier`可以进行多次使用。\n以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；\n\n运动员代码\n```java\n\npublic class Athlete extends Thread {\n\n    //用于表示耗时\n    private double time =90;\n\n    private static Random rand = new Random(1);\n\n    private static CyclicBarrier cyclicBarrier;\n\n    public Athlete(CyclicBarrier cyclicBarrier){\n        this.cyclicBarrier=cyclicBarrier;\n    }\n\n    public synchronized double getTime(){\n        return time;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()){\n                synchronized (this){\n                    time =(double)(rand.nextInt(20)+90)/10;\n                    System.out.println(getName()+\"跑步耗时：\"+ getTime());\n                }\n                Thread.sleep(1000);\n                cyclicBarrier.await();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n所有运动员跑完标志输出代码\n\n```java\npublic class RunningCtrl extends Thread{\n\n    public RunningCtrl(){\n\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n    }\n}\n\n```\n\n测试代码\n\n```java\npublic class CyclicBarrierMain {\n\n    public static void main(String[] args) {\n\n        RunningCtrl  runningCtrl=new RunningCtrl();\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i <5; i++) {\n            Athlete athlete = new Athlete(cyclicBarrier);\n            athlete.setName(\"选手：\"+i);\n            exec.execute(athlete);\n        }\n    }\n}\n\n```\n\n运行结果\n```xml\n\n选手：0跑步耗时：9.5\n选手：1跑步耗时：9.8\n选手：4跑步耗时：10.4\n选手：2跑步耗时：9.7\n选手：3跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：0跑步耗时：10.4\n选手：2跑步耗时：9.8\n选手：1跑步耗时：9.6\n选手：4跑步耗时：9.4\n选手：3跑步耗时：10.8\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：9.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：9.2\n选手：2跑步耗时：9.3\n选手：0跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：1跑步耗时：10.4\n选手：2跑步耗时：9.2\n选手：0跑步耗时：9.9\n选手：3跑步耗时：10.2\n选手：4跑步耗时：10.6\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：10.2\n选手：2跑步耗时：10.9\n选手：0跑步耗时：10.6\n选手：3跑步耗时：10.0\n选手：1跑步耗时：10.4\n++++++++++++++++++++++++++++++++\n选手：2跑步耗时：10.8\n选手：4跑步耗时：10.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：10.3\n选手：0跑步耗时：9.2\n++++++++++++++++++++++++++++++++\n```\n\n#### `DelayQueue`的使用\n\n`DelayQueue`是一个无界的阻塞队列，实现`Delayed`接口。只有当`delay`被激发时，该对象才能从队列中获取数据\n\n\n\n### 线程间通信管道模式\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java多线程/Java线程间通信.md","raw":"# 线程间通信\n\n* 使用单向管道（Pipe）传递数据\n* 共享内存（Shared Memory）通信\n* 使用阻塞队列（Blocking Queue）实现生产者-消费者模式\n* 处理消息队列（Message Queue）\n\n\n## wait/notify机制\n\n等待/通知机制主要由Object类中的三个方法进行保证\n\n1、wait()；notify();notifyAll()\n上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；`wait();notify();notifyAll()`只有在被`synchronized `修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出`IllegalMonitorStateException`异常。\n\n1)wait()\n让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用`notify()`或者`notifyAll()`时唤醒当前线程。`wait()`也可以作为任务同步的一种方式。\n\n**注：调用`sleep()`和`yield()`方法不能释放当前的对象锁**\n`wait()`方法有两种用法：\n* ` wait(long timeout)`等待一定的时间，但与`sleep()`方法不同，其会释放对象锁\n* 使用`wait()`等待`notify()`或者`notifyAll()`唤醒。 \n\n\n2)notify()\n唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；\n\n3)notifyAll()\n唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过`synchronized(x)`来获取对象锁。\n\n```java\n     synchronized(x) { \n       x.notifyAll();\n     }\n\n```\n\n\n2、方法调用与线程状态关系\n\n每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列\n\n## Condition\n\nCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；\n\n对应关系\n\n* Condition中的await()对应Object的wait()\n* Condition中的signal()对应Object的notify()\n* Condition中的signalAll()对应Object中的notifyAll();\n\n**Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同**\n\n### 生产者消费者模型\n\n线程锁控制代码\n```java\npublic class Service {\n\n    //线程锁\n    private ReentrantLock lock=new ReentrantLock();\n    //生产者线程控制\n    private Condition conditionCustomer=lock.newCondition();\n    //消费者线程控制\n    private Condition conditionProducer=lock.newCondition();\n    //用于表示需要生产\n    private boolean hasValue=false;\n    //用于随机消费时间；\n    private static Random rand = new Random(2000);\n\n    //用于生产者\n    public void produce(){\n        try {\n            lock.lock();\n            while (hasValue){\n                System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionCustomer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\");\n            Thread.sleep(rand.nextInt(500));\n            hasValue=true;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的消费者线程\n            conditionProducer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //用于消费者\n    public void custome(){\n        try{\n            lock.lock();\n            while (!hasValue){\n                System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionProducer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\");\n            Thread.sleep(rand.nextInt(4000));\n            hasValue=false;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的生产者线程\n            conditionCustomer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n消费者线程\n\n```java\npublic class CustomerThread extends Thread {\n\n    private Service service;\n    public CustomerThread(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        while (true){\n            service.custome();\n        }\n    }\n}\n\n```\n测试代码\n```java\n\npublic class Customer_ServiceMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n        CustomerThread[] customerThread=new CustomerThread[10];\n        ProducerThread[] producerThreads=new ProducerThread[10];\n        for (int i=0;i<3;i++){\n            customerThread[i]=new CustomerThread(service);\n            customerThread[i].setName(\"生产者Thread：\"+i);\n            producerThreads[i]=new ProducerThread(service);\n            producerThreads[i].setName(\"消费者Thread：\"+i);\n            customerThread[i].start();\n            producerThreads[i].start();\n\n        }\n    }\n    }\n\n```\n\n运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。\n\n```xml\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：2await\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：2await\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n\n```\n\n\n### 线程间通信管道模式\n\n#### CountDownLatch的使用\n\n用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。\n\n任务执行线程\n```java\n    public class Task extends Thread {\n\n    private static Random random = new Random(100);\n\n    private final CountDownLatch latch;\n\n    //使用CountDownLatch会被自动要求加上此构造函数\n    public Task(CountDownLatch latch, String name) {\n        this.latch = latch;\n        this.setName(name);\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            doWork();\n            //用于倒数技术\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doWork() throws InterruptedException {\n        //random.nextInt(2000)在Java中是线程安全的来自TIJ\n        TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));\n        System.out.println(this.getName() + \"completed\");\n    }\n}\n```\n等待任务执行完毕，需要唤醒的线程\n```java\n  public class WaitingTask implements Runnable {\n    \n    private final CountDownLatch latch;\n\n    public WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            latch.await();\n            System.out.println(\"Latch阻塞运行至waiting class\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n\n```\n测试代码\n```java\npublic class TestCountDown {\n\n    static final int SIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n\n        ExecutorService exec = Executors.newFixedThreadPool(5);\n        //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数\n        CountDownLatch latch = new CountDownLatch(SIZE);\n      // for (int i=0;i<10;i++){   //可以有多个等待线程\n        exec.execute(new WaitingTask(latch));\n      // }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new Task(latch,\"线程\"+i));\n        }\n        System.out.println(\"启动所有任务\");\n        exec.shutdown();  //任务只有在执行完毕后才会结束\n    }\n}\n\n```\n任务执行结果\n```xml\n启动所有任务\n线程0completed\n线程4completed\n线程1completed\n线程2completed\n线程3completed\nLatch阻塞运行至waiting class\n\nProcess finished with exit code 0\n\n```\n\n\n#### CyclicBarrier的使用\n\n`CyclicBarrier`类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于`join`)，与`CountDownLatch`类的使用类似，`CountDownLatch`类只能执行一次，而`CyclicBarrier`可以进行多次使用。\n以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；\n\n运动员代码\n```java\n\npublic class Athlete extends Thread {\n\n    //用于表示耗时\n    private double time =90;\n\n    private static Random rand = new Random(1);\n\n    private static CyclicBarrier cyclicBarrier;\n\n    public Athlete(CyclicBarrier cyclicBarrier){\n        this.cyclicBarrier=cyclicBarrier;\n    }\n\n    public synchronized double getTime(){\n        return time;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()){\n                synchronized (this){\n                    time =(double)(rand.nextInt(20)+90)/10;\n                    System.out.println(getName()+\"跑步耗时：\"+ getTime());\n                }\n                Thread.sleep(1000);\n                cyclicBarrier.await();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n所有运动员跑完标志输出代码\n\n```java\npublic class RunningCtrl extends Thread{\n\n    public RunningCtrl(){\n\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n    }\n}\n\n```\n\n测试代码\n\n```java\npublic class CyclicBarrierMain {\n\n    public static void main(String[] args) {\n\n        RunningCtrl  runningCtrl=new RunningCtrl();\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i <5; i++) {\n            Athlete athlete = new Athlete(cyclicBarrier);\n            athlete.setName(\"选手：\"+i);\n            exec.execute(athlete);\n        }\n    }\n}\n\n```\n\n运行结果\n```xml\n\n选手：0跑步耗时：9.5\n选手：1跑步耗时：9.8\n选手：4跑步耗时：10.4\n选手：2跑步耗时：9.7\n选手：3跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：0跑步耗时：10.4\n选手：2跑步耗时：9.8\n选手：1跑步耗时：9.6\n选手：4跑步耗时：9.4\n选手：3跑步耗时：10.8\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：9.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：9.2\n选手：2跑步耗时：9.3\n选手：0跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：1跑步耗时：10.4\n选手：2跑步耗时：9.2\n选手：0跑步耗时：9.9\n选手：3跑步耗时：10.2\n选手：4跑步耗时：10.6\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：10.2\n选手：2跑步耗时：10.9\n选手：0跑步耗时：10.6\n选手：3跑步耗时：10.0\n选手：1跑步耗时：10.4\n++++++++++++++++++++++++++++++++\n选手：2跑步耗时：10.8\n选手：4跑步耗时：10.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：10.3\n选手：0跑步耗时：9.2\n++++++++++++++++++++++++++++++++\n```\n\n#### `DelayQueue`的使用\n\n`DelayQueue`是一个无界的阻塞队列，实现`Delayed`接口。只有当`delay`被激发时，该对象才能从队列中获取数据\n\n\n\n### 线程间通信管道模式\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/Java多线程/Java线程间通信","published":1,"date":"2019-09-19T09:41:14.777Z","updated":"2019-09-30T08:28:42.975Z","title":"Java/Java多线程/Java线程间通信","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0w001ukguiasbab8q8","content":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><ul>\n<li>使用单向管道（Pipe）传递数据</li>\n<li>共享内存（Shared Memory）通信</li>\n<li>使用阻塞队列（Blocking Queue）实现生产者-消费者模式</li>\n<li>处理消息队列（Message Queue）</li>\n</ul>\n<h2 id=\"wait-notify机制\"><a href=\"#wait-notify机制\" class=\"headerlink\" title=\"wait/notify机制\"></a>wait/notify机制</h2><p>等待/通知机制主要由Object类中的三个方法进行保证</p>\n<p>1、wait()；notify();notifyAll()<br>上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；<code>wait();notify();notifyAll()</code>只有在被<code>synchronized</code>修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出<code>IllegalMonitorStateException</code>异常。</p>\n<p>1)wait()<br>让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用<code>notify()</code>或者<code>notifyAll()</code>时唤醒当前线程。<code>wait()</code>也可以作为任务同步的一种方式。</p>\n<p><strong>注：调用<code>sleep()</code>和<code>yield()</code>方法不能释放当前的对象锁</strong><br><code>wait()</code>方法有两种用法：</p>\n<ul>\n<li><code>wait(long timeout)</code>等待一定的时间，但与<code>sleep()</code>方法不同，其会释放对象锁</li>\n<li>使用<code>wait()</code>等待<code>notify()</code>或者<code>notifyAll()</code>唤醒。 </li>\n</ul>\n<p>2)notify()<br>唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；</p>\n<p>3)notifyAll()<br>唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过<code>synchronized(x)</code>来获取对象锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(x) &#123; </span><br><span class=\"line\">  x.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2、方法调用与线程状态关系</p>\n<p>每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列</p>\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p>Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；</p>\n<p>对应关系</p>\n<ul>\n<li>Condition中的await()对应Object的wait()</li>\n<li>Condition中的signal()对应Object的notify()</li>\n<li>Condition中的signalAll()对应Object中的notifyAll();</li>\n</ul>\n<p><strong>Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同</strong></p>\n<h3 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h3><p>线程锁控制代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">//生产者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionCustomer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//消费者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionProducer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//用于表示需要生产</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用于随机消费时间；</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于生产者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"生产线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionCustomer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">500</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有消费者线程 \"</span>+<span class=\"string\">\"....\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的消费者线程</span></span><br><span class=\"line\">            conditionProducer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">custome</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"消费线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionProducer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">4000</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有生产者线程 \"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的生产者线程</span></span><br><span class=\"line\">            conditionCustomer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomerThread</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            service.custome();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer_ServiceMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Service service=<span class=\"keyword\">new</span> Service();</span><br><span class=\"line\">        CustomerThread[] customerThread=<span class=\"keyword\">new</span> CustomerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        ProducerThread[] producerThreads=<span class=\"keyword\">new</span> ProducerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            customerThread[i]=<span class=\"keyword\">new</span> CustomerThread(service);</span><br><span class=\"line\">            customerThread[i].setName(<span class=\"string\">\"生产者Thread：\"</span>+i);</span><br><span class=\"line\">            producerThreads[i]=<span class=\"keyword\">new</span> ProducerThread(service);</span><br><span class=\"line\">            producerThreads[i].setName(<span class=\"string\">\"消费者Thread：\"</span>+i);</span><br><span class=\"line\">            customerThread[i].start();</span><br><span class=\"line\">            producerThreads[i].start();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：2await</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：2await</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"线程间通信管道模式\"><a href=\"#线程间通信管道模式\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3><h4 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h4><p>用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。</p>\n<p>任务执行线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用CountDownLatch会被自动要求加上此构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setName(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doWork();</span><br><span class=\"line\">            <span class=\"comment\">//用于倒数技术</span></span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//random.nextInt(2000)在Java中是线程安全的来自TIJ</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\"completed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等待任务执行完毕，需要唤醒的线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitingTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WaitingTask</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           latch.await();</span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"Latch阻塞运行至waiting class\"</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCountDown</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数</span></span><br><span class=\"line\">        CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(SIZE);</span><br><span class=\"line\">      <span class=\"comment\">// for (int i=0;i&lt;10;i++)&#123;   //可以有多个等待线程</span></span><br><span class=\"line\">        exec.execute(<span class=\"keyword\">new</span> WaitingTask(latch));</span><br><span class=\"line\">      <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> Task(latch,<span class=\"string\">\"线程\"</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"启动所有任务\"</span>);</span><br><span class=\"line\">        exec.shutdown();  <span class=\"comment\">//任务只有在执行完毕后才会结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任务执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动所有任务</span><br><span class=\"line\">线程0completed</span><br><span class=\"line\">线程4completed</span><br><span class=\"line\">线程1completed</span><br><span class=\"line\">线程2completed</span><br><span class=\"line\">线程3completed</span><br><span class=\"line\">Latch阻塞运行至waiting class</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h4><p><code>CyclicBarrier</code>类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于<code>join</code>)，与<code>CountDownLatch</code>类的使用类似，<code>CountDownLatch</code>类只能执行一次，而<code>CyclicBarrier</code>可以进行多次使用。<br>以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；</p>\n<p>运动员代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Athlete</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示耗时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> time =<span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Athlete</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cyclicBarrier=cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">double</span> <span class=\"title\">getTime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.interrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                    time =(<span class=\"keyword\">double</span>)(rand.nextInt(<span class=\"number\">20</span>)+<span class=\"number\">90</span>)/<span class=\"number\">10</span>;</span><br><span class=\"line\">                    System.out.println(getName()+<span class=\"string\">\"跑步耗时：\"</span>+ getTime());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有运动员跑完标志输出代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunningCtrl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RunningCtrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"++++++++++++++++++++++++++++++++\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RunningCtrl  runningCtrl=<span class=\"keyword\">new</span> RunningCtrl();</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>,runningCtrl);</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Athlete athlete = <span class=\"keyword\">new</span> Athlete(cyclicBarrier);</span><br><span class=\"line\">            athlete.setName(<span class=\"string\">\"选手：\"</span>+i);</span><br><span class=\"line\">            exec.execute(athlete);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">选手：0跑步耗时：9.5</span><br><span class=\"line\">选手：1跑步耗时：9.8</span><br><span class=\"line\">选手：4跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：0跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.8</span><br><span class=\"line\">选手：1跑步耗时：9.6</span><br><span class=\"line\">选手：4跑步耗时：9.4</span><br><span class=\"line\">选手：3跑步耗时：10.8</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：9.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：9.2</span><br><span class=\"line\">选手：2跑步耗时：9.3</span><br><span class=\"line\">选手：0跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.2</span><br><span class=\"line\">选手：0跑步耗时：9.9</span><br><span class=\"line\">选手：3跑步耗时：10.2</span><br><span class=\"line\">选手：4跑步耗时：10.6</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：10.2</span><br><span class=\"line\">选手：2跑步耗时：10.9</span><br><span class=\"line\">选手：0跑步耗时：10.6</span><br><span class=\"line\">选手：3跑步耗时：10.0</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：2跑步耗时：10.8</span><br><span class=\"line\">选手：4跑步耗时：10.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">选手：0跑步耗时：9.2</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DelayQueue的使用\"><a href=\"#DelayQueue的使用\" class=\"headerlink\" title=\"DelayQueue的使用\"></a><code>DelayQueue</code>的使用</h4><p><code>DelayQueue</code>是一个无界的阻塞队列，实现<code>Delayed</code>接口。只有当<code>delay</code>被激发时，该对象才能从队列中获取数据</p>\n<h3 id=\"线程间通信管道模式-1\"><a href=\"#线程间通信管道模式-1\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><ul>\n<li>使用单向管道（Pipe）传递数据</li>\n<li>共享内存（Shared Memory）通信</li>\n<li>使用阻塞队列（Blocking Queue）实现生产者-消费者模式</li>\n<li>处理消息队列（Message Queue）</li>\n</ul>\n<h2 id=\"wait-notify机制\"><a href=\"#wait-notify机制\" class=\"headerlink\" title=\"wait/notify机制\"></a>wait/notify机制</h2><p>等待/通知机制主要由Object类中的三个方法进行保证</p>\n<p>1、wait()；notify();notifyAll()<br>上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；<code>wait();notify();notifyAll()</code>只有在被<code>synchronized</code>修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出<code>IllegalMonitorStateException</code>异常。</p>\n<p>1)wait()<br>让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用<code>notify()</code>或者<code>notifyAll()</code>时唤醒当前线程。<code>wait()</code>也可以作为任务同步的一种方式。</p>\n<p><strong>注：调用<code>sleep()</code>和<code>yield()</code>方法不能释放当前的对象锁</strong><br><code>wait()</code>方法有两种用法：</p>\n<ul>\n<li><code>wait(long timeout)</code>等待一定的时间，但与<code>sleep()</code>方法不同，其会释放对象锁</li>\n<li>使用<code>wait()</code>等待<code>notify()</code>或者<code>notifyAll()</code>唤醒。 </li>\n</ul>\n<p>2)notify()<br>唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；</p>\n<p>3)notifyAll()<br>唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过<code>synchronized(x)</code>来获取对象锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(x) &#123; </span><br><span class=\"line\">  x.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2、方法调用与线程状态关系</p>\n<p>每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列</p>\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p>Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；</p>\n<p>对应关系</p>\n<ul>\n<li>Condition中的await()对应Object的wait()</li>\n<li>Condition中的signal()对应Object的notify()</li>\n<li>Condition中的signalAll()对应Object中的notifyAll();</li>\n</ul>\n<p><strong>Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同</strong></p>\n<h3 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h3><p>线程锁控制代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">//生产者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionCustomer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//消费者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionProducer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//用于表示需要生产</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用于随机消费时间；</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于生产者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"生产线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionCustomer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">500</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"生产完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有消费者线程 \"</span>+<span class=\"string\">\"....\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的消费者线程</span></span><br><span class=\"line\">            conditionProducer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">custome</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"消费线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"await\"</span>);</span><br><span class=\"line\">                conditionProducer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费中\"</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">4000</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"线程：\"</span>+Thread.currentThread().getName()+<span class=\"string\">\"消费完毕\"</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">\"唤醒所有生产者线程 \"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的生产者线程</span></span><br><span class=\"line\">            conditionCustomer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomerThread</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            service.custome();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer_ServiceMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Service service=<span class=\"keyword\">new</span> Service();</span><br><span class=\"line\">        CustomerThread[] customerThread=<span class=\"keyword\">new</span> CustomerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        ProducerThread[] producerThreads=<span class=\"keyword\">new</span> ProducerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            customerThread[i]=<span class=\"keyword\">new</span> CustomerThread(service);</span><br><span class=\"line\">            customerThread[i].setName(<span class=\"string\">\"生产者Thread：\"</span>+i);</span><br><span class=\"line\">            producerThreads[i]=<span class=\"keyword\">new</span> ProducerThread(service);</span><br><span class=\"line\">            producerThreads[i].setName(<span class=\"string\">\"消费者Thread：\"</span>+i);</span><br><span class=\"line\">            customerThread[i].start();</span><br><span class=\"line\">            producerThreads[i].start();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：2await</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：2await</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"线程间通信管道模式\"><a href=\"#线程间通信管道模式\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3><h4 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h4><p>用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。</p>\n<p>任务执行线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用CountDownLatch会被自动要求加上此构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setName(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doWork();</span><br><span class=\"line\">            <span class=\"comment\">//用于倒数技术</span></span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//random.nextInt(2000)在Java中是线程安全的来自TIJ</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">\"completed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等待任务执行完毕，需要唤醒的线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitingTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WaitingTask</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           latch.await();</span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"Latch阻塞运行至waiting class\"</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCountDown</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数</span></span><br><span class=\"line\">        CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(SIZE);</span><br><span class=\"line\">      <span class=\"comment\">// for (int i=0;i&lt;10;i++)&#123;   //可以有多个等待线程</span></span><br><span class=\"line\">        exec.execute(<span class=\"keyword\">new</span> WaitingTask(latch));</span><br><span class=\"line\">      <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> Task(latch,<span class=\"string\">\"线程\"</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"启动所有任务\"</span>);</span><br><span class=\"line\">        exec.shutdown();  <span class=\"comment\">//任务只有在执行完毕后才会结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任务执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动所有任务</span><br><span class=\"line\">线程0completed</span><br><span class=\"line\">线程4completed</span><br><span class=\"line\">线程1completed</span><br><span class=\"line\">线程2completed</span><br><span class=\"line\">线程3completed</span><br><span class=\"line\">Latch阻塞运行至waiting class</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h4><p><code>CyclicBarrier</code>类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于<code>join</code>)，与<code>CountDownLatch</code>类的使用类似，<code>CountDownLatch</code>类只能执行一次，而<code>CyclicBarrier</code>可以进行多次使用。<br>以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；</p>\n<p>运动员代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Athlete</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示耗时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> time =<span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Athlete</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cyclicBarrier=cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">double</span> <span class=\"title\">getTime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.interrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                    time =(<span class=\"keyword\">double</span>)(rand.nextInt(<span class=\"number\">20</span>)+<span class=\"number\">90</span>)/<span class=\"number\">10</span>;</span><br><span class=\"line\">                    System.out.println(getName()+<span class=\"string\">\"跑步耗时：\"</span>+ getTime());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所有运动员跑完标志输出代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunningCtrl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RunningCtrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"++++++++++++++++++++++++++++++++\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RunningCtrl  runningCtrl=<span class=\"keyword\">new</span> RunningCtrl();</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>,runningCtrl);</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Athlete athlete = <span class=\"keyword\">new</span> Athlete(cyclicBarrier);</span><br><span class=\"line\">            athlete.setName(<span class=\"string\">\"选手：\"</span>+i);</span><br><span class=\"line\">            exec.execute(athlete);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">选手：0跑步耗时：9.5</span><br><span class=\"line\">选手：1跑步耗时：9.8</span><br><span class=\"line\">选手：4跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：0跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.8</span><br><span class=\"line\">选手：1跑步耗时：9.6</span><br><span class=\"line\">选手：4跑步耗时：9.4</span><br><span class=\"line\">选手：3跑步耗时：10.8</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：9.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：9.2</span><br><span class=\"line\">选手：2跑步耗时：9.3</span><br><span class=\"line\">选手：0跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.2</span><br><span class=\"line\">选手：0跑步耗时：9.9</span><br><span class=\"line\">选手：3跑步耗时：10.2</span><br><span class=\"line\">选手：4跑步耗时：10.6</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：10.2</span><br><span class=\"line\">选手：2跑步耗时：10.9</span><br><span class=\"line\">选手：0跑步耗时：10.6</span><br><span class=\"line\">选手：3跑步耗时：10.0</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：2跑步耗时：10.8</span><br><span class=\"line\">选手：4跑步耗时：10.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">选手：0跑步耗时：9.2</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DelayQueue的使用\"><a href=\"#DelayQueue的使用\" class=\"headerlink\" title=\"DelayQueue的使用\"></a><code>DelayQueue</code>的使用</h4><p><code>DelayQueue</code>是一个无界的阻塞队列，实现<code>Delayed</code>接口。只有当<code>delay</code>被激发时，该对象才能从队列中获取数据</p>\n<h3 id=\"线程间通信管道模式-1\"><a href=\"#线程间通信管道模式-1\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3>"},{"_content":"### Runnable接口\n\n仅调用Runnable的`run()`方法不能产生一个新的线程，新线程的执行必须通过`Thread.start()`方法来执行。\n\n通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。\n\n实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。\n\nThread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。\n\n### Thread类\n\nThread类的构造函数需要Runnable实例，调用Thread类的`start()`方法，可以对线程进行必要额初始化，然后执行Runnable实例的`run()`方法。\n\n静态方法`Thread.yield()`用于通知CPU从一个线程切换至另外一个线程；\n\n**注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。**\n\n\n### 多线程框架Executor的使用\nExecutors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。\n\n ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。\n \n Executors中的`shutdown()`方法用于停止向Executor中提交新的任务，在`shutdown()`方法调用之前提交的同步线程任务则会继续执行。\n \n ***注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理***\n \n#### Executor、Executors、ExecutorService区别\n\n* Executor是一个接口，用于并发提交的任务，只有`execute()`一个方法，没有返回值，不能对任务进行任何操作。\n\n```java\n    public interface Executor {\n        void execute(Runnable var1);\n    }\n```\n\n* Executors类提供不同的工厂方法来创建不同类型的线程池，包括：`newSingleThreadExecutor()`、`newFixedThreadPool(int numOfThreads)`、`newCachedThreadPool()`\n\n```java\n\n    public class Executors {\n            //...\n            public static ExecutorService newFixedThreadPool(int var0) {\n            return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());\n        }\n        \n        //...\n    }\n\n```\n\n\n* ExecutorService 是继承自`Exxecutor`的接口，其中有异步执行和关闭线程池的方法。可以通过`submit()`方法来提交任务，同时可以对任务进行取消等操作。\n\n```java\n    public interface ExecutorService extends Executor {\n        //...\n        void shutdown();\n\n        List<Runnable> shutdownNow();\n\n        boolean isShutdown();\n\n        boolean isTerminated();\n        //...          \n          \n    }\n```\n\n \n ### 不同线程池的使用\n\nCachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。\n\n ```java\n     ExecutorService exec = Executors.newCachedThreadPool();\n ```\n \n FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。\n \n ```java\n     ExecutorService exec = Executors.newFixedThreadPool(5); \n ```\n \n SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。\n \n ```java\n     Executors.newSingleThreadExecutor(); \n ```\n \n ### 任务的回调\n \n使用Callable和Future,一个产生结果，一个拿到结果\n \n每一个**Runnable**都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用**Callable**接口，而非**Runnable接口**。\n\nCallable接口带有`type`类型参数，该参数表示`call()`方法（非`run()`）方法执行完成后的返回值，必须通过调用` ExecutorService submit()`调用来执行。\n\n`submit()`方法返回一个一个Future对象，可以通过调用Future的`isDone()`方法来判断当前任务是否执行结束。调用Future的`get()`方法，如果当前任务没有结束，则会被阻塞，直至任务结束\n\n```java\n     class CallableResult implements Callable<String> {   \n        private int id;    \n        public TaskWithResult(int id) {     \n          this.id = id; \n         } \n           public String call() {    \n            return \"result\" + id;  \n           }\n        }\n        \n      public class CallableDemo {   \n        public static void main(String[] args) {   \n        ExecutorService exec = Executors.newCachedThreadPool();                    \n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();               \n         for(int i = 0; i < 10; i++)\n          results.add(exec.submit(new CallableResult(i)));  \n         for(Future<String> fs : results)     \n                try {               \n                   System.out.println(fs.get()); \n                } catch(InterruptedException e) {\n                    System.out.println(e);         \n                    return;      \n                } catch(ExecutionException e) {     \n                    System.out.println(e);      \n                } finally{        \n                     exec.shutdown(); \n                 } \n             } \n     }\n\n```\n\n### 任务的暂停\n\n通过调用`TimeUnit.MILLISECONDS.sleep(100);`来阻塞当前线程指定的时间。\n\n\n### 线程优先级\n \n JDK有十中不同的优先级。\n \n 线程优先级`Thread.MIN_PRIORIT`、`Thread.MAX_PRIORITY`，通过`setPriority()`方法进行设置，以及`getPriority()`方法进行获取。\n\n```\n     public void run() {Thread.currentThread().setPriority(priority);\n```\n\n\n### 守护线程Daemon threads \n\n守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在`thread.start();`之前调用`daemon.setDaemon(true)`;\n\n如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用`isDaemon()`方法进行查看是否为守护线程。\n\n\n\n### 数据共享\n\n#### synchronized关键字\n\n使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。\n```java\n\n    synchronized void f() { /* ... */ }\n```\n\n当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。\n\n在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。\n\n\n#### Lock对象的使用\n\n在调用`lock()`方法后，一定需要添加在`try-finally`的代码块，并在finally中调用`unlock()`方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在`try`代码块中实现，这样可以保证锁释放之前返回需要的值。***如果`lock.lock()`方法调用失败会出现什么情况***\n\n```\n     private Lock lock = new ReentrantLock();\n     int num=0;\n     \n     public int f(){\n        lock.lock();    \n        try {       \n             Thread.yield();   \n             return num++;    \n         }finally {      \n            lock.unlock();  \n        }   \n```\n当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。\n\n```java\n     boolean captured = false;    \n      try {      \n        captured = lock.tryLock(2, TimeUnit.SECONDS);   //限制请求次数\n        //captured = lock.tryLock();          //不限制请求次数\n       } catch(InterruptedException e) {      \n         throw new RuntimeException(e);     \n       } \n      try {       \n         System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured);    \n       } finally {     \n              if(captured)        \n              lock.unlock();    \n       }   \n\n```\n\n#### 原子性和波动性（Atomicity and Volality（易变的））\n原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是`synchronized`而非`volatile`。\n\n原子操作被应用于除`long`和`double`的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（`long`和`double`类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在`long`和`double`数据类型使用`volatile`关键字可以保证其操作的原子性。\n\n在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。\n\n当一个变量`volatile`关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。`volatile`关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。`volatile`关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。\n\n atomicity和volatility是两个不同的概念，原子性操作如果是非`volatile`类型的，那么其不会被立即刷到内存中；如果一个变量在一个` synchronized `的方法或者代码块中，那么变量也会被刷到内存中。\n\n\n#### Atomic classes （原子类）\n\n在Java SE 5中介绍了特殊的原子类：`Atomiclnteger`, `AtomicLong`, `AtomicReference`；对其操作时提供了原子类型的状态。\n\n#### 临界区\n\n在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。\n\n\n使用`synchronized`创建临界区\n```java\n     synchronized(syncObject) {  \n       // This code can be accessed \n      }\n    \n    \n    class PairManager2 extends PairManager { \n     public void increment() { \n         Pair temp;     \n         synchronized(this) {   \n             p.incrementX();    \n             p.incrementY();     \n             emp = getPair();   \n         }   \n         store(temp); \n        }\n    } \n   \n```\n\n使用功`Lock`锁创建临界区\n\n```java\n    class ExplicitPairManager2 extends PairManager {\n      private Lock lock = new ReentrantLock();  \n      public void increment() {    \n         Pair temp;     \n         lock.lock();    \n         try {     \n           p.incrementX();    \n           p.incrementY();     \n           temp = getPair();   \n           } finally {     \n             lock.unlock();   \n             }   \n           store(temp);  \n     } \n    }\n\n```\n\n\n\n\n\n\n\n\n \n ","source":"_posts/Java/Java多线程/Java多线程基础.md","raw":"### Runnable接口\n\n仅调用Runnable的`run()`方法不能产生一个新的线程，新线程的执行必须通过`Thread.start()`方法来执行。\n\n通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。\n\n实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。\n\nThread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。\n\n### Thread类\n\nThread类的构造函数需要Runnable实例，调用Thread类的`start()`方法，可以对线程进行必要额初始化，然后执行Runnable实例的`run()`方法。\n\n静态方法`Thread.yield()`用于通知CPU从一个线程切换至另外一个线程；\n\n**注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。**\n\n\n### 多线程框架Executor的使用\nExecutors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。\n\n ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。\n \n Executors中的`shutdown()`方法用于停止向Executor中提交新的任务，在`shutdown()`方法调用之前提交的同步线程任务则会继续执行。\n \n ***注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理***\n \n#### Executor、Executors、ExecutorService区别\n\n* Executor是一个接口，用于并发提交的任务，只有`execute()`一个方法，没有返回值，不能对任务进行任何操作。\n\n```java\n    public interface Executor {\n        void execute(Runnable var1);\n    }\n```\n\n* Executors类提供不同的工厂方法来创建不同类型的线程池，包括：`newSingleThreadExecutor()`、`newFixedThreadPool(int numOfThreads)`、`newCachedThreadPool()`\n\n```java\n\n    public class Executors {\n            //...\n            public static ExecutorService newFixedThreadPool(int var0) {\n            return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());\n        }\n        \n        //...\n    }\n\n```\n\n\n* ExecutorService 是继承自`Exxecutor`的接口，其中有异步执行和关闭线程池的方法。可以通过`submit()`方法来提交任务，同时可以对任务进行取消等操作。\n\n```java\n    public interface ExecutorService extends Executor {\n        //...\n        void shutdown();\n\n        List<Runnable> shutdownNow();\n\n        boolean isShutdown();\n\n        boolean isTerminated();\n        //...          \n          \n    }\n```\n\n \n ### 不同线程池的使用\n\nCachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。\n\n ```java\n     ExecutorService exec = Executors.newCachedThreadPool();\n ```\n \n FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。\n \n ```java\n     ExecutorService exec = Executors.newFixedThreadPool(5); \n ```\n \n SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。\n \n ```java\n     Executors.newSingleThreadExecutor(); \n ```\n \n ### 任务的回调\n \n使用Callable和Future,一个产生结果，一个拿到结果\n \n每一个**Runnable**都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用**Callable**接口，而非**Runnable接口**。\n\nCallable接口带有`type`类型参数，该参数表示`call()`方法（非`run()`）方法执行完成后的返回值，必须通过调用` ExecutorService submit()`调用来执行。\n\n`submit()`方法返回一个一个Future对象，可以通过调用Future的`isDone()`方法来判断当前任务是否执行结束。调用Future的`get()`方法，如果当前任务没有结束，则会被阻塞，直至任务结束\n\n```java\n     class CallableResult implements Callable<String> {   \n        private int id;    \n        public TaskWithResult(int id) {     \n          this.id = id; \n         } \n           public String call() {    \n            return \"result\" + id;  \n           }\n        }\n        \n      public class CallableDemo {   \n        public static void main(String[] args) {   \n        ExecutorService exec = Executors.newCachedThreadPool();                    \n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();               \n         for(int i = 0; i < 10; i++)\n          results.add(exec.submit(new CallableResult(i)));  \n         for(Future<String> fs : results)     \n                try {               \n                   System.out.println(fs.get()); \n                } catch(InterruptedException e) {\n                    System.out.println(e);         \n                    return;      \n                } catch(ExecutionException e) {     \n                    System.out.println(e);      \n                } finally{        \n                     exec.shutdown(); \n                 } \n             } \n     }\n\n```\n\n### 任务的暂停\n\n通过调用`TimeUnit.MILLISECONDS.sleep(100);`来阻塞当前线程指定的时间。\n\n\n### 线程优先级\n \n JDK有十中不同的优先级。\n \n 线程优先级`Thread.MIN_PRIORIT`、`Thread.MAX_PRIORITY`，通过`setPriority()`方法进行设置，以及`getPriority()`方法进行获取。\n\n```\n     public void run() {Thread.currentThread().setPriority(priority);\n```\n\n\n### 守护线程Daemon threads \n\n守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在`thread.start();`之前调用`daemon.setDaemon(true)`;\n\n如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用`isDaemon()`方法进行查看是否为守护线程。\n\n\n\n### 数据共享\n\n#### synchronized关键字\n\n使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。\n```java\n\n    synchronized void f() { /* ... */ }\n```\n\n当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。\n\n在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。\n\n\n#### Lock对象的使用\n\n在调用`lock()`方法后，一定需要添加在`try-finally`的代码块，并在finally中调用`unlock()`方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在`try`代码块中实现，这样可以保证锁释放之前返回需要的值。***如果`lock.lock()`方法调用失败会出现什么情况***\n\n```\n     private Lock lock = new ReentrantLock();\n     int num=0;\n     \n     public int f(){\n        lock.lock();    \n        try {       \n             Thread.yield();   \n             return num++;    \n         }finally {      \n            lock.unlock();  \n        }   \n```\n当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。\n\n```java\n     boolean captured = false;    \n      try {      \n        captured = lock.tryLock(2, TimeUnit.SECONDS);   //限制请求次数\n        //captured = lock.tryLock();          //不限制请求次数\n       } catch(InterruptedException e) {      \n         throw new RuntimeException(e);     \n       } \n      try {       \n         System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured);    \n       } finally {     \n              if(captured)        \n              lock.unlock();    \n       }   \n\n```\n\n#### 原子性和波动性（Atomicity and Volality（易变的））\n原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是`synchronized`而非`volatile`。\n\n原子操作被应用于除`long`和`double`的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（`long`和`double`类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在`long`和`double`数据类型使用`volatile`关键字可以保证其操作的原子性。\n\n在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。\n\n当一个变量`volatile`关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。`volatile`关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。`volatile`关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。\n\n atomicity和volatility是两个不同的概念，原子性操作如果是非`volatile`类型的，那么其不会被立即刷到内存中；如果一个变量在一个` synchronized `的方法或者代码块中，那么变量也会被刷到内存中。\n\n\n#### Atomic classes （原子类）\n\n在Java SE 5中介绍了特殊的原子类：`Atomiclnteger`, `AtomicLong`, `AtomicReference`；对其操作时提供了原子类型的状态。\n\n#### 临界区\n\n在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。\n\n\n使用`synchronized`创建临界区\n```java\n     synchronized(syncObject) {  \n       // This code can be accessed \n      }\n    \n    \n    class PairManager2 extends PairManager { \n     public void increment() { \n         Pair temp;     \n         synchronized(this) {   \n             p.incrementX();    \n             p.incrementY();     \n             emp = getPair();   \n         }   \n         store(temp); \n        }\n    } \n   \n```\n\n使用功`Lock`锁创建临界区\n\n```java\n    class ExplicitPairManager2 extends PairManager {\n      private Lock lock = new ReentrantLock();  \n      public void increment() {    \n         Pair temp;     \n         lock.lock();    \n         try {     \n           p.incrementX();    \n           p.incrementY();     \n           temp = getPair();   \n           } finally {     \n             lock.unlock();   \n             }   \n           store(temp);  \n     } \n    }\n\n```\n\n\n\n\n\n\n\n\n \n ","slug":"Java/Java多线程/Java多线程基础","published":1,"date":"2019-09-19T09:41:14.776Z","updated":"2019-09-30T08:28:42.974Z","title":"Java/Java多线程/Java多线程基础","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0w001vkguiers6fiwr","content":"<h3 id=\"Runnable接口\"><a href=\"#Runnable接口\" class=\"headerlink\" title=\"Runnable接口\"></a>Runnable接口</h3><p>仅调用Runnable的<code>run()</code>方法不能产生一个新的线程，新线程的执行必须通过<code>Thread.start()</code>方法来执行。</p>\n<p>通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。</p>\n<p>实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。</p>\n<p>Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p>Thread类的构造函数需要Runnable实例，调用Thread类的<code>start()</code>方法，可以对线程进行必要额初始化，然后执行Runnable实例的<code>run()</code>方法。</p>\n<p>静态方法<code>Thread.yield()</code>用于通知CPU从一个线程切换至另外一个线程；</p>\n<p><strong>注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</strong></p>\n<h3 id=\"多线程框架Executor的使用\"><a href=\"#多线程框架Executor的使用\" class=\"headerlink\" title=\"多线程框架Executor的使用\"></a>多线程框架Executor的使用</h3><p>Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。</p>\n<p> ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。</p>\n<p> Executors中的<code>shutdown()</code>方法用于停止向Executor中提交新的任务，在<code>shutdown()</code>方法调用之前提交的同步线程任务则会继续执行。</p>\n<p> <strong><em>注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理</em></strong></p>\n<h4 id=\"Executor、Executors、ExecutorService区别\"><a href=\"#Executor、Executors、ExecutorService区别\" class=\"headerlink\" title=\"Executor、Executors、ExecutorService区别\"></a>Executor、Executors、ExecutorService区别</h4><ul>\n<li>Executor是一个接口，用于并发提交的任务，只有<code>execute()</code>一个方法，没有返回值，不能对任务进行任何操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Executors类提供不同的工厂方法来创建不同类型的线程池，包括：<code>newSingleThreadExecutor()</code>、<code>newFixedThreadPool(int numOfThreads)</code>、<code>newCachedThreadPool()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Executors</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(var0, var0, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>ExecutorService 是继承自<code>Exxecutor</code>的接口，其中有异步执行和关闭线程池的方法。可以通过<code>submit()</code>方法来提交任务，同时可以对任务进行取消等操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//...          </span></span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"不同线程池的使用\"><a href=\"#不同线程池的使用\" class=\"headerlink\" title=\"不同线程池的使用\"></a>不同线程池的使用</h3><p>CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p> FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p> SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的回调\"><a href=\"#任务的回调\" class=\"headerlink\" title=\"任务的回调\"></a>任务的回调</h3><p>使用Callable和Future,一个产生结果，一个拿到结果</p>\n<p>每一个<strong>Runnable</strong>都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用<strong>Callable</strong>接口，而非<strong>Runnable接口</strong>。</p>\n<p>Callable接口带有<code>type</code>类型参数，该参数表示<code>call()</code>方法（非<code>run()</code>）方法执行完成后的返回值，必须通过调用<code>ExecutorService submit()</code>调用来执行。</p>\n<p><code>submit()</code>方法返回一个一个Future对象，可以通过调用Future的<code>isDone()</code>方法来判断当前任务是否执行结束。调用Future的<code>get()</code>方法，如果当前任务没有结束，则会被阻塞，直至任务结束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"result\"</span> + id;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;   </span><br><span class=\"line\">   ExecutorService exec = Executors.newCachedThreadPool();                    </span><br><span class=\"line\">   ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();               </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">     results.add(exec.submit(<span class=\"keyword\">new</span> CallableResult(i)));  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Future&lt;String&gt; fs : results)     </span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;               </span><br><span class=\"line\">              System.out.println(fs.get()); </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">               System.out.println(e);         </span><br><span class=\"line\">               <span class=\"keyword\">return</span>;      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(ExecutionException e) &#123;     </span><br><span class=\"line\">               System.out.println(e);      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span>&#123;        </span><br><span class=\"line\">                exec.shutdown(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的暂停\"><a href=\"#任务的暂停\" class=\"headerlink\" title=\"任务的暂停\"></a>任务的暂停</h3><p>通过调用<code>TimeUnit.MILLISECONDS.sleep(100);</code>来阻塞当前线程指定的时间。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p> JDK有十中不同的优先级。</p>\n<p> 线程优先级<code>Thread.MIN_PRIORIT</code>、<code>Thread.MAX_PRIORITY</code>，通过<code>setPriority()</code>方法进行设置，以及<code>getPriority()</code>方法进行获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;Thread.currentThread().setPriority(priority);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"守护线程Daemon-threads\"><a href=\"#守护线程Daemon-threads\" class=\"headerlink\" title=\"守护线程Daemon threads\"></a>守护线程Daemon threads</h3><p>守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在<code>thread.start();</code>之前调用<code>daemon.setDaemon(true)</code>;</p>\n<p>如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用<code>isDaemon()</code>方法进行查看是否为守护线程。</p>\n<h3 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h3><h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。</p>\n<p>在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。</p>\n<h4 id=\"Lock对象的使用\"><a href=\"#Lock对象的使用\" class=\"headerlink\" title=\"Lock对象的使用\"></a>Lock对象的使用</h4><p>在调用<code>lock()</code>方法后，一定需要添加在<code>try-finally</code>的代码块，并在finally中调用<code>unlock()</code>方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在<code>try</code>代码块中实现，这样可以保证锁释放之前返回需要的值。<strong><em>如果<code>lock.lock()</code>方法调用失败会出现什么情况</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Lock lock &#x3D; new ReentrantLock();</span><br><span class=\"line\">int num&#x3D;0;</span><br><span class=\"line\"></span><br><span class=\"line\">public int f()&#123;</span><br><span class=\"line\">   lock.lock();    </span><br><span class=\"line\">   try &#123;       </span><br><span class=\"line\">        Thread.yield();   </span><br><span class=\"line\">        return num++;    </span><br><span class=\"line\">    &#125;finally &#123;      </span><br><span class=\"line\">       lock.unlock();  </span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;    </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;      </span><br><span class=\"line\">   captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);   <span class=\"comment\">//限制请求次数</span></span><br><span class=\"line\">   <span class=\"comment\">//captured = lock.tryLock();          //不限制请求次数</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);     </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;       </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"tryLock(2, TimeUnit.SECONDS): \"</span> + captured);    </span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         <span class=\"keyword\">if</span>(captured)        </span><br><span class=\"line\">         lock.unlock();    </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原子性和波动性（Atomicity-and-Volality（易变的））\"><a href=\"#原子性和波动性（Atomicity-and-Volality（易变的））\" class=\"headerlink\" title=\"原子性和波动性（Atomicity and Volality（易变的））\"></a>原子性和波动性（Atomicity and Volality（易变的））</h4><p>原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是<code>synchronized</code>而非<code>volatile</code>。</p>\n<p>原子操作被应用于除<code>long</code>和<code>double</code>的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（<code>long</code>和<code>double</code>类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在<code>long</code>和<code>double</code>数据类型使用<code>volatile</code>关键字可以保证其操作的原子性。</p>\n<p>在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。</p>\n<p>当一个变量<code>volatile</code>关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。<code>volatile</code>关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。<code>volatile</code>关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。</p>\n<p> atomicity和volatility是两个不同的概念，原子性操作如果是非<code>volatile</code>类型的，那么其不会被立即刷到内存中；如果一个变量在一个<code>synchronized</code>的方法或者代码块中，那么变量也会被刷到内存中。</p>\n<h4 id=\"Atomic-classes-（原子类）\"><a href=\"#Atomic-classes-（原子类）\" class=\"headerlink\" title=\"Atomic classes （原子类）\"></a>Atomic classes （原子类）</h4><p>在Java SE 5中介绍了特殊的原子类：<code>Atomiclnteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>；对其操作时提供了原子类型的状态。</p>\n<h4 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h4><p>在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。</p>\n<p>使用<code>synchronized</code>创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">synchronized</span>(syncObject) &#123;  </span><br><span class=\"line\">   <span class=\"comment\">// This code can be accessed </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;   </span><br><span class=\"line\">         p.incrementX();    </span><br><span class=\"line\">         p.incrementY();     </span><br><span class=\"line\">         emp = getPair();   </span><br><span class=\"line\">     &#125;   </span><br><span class=\"line\">     store(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用功<code>Lock</code>锁创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExplicitPairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     lock.lock();    </span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;     </span><br><span class=\"line\">       p.incrementX();    </span><br><span class=\"line\">       p.incrementY();     </span><br><span class=\"line\">       temp = getPair();   </span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         lock.unlock();   </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">       store(temp);  </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Runnable接口\"><a href=\"#Runnable接口\" class=\"headerlink\" title=\"Runnable接口\"></a>Runnable接口</h3><p>仅调用Runnable的<code>run()</code>方法不能产生一个新的线程，新线程的执行必须通过<code>Thread.start()</code>方法来执行。</p>\n<p>通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。</p>\n<p>实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。</p>\n<p>Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p>Thread类的构造函数需要Runnable实例，调用Thread类的<code>start()</code>方法，可以对线程进行必要额初始化，然后执行Runnable实例的<code>run()</code>方法。</p>\n<p>静态方法<code>Thread.yield()</code>用于通知CPU从一个线程切换至另外一个线程；</p>\n<p><strong>注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</strong></p>\n<h3 id=\"多线程框架Executor的使用\"><a href=\"#多线程框架Executor的使用\" class=\"headerlink\" title=\"多线程框架Executor的使用\"></a>多线程框架Executor的使用</h3><p>Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。</p>\n<p> ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。</p>\n<p> Executors中的<code>shutdown()</code>方法用于停止向Executor中提交新的任务，在<code>shutdown()</code>方法调用之前提交的同步线程任务则会继续执行。</p>\n<p> <strong><em>注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理</em></strong></p>\n<h4 id=\"Executor、Executors、ExecutorService区别\"><a href=\"#Executor、Executors、ExecutorService区别\" class=\"headerlink\" title=\"Executor、Executors、ExecutorService区别\"></a>Executor、Executors、ExecutorService区别</h4><ul>\n<li>Executor是一个接口，用于并发提交的任务，只有<code>execute()</code>一个方法，没有返回值，不能对任务进行任何操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Executors类提供不同的工厂方法来创建不同类型的线程池，包括：<code>newSingleThreadExecutor()</code>、<code>newFixedThreadPool(int numOfThreads)</code>、<code>newCachedThreadPool()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Executors</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(var0, var0, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>ExecutorService 是继承自<code>Exxecutor</code>的接口，其中有异步执行和关闭线程池的方法。可以通过<code>submit()</code>方法来提交任务，同时可以对任务进行取消等操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//...          </span></span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"不同线程池的使用\"><a href=\"#不同线程池的使用\" class=\"headerlink\" title=\"不同线程池的使用\"></a>不同线程池的使用</h3><p>CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p> FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p> SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的回调\"><a href=\"#任务的回调\" class=\"headerlink\" title=\"任务的回调\"></a>任务的回调</h3><p>使用Callable和Future,一个产生结果，一个拿到结果</p>\n<p>每一个<strong>Runnable</strong>都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用<strong>Callable</strong>接口，而非<strong>Runnable接口</strong>。</p>\n<p>Callable接口带有<code>type</code>类型参数，该参数表示<code>call()</code>方法（非<code>run()</code>）方法执行完成后的返回值，必须通过调用<code>ExecutorService submit()</code>调用来执行。</p>\n<p><code>submit()</code>方法返回一个一个Future对象，可以通过调用Future的<code>isDone()</code>方法来判断当前任务是否执行结束。调用Future的<code>get()</code>方法，如果当前任务没有结束，则会被阻塞，直至任务结束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">\"result\"</span> + id;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;   </span><br><span class=\"line\">   ExecutorService exec = Executors.newCachedThreadPool();                    </span><br><span class=\"line\">   ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();               </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">     results.add(exec.submit(<span class=\"keyword\">new</span> CallableResult(i)));  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Future&lt;String&gt; fs : results)     </span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;               </span><br><span class=\"line\">              System.out.println(fs.get()); </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">               System.out.println(e);         </span><br><span class=\"line\">               <span class=\"keyword\">return</span>;      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(ExecutionException e) &#123;     </span><br><span class=\"line\">               System.out.println(e);      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span>&#123;        </span><br><span class=\"line\">                exec.shutdown(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的暂停\"><a href=\"#任务的暂停\" class=\"headerlink\" title=\"任务的暂停\"></a>任务的暂停</h3><p>通过调用<code>TimeUnit.MILLISECONDS.sleep(100);</code>来阻塞当前线程指定的时间。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p> JDK有十中不同的优先级。</p>\n<p> 线程优先级<code>Thread.MIN_PRIORIT</code>、<code>Thread.MAX_PRIORITY</code>，通过<code>setPriority()</code>方法进行设置，以及<code>getPriority()</code>方法进行获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;Thread.currentThread().setPriority(priority);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"守护线程Daemon-threads\"><a href=\"#守护线程Daemon-threads\" class=\"headerlink\" title=\"守护线程Daemon threads\"></a>守护线程Daemon threads</h3><p>守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在<code>thread.start();</code>之前调用<code>daemon.setDaemon(true)</code>;</p>\n<p>如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用<code>isDaemon()</code>方法进行查看是否为守护线程。</p>\n<h3 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h3><h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。</p>\n<p>在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。</p>\n<h4 id=\"Lock对象的使用\"><a href=\"#Lock对象的使用\" class=\"headerlink\" title=\"Lock对象的使用\"></a>Lock对象的使用</h4><p>在调用<code>lock()</code>方法后，一定需要添加在<code>try-finally</code>的代码块，并在finally中调用<code>unlock()</code>方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在<code>try</code>代码块中实现，这样可以保证锁释放之前返回需要的值。<strong><em>如果<code>lock.lock()</code>方法调用失败会出现什么情况</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Lock lock &#x3D; new ReentrantLock();</span><br><span class=\"line\">int num&#x3D;0;</span><br><span class=\"line\"></span><br><span class=\"line\">public int f()&#123;</span><br><span class=\"line\">   lock.lock();    </span><br><span class=\"line\">   try &#123;       </span><br><span class=\"line\">        Thread.yield();   </span><br><span class=\"line\">        return num++;    </span><br><span class=\"line\">    &#125;finally &#123;      </span><br><span class=\"line\">       lock.unlock();  </span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;    </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;      </span><br><span class=\"line\">   captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);   <span class=\"comment\">//限制请求次数</span></span><br><span class=\"line\">   <span class=\"comment\">//captured = lock.tryLock();          //不限制请求次数</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);     </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;       </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"tryLock(2, TimeUnit.SECONDS): \"</span> + captured);    </span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         <span class=\"keyword\">if</span>(captured)        </span><br><span class=\"line\">         lock.unlock();    </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原子性和波动性（Atomicity-and-Volality（易变的））\"><a href=\"#原子性和波动性（Atomicity-and-Volality（易变的））\" class=\"headerlink\" title=\"原子性和波动性（Atomicity and Volality（易变的））\"></a>原子性和波动性（Atomicity and Volality（易变的））</h4><p>原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是<code>synchronized</code>而非<code>volatile</code>。</p>\n<p>原子操作被应用于除<code>long</code>和<code>double</code>的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（<code>long</code>和<code>double</code>类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在<code>long</code>和<code>double</code>数据类型使用<code>volatile</code>关键字可以保证其操作的原子性。</p>\n<p>在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。</p>\n<p>当一个变量<code>volatile</code>关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。<code>volatile</code>关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。<code>volatile</code>关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。</p>\n<p> atomicity和volatility是两个不同的概念，原子性操作如果是非<code>volatile</code>类型的，那么其不会被立即刷到内存中；如果一个变量在一个<code>synchronized</code>的方法或者代码块中，那么变量也会被刷到内存中。</p>\n<h4 id=\"Atomic-classes-（原子类）\"><a href=\"#Atomic-classes-（原子类）\" class=\"headerlink\" title=\"Atomic classes （原子类）\"></a>Atomic classes （原子类）</h4><p>在Java SE 5中介绍了特殊的原子类：<code>Atomiclnteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>；对其操作时提供了原子类型的状态。</p>\n<h4 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h4><p>在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。</p>\n<p>使用<code>synchronized</code>创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">synchronized</span>(syncObject) &#123;  </span><br><span class=\"line\">   <span class=\"comment\">// This code can be accessed </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;   </span><br><span class=\"line\">         p.incrementX();    </span><br><span class=\"line\">         p.incrementY();     </span><br><span class=\"line\">         emp = getPair();   </span><br><span class=\"line\">     &#125;   </span><br><span class=\"line\">     store(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用功<code>Lock</code>锁创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExplicitPairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     lock.lock();    </span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;     </span><br><span class=\"line\">       p.incrementX();    </span><br><span class=\"line\">       p.incrementY();     </span><br><span class=\"line\">       temp = getPair();   </span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         lock.unlock();   </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">       store(temp);  </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n"},{"_content":"","source":"_posts/Java/Java基础/Img/README.md","raw":"","slug":"Java/Java基础/Img/README","published":1,"date":"2019-09-27T08:23:54.079Z","updated":"2019-09-27T08:23:54.079Z","title":"Java/Java基础/Img/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li0z0022kgui6wi4csg7","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/Java/设计模式/Img/README.md","raw":"","slug":"Java/设计模式/Img/README","published":1,"date":"2019-11-28T12:20:23.102Z","updated":"2019-11-28T12:20:23.102Z","title":"Java/设计模式/Img/README","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li100023kgui2gvogrwx","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# Retrofit 2.5 框架使用与源码分析\n\n## Retrofit 框架使用\n\n\n#### 请求内容与返回值\n\n使用PostMan进行请求测试\n请求：`https://api.github.com/search/repositories?q=android`\n\n返回值：\n\nHeader:\n![](/assets/Retrofit.png)\n\nBody:\n```json\n{\n    \"total_count\": 943593,\n    \"incomplete_results\": false,\n    \"items\": [\n        {\n            \"id\": 82128465,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\",\n            \"name\": \"Android\",\n            \"full_name\": \"open-android/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"open-android\",\n                \"id\": 23095877,\n                \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\",\n                \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\",\n                //……\n            },\n            \"html_url\": \"https://github.com/open-android/Android\",\n            \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\",\n            \"fork\": false,\n            \"url\": \"https://api.github.com/repos/open-android/Android\",\n            //……\n        },\n        {\n            \"id\": 12544093,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\",\n            \"name\": \"Android\",\n            \"full_name\": \"hmkcode/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"hmkcode\",\n                \"id\": 3790597,\n                //……\n            },\n            //……\n        }\n    ]\n}\n```\n#### 引入Retrofit依赖\n\n```java\n    implementation 'com.squareup.retrofit2:retrofit:2.5.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'\n```\n#### 根据返回的请求结果定义Repository Bean类\n返回的报文采用google.gson进行处理，金处理必要的值\n\n```java\npublic class RepoBean {\n\n    //用于表示Repo id\n    private int id;\n    //用于表示RepoName\n    private String name;\n\n    //用于表示完整名称\n    //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注\n    @SerializedName(\"full_name\")\n    private String fullName;\n    \n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 根据返回的请求结果定义一次查询结果\n\n```java\npublic class SearchRepoBean {\n\n    //用于表示仓库数量\n    @SerializedName(\"total_count\")\n    private int totalCount;\n    //用于表示是否为完整结果\n    private boolean incompleteResults;\n    //用于表示持有的所有的仓库类\n    private List<RepoBean>items;\n\n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 定义网络请求API接口\n\n```java\n    public interface GithubService {\n        \n        //@Get注解，表示以Get方法发送网络请求\n        //返回类型为Call<SearchRepoBean>，SearchRepoBean是接收数据的类，可以自定义\n        @GET(\"search/repositories\")\n        Call<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n\n```\n\n#### 初始化Retrofit实例，生成接口实现类\n\n```java\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")                   //设置网络请求的URL地址           \n                .addConverterFactory(GsonConverterFactory.create())   //设置数据解析器 \n                .build();\n\n        githubService = retrofit.create(GithubService.class);\n\n```\n\n#### 进行网络请求\n\n```java\n\n    Call<SearchRepoBean> call = githubService.getRepoInfo(\"Android\");\n        //同步请求方式\n        //call.request();\n        //异步请求方式\n        call.enqueue(new Callback<SearchRepoBean>() {\n            @Override\n            public void onResponse(Call<SearchRepoBean> call, Response<SearchRepoBean> response) {\n              //输出请求结果 \n              //  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());\n               // List<RepoBean>repoBeans=new ArrayList<>();\n               // repoBeans.addAll(response.body().getItems());\n               // for (int i=repoBeans.size()-1;i>=0;i--){\n               //  LogUtils.printInfo(repoBeans.get(i).getFullName());\n               // }\n              }\n\n            @Override\n            public void onFailure(Call<SearchRepoBean> call, Throwable t) {\n                }\n            });\n```\n\n#### 将请求值的返回设为LiveData\n\n将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现\n\n```java\n    public interface GithubService {\n         @GET(\"search/repositories\")\n         LiveData<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n```\n自定义LiveDataCallAdapterFactory \n\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n\n        //用于获取泛型的参数\n        Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n        Class<?> rawObserverType = getRawType(observerType);\n\n\n        LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType);\n\n        return liveDataCallAdapter;\n        }\n    }\n\n\n```\n自定义 LiveDataCallAdapter\n```java\n\n    public class LiveDataCallAdapter<R> implements CallAdapter<R, LiveData<SearchRepoBean>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<SearchRepoBean> adapt(final Call<R> call) {\n\n             LiveData<SearchRepoBean>searchRepoBeanLiveData=new LiveData<SearchRepoBean>() {\n\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n    \n                    @Override\n                    public void onResponse(Call<R> call, Response<R> response) {\n                        postValue((SearchRepoBean) response.body());\n                    }\n\n                    @Override\n                    public void onFailure(Call<R> call, Throwable t) {\n                        LogUtils.printInfo(\"error\");\n                    }\n                });\n            }\n        };\n        //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值\n       return searchRepoBeanLiveData;\n    }\n    }\n\n```\n为Retrofit实例添加CallAdapterFactory\n\n```java\n      Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(new LiveDataCallAdapterFactory())\n                .build();\n\n```\n调用方法\n```java\n\n            repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n            repoBeanLiveData.observe(GithubApiActivity.this, new Observer<SearchRepoBean>() {\n                @Override\n                public void onChanged(SearchRepoBean searchRepoBean) {                            \n                     //输出结果\n                    }\n                });\n\n```\n\n\n#### 添加通用的响应实体\n\n通过`LiveDataCallAdapter` 和`LiveDataCallAdapterFactory` 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为`SearchRepoBean`类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。\n\n定义一个通用的响应实体\n\n```java\n    public class ApiResponse<T> {\n\n    public ApiResponseSuccess<T> create(Response<T> response) {\n        if (response.isSuccessful()) {\n            return new ApiResponseSuccess<T>(response.body());\n        } else {\n            return null;\n        }\n    }\n\n    //用于表示返回成功的值\n    public static class ApiResponseSuccess<T> extends ApiResponse<T> {\n        /用于表示请求返回成功的内容，在本代码中是SearchRepoBean\n        private T body;\n\n        public ApiResponseSuccess(T body) {\n            this.body = body;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n  }\n\n```\n修改LiveDataCallAdapterFactory\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n            //用于获取泛型的参数\n            //return type为LiveData<ApiResponse<SearchRepoBean>> \n            //observerType为ApiResponse<SearchRepoBean>\n            Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n            //bodyType为SearchRepoBean\n            Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType);\n            LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType);\n\n            return liveDataCallAdapter;\n        }\n    }\n\n```\n修改LiveDataCallAdapter\n\n```java\n    public class LiveDataCallAdapter<R> implements CallAdapter<R,LiveData<ApiResponse<R>>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<ApiResponse<R>> adapt(final Call<R> call) {\n            LiveData<ApiResponse<R>> result=new LiveData<ApiResponse<R>>() {\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n                        @Override\n                        public void onResponse(Call<R> call, Response<R> response) {\n                       postValue(new ApiResponse<R>().create(response));\n                    }\n\n                        @Override\n                        public void onFailure(Call<R> call, Throwable t) {\n                          //  LogUtils.printInfo(\"+++++!2312qwqweww31\");\n                        }\n                    });\n                }\n            };\n        return result;\n    }\n}\n```\n\n修改调用方法\n```java\n    repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n    repoBeanLiveData.observe(GithubApiActivity.this, new Observer<ApiResponse<SearchRepoBean>>() {\n        @Override\n        public void onChanged(ApiResponse<SearchRepoBean> searchRepoBeanApiResponse) {\n            SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();\n           //输出结果\n        }\n    });\n\n```\n\n## 源码详解\n\n##### Retrofit构建中的`.baseUrl(\"https://api.github.com/\")`介绍\nRetrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型\n```java\n\n    public final class Retrofit {\n\n      public static final class Builder {\n             public Builder baseUrl(String baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  return baseUrl(HttpUrl.get(baseUrl));\n                }\n                \n            public Builder baseUrl(HttpUrl baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  List<String> pathSegments = baseUrl.pathSegments();\n                  if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n                    throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n                  }\n              this.baseUrl = baseUrl;\n              return this;\n            }\n          }\n        }\n\n```\n\n##### Retrofit构建中的`.addConverterFactory(GsonConverterFactory.create())`\n通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory\n\n```java\n    public Builder addConverterFactory(Converter.Factory factory) {\n      converterFactories.add(checkNotNull(factory, \"factory == null\"));\n      return this;\n    }\n\n```\nConverter接口源码，核心是`T convert(F value)`,将F类型的数据转换为T类型\n\n```java\n\npublic interface Converter<F, T> {\n  //将F类型的数据转换为T类型\n  @Nullable T convert(F value) throws IOException;\n\n  //根据数据类型创建Converter创建 Converter\n  abstract class Factory {\n    //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。\n    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,\n        Annotation[] annotations, Retrofit retrofit) {\n      return null;\n    }\n\n       //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody\n    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,\n        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n      return null;\n    }\n        //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String\n    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n      return null;\n    }\n\n    protected static Type getParameterUpperBound(int index, ParameterizedType type) {\n      return Utils.getParameterUpperBound(index, type);\n    }\n\n    protected static Class<?> getRawType(Type type) {\n      return Utils.getRawType(type);\n    }\n  }\n}\n\n```\n\n\n##### Retrofit构建中的`.addCallAdapterFactory(new LiveDataCallAdapterFactory())`\n用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用\n\n```java\npublic final class Retrofit {\n      final List<CallAdapter.Factory> callAdapterFactories;\n      \n      //…………\n      public Builder addCallAdapterFactory(CallAdapter.Factory factory) {\n          callAdapterFactories.add(checkNotNull(factory, \"factory == null\"));\n          return this;\n        }\n      //…………\n}\n\n```\n\n##### 最终用来创建Service的代码`retrofit.create(GithubService.class)`\ncreate()采用代理的方式进行创建，\n\n```java\npublic final class Retrofit {\n  //……\n  public <T> T create(final Class<T> service) {\n    //判断定义的接口服务是否可用\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // 如果是Object本身的方法，正常调用后返回\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            //如果是platform默认的方法，正常调用后返回\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            //解析我们定义的网络请求的方法\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n  //……\n}\n```\n`loadServiceMethod(Method method)`源码解析,其实际上是HttpServiceMethod对象\n\n```java\n\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    //从解析的缓存中获取\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        \n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n\n```\n` static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method)`源码\n\n```java\nabstract class ServiceMethod<T> {\n      static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n      //RequestFactory负责解析接口并且生成Request\n        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n       //…………\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract T invoke(Object[] args);\n}\n\n\n```\n\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)`源码\n\n```java\n\n//将一个接口方法转变为一个Http请求\nfinal class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {\n\n  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n      //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码\n    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);\n \n    //……\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    okhttp3.Call.Factory callFactory = retrofit.callFactory;\n    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);\n  }\n\n  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(\n      Retrofit retrofit, Method method) {\n    Type returnType = method.getGenericReturnType();\n    Annotation[] annotations = method.getAnnotations();\n    try {\n      //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter\n      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);\n    } catch (RuntimeException e) { // Wide exception range because factories are user code.\n      throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n    }\n  }\n\n //…………\n\n  private final RequestFactory requestFactory;\n  private final okhttp3.Call.Factory callFactory;\n  private final CallAdapter<ResponseT, ReturnT> callAdapter;\n  private final Converter<ResponseBody, ResponseT> responseConverter;\n\n  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n      CallAdapter<ResponseT, ReturnT> callAdapter,\n      Converter<ResponseBody, ResponseT> responseConverter) {\n    this.requestFactory = requestFactory;\n    this.callFactory = callFactory;\n    this.callAdapter = callAdapter;\n    this.responseConverter = responseConverter;\n  }\n\n  //代理调用的invoke最终会调用下面invoke方法\n  @Override ReturnT invoke(Object[] args) {\n    return callAdapter.adapt(\n        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));\n  }\n}\n\n\n`call.enqueue(new Callback<SearchRepoBean>() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})`\n\n```java\n\nfinal class OkHttpCall<T> implements Call<T> {\n\n    //……\n   @Override public void enqueue(final Callback<T> callback) {\n\n    //……\n    call.enqueue(new okhttp3.Callback() {\n      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        //……\n        try {\n          callback.onResponse(OkHttpCall.this, response);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n    });\n   }\n    //……\n}\n\n```\n\n\n\n\n\n\n\n","source":"_posts/Android/框架/Retrofit 2.5 框架使用与源码分析.md","raw":"# Retrofit 2.5 框架使用与源码分析\n\n## Retrofit 框架使用\n\n\n#### 请求内容与返回值\n\n使用PostMan进行请求测试\n请求：`https://api.github.com/search/repositories?q=android`\n\n返回值：\n\nHeader:\n![](/assets/Retrofit.png)\n\nBody:\n```json\n{\n    \"total_count\": 943593,\n    \"incomplete_results\": false,\n    \"items\": [\n        {\n            \"id\": 82128465,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\",\n            \"name\": \"Android\",\n            \"full_name\": \"open-android/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"open-android\",\n                \"id\": 23095877,\n                \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\",\n                \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\",\n                //……\n            },\n            \"html_url\": \"https://github.com/open-android/Android\",\n            \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\",\n            \"fork\": false,\n            \"url\": \"https://api.github.com/repos/open-android/Android\",\n            //……\n        },\n        {\n            \"id\": 12544093,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\",\n            \"name\": \"Android\",\n            \"full_name\": \"hmkcode/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"hmkcode\",\n                \"id\": 3790597,\n                //……\n            },\n            //……\n        }\n    ]\n}\n```\n#### 引入Retrofit依赖\n\n```java\n    implementation 'com.squareup.retrofit2:retrofit:2.5.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'\n```\n#### 根据返回的请求结果定义Repository Bean类\n返回的报文采用google.gson进行处理，金处理必要的值\n\n```java\npublic class RepoBean {\n\n    //用于表示Repo id\n    private int id;\n    //用于表示RepoName\n    private String name;\n\n    //用于表示完整名称\n    //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注\n    @SerializedName(\"full_name\")\n    private String fullName;\n    \n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 根据返回的请求结果定义一次查询结果\n\n```java\npublic class SearchRepoBean {\n\n    //用于表示仓库数量\n    @SerializedName(\"total_count\")\n    private int totalCount;\n    //用于表示是否为完整结果\n    private boolean incompleteResults;\n    //用于表示持有的所有的仓库类\n    private List<RepoBean>items;\n\n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 定义网络请求API接口\n\n```java\n    public interface GithubService {\n        \n        //@Get注解，表示以Get方法发送网络请求\n        //返回类型为Call<SearchRepoBean>，SearchRepoBean是接收数据的类，可以自定义\n        @GET(\"search/repositories\")\n        Call<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n\n```\n\n#### 初始化Retrofit实例，生成接口实现类\n\n```java\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")                   //设置网络请求的URL地址           \n                .addConverterFactory(GsonConverterFactory.create())   //设置数据解析器 \n                .build();\n\n        githubService = retrofit.create(GithubService.class);\n\n```\n\n#### 进行网络请求\n\n```java\n\n    Call<SearchRepoBean> call = githubService.getRepoInfo(\"Android\");\n        //同步请求方式\n        //call.request();\n        //异步请求方式\n        call.enqueue(new Callback<SearchRepoBean>() {\n            @Override\n            public void onResponse(Call<SearchRepoBean> call, Response<SearchRepoBean> response) {\n              //输出请求结果 \n              //  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());\n               // List<RepoBean>repoBeans=new ArrayList<>();\n               // repoBeans.addAll(response.body().getItems());\n               // for (int i=repoBeans.size()-1;i>=0;i--){\n               //  LogUtils.printInfo(repoBeans.get(i).getFullName());\n               // }\n              }\n\n            @Override\n            public void onFailure(Call<SearchRepoBean> call, Throwable t) {\n                }\n            });\n```\n\n#### 将请求值的返回设为LiveData\n\n将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现\n\n```java\n    public interface GithubService {\n         @GET(\"search/repositories\")\n         LiveData<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n```\n自定义LiveDataCallAdapterFactory \n\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n\n        //用于获取泛型的参数\n        Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n        Class<?> rawObserverType = getRawType(observerType);\n\n\n        LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType);\n\n        return liveDataCallAdapter;\n        }\n    }\n\n\n```\n自定义 LiveDataCallAdapter\n```java\n\n    public class LiveDataCallAdapter<R> implements CallAdapter<R, LiveData<SearchRepoBean>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<SearchRepoBean> adapt(final Call<R> call) {\n\n             LiveData<SearchRepoBean>searchRepoBeanLiveData=new LiveData<SearchRepoBean>() {\n\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n    \n                    @Override\n                    public void onResponse(Call<R> call, Response<R> response) {\n                        postValue((SearchRepoBean) response.body());\n                    }\n\n                    @Override\n                    public void onFailure(Call<R> call, Throwable t) {\n                        LogUtils.printInfo(\"error\");\n                    }\n                });\n            }\n        };\n        //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值\n       return searchRepoBeanLiveData;\n    }\n    }\n\n```\n为Retrofit实例添加CallAdapterFactory\n\n```java\n      Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(new LiveDataCallAdapterFactory())\n                .build();\n\n```\n调用方法\n```java\n\n            repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n            repoBeanLiveData.observe(GithubApiActivity.this, new Observer<SearchRepoBean>() {\n                @Override\n                public void onChanged(SearchRepoBean searchRepoBean) {                            \n                     //输出结果\n                    }\n                });\n\n```\n\n\n#### 添加通用的响应实体\n\n通过`LiveDataCallAdapter` 和`LiveDataCallAdapterFactory` 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为`SearchRepoBean`类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。\n\n定义一个通用的响应实体\n\n```java\n    public class ApiResponse<T> {\n\n    public ApiResponseSuccess<T> create(Response<T> response) {\n        if (response.isSuccessful()) {\n            return new ApiResponseSuccess<T>(response.body());\n        } else {\n            return null;\n        }\n    }\n\n    //用于表示返回成功的值\n    public static class ApiResponseSuccess<T> extends ApiResponse<T> {\n        /用于表示请求返回成功的内容，在本代码中是SearchRepoBean\n        private T body;\n\n        public ApiResponseSuccess(T body) {\n            this.body = body;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n  }\n\n```\n修改LiveDataCallAdapterFactory\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n            //用于获取泛型的参数\n            //return type为LiveData<ApiResponse<SearchRepoBean>> \n            //observerType为ApiResponse<SearchRepoBean>\n            Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n            //bodyType为SearchRepoBean\n            Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType);\n            LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType);\n\n            return liveDataCallAdapter;\n        }\n    }\n\n```\n修改LiveDataCallAdapter\n\n```java\n    public class LiveDataCallAdapter<R> implements CallAdapter<R,LiveData<ApiResponse<R>>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<ApiResponse<R>> adapt(final Call<R> call) {\n            LiveData<ApiResponse<R>> result=new LiveData<ApiResponse<R>>() {\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n                        @Override\n                        public void onResponse(Call<R> call, Response<R> response) {\n                       postValue(new ApiResponse<R>().create(response));\n                    }\n\n                        @Override\n                        public void onFailure(Call<R> call, Throwable t) {\n                          //  LogUtils.printInfo(\"+++++!2312qwqweww31\");\n                        }\n                    });\n                }\n            };\n        return result;\n    }\n}\n```\n\n修改调用方法\n```java\n    repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n    repoBeanLiveData.observe(GithubApiActivity.this, new Observer<ApiResponse<SearchRepoBean>>() {\n        @Override\n        public void onChanged(ApiResponse<SearchRepoBean> searchRepoBeanApiResponse) {\n            SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();\n           //输出结果\n        }\n    });\n\n```\n\n## 源码详解\n\n##### Retrofit构建中的`.baseUrl(\"https://api.github.com/\")`介绍\nRetrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型\n```java\n\n    public final class Retrofit {\n\n      public static final class Builder {\n             public Builder baseUrl(String baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  return baseUrl(HttpUrl.get(baseUrl));\n                }\n                \n            public Builder baseUrl(HttpUrl baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  List<String> pathSegments = baseUrl.pathSegments();\n                  if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n                    throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n                  }\n              this.baseUrl = baseUrl;\n              return this;\n            }\n          }\n        }\n\n```\n\n##### Retrofit构建中的`.addConverterFactory(GsonConverterFactory.create())`\n通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory\n\n```java\n    public Builder addConverterFactory(Converter.Factory factory) {\n      converterFactories.add(checkNotNull(factory, \"factory == null\"));\n      return this;\n    }\n\n```\nConverter接口源码，核心是`T convert(F value)`,将F类型的数据转换为T类型\n\n```java\n\npublic interface Converter<F, T> {\n  //将F类型的数据转换为T类型\n  @Nullable T convert(F value) throws IOException;\n\n  //根据数据类型创建Converter创建 Converter\n  abstract class Factory {\n    //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。\n    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,\n        Annotation[] annotations, Retrofit retrofit) {\n      return null;\n    }\n\n       //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody\n    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,\n        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n      return null;\n    }\n        //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String\n    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n      return null;\n    }\n\n    protected static Type getParameterUpperBound(int index, ParameterizedType type) {\n      return Utils.getParameterUpperBound(index, type);\n    }\n\n    protected static Class<?> getRawType(Type type) {\n      return Utils.getRawType(type);\n    }\n  }\n}\n\n```\n\n\n##### Retrofit构建中的`.addCallAdapterFactory(new LiveDataCallAdapterFactory())`\n用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用\n\n```java\npublic final class Retrofit {\n      final List<CallAdapter.Factory> callAdapterFactories;\n      \n      //…………\n      public Builder addCallAdapterFactory(CallAdapter.Factory factory) {\n          callAdapterFactories.add(checkNotNull(factory, \"factory == null\"));\n          return this;\n        }\n      //…………\n}\n\n```\n\n##### 最终用来创建Service的代码`retrofit.create(GithubService.class)`\ncreate()采用代理的方式进行创建，\n\n```java\npublic final class Retrofit {\n  //……\n  public <T> T create(final Class<T> service) {\n    //判断定义的接口服务是否可用\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // 如果是Object本身的方法，正常调用后返回\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            //如果是platform默认的方法，正常调用后返回\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            //解析我们定义的网络请求的方法\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n  //……\n}\n```\n`loadServiceMethod(Method method)`源码解析,其实际上是HttpServiceMethod对象\n\n```java\n\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    //从解析的缓存中获取\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        \n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n\n```\n` static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method)`源码\n\n```java\nabstract class ServiceMethod<T> {\n      static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n      //RequestFactory负责解析接口并且生成Request\n        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n       //…………\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract T invoke(Object[] args);\n}\n\n\n```\n\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)`源码\n\n```java\n\n//将一个接口方法转变为一个Http请求\nfinal class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {\n\n  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n      //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码\n    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);\n \n    //……\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    okhttp3.Call.Factory callFactory = retrofit.callFactory;\n    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);\n  }\n\n  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(\n      Retrofit retrofit, Method method) {\n    Type returnType = method.getGenericReturnType();\n    Annotation[] annotations = method.getAnnotations();\n    try {\n      //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter\n      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);\n    } catch (RuntimeException e) { // Wide exception range because factories are user code.\n      throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n    }\n  }\n\n //…………\n\n  private final RequestFactory requestFactory;\n  private final okhttp3.Call.Factory callFactory;\n  private final CallAdapter<ResponseT, ReturnT> callAdapter;\n  private final Converter<ResponseBody, ResponseT> responseConverter;\n\n  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n      CallAdapter<ResponseT, ReturnT> callAdapter,\n      Converter<ResponseBody, ResponseT> responseConverter) {\n    this.requestFactory = requestFactory;\n    this.callFactory = callFactory;\n    this.callAdapter = callAdapter;\n    this.responseConverter = responseConverter;\n  }\n\n  //代理调用的invoke最终会调用下面invoke方法\n  @Override ReturnT invoke(Object[] args) {\n    return callAdapter.adapt(\n        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));\n  }\n}\n\n\n`call.enqueue(new Callback<SearchRepoBean>() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})`\n\n```java\n\nfinal class OkHttpCall<T> implements Call<T> {\n\n    //……\n   @Override public void enqueue(final Callback<T> callback) {\n\n    //……\n    call.enqueue(new okhttp3.Callback() {\n      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        //……\n        try {\n          callback.onResponse(OkHttpCall.this, response);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n    });\n   }\n    //……\n}\n\n```\n\n\n\n\n\n\n\n","slug":"Android/框架/Retrofit 2.5 框架使用与源码分析","published":1,"date":"2019-11-30T11:13:20.728Z","updated":"2019-11-30T11:14:32.190Z","title":"Android/框架/Retrofit 2.5 框架使用与源码分析","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li120024kguibyuih7rn","content":"<h1 id=\"Retrofit-2-5-框架使用与源码分析\"><a href=\"#Retrofit-2-5-框架使用与源码分析\" class=\"headerlink\" title=\"Retrofit 2.5 框架使用与源码分析\"></a>Retrofit 2.5 框架使用与源码分析</h1><h2 id=\"Retrofit-框架使用\"><a href=\"#Retrofit-框架使用\" class=\"headerlink\" title=\"Retrofit 框架使用\"></a>Retrofit 框架使用</h2><h4 id=\"请求内容与返回值\"><a href=\"#请求内容与返回值\" class=\"headerlink\" title=\"请求内容与返回值\"></a>请求内容与返回值</h4><p>使用PostMan进行请求测试<br>请求：<code>https://api.github.com/search/repositories?q=android</code></p>\n<p>返回值：</p>\n<p>Header:<br><img src=\"/assets/Retrofit.png\" alt=\"\"></p>\n<p>Body:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"total_count\"</span>: <span class=\"number\">943593</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"incomplete_results\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"items\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">82128465</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"open-android\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">23095877</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDQ6VXNlcjIzMDk1ODc3\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"avatar_url\"</span>: <span class=\"string\">\"https://avatars2.githubusercontent.com/u/23095877?v=4\"</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"html_url\"</span>: <span class=\"string\">\"https://github.com/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"fork\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/repos/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">12544093</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"hmkcode/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"hmkcode\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">3790597</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引入Retrofit依赖\"><a href=\"#引入Retrofit依赖\" class=\"headerlink\" title=\"引入Retrofit依赖\"></a>引入Retrofit依赖</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:retrofit:2.5.0'</span></span><br><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义Repository-Bean类\"><a href=\"#根据返回的请求结果定义Repository-Bean类\" class=\"headerlink\" title=\"根据返回的请求结果定义Repository Bean类\"></a>根据返回的请求结果定义Repository Bean类</h4><p>返回的报文采用google.gson进行处理，金处理必要的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示Repo id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示RepoName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示完整名称</span></span><br><span class=\"line\">    <span class=\"comment\">//Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"full_name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fullName;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"根据返回的请求结果定义一次查询结果\"><a href=\"#根据返回的请求结果定义一次查询结果\" class=\"headerlink\" title=\"根据返回的请求结果定义一次查询结果\"></a>根据返回的请求结果定义一次查询结果</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SearchRepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示仓库数量</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"total_count\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示是否为完整结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> incompleteResults;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示持有的所有的仓库类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RepoBean&gt;items;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义网络请求API接口\"><a href=\"#定义网络请求API接口\" class=\"headerlink\" title=\"定义网络请求API接口\"></a>定义网络请求API接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//@Get注解，表示以Get方法发送网络请求</span></span><br><span class=\"line\">    <span class=\"comment\">//返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化Retrofit实例，生成接口实现类\"><a href=\"#初始化Retrofit实例，生成接口实现类\" class=\"headerlink\" title=\"初始化Retrofit实例，生成接口实现类\"></a>初始化Retrofit实例，生成接口实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)                   <span class=\"comment\">//设置网络请求的URL地址           </span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())   <span class=\"comment\">//设置数据解析器 </span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">githubService = retrofit.create(GithubService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//同步请求方式</span></span><br><span class=\"line\">    <span class=\"comment\">//call.request();</span></span><br><span class=\"line\">    <span class=\"comment\">//异步请求方式</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//输出请求结果 </span></span><br><span class=\"line\">          <span class=\"comment\">//  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());</span></span><br><span class=\"line\">           <span class=\"comment\">// List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"comment\">// repoBeans.addAll(response.body().getItems());</span></span><br><span class=\"line\">           <span class=\"comment\">// for (int i=repoBeans.size()-1;i&gt;=0;i--)&#123;</span></span><br><span class=\"line\">           <span class=\"comment\">//  LogUtils.printInfo(repoBeans.get(i).getFullName());</span></span><br><span class=\"line\">           <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将请求值的返回设为LiveData\"><a href=\"#将请求值的返回设为LiveData\" class=\"headerlink\" title=\"将请求值的返回设为LiveData\"></a>将请求值的返回设为LiveData</h4><p>将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">     <span class=\"function\">LiveData&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义LiveDataCallAdapterFactory </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">    Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; rawObserverType = getRawType(observerType);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(rawObserverType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义 LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">LiveData</span>&lt;<span class=\"title\">SearchRepoBean</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;SearchRepoBean&gt; <span class=\"title\">adapt</span><span class=\"params\">(<span class=\"keyword\">final</span> Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=<span class=\"keyword\">new</span> LiveData&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                    postValue((SearchRepoBean) response.body());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                    LogUtils.printInfo(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> searchRepoBeanLiveData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为Retrofit实例添加CallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">          .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)</span><br><span class=\"line\">          .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">          .addCallAdapterFactory(<span class=\"keyword\">new</span> LiveDataCallAdapterFactory())</span><br><span class=\"line\">          .build();</span><br></pre></td></tr></table></figure>\n<p>调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(SearchRepoBean searchRepoBean)</span> </span>&#123;                            </span><br><span class=\"line\">         <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"添加通用的响应实体\"><a href=\"#添加通用的响应实体\" class=\"headerlink\" title=\"添加通用的响应实体\"></a>添加通用的响应实体</h4><p>通过<code>LiveDataCallAdapter</code> 和<code>LiveDataCallAdapterFactory</code> 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为<code>SearchRepoBean</code>类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。</p>\n<p>定义一个通用的响应实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ApiResponseSuccess&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.isSuccessful()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiResponseSuccess&lt;T&gt;(response.body());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用于表示返回成功的值</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponseSuccess</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      /用于表示请求返回成功的内容，在本代码中是SearchRepoBean</span><br><span class=\"line\">      <span class=\"keyword\">private</span> T body;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiResponseSuccess</span><span class=\"params\">(T body)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getBody</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">        <span class=\"comment\">//return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//observerType为ApiResponse&lt;SearchRepoBean&gt;</span></span><br><span class=\"line\">        Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\">        <span class=\"comment\">//bodyType为SearchRepoBean</span></span><br><span class=\"line\">        Type bodyType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) observerType);</span><br><span class=\"line\">        LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(bodyType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>,<span class=\"title\">LiveData</span>&lt;<span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">R</span>&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(<span class=\"keyword\">final</span> Call&lt;R&gt; call) &#123;</span><br><span class=\"line\">            LiveData&lt;ApiResponse&lt;R&gt;&gt; result=<span class=\"keyword\">new</span> LiveData&lt;ApiResponse&lt;R&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                       postValue(<span class=\"keyword\">new</span> ApiResponse&lt;R&gt;().create(response));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                          <span class=\"comment\">//  LogUtils.printInfo(\"+++++!2312qwqweww31\");</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse)</span> </span>&#123;</span><br><span class=\"line\">        SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();</span><br><span class=\"line\">       <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h5 id=\"Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\"><a href=\"#Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\" class=\"headerlink\" title=\"Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍\"></a>Retrofit构建中的<code>.baseUrl(&quot;https://api.github.com/&quot;)</code>介绍</h5><p>Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(String baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"string\">\"\"</span>.equals(pathSegments.get(pathSegments.size() - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"baseUrl must end in /: \"</span> + baseUrl);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.baseUrl = baseUrl;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\"><a href=\"#Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\" class=\"headerlink\" title=\"Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())\"></a>Retrofit构建中的<code>.addConverterFactory(GsonConverterFactory.create())</code></h5><p>通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addConverterFactory</span><span class=\"params\">(Converter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">  converterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Converter接口源码，核心是<code>T convert(F value)</code>,将F类型的数据转换为T类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">F</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将F类型的数据转换为T类型</span></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">convert</span><span class=\"params\">(F value)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据数据类型创建Converter创建 Converter</span></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Type <span class=\"title\">getParameterUpperBound</span><span class=\"params\">(<span class=\"keyword\">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getRawType(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\"><a href=\"#Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\" class=\"headerlink\" title=\"Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())\"></a>Retrofit构建中的<code>.addCallAdapterFactory(new LiveDataCallAdapterFactory())</code></h5><p>用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addCallAdapterFactory</span><span class=\"params\">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">          callAdapterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"最终用来创建Service的代码retrofit-create-GithubService-class\"><a href=\"#最终用来创建Service的代码retrofit-create-GithubService-class\" class=\"headerlink\" title=\"最终用来创建Service的代码retrofit.create(GithubService.class)\"></a>最终用来创建Service的代码<code>retrofit.create(GithubService.class)</code></h5><p>create()采用代理的方式进行创建，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断定义的接口服务是否可用</span></span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是Object本身的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是platform默认的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解析我们定义的网络请求的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loadServiceMethod(Method method)</code>源码解析,其实际上是HttpServiceMethod对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//从解析的缓存中获取</span></span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//RequestFactory负责解析接口并且生成Request</span></span><br><span class=\"line\">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//…………</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将一个接口方法转变为一个Http请求</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServiceMethod</span>&lt;<span class=\"title\">ResponseT</span>, <span class=\"title\">ReturnT</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">ReturnT</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">CallAdapter&lt;ResponseT, ReturnT&gt; <span class=\"title\">createCallAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123; <span class=\"comment\">// Wide exception range because factories are user code.</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> methodError(method, e, <span class=\"string\">\"Unable to create call adapter for %s\"</span>, returnType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//…………</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestFactory requestFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> okhttp3.Call.Factory callFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;ResponseBody, ResponseT&gt; responseConverter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HttpServiceMethod</span><span class=\"params\">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.requestFactory = requestFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callFactory = callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callAdapter = callAdapter;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.responseConverter = responseConverter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//代理调用的invoke最终会调用下面invoke方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callAdapter.adapt(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;&#125;)`最终调用的方法是OkhttpCall中的`call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkHttpCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">        Response&lt;T&gt; response;</span><br><span class=\"line\">        <span class=\"comment\">//……</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">          t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Retrofit-2-5-框架使用与源码分析\"><a href=\"#Retrofit-2-5-框架使用与源码分析\" class=\"headerlink\" title=\"Retrofit 2.5 框架使用与源码分析\"></a>Retrofit 2.5 框架使用与源码分析</h1><h2 id=\"Retrofit-框架使用\"><a href=\"#Retrofit-框架使用\" class=\"headerlink\" title=\"Retrofit 框架使用\"></a>Retrofit 框架使用</h2><h4 id=\"请求内容与返回值\"><a href=\"#请求内容与返回值\" class=\"headerlink\" title=\"请求内容与返回值\"></a>请求内容与返回值</h4><p>使用PostMan进行请求测试<br>请求：<code>https://api.github.com/search/repositories?q=android</code></p>\n<p>返回值：</p>\n<p>Header:<br><img src=\"/assets/Retrofit.png\" alt=\"\"></p>\n<p>Body:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"total_count\"</span>: <span class=\"number\">943593</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"incomplete_results\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"items\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">82128465</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"open-android\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">23095877</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDQ6VXNlcjIzMDk1ODc3\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"avatar_url\"</span>: <span class=\"string\">\"https://avatars2.githubusercontent.com/u/23095877?v=4\"</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"html_url\"</span>: <span class=\"string\">\"https://github.com/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"description\"</span>: <span class=\"string\">\"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"fork\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://api.github.com/repos/open-android/Android\"</span>,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"id\"</span>: <span class=\"number\">12544093</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"node_id\"</span>: <span class=\"string\">\"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"full_name\"</span>: <span class=\"string\">\"hmkcode/Android\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"private\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"owner\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"login\"</span>: <span class=\"string\">\"hmkcode\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"id\"</span>: <span class=\"number\">3790597</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引入Retrofit依赖\"><a href=\"#引入Retrofit依赖\" class=\"headerlink\" title=\"引入Retrofit依赖\"></a>引入Retrofit依赖</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:retrofit:2.5.0'</span></span><br><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.5.0'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义Repository-Bean类\"><a href=\"#根据返回的请求结果定义Repository-Bean类\" class=\"headerlink\" title=\"根据返回的请求结果定义Repository Bean类\"></a>根据返回的请求结果定义Repository Bean类</h4><p>返回的报文采用google.gson进行处理，金处理必要的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示Repo id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示RepoName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示完整名称</span></span><br><span class=\"line\">    <span class=\"comment\">//Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"full_name\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fullName;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"根据返回的请求结果定义一次查询结果\"><a href=\"#根据返回的请求结果定义一次查询结果\" class=\"headerlink\" title=\"根据返回的请求结果定义一次查询结果\"></a>根据返回的请求结果定义一次查询结果</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SearchRepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示仓库数量</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"total_count\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示是否为完整结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> incompleteResults;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示持有的所有的仓库类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RepoBean&gt;items;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"定义网络请求API接口\"><a href=\"#定义网络请求API接口\" class=\"headerlink\" title=\"定义网络请求API接口\"></a>定义网络请求API接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//@Get注解，表示以Get方法发送网络请求</span></span><br><span class=\"line\">    <span class=\"comment\">//返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化Retrofit实例，生成接口实现类\"><a href=\"#初始化Retrofit实例，生成接口实现类\" class=\"headerlink\" title=\"初始化Retrofit实例，生成接口实现类\"></a>初始化Retrofit实例，生成接口实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)                   <span class=\"comment\">//设置网络请求的URL地址           </span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())   <span class=\"comment\">//设置数据解析器 </span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">githubService = retrofit.create(GithubService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//同步请求方式</span></span><br><span class=\"line\">    <span class=\"comment\">//call.request();</span></span><br><span class=\"line\">    <span class=\"comment\">//异步请求方式</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//输出请求结果 </span></span><br><span class=\"line\">          <span class=\"comment\">//  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());</span></span><br><span class=\"line\">           <span class=\"comment\">// List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"comment\">// repoBeans.addAll(response.body().getItems());</span></span><br><span class=\"line\">           <span class=\"comment\">// for (int i=repoBeans.size()-1;i&gt;=0;i--)&#123;</span></span><br><span class=\"line\">           <span class=\"comment\">//  LogUtils.printInfo(repoBeans.get(i).getFullName());</span></span><br><span class=\"line\">           <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"将请求值的返回设为LiveData\"><a href=\"#将请求值的返回设为LiveData\" class=\"headerlink\" title=\"将请求值的返回设为LiveData\"></a>将请求值的返回设为LiveData</h4><p>将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@GET</span>(<span class=\"string\">\"search/repositories\"</span>)</span><br><span class=\"line\">     <span class=\"function\">LiveData&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(@Query(<span class=\"string\">\"q\"</span>)</span> String query)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义LiveDataCallAdapterFactory </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">    Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; rawObserverType = getRawType(observerType);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(rawObserverType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义 LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">LiveData</span>&lt;<span class=\"title\">SearchRepoBean</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;SearchRepoBean&gt; <span class=\"title\">adapt</span><span class=\"params\">(<span class=\"keyword\">final</span> Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=<span class=\"keyword\">new</span> LiveData&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                    postValue((SearchRepoBean) response.body());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                    LogUtils.printInfo(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> searchRepoBeanLiveData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为Retrofit实例添加CallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">          .baseUrl(<span class=\"string\">\"https://api.github.com/\"</span>)</span><br><span class=\"line\">          .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">          .addCallAdapterFactory(<span class=\"keyword\">new</span> LiveDataCallAdapterFactory())</span><br><span class=\"line\">          .build();</span><br></pre></td></tr></table></figure>\n<p>调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(SearchRepoBean searchRepoBean)</span> </span>&#123;                            </span><br><span class=\"line\">         <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"添加通用的响应实体\"><a href=\"#添加通用的响应实体\" class=\"headerlink\" title=\"添加通用的响应实体\"></a>添加通用的响应实体</h4><p>通过<code>LiveDataCallAdapter</code> 和<code>LiveDataCallAdapterFactory</code> 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为<code>SearchRepoBean</code>类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。</p>\n<p>定义一个通用的响应实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ApiResponseSuccess&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.isSuccessful()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiResponseSuccess&lt;T&gt;(response.body());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用于表示返回成功的值</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponseSuccess</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      /用于表示请求返回成功的内容，在本代码中是SearchRepoBean</span><br><span class=\"line\">      <span class=\"keyword\">private</span> T body;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiResponseSuccess</span><span class=\"params\">(T body)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getBody</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">        <span class=\"comment\">//return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//observerType为ApiResponse&lt;SearchRepoBean&gt;</span></span><br><span class=\"line\">        Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\">        <span class=\"comment\">//bodyType为SearchRepoBean</span></span><br><span class=\"line\">        Type bodyType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) observerType);</span><br><span class=\"line\">        LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(bodyType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>,<span class=\"title\">LiveData</span>&lt;<span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">R</span>&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(<span class=\"keyword\">final</span> Call&lt;R&gt; call) &#123;</span><br><span class=\"line\">            LiveData&lt;ApiResponse&lt;R&gt;&gt; result=<span class=\"keyword\">new</span> LiveData&lt;ApiResponse&lt;R&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                       postValue(<span class=\"keyword\">new</span> ApiResponse&lt;R&gt;().create(response));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                          <span class=\"comment\">//  LogUtils.printInfo(\"+++++!2312qwqweww31\");</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">\"Android\"</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse)</span> </span>&#123;</span><br><span class=\"line\">        SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();</span><br><span class=\"line\">       <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h5 id=\"Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\"><a href=\"#Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\" class=\"headerlink\" title=\"Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍\"></a>Retrofit构建中的<code>.baseUrl(&quot;https://api.github.com/&quot;)</code>介绍</h5><p>Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(String baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">\"baseUrl == null\"</span>);</span><br><span class=\"line\">              List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"string\">\"\"</span>.equals(pathSegments.get(pathSegments.size() - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"baseUrl must end in /: \"</span> + baseUrl);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.baseUrl = baseUrl;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\"><a href=\"#Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\" class=\"headerlink\" title=\"Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())\"></a>Retrofit构建中的<code>.addConverterFactory(GsonConverterFactory.create())</code></h5><p>通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addConverterFactory</span><span class=\"params\">(Converter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">  converterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Converter接口源码，核心是<code>T convert(F value)</code>,将F类型的数据转换为T类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">F</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将F类型的数据转换为T类型</span></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">convert</span><span class=\"params\">(F value)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据数据类型创建Converter创建 Converter</span></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Type <span class=\"title\">getParameterUpperBound</span><span class=\"params\">(<span class=\"keyword\">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getRawType(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h5 id=\"Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\"><a href=\"#Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\" class=\"headerlink\" title=\"Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())\"></a>Retrofit构建中的<code>.addCallAdapterFactory(new LiveDataCallAdapterFactory())</code></h5><p>用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addCallAdapterFactory</span><span class=\"params\">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">          callAdapterFactories.add(checkNotNull(factory, <span class=\"string\">\"factory == null\"</span>));</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"最终用来创建Service的代码retrofit-create-GithubService-class\"><a href=\"#最终用来创建Service的代码retrofit-create-GithubService-class\" class=\"headerlink\" title=\"最终用来创建Service的代码retrofit.create(GithubService.class)\"></a>最终用来创建Service的代码<code>retrofit.create(GithubService.class)</code></h5><p>create()采用代理的方式进行创建，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断定义的接口服务是否可用</span></span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是Object本身的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是platform默认的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解析我们定义的网络请求的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loadServiceMethod(Method method)</code>源码解析,其实际上是HttpServiceMethod对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//从解析的缓存中获取</span></span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//RequestFactory负责解析接口并且生成Request</span></span><br><span class=\"line\">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//…………</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将一个接口方法转变为一个Http请求</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServiceMethod</span>&lt;<span class=\"title\">ResponseT</span>, <span class=\"title\">ReturnT</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">ReturnT</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">CallAdapter&lt;ResponseT, ReturnT&gt; <span class=\"title\">createCallAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123; <span class=\"comment\">// Wide exception range because factories are user code.</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> methodError(method, e, <span class=\"string\">\"Unable to create call adapter for %s\"</span>, returnType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//…………</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestFactory requestFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> okhttp3.Call.Factory callFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;ResponseBody, ResponseT&gt; responseConverter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HttpServiceMethod</span><span class=\"params\">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.requestFactory = requestFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callFactory = callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callAdapter = callAdapter;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.responseConverter = responseConverter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//代理调用的invoke最终会调用下面invoke方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callAdapter.adapt(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;&#125;)`最终调用的方法是OkhttpCall中的`call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkHttpCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">        Response&lt;T&gt; response;</span><br><span class=\"line\">        <span class=\"comment\">//……</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">          t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"_content":"\n## Android生命周期感知组件详解\n\n使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 `onStart()` `onStop()`中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。\n\n### Lifecycle类\n\n![](/assets/lifecycle.png)\n\nLifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。\n\n* Event\n\n    由framework层分发的以及`Lifecycle`类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调\n\n* State\n   \n    表示由`Lifecycle`对象跟踪的组件的当前的状态\n    \n### LifecycleOwner\n\n`LifecycleOwner`是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。\n\n源码：\n\n```java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     *\n    @NonNull\n    Lifecycle getLifecycle();\n}\n\n```\n\n一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现`LifecycleOwner`接口。\n\n\n### LifecycleObserver\n\n`LifecycleObserver`接口可以与实现`LifecycleOwner`接口的类配合使用，实现`LifecycleOwner`接口的类提供`Lifecycle`，而`LifecycleObserver`可以注册至被观察者。\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/Android Lifecycle-Aware组件详解.md","raw":"\n## Android生命周期感知组件详解\n\n使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 `onStart()` `onStop()`中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。\n\n### Lifecycle类\n\n![](/assets/lifecycle.png)\n\nLifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。\n\n* Event\n\n    由framework层分发的以及`Lifecycle`类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调\n\n* State\n   \n    表示由`Lifecycle`对象跟踪的组件的当前的状态\n    \n### LifecycleOwner\n\n`LifecycleOwner`是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。\n\n源码：\n\n```java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     *\n    @NonNull\n    Lifecycle getLifecycle();\n}\n\n```\n\n一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现`LifecycleOwner`接口。\n\n\n### LifecycleObserver\n\n`LifecycleObserver`接口可以与实现`LifecycleOwner`接口的类配合使用，实现`LifecycleOwner`接口的类提供`Lifecycle`，而`LifecycleObserver`可以注册至被观察者。\n\n\n\n\n\n","slug":"Android/框架/AAC/Android Lifecycle-Aware组件详解","published":1,"date":"2019-11-28T12:20:15.895Z","updated":"2019-11-30T11:14:32.184Z","title":"Android/框架/AAC/Android Lifecycle-Aware组件详解","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li130025kgui7camart2","content":"<h2 id=\"Android生命周期感知组件详解\"><a href=\"#Android生命周期感知组件详解\" class=\"headerlink\" title=\"Android生命周期感知组件详解\"></a>Android生命周期感知组件详解</h2><p>使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 <code>onStart()</code> <code>onStop()</code>中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。</p>\n<h3 id=\"Lifecycle类\"><a href=\"#Lifecycle类\" class=\"headerlink\" title=\"Lifecycle类\"></a>Lifecycle类</h3><p><img src=\"/assets/lifecycle.png\" alt=\"\"></p>\n<p>Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。</p>\n<ul>\n<li><p>Event</p>\n<p>  由framework层分发的以及<code>Lifecycle</code>类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调</p>\n</li>\n<li><p>State</p>\n<p>  表示由<code>Lifecycle</code>对象跟踪的组件的当前的状态</p>\n</li>\n</ul>\n<h3 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h3><p><code>LifecycleOwner</code>是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">@NonNull</span></span></span><br><span class=\"line\"><span class=\"comment\">    Lifecycle getLifecycle();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现<code>LifecycleOwner</code>接口。</p>\n<h3 id=\"LifecycleObserver\"><a href=\"#LifecycleObserver\" class=\"headerlink\" title=\"LifecycleObserver\"></a>LifecycleObserver</h3><p><code>LifecycleObserver</code>接口可以与实现<code>LifecycleOwner</code>接口的类配合使用，实现<code>LifecycleOwner</code>接口的类提供<code>Lifecycle</code>，而<code>LifecycleObserver</code>可以注册至被观察者。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android生命周期感知组件详解\"><a href=\"#Android生命周期感知组件详解\" class=\"headerlink\" title=\"Android生命周期感知组件详解\"></a>Android生命周期感知组件详解</h2><p>使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 <code>onStart()</code> <code>onStop()</code>中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。</p>\n<h3 id=\"Lifecycle类\"><a href=\"#Lifecycle类\" class=\"headerlink\" title=\"Lifecycle类\"></a>Lifecycle类</h3><p><img src=\"/assets/lifecycle.png\" alt=\"\"></p>\n<p>Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。</p>\n<ul>\n<li><p>Event</p>\n<p>  由framework层分发的以及<code>Lifecycle</code>类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调</p>\n</li>\n<li><p>State</p>\n<p>  表示由<code>Lifecycle</code>对象跟踪的组件的当前的状态</p>\n</li>\n</ul>\n<h3 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h3><p><code>LifecycleOwner</code>是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">@NonNull</span></span></span><br><span class=\"line\"><span class=\"comment\">    Lifecycle getLifecycle();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现<code>LifecycleOwner</code>接口。</p>\n<h3 id=\"LifecycleObserver\"><a href=\"#LifecycleObserver\" class=\"headerlink\" title=\"LifecycleObserver\"></a>LifecycleObserver</h3><p><code>LifecycleObserver</code>接口可以与实现<code>LifecycleOwner</code>接口的类配合使用，实现<code>LifecycleOwner</code>接口的类提供<code>Lifecycle</code>，而<code>LifecycleObserver</code>可以注册至被观察者。</p>\n"},{"_content":"## Databinding点击事件的几种实现方式\n\n代码片段\n\n```\n    //BaseActivity中\n    public void click(View view){\n    }\n    \n    public void click1(){\n    }\n    \n    public void click2(int id){\n    }\n    \n    //xml文件中\n    <variable\n        name=\"activity\"\n        type=\".BaseActivity\" />\n    \n    <variable\n        name=\"user\"\n        type=\".User\" />\n    \n\n```\n\n### 1、@{activity.click}\n`click`函数带有参数\n\n```\n    <TextView\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"wrap_content\"\n         android:text=\"点击事件\"\n         android:onClick=\"@{activity.click}\"\n    />\n```\n\n### 2、@{()->activity.click()}\n`click`函数无参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click1()}\"\n    />\n```\n\n### 3、@{activity::click}\n`click`带参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{activity::click}\"\n    />\n```\n\n### 4、@{()->activity.click(user.id)}\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(user.id)}\"\n    />\n```\n\n### 5、@{()->activity.click(3)}\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(3)}\"\n    />\n```\n\n### 6、自定义View中DataBinding的点击事件\n\n\n\n### 7、在RecyclerView中的item添加点击事件\n\n```\n    // 按钮点击\n            holder.getBinding.getRoot().findViewById(R.id.btn_edit)\n            .setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    // todo\n                }\n            });\n\n```\n\n## DataBinding赋值操作\n\n方法一：\n\n\n\n\n\n## Databinding特殊用法\n```\n    <CheckBox\n        android:id=\"@+id/showName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n    <TextView\n        android:text=\"@{user.firstName}\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"@{showName.checked ? View.VISIBLE :             View.GONE}\"\n        />\n\n```\n\n## 注意事项\n\n**在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误**\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/DataBinding的使用.md","raw":"## Databinding点击事件的几种实现方式\n\n代码片段\n\n```\n    //BaseActivity中\n    public void click(View view){\n    }\n    \n    public void click1(){\n    }\n    \n    public void click2(int id){\n    }\n    \n    //xml文件中\n    <variable\n        name=\"activity\"\n        type=\".BaseActivity\" />\n    \n    <variable\n        name=\"user\"\n        type=\".User\" />\n    \n\n```\n\n### 1、@{activity.click}\n`click`函数带有参数\n\n```\n    <TextView\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"wrap_content\"\n         android:text=\"点击事件\"\n         android:onClick=\"@{activity.click}\"\n    />\n```\n\n### 2、@{()->activity.click()}\n`click`函数无参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click1()}\"\n    />\n```\n\n### 3、@{activity::click}\n`click`带参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{activity::click}\"\n    />\n```\n\n### 4、@{()->activity.click(user.id)}\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(user.id)}\"\n    />\n```\n\n### 5、@{()->activity.click(3)}\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(3)}\"\n    />\n```\n\n### 6、自定义View中DataBinding的点击事件\n\n\n\n### 7、在RecyclerView中的item添加点击事件\n\n```\n    // 按钮点击\n            holder.getBinding.getRoot().findViewById(R.id.btn_edit)\n            .setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    // todo\n                }\n            });\n\n```\n\n## DataBinding赋值操作\n\n方法一：\n\n\n\n\n\n## Databinding特殊用法\n```\n    <CheckBox\n        android:id=\"@+id/showName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n    <TextView\n        android:text=\"@{user.firstName}\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"@{showName.checked ? View.VISIBLE :             View.GONE}\"\n        />\n\n```\n\n## 注意事项\n\n**在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误**\n\n\n\n\n\n\n","slug":"Android/框架/AAC/DataBinding的使用","published":1,"date":"2019-09-30T07:19:02.853Z","updated":"2020-02-26T06:12:59.613Z","title":"Android/框架/AAC/DataBinding的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li130026kgui74ye802o","content":"<h2 id=\"Databinding点击事件的几种实现方式\"><a href=\"#Databinding点击事件的几种实现方式\" class=\"headerlink\" title=\"Databinding点击事件的几种实现方式\"></a>Databinding点击事件的几种实现方式</h2><p>代码片段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;BaseActivity中</span><br><span class=\"line\">public void click(View view)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click1()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click2(int id)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;xml文件中</span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;activity&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.BaseActivity&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;user&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.User&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、-activity-click\"><a href=\"#1、-activity-click\" class=\"headerlink\" title=\"1、@{activity.click}\"></a>1、@{activity.click}</h3><p><code>click</code>函数带有参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">     android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">     android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">     android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">     android:onClick&#x3D;&quot;@&#123;activity.click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、-gt-activity-click\"><a href=\"#2、-gt-activity-click\" class=\"headerlink\" title=\"2、@{()-&gt;activity.click()}\"></a>2、@{()-&gt;activity.click()}</h3><p><code>click</code>函数无参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click1()&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、-activity-click\"><a href=\"#3、-activity-click\" class=\"headerlink\" title=\"3、@{activity::click}\"></a>3、@{activity::click}</h3><p><code>click</code>带参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;activity::click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、-gt-activity-click-user-id\"><a href=\"#4、-gt-activity-click-user-id\" class=\"headerlink\" title=\"4、@{()-&gt;activity.click(user.id)}\"></a>4、@{()-&gt;activity.click(user.id)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(user.id)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、-gt-activity-click-3\"><a href=\"#5、-gt-activity-click-3\" class=\"headerlink\" title=\"5、@{()-&gt;activity.click(3)}\"></a>5、@{()-&gt;activity.click(3)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(3)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、自定义View中DataBinding的点击事件\"><a href=\"#6、自定义View中DataBinding的点击事件\" class=\"headerlink\" title=\"6、自定义View中DataBinding的点击事件\"></a>6、自定义View中DataBinding的点击事件</h3><h3 id=\"7、在RecyclerView中的item添加点击事件\"><a href=\"#7、在RecyclerView中的item添加点击事件\" class=\"headerlink\" title=\"7、在RecyclerView中的item添加点击事件\"></a>7、在RecyclerView中的item添加点击事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 按钮点击</span><br><span class=\"line\">        holder.getBinding.getRoot().findViewById(R.id.btn_edit)</span><br><span class=\"line\">        .setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; todo</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DataBinding赋值操作\"><a href=\"#DataBinding赋值操作\" class=\"headerlink\" title=\"DataBinding赋值操作\"></a>DataBinding赋值操作</h2><p>方法一：</p>\n<h2 id=\"Databinding特殊用法\"><a href=\"#Databinding特殊用法\" class=\"headerlink\" title=\"Databinding特殊用法\"></a>Databinding特殊用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CheckBox</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;showName&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility&#x3D;&quot;@&#123;showName.checked ? View.VISIBLE :             View.GONE&#125;&quot;</span><br><span class=\"line\">    &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Databinding点击事件的几种实现方式\"><a href=\"#Databinding点击事件的几种实现方式\" class=\"headerlink\" title=\"Databinding点击事件的几种实现方式\"></a>Databinding点击事件的几种实现方式</h2><p>代码片段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;BaseActivity中</span><br><span class=\"line\">public void click(View view)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click1()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click2(int id)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;xml文件中</span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;activity&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.BaseActivity&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;user&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.User&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、-activity-click\"><a href=\"#1、-activity-click\" class=\"headerlink\" title=\"1、@{activity.click}\"></a>1、@{activity.click}</h3><p><code>click</code>函数带有参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">     android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">     android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">     android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">     android:onClick&#x3D;&quot;@&#123;activity.click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、-gt-activity-click\"><a href=\"#2、-gt-activity-click\" class=\"headerlink\" title=\"2、@{()-&gt;activity.click()}\"></a>2、@{()-&gt;activity.click()}</h3><p><code>click</code>函数无参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click1()&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、-activity-click\"><a href=\"#3、-activity-click\" class=\"headerlink\" title=\"3、@{activity::click}\"></a>3、@{activity::click}</h3><p><code>click</code>带参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;activity::click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、-gt-activity-click-user-id\"><a href=\"#4、-gt-activity-click-user-id\" class=\"headerlink\" title=\"4、@{()-&gt;activity.click(user.id)}\"></a>4、@{()-&gt;activity.click(user.id)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(user.id)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、-gt-activity-click-3\"><a href=\"#5、-gt-activity-click-3\" class=\"headerlink\" title=\"5、@{()-&gt;activity.click(3)}\"></a>5、@{()-&gt;activity.click(3)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(3)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、自定义View中DataBinding的点击事件\"><a href=\"#6、自定义View中DataBinding的点击事件\" class=\"headerlink\" title=\"6、自定义View中DataBinding的点击事件\"></a>6、自定义View中DataBinding的点击事件</h3><h3 id=\"7、在RecyclerView中的item添加点击事件\"><a href=\"#7、在RecyclerView中的item添加点击事件\" class=\"headerlink\" title=\"7、在RecyclerView中的item添加点击事件\"></a>7、在RecyclerView中的item添加点击事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 按钮点击</span><br><span class=\"line\">        holder.getBinding.getRoot().findViewById(R.id.btn_edit)</span><br><span class=\"line\">        .setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; todo</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DataBinding赋值操作\"><a href=\"#DataBinding赋值操作\" class=\"headerlink\" title=\"DataBinding赋值操作\"></a>DataBinding赋值操作</h2><p>方法一：</p>\n<h2 id=\"Databinding特殊用法\"><a href=\"#Databinding特殊用法\" class=\"headerlink\" title=\"Databinding特殊用法\"></a>Databinding特殊用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CheckBox</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;showName&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility&#x3D;&quot;@&#123;showName.checked ? View.VISIBLE :             View.GONE&#125;&quot;</span><br><span class=\"line\">    &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误</strong></p>\n"},{"_content":"# 结构化组件介绍\n\n结构化组件\\(Android Architecture Components\\)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。\n\n* 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。\n* 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。\n* ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁\n* Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。\n\n## 结构化组件推荐\n\n结构化组件的工作原理介绍如图所示，\n\n* Entity\\(实体\\)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。\n* SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。\n* Dao：用于获取数据的Object，将Sql语句映射为`Funcation`，通常需要在`SQLite OpenHelper`中进行定义，但使用Room持久化层，只需调用方法即可，不需要再`SQLite OpenHelper`中进行定义。\n* Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在`SQLite Openhelper`中进行处理），Room数据库使用Dao来操作SQLite Database。\n* Repository：使用Repository来操作多种数据源。\n* ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，\n* LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。`LiveData`可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，`LiveData`可以自动感知与它相关的组件的生命周期的改变。\n\n","source":"_posts/Android/框架/AAC/Android Architecture Components.md","raw":"# 结构化组件介绍\n\n结构化组件\\(Android Architecture Components\\)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。\n\n* 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。\n* 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。\n* ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁\n* Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。\n\n## 结构化组件推荐\n\n结构化组件的工作原理介绍如图所示，\n\n* Entity\\(实体\\)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。\n* SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。\n* Dao：用于获取数据的Object，将Sql语句映射为`Funcation`，通常需要在`SQLite OpenHelper`中进行定义，但使用Room持久化层，只需调用方法即可，不需要再`SQLite OpenHelper`中进行定义。\n* Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在`SQLite Openhelper`中进行处理），Room数据库使用Dao来操作SQLite Database。\n* Repository：使用Repository来操作多种数据源。\n* ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，\n* LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。`LiveData`可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，`LiveData`可以自动感知与它相关的组件的生命周期的改变。\n\n","slug":"Android/框架/AAC/Android Architecture Components","published":1,"date":"2019-09-19T09:41:14.748Z","updated":"2019-09-19T09:41:14.748Z","title":"Android/框架/AAC/Android Architecture Components","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li140027kgui1d6pf1e9","content":"<h1 id=\"结构化组件介绍\"><a href=\"#结构化组件介绍\" class=\"headerlink\" title=\"结构化组件介绍\"></a>结构化组件介绍</h1><p>结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。</p>\n<ul>\n<li>使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。</li>\n<li>使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。</li>\n<li>ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁</li>\n<li>Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。</li>\n</ul>\n<h2 id=\"结构化组件推荐\"><a href=\"#结构化组件推荐\" class=\"headerlink\" title=\"结构化组件推荐\"></a>结构化组件推荐</h2><p>结构化组件的工作原理介绍如图所示，</p>\n<ul>\n<li>Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。</li>\n<li>SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。</li>\n<li>Dao：用于获取数据的Object，将Sql语句映射为<code>Funcation</code>，通常需要在<code>SQLite OpenHelper</code>中进行定义，但使用Room持久化层，只需调用方法即可，不需要再<code>SQLite OpenHelper</code>中进行定义。</li>\n<li>Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在<code>SQLite Openhelper</code>中进行处理），Room数据库使用Dao来操作SQLite Database。</li>\n<li>Repository：使用Repository来操作多种数据源。</li>\n<li>ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，</li>\n<li>LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。<code>LiveData</code>可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，<code>LiveData</code>可以自动感知与它相关的组件的生命周期的改变。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"结构化组件介绍\"><a href=\"#结构化组件介绍\" class=\"headerlink\" title=\"结构化组件介绍\"></a>结构化组件介绍</h1><p>结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。</p>\n<ul>\n<li>使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。</li>\n<li>使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。</li>\n<li>ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁</li>\n<li>Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。</li>\n</ul>\n<h2 id=\"结构化组件推荐\"><a href=\"#结构化组件推荐\" class=\"headerlink\" title=\"结构化组件推荐\"></a>结构化组件推荐</h2><p>结构化组件的工作原理介绍如图所示，</p>\n<ul>\n<li>Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。</li>\n<li>SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。</li>\n<li>Dao：用于获取数据的Object，将Sql语句映射为<code>Funcation</code>，通常需要在<code>SQLite OpenHelper</code>中进行定义，但使用Room持久化层，只需调用方法即可，不需要再<code>SQLite OpenHelper</code>中进行定义。</li>\n<li>Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在<code>SQLite Openhelper</code>中进行处理），Room数据库使用Dao来操作SQLite Database。</li>\n<li>Repository：使用Repository来操作多种数据源。</li>\n<li>ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，</li>\n<li>LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。<code>LiveData</code>可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，<code>LiveData</code>可以自动感知与它相关的组件的生命周期的改变。</li>\n</ul>\n"},{"_content":"\n\n## LiveData介绍\n`LiveData`是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。`LiveData`是一个抽象类，其继承关系如下：\n\n![](/assets/livedata.png)\n\n#### LiveData的优势\n* 保证UI界面与数据相匹配\n* 无内存泄漏\n    \n    观察者绑定至`Lifecycle`，当观察者的生命周期结束后，其会自动清理\n* 不会由于Activity stop而发生崩溃\n\n    如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据\n* 合理的数据配置\n         \n    如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 \n* 数据共享\n\n    可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。\n\n### 在具有生命周期的对象中使用LiveData\n\n#### 定义被观察者\n在定义被观察者对象时通常使用`MutableLiveData`类，在Activity中定义一个被观察的对象：\n\n```java\n  \n    MutableLiveData<String> mutableLiveData=new MutableLiveData<>();\n\n```\n\n#### 注册观察者：\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mutableLiveData.observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String s) {\n                Log.i(\"输出数据：\",s);\n            }\n        });\n    }\n```\n\n被观察者`mutableLiveData`的数据修改有两种方式：`setValue(T value)`和`postValue(T value) `。当被观察者数据在UI主线程中进行修改时，使用`setValue(T value)`，当被观察者在子线程中使用时，使用`postValue(T value) `；\n\n#### 通过`setValue(T value)`修改被观察者并通知观察者\n\n```\n    mutableLiveData.setValue(\"TEST\");\n```\n\n`setValue(T value)`源码：\n```java\n    @MainThread\n    protected void setValue(T value) {\n        assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常\n        mVersion++;\n        mData = value;\n        dispatchingValue(null);  //用于数据分发通知观察者\n    }\n\n```\n在`setValue(T value)`中调用`dispatchingValue(null)`，用于通知观察者。\n\n`dispatchingValue(@Nullable ObserverWrapper initiator)`源码\n```java\n    //参数ObserverWrapper是每一个观察者的封装\n    void dispatchingValue(@Nullable ObserverWrapper initiator) {\n       \n        //...\n        do {\n            mDispatchInvalidated = false;\n                //...\n                //遍历所有的观察者，并进行通知\n                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                    //considerNotify用于通知观察者\n                    considerNotify(iterator.next().getValue());\n                    if (mDispatchInvalidated) {\n                        break;\n                    }\n            }\n        } while (mDispatchInvalidated);\n        mDispatchingValue = false;\n    }\n\n```\n\n在`dispatchingValue(@Nullable ObserverWrapper initiator)`方法中调用`considerNotify(ObserverWrapper observer)`通知观察者\n\n```java\n    private void considerNotify(ObserverWrapper observer) {\n        if (!observer.mActive) {\n            return;\n        }\n        if (!observer.shouldBeActive()) {\n            observer.activeStateChanged(false);\n            return;\n        }\n        if (observer.mLastVersion >= mVersion) {\n            return;\n        }\n        observer.mLastVersion = mVersion;\n        observer.mObserver.onChanged((T) mData);\n    }\n```\n\n\n#### 通过`postValue(T value) `修改被观察者并通知观察者\n\n```\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                mutableLiveData.postValue(\"TEST\");\n            }\n        }).start();\n\n```\n\n`postValue(T value) `源码：\n\n```java\n    protected void postValue(T value) {\n        boolean postTask;\n        synchronized (mDataLock) {\n            postTask = mPendingData == NOT_SET;\n            mPendingData = value;\n        }\n        if (!postTask) {\n            return;\n        }\n        \n        //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n```\n`mPostValueRunnable`源码：\n```java\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            //...\n            //依然是调用setValue对数据进行修改\n            setValue((T) newValue);\n        }\n    };\n\n```\n\n#### 在不具有生命周期的对象中使用LiveData\n\n```\n    public class TestLiveDataBean {\n\n        MutableLiveData<String> mutableLiveData = new MutableLiveData<>();\n        \n        Observer<String> observer;\n\n        public TestLiveDataBean() {\n            observer = new Observer<String>() {\n                @Override\n                public void onChanged(String s) {\n                    LogUtils.printInfo(s);\n                }\n            };\n            //添加观察者\n            mutableLiveData.observeForever(observer);\n        }\n\n        public void setValue() {\n            //无论setValue是否在UI主线程中，都可以用postValue\n            mutableLiveData.postValue(\"测试\");\n            //当在子线程中调用setValue报错\n            //mutableLiveData.setValue(\"测试\");\n        }\n    \n          public void removeObserver() {\n            mutableLiveData.removeObserver(observer);\n        }\n    }\n\n```\n`observeForever()`与`removeOberver()`方法需要成对进行使用，通过`observeForever()`方法添加观察者，该方法只能在主线程中调用;\n\n```java\n\n    @MainThread\n    public void observeForever(@NonNull Observer<? super T> observer) {\n        assertMainThread(\"observeForever\");\n        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        if (existing instanceof LiveData.LifecycleBoundObserver) {\n            throw new IllegalArgumentException(\"Cannot add the same observer\"\n                    + \" with different lifecycles\");\n        }\n        if (existing != null) {\n            return;\n        }\n        wrapper.activeStateChanged(true);\n    }\n\n```\n\n\n观察者使用完毕后，需要通过`removeOberver()`方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用\n\n`removeObserver(@NonNull final Observer<? super T> observer)`源码：\n```java\n\n    @MainThread\n    public void removeObserver(@NonNull final Observer<? super T> observer) {\n        assertMainThread(\"removeObserver\");\n        ObserverWrapper removed = mObservers.remove(observer);\n        if (removed == null) {\n            return;\n        }\n        removed.detachObserver();\n        removed.activeStateChanged(false);\n    }\n\n\n```\n\n### MediatorLiveData介绍\n\n`MediatorLiveData`是`LiveData`的一个子类，可以将`LiveData`的数据源合并至一起；当任一`LiveData`数据源的数据发生改变后，都会触发`MediatorLiveData`的观察者。\n\n\n### 继承LiveData进行数据共享\n\n\n","source":"_posts/Android/框架/AAC/Android Livedata详解.md","raw":"\n\n## LiveData介绍\n`LiveData`是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。`LiveData`是一个抽象类，其继承关系如下：\n\n![](/assets/livedata.png)\n\n#### LiveData的优势\n* 保证UI界面与数据相匹配\n* 无内存泄漏\n    \n    观察者绑定至`Lifecycle`，当观察者的生命周期结束后，其会自动清理\n* 不会由于Activity stop而发生崩溃\n\n    如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据\n* 合理的数据配置\n         \n    如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 \n* 数据共享\n\n    可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。\n\n### 在具有生命周期的对象中使用LiveData\n\n#### 定义被观察者\n在定义被观察者对象时通常使用`MutableLiveData`类，在Activity中定义一个被观察的对象：\n\n```java\n  \n    MutableLiveData<String> mutableLiveData=new MutableLiveData<>();\n\n```\n\n#### 注册观察者：\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mutableLiveData.observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String s) {\n                Log.i(\"输出数据：\",s);\n            }\n        });\n    }\n```\n\n被观察者`mutableLiveData`的数据修改有两种方式：`setValue(T value)`和`postValue(T value) `。当被观察者数据在UI主线程中进行修改时，使用`setValue(T value)`，当被观察者在子线程中使用时，使用`postValue(T value) `；\n\n#### 通过`setValue(T value)`修改被观察者并通知观察者\n\n```\n    mutableLiveData.setValue(\"TEST\");\n```\n\n`setValue(T value)`源码：\n```java\n    @MainThread\n    protected void setValue(T value) {\n        assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常\n        mVersion++;\n        mData = value;\n        dispatchingValue(null);  //用于数据分发通知观察者\n    }\n\n```\n在`setValue(T value)`中调用`dispatchingValue(null)`，用于通知观察者。\n\n`dispatchingValue(@Nullable ObserverWrapper initiator)`源码\n```java\n    //参数ObserverWrapper是每一个观察者的封装\n    void dispatchingValue(@Nullable ObserverWrapper initiator) {\n       \n        //...\n        do {\n            mDispatchInvalidated = false;\n                //...\n                //遍历所有的观察者，并进行通知\n                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                    //considerNotify用于通知观察者\n                    considerNotify(iterator.next().getValue());\n                    if (mDispatchInvalidated) {\n                        break;\n                    }\n            }\n        } while (mDispatchInvalidated);\n        mDispatchingValue = false;\n    }\n\n```\n\n在`dispatchingValue(@Nullable ObserverWrapper initiator)`方法中调用`considerNotify(ObserverWrapper observer)`通知观察者\n\n```java\n    private void considerNotify(ObserverWrapper observer) {\n        if (!observer.mActive) {\n            return;\n        }\n        if (!observer.shouldBeActive()) {\n            observer.activeStateChanged(false);\n            return;\n        }\n        if (observer.mLastVersion >= mVersion) {\n            return;\n        }\n        observer.mLastVersion = mVersion;\n        observer.mObserver.onChanged((T) mData);\n    }\n```\n\n\n#### 通过`postValue(T value) `修改被观察者并通知观察者\n\n```\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                mutableLiveData.postValue(\"TEST\");\n            }\n        }).start();\n\n```\n\n`postValue(T value) `源码：\n\n```java\n    protected void postValue(T value) {\n        boolean postTask;\n        synchronized (mDataLock) {\n            postTask = mPendingData == NOT_SET;\n            mPendingData = value;\n        }\n        if (!postTask) {\n            return;\n        }\n        \n        //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n```\n`mPostValueRunnable`源码：\n```java\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            //...\n            //依然是调用setValue对数据进行修改\n            setValue((T) newValue);\n        }\n    };\n\n```\n\n#### 在不具有生命周期的对象中使用LiveData\n\n```\n    public class TestLiveDataBean {\n\n        MutableLiveData<String> mutableLiveData = new MutableLiveData<>();\n        \n        Observer<String> observer;\n\n        public TestLiveDataBean() {\n            observer = new Observer<String>() {\n                @Override\n                public void onChanged(String s) {\n                    LogUtils.printInfo(s);\n                }\n            };\n            //添加观察者\n            mutableLiveData.observeForever(observer);\n        }\n\n        public void setValue() {\n            //无论setValue是否在UI主线程中，都可以用postValue\n            mutableLiveData.postValue(\"测试\");\n            //当在子线程中调用setValue报错\n            //mutableLiveData.setValue(\"测试\");\n        }\n    \n          public void removeObserver() {\n            mutableLiveData.removeObserver(observer);\n        }\n    }\n\n```\n`observeForever()`与`removeOberver()`方法需要成对进行使用，通过`observeForever()`方法添加观察者，该方法只能在主线程中调用;\n\n```java\n\n    @MainThread\n    public void observeForever(@NonNull Observer<? super T> observer) {\n        assertMainThread(\"observeForever\");\n        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        if (existing instanceof LiveData.LifecycleBoundObserver) {\n            throw new IllegalArgumentException(\"Cannot add the same observer\"\n                    + \" with different lifecycles\");\n        }\n        if (existing != null) {\n            return;\n        }\n        wrapper.activeStateChanged(true);\n    }\n\n```\n\n\n观察者使用完毕后，需要通过`removeOberver()`方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用\n\n`removeObserver(@NonNull final Observer<? super T> observer)`源码：\n```java\n\n    @MainThread\n    public void removeObserver(@NonNull final Observer<? super T> observer) {\n        assertMainThread(\"removeObserver\");\n        ObserverWrapper removed = mObservers.remove(observer);\n        if (removed == null) {\n            return;\n        }\n        removed.detachObserver();\n        removed.activeStateChanged(false);\n    }\n\n\n```\n\n### MediatorLiveData介绍\n\n`MediatorLiveData`是`LiveData`的一个子类，可以将`LiveData`的数据源合并至一起；当任一`LiveData`数据源的数据发生改变后，都会触发`MediatorLiveData`的观察者。\n\n\n### 继承LiveData进行数据共享\n\n\n","slug":"Android/框架/AAC/Android Livedata详解","published":1,"date":"2019-11-28T12:20:15.896Z","updated":"2020-02-26T06:12:59.606Z","title":"Android/框架/AAC/Android Livedata详解","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li140028kguihed10pq0","content":"<h2 id=\"LiveData介绍\"><a href=\"#LiveData介绍\" class=\"headerlink\" title=\"LiveData介绍\"></a>LiveData介绍</h2><p><code>LiveData</code>是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。<code>LiveData</code>是一个抽象类，其继承关系如下：</p>\n<p><img src=\"/assets/livedata.png\" alt=\"\"></p>\n<h4 id=\"LiveData的优势\"><a href=\"#LiveData的优势\" class=\"headerlink\" title=\"LiveData的优势\"></a>LiveData的优势</h4><ul>\n<li><p>保证UI界面与数据相匹配</p>\n</li>\n<li><p>无内存泄漏</p>\n<p>  观察者绑定至<code>Lifecycle</code>，当观察者的生命周期结束后，其会自动清理</p>\n</li>\n<li><p>不会由于Activity stop而发生崩溃</p>\n<p>  如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据</p>\n</li>\n<li><p>合理的数据配置</p>\n<p>  如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 </p>\n</li>\n<li><p>数据共享</p>\n<p>  可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。</p>\n</li>\n</ul>\n<h3 id=\"在具有生命周期的对象中使用LiveData\"><a href=\"#在具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在具有生命周期的对象中使用LiveData\"></a>在具有生命周期的对象中使用LiveData</h3><h4 id=\"定义被观察者\"><a href=\"#定义被观察者\" class=\"headerlink\" title=\"定义被观察者\"></a>定义被观察者</h4><p>在定义被观察者对象时通常使用<code>MutableLiveData</code>类，在Activity中定义一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">MutableLiveData&lt;String&gt; mutableLiveData=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注册观察者：\"><a href=\"#注册观察者：\" class=\"headerlink\" title=\"注册观察者：\"></a>注册观察者：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    mutableLiveData.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">            Log.i(<span class=\"string\">\"输出数据：\"</span>,s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者<code>mutableLiveData</code>的数据修改有两种方式：<code>setValue(T value)</code>和<code>postValue(T value)</code>。当被观察者数据在UI主线程中进行修改时，使用<code>setValue(T value)</code>，当被观察者在子线程中使用时，使用<code>postValue(T value)</code>；</p>\n<h4 id=\"通过setValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过setValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过setValue(T value)修改被观察者并通知观察者\"></a>通过<code>setValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableLiveData.setValue(&quot;TEST&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><code>setValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>); <span class=\"comment\">//用于判断是否在主线程，否则抛出异常</span></span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);  <span class=\"comment\">//用于数据分发通知观察者</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>setValue(T value)</code>中调用<code>dispatchingValue(null)</code>，用于通知观察者。</p>\n<p><code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//参数ObserverWrapper是每一个观察者的封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"comment\">//遍历所有的观察者，并进行通知</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//considerNotify用于通知观察者</span></span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>方法中调用<code>considerNotify(ObserverWrapper observer)</code>通知观察者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"通过postValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过postValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过postValue(T value)修改被观察者并通知观察者\"></a>通过<code>postValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;TEST&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><code>postValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;</span><br><span class=\"line\">        mPendingData = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行</span></span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mPostValueRunnable</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//依然是调用setValue对数据进行修改</span></span><br><span class=\"line\">        setValue((T) newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在不具有生命周期的对象中使用LiveData\"><a href=\"#在不具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在不具有生命周期的对象中使用LiveData\"></a>在不具有生命周期的对象中使用LiveData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestLiveDataBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MutableLiveData&lt;String&gt; mutableLiveData &#x3D; new MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Observer&lt;String&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestLiveDataBean() &#123;</span><br><span class=\"line\">        observer &#x3D; new Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onChanged(String s) &#123;</span><br><span class=\"line\">                LogUtils.printInfo(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F;添加观察者</span><br><span class=\"line\">        mutableLiveData.observeForever(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setValue() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;无论setValue是否在UI主线程中，都可以用postValue</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;测试&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;当在子线程中调用setValue报错</span><br><span class=\"line\">        &#x2F;&#x2F;mutableLiveData.setValue(&quot;测试&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public void removeObserver() &#123;</span><br><span class=\"line\">        mutableLiveData.removeObserver(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>observeForever()</code>与<code>removeOberver()</code>方法需要成对进行使用，通过<code>observeForever()</code>方法添加观察者，该方法只能在主线程中调用;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"observeForever\"</span>);</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing <span class=\"keyword\">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span></span><br><span class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>观察者使用完毕后，需要通过<code>removeOberver()</code>方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用</p>\n<p><code>removeObserver(@NonNull final Observer&lt;? super T&gt; observer)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"removeObserver\"</span>);</span><br><span class=\"line\">    ObserverWrapper removed = mObservers.remove(observer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    removed.detachObserver();</span><br><span class=\"line\">    removed.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MediatorLiveData介绍\"><a href=\"#MediatorLiveData介绍\" class=\"headerlink\" title=\"MediatorLiveData介绍\"></a>MediatorLiveData介绍</h3><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，可以将<code>LiveData</code>的数据源合并至一起；当任一<code>LiveData</code>数据源的数据发生改变后，都会触发<code>MediatorLiveData</code>的观察者。</p>\n<h3 id=\"继承LiveData进行数据共享\"><a href=\"#继承LiveData进行数据共享\" class=\"headerlink\" title=\"继承LiveData进行数据共享\"></a>继承LiveData进行数据共享</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LiveData介绍\"><a href=\"#LiveData介绍\" class=\"headerlink\" title=\"LiveData介绍\"></a>LiveData介绍</h2><p><code>LiveData</code>是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。<code>LiveData</code>是一个抽象类，其继承关系如下：</p>\n<p><img src=\"/assets/livedata.png\" alt=\"\"></p>\n<h4 id=\"LiveData的优势\"><a href=\"#LiveData的优势\" class=\"headerlink\" title=\"LiveData的优势\"></a>LiveData的优势</h4><ul>\n<li><p>保证UI界面与数据相匹配</p>\n</li>\n<li><p>无内存泄漏</p>\n<p>  观察者绑定至<code>Lifecycle</code>，当观察者的生命周期结束后，其会自动清理</p>\n</li>\n<li><p>不会由于Activity stop而发生崩溃</p>\n<p>  如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据</p>\n</li>\n<li><p>合理的数据配置</p>\n<p>  如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 </p>\n</li>\n<li><p>数据共享</p>\n<p>  可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。</p>\n</li>\n</ul>\n<h3 id=\"在具有生命周期的对象中使用LiveData\"><a href=\"#在具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在具有生命周期的对象中使用LiveData\"></a>在具有生命周期的对象中使用LiveData</h3><h4 id=\"定义被观察者\"><a href=\"#定义被观察者\" class=\"headerlink\" title=\"定义被观察者\"></a>定义被观察者</h4><p>在定义被观察者对象时通常使用<code>MutableLiveData</code>类，在Activity中定义一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">MutableLiveData&lt;String&gt; mutableLiveData=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注册观察者：\"><a href=\"#注册观察者：\" class=\"headerlink\" title=\"注册观察者：\"></a>注册观察者：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    mutableLiveData.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">            Log.i(<span class=\"string\">\"输出数据：\"</span>,s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被观察者<code>mutableLiveData</code>的数据修改有两种方式：<code>setValue(T value)</code>和<code>postValue(T value)</code>。当被观察者数据在UI主线程中进行修改时，使用<code>setValue(T value)</code>，当被观察者在子线程中使用时，使用<code>postValue(T value)</code>；</p>\n<h4 id=\"通过setValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过setValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过setValue(T value)修改被观察者并通知观察者\"></a>通过<code>setValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableLiveData.setValue(&quot;TEST&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><code>setValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>); <span class=\"comment\">//用于判断是否在主线程，否则抛出异常</span></span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);  <span class=\"comment\">//用于数据分发通知观察者</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>setValue(T value)</code>中调用<code>dispatchingValue(null)</code>，用于通知观察者。</p>\n<p><code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//参数ObserverWrapper是每一个观察者的封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"comment\">//遍历所有的观察者，并进行通知</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//considerNotify用于通知观察者</span></span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>方法中调用<code>considerNotify(ObserverWrapper observer)</code>通知观察者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"通过postValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过postValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过postValue(T value)修改被观察者并通知观察者\"></a>通过<code>postValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;TEST&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><code>postValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;</span><br><span class=\"line\">        mPendingData = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行</span></span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mPostValueRunnable</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//依然是调用setValue对数据进行修改</span></span><br><span class=\"line\">        setValue((T) newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在不具有生命周期的对象中使用LiveData\"><a href=\"#在不具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在不具有生命周期的对象中使用LiveData\"></a>在不具有生命周期的对象中使用LiveData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestLiveDataBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MutableLiveData&lt;String&gt; mutableLiveData &#x3D; new MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Observer&lt;String&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestLiveDataBean() &#123;</span><br><span class=\"line\">        observer &#x3D; new Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onChanged(String s) &#123;</span><br><span class=\"line\">                LogUtils.printInfo(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F;添加观察者</span><br><span class=\"line\">        mutableLiveData.observeForever(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setValue() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;无论setValue是否在UI主线程中，都可以用postValue</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;测试&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;当在子线程中调用setValue报错</span><br><span class=\"line\">        &#x2F;&#x2F;mutableLiveData.setValue(&quot;测试&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public void removeObserver() &#123;</span><br><span class=\"line\">        mutableLiveData.removeObserver(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>observeForever()</code>与<code>removeOberver()</code>方法需要成对进行使用，通过<code>observeForever()</code>方法添加观察者，该方法只能在主线程中调用;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"observeForever\"</span>);</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing <span class=\"keyword\">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span></span><br><span class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>观察者使用完毕后，需要通过<code>removeOberver()</code>方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用</p>\n<p><code>removeObserver(@NonNull final Observer&lt;? super T&gt; observer)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(@NonNull <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"removeObserver\"</span>);</span><br><span class=\"line\">    ObserverWrapper removed = mObservers.remove(observer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    removed.detachObserver();</span><br><span class=\"line\">    removed.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MediatorLiveData介绍\"><a href=\"#MediatorLiveData介绍\" class=\"headerlink\" title=\"MediatorLiveData介绍\"></a>MediatorLiveData介绍</h3><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，可以将<code>LiveData</code>的数据源合并至一起；当任一<code>LiveData</code>数据源的数据发生改变后，都会触发<code>MediatorLiveData</code>的观察者。</p>\n<h3 id=\"继承LiveData进行数据共享\"><a href=\"#继承LiveData进行数据共享\" class=\"headerlink\" title=\"继承LiveData进行数据共享\"></a>继承LiveData进行数据共享</h3>"},{"_content":"# Android框架组件paging+room的使用\n\n## 简介：\n\n### DataSource\n\nDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，\n\n\n创建一个`PagedList`被观察者的对象，需要将一个`DataSource.Factory`的实例传递给`LivePagedListBuilder`对象。一个DataSource对象为单一的`PagedList`加载pages。当数据更新时，工厂类会创建一个`PagedSource`的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供`DataSource.Factory`对象，或者可以自己创建`DataSource.Factory`\n\nRoom持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：\n\n```java\n@Query(\"SELECT * FROM COUNTRIES\")\npublic abstract DataSource.Factory<Integer,Country> getCountries();\n```\n\n### PagedList\n\nPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。\n\n### PagedListAdapter\n\nPagedListAdapter是一个`RecyclerView.Adapter`用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？\n\n## 将架构组件添加到项目中\n\n在build.gradle中添加下面的依赖\n\n```markup\n    //recyclerView\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n\n    // ViewModel and LiveData\n    implementation \"android.arch.lifecycle:extensions:1.1.1\"\n    annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"\n\n   // Room\n    implementation \"android.arch.persistence.room:runtime:1.1.1\"\n    annotationProcessor \"android.arch.persistence.room:compiler:1.1.1\"\n\n    // Paging\n    implementation \"android.arch.paging:runtime:1.0.1\"\n```\n\n## 创建DataSource\n\n### 创建实体\n\n### 创建Dao层\n\nDataSource.Factory\\(在Room中实现\\)创建\n\n### 创建数据库\n\n### 创建ViewModel\n\nLivePagedListBuilder会使用\n\nLivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。\n\n创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：\n\n* setPageSize\\(int\\)：\n* setPrefetchDistance\\(int\\)：\n* setInitialLoadSizeHint\\(int\\)：设置页面中第一次显示的数量\n* setEnablePlaceholders\\(boolean\\) ：\n\n在`onCreate`方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。\n\n## 创建Adapter\n\n使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用`DiffCallback`来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：\n\n* areItemsTheSame:判断是否指向了同一个数据元素。\n* areContentsTheSame:判断\n\n","source":"_posts/Android/框架/AAC/Paging和Room使用.md","raw":"# Android框架组件paging+room的使用\n\n## 简介：\n\n### DataSource\n\nDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，\n\n\n创建一个`PagedList`被观察者的对象，需要将一个`DataSource.Factory`的实例传递给`LivePagedListBuilder`对象。一个DataSource对象为单一的`PagedList`加载pages。当数据更新时，工厂类会创建一个`PagedSource`的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供`DataSource.Factory`对象，或者可以自己创建`DataSource.Factory`\n\nRoom持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：\n\n```java\n@Query(\"SELECT * FROM COUNTRIES\")\npublic abstract DataSource.Factory<Integer,Country> getCountries();\n```\n\n### PagedList\n\nPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。\n\n### PagedListAdapter\n\nPagedListAdapter是一个`RecyclerView.Adapter`用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？\n\n## 将架构组件添加到项目中\n\n在build.gradle中添加下面的依赖\n\n```markup\n    //recyclerView\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n\n    // ViewModel and LiveData\n    implementation \"android.arch.lifecycle:extensions:1.1.1\"\n    annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"\n\n   // Room\n    implementation \"android.arch.persistence.room:runtime:1.1.1\"\n    annotationProcessor \"android.arch.persistence.room:compiler:1.1.1\"\n\n    // Paging\n    implementation \"android.arch.paging:runtime:1.0.1\"\n```\n\n## 创建DataSource\n\n### 创建实体\n\n### 创建Dao层\n\nDataSource.Factory\\(在Room中实现\\)创建\n\n### 创建数据库\n\n### 创建ViewModel\n\nLivePagedListBuilder会使用\n\nLivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。\n\n创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：\n\n* setPageSize\\(int\\)：\n* setPrefetchDistance\\(int\\)：\n* setInitialLoadSizeHint\\(int\\)：设置页面中第一次显示的数量\n* setEnablePlaceholders\\(boolean\\) ：\n\n在`onCreate`方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。\n\n## 创建Adapter\n\n使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用`DiffCallback`来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：\n\n* areItemsTheSame:判断是否指向了同一个数据元素。\n* areContentsTheSame:判断\n\n","slug":"Android/框架/AAC/Paging和Room使用","published":1,"date":"2019-09-30T07:19:02.865Z","updated":"2019-09-30T08:28:42.964Z","title":"Android/框架/AAC/Paging和Room使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li140029kgui4gqz3pkz","content":"<h1 id=\"Android框架组件paging-room的使用\"><a href=\"#Android框架组件paging-room的使用\" class=\"headerlink\" title=\"Android框架组件paging+room的使用\"></a>Android框架组件paging+room的使用</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><h3 id=\"DataSource\"><a href=\"#DataSource\" class=\"headerlink\" title=\"DataSource\"></a>DataSource</h3><p>DataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，</p>\n<p>创建一个<code>PagedList</code>被观察者的对象，需要将一个<code>DataSource.Factory</code>的实例传递给<code>LivePagedListBuilder</code>对象。一个DataSource对象为单一的<code>PagedList</code>加载pages。当数据更新时，工厂类会创建一个<code>PagedSource</code>的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供<code>DataSource.Factory</code>对象，或者可以自己创建<code>DataSource.Factory</code></p>\n<p>Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * FROM COUNTRIES\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DataSource.<span class=\"function\">Factory&lt;Integer,Country&gt; <span class=\"title\">getCountries</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PagedList\"><a href=\"#PagedList\" class=\"headerlink\" title=\"PagedList\"></a>PagedList</h3><p>PagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。</p>\n<h3 id=\"PagedListAdapter\"><a href=\"#PagedListAdapter\" class=\"headerlink\" title=\"PagedListAdapter\"></a>PagedListAdapter</h3><p>PagedListAdapter是一个<code>RecyclerView.Adapter</code>用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？</p>\n<h2 id=\"将架构组件添加到项目中\"><a href=\"#将架构组件添加到项目中\" class=\"headerlink\" title=\"将架构组件添加到项目中\"></a>将架构组件添加到项目中</h2><p>在build.gradle中添加下面的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;recyclerView</span><br><span class=\"line\"> implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; ViewModel and LiveData</span><br><span class=\"line\"> implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Room</span><br><span class=\"line\"> implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; Paging</span><br><span class=\"line\"> implementation &quot;android.arch.paging:runtime:1.0.1&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建DataSource\"><a href=\"#创建DataSource\" class=\"headerlink\" title=\"创建DataSource\"></a>创建DataSource</h2><h3 id=\"创建实体\"><a href=\"#创建实体\" class=\"headerlink\" title=\"创建实体\"></a>创建实体</h3><h3 id=\"创建Dao层\"><a href=\"#创建Dao层\" class=\"headerlink\" title=\"创建Dao层\"></a>创建Dao层</h3><p>DataSource.Factory(在Room中实现)创建</p>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h3 id=\"创建ViewModel\"><a href=\"#创建ViewModel\" class=\"headerlink\" title=\"创建ViewModel\"></a>创建ViewModel</h3><p>LivePagedListBuilder会使用</p>\n<p>LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。</p>\n<p>创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：</p>\n<ul>\n<li>setPageSize(int)：</li>\n<li>setPrefetchDistance(int)：</li>\n<li>setInitialLoadSizeHint(int)：设置页面中第一次显示的数量</li>\n<li>setEnablePlaceholders(boolean) ：</li>\n</ul>\n<p>在<code>onCreate</code>方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。</p>\n<h2 id=\"创建Adapter\"><a href=\"#创建Adapter\" class=\"headerlink\" title=\"创建Adapter\"></a>创建Adapter</h2><p>使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用<code>DiffCallback</code>来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：</p>\n<ul>\n<li>areItemsTheSame:判断是否指向了同一个数据元素。</li>\n<li>areContentsTheSame:判断</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android框架组件paging-room的使用\"><a href=\"#Android框架组件paging-room的使用\" class=\"headerlink\" title=\"Android框架组件paging+room的使用\"></a>Android框架组件paging+room的使用</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><h3 id=\"DataSource\"><a href=\"#DataSource\" class=\"headerlink\" title=\"DataSource\"></a>DataSource</h3><p>DataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，</p>\n<p>创建一个<code>PagedList</code>被观察者的对象，需要将一个<code>DataSource.Factory</code>的实例传递给<code>LivePagedListBuilder</code>对象。一个DataSource对象为单一的<code>PagedList</code>加载pages。当数据更新时，工厂类会创建一个<code>PagedSource</code>的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供<code>DataSource.Factory</code>对象，或者可以自己创建<code>DataSource.Factory</code></p>\n<p>Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * FROM COUNTRIES\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DataSource.<span class=\"function\">Factory&lt;Integer,Country&gt; <span class=\"title\">getCountries</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PagedList\"><a href=\"#PagedList\" class=\"headerlink\" title=\"PagedList\"></a>PagedList</h3><p>PagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。</p>\n<h3 id=\"PagedListAdapter\"><a href=\"#PagedListAdapter\" class=\"headerlink\" title=\"PagedListAdapter\"></a>PagedListAdapter</h3><p>PagedListAdapter是一个<code>RecyclerView.Adapter</code>用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？</p>\n<h2 id=\"将架构组件添加到项目中\"><a href=\"#将架构组件添加到项目中\" class=\"headerlink\" title=\"将架构组件添加到项目中\"></a>将架构组件添加到项目中</h2><p>在build.gradle中添加下面的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;recyclerView</span><br><span class=\"line\"> implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; ViewModel and LiveData</span><br><span class=\"line\"> implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Room</span><br><span class=\"line\"> implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; Paging</span><br><span class=\"line\"> implementation &quot;android.arch.paging:runtime:1.0.1&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建DataSource\"><a href=\"#创建DataSource\" class=\"headerlink\" title=\"创建DataSource\"></a>创建DataSource</h2><h3 id=\"创建实体\"><a href=\"#创建实体\" class=\"headerlink\" title=\"创建实体\"></a>创建实体</h3><h3 id=\"创建Dao层\"><a href=\"#创建Dao层\" class=\"headerlink\" title=\"创建Dao层\"></a>创建Dao层</h3><p>DataSource.Factory(在Room中实现)创建</p>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h3 id=\"创建ViewModel\"><a href=\"#创建ViewModel\" class=\"headerlink\" title=\"创建ViewModel\"></a>创建ViewModel</h3><p>LivePagedListBuilder会使用</p>\n<p>LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。</p>\n<p>创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：</p>\n<ul>\n<li>setPageSize(int)：</li>\n<li>setPrefetchDistance(int)：</li>\n<li>setInitialLoadSizeHint(int)：设置页面中第一次显示的数量</li>\n<li>setEnablePlaceholders(boolean) ：</li>\n</ul>\n<p>在<code>onCreate</code>方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。</p>\n<h2 id=\"创建Adapter\"><a href=\"#创建Adapter\" class=\"headerlink\" title=\"创建Adapter\"></a>创建Adapter</h2><p>使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用<code>DiffCallback</code>来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：</p>\n<ul>\n<li>areItemsTheSame:判断是否指向了同一个数据元素。</li>\n<li>areContentsTheSame:判断</li>\n</ul>\n"},{"_content":"WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。\n\n在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。\n\n当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。\n\nWorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service\n\nWorkManager可以执行两种类型的任务\n\n* 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中\n\n```java\n    WorkManager workManager=workManager.getInstance();\n    workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build());\n    \n```\n\n因为没有加其他的限制条件，所以上述任务只会执行一次；\n\n* 多次任务，如：每天将应用数据同步至服务器；\n\n创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中\n\n```\n    new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);\n    \n    PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();\n    WorkManager.getInstance().enqueue(dataCheckWork);\n    \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/WorkManager介绍.md","raw":"WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。\n\n在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。\n\n当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。\n\nWorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service\n\nWorkManager可以执行两种类型的任务\n\n* 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中\n\n```java\n    WorkManager workManager=workManager.getInstance();\n    workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build());\n    \n```\n\n因为没有加其他的限制条件，所以上述任务只会执行一次；\n\n* 多次任务，如：每天将应用数据同步至服务器；\n\n创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中\n\n```\n    new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);\n    \n    PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();\n    WorkManager.getInstance().enqueue(dataCheckWork);\n    \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/框架/AAC/WorkManager介绍","published":1,"date":"2019-09-30T07:19:02.876Z","updated":"2019-09-30T08:28:42.965Z","title":"Android/框架/AAC/WorkManager介绍","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li15002akguihwtl7yb2","content":"<p>WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。</p>\n<p>在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。</p>\n<p>当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。</p>\n<p>WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service</p>\n<p>WorkManager可以执行两种类型的任务</p>\n<ul>\n<li>只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkManager workManager=workManager.getInstance();</span><br><span class=\"line\">workManager.enqueue(<span class=\"keyword\">new</span> OneTimeWorkRequest.Builder(MyWork<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">build</span>())</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为没有加其他的限制条件，所以上述任务只会执行一次；</p>\n<ul>\n<li>多次任务，如：每天将应用数据同步至服务器；</li>\n</ul>\n<p>创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PeriodicWorkRequest.Builder dataCheckBuilder&#x3D;new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);</span><br><span class=\"line\"></span><br><span class=\"line\">PeriodicWorkRequest dataCheckWork&#x3D;dataCheckBuilder.build();</span><br><span class=\"line\">WorkManager.getInstance().enqueue(dataCheckWork);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。</p>\n<p>在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。</p>\n<p>当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。</p>\n<p>WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service</p>\n<p>WorkManager可以执行两种类型的任务</p>\n<ul>\n<li>只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkManager workManager=workManager.getInstance();</span><br><span class=\"line\">workManager.enqueue(<span class=\"keyword\">new</span> OneTimeWorkRequest.Builder(MyWork<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">build</span>())</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为没有加其他的限制条件，所以上述任务只会执行一次；</p>\n<ul>\n<li>多次任务，如：每天将应用数据同步至服务器；</li>\n</ul>\n<p>创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PeriodicWorkRequest.Builder dataCheckBuilder&#x3D;new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);</span><br><span class=\"line\"></span><br><span class=\"line\">PeriodicWorkRequest dataCheckWork&#x3D;dataCheckBuilder.build();</span><br><span class=\"line\">WorkManager.getInstance().enqueue(dataCheckWork);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"_content":"\n### 1、数据库在表中可以指定多个主键\n\n```java\n\n    @Entity(primaryKeys = {\"firstName\", \"lastName\"})\n    public class User{\n         \n         public String firstName;\n         public String lastName;\n         \n         \n         //使用Ignore使得该变量不生成表段名\n         \n         @Ignore\n         Bitmap bitmap;\n    }\n\n```\n如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns\n\n```\n    public class RemotePerson extends Person {\n        @PrimaryKey\n        public int id;\n\n        public boolean hasVpn;\n    }\n\n```\n\n### 2、Entity进行嵌套\n\n如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded\n\n```\n    public class Address {\n        public String street;\n        public String state;\n        public String city;\n    \n        @ColumnInfo(name = \"post_code\")\n        public int postCode;\n    }    \n\n    @Entity\n    public class Person{\n        @PrimaryKey\n        public int id;\n\n        public String firstName;\n\n        @Embedded\n        public Address address;\n    }\n\n```\n\n这样在Person表中有id,firstName,street,state,city,post_code等字段\n\n### 3、插入数据产生冲突时操作\n\n```\n    @Dao\n    public interface UserDao{\n        //插入如果冲突则替换    \n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        public void insertUser(User ... users);\n    \n    }\n\n```\n\n### 用于对数据表中某一列进行更新\n\n```\n     @Query(\"UPDATE item SET quantity = quantity + 1 WHERE id = :id\")\n     void updateQuantity(int id)\n     //item为表名\n\n```\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/Room数据库.md","raw":"\n### 1、数据库在表中可以指定多个主键\n\n```java\n\n    @Entity(primaryKeys = {\"firstName\", \"lastName\"})\n    public class User{\n         \n         public String firstName;\n         public String lastName;\n         \n         \n         //使用Ignore使得该变量不生成表段名\n         \n         @Ignore\n         Bitmap bitmap;\n    }\n\n```\n如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns\n\n```\n    public class RemotePerson extends Person {\n        @PrimaryKey\n        public int id;\n\n        public boolean hasVpn;\n    }\n\n```\n\n### 2、Entity进行嵌套\n\n如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded\n\n```\n    public class Address {\n        public String street;\n        public String state;\n        public String city;\n    \n        @ColumnInfo(name = \"post_code\")\n        public int postCode;\n    }    \n\n    @Entity\n    public class Person{\n        @PrimaryKey\n        public int id;\n\n        public String firstName;\n\n        @Embedded\n        public Address address;\n    }\n\n```\n\n这样在Person表中有id,firstName,street,state,city,post_code等字段\n\n### 3、插入数据产生冲突时操作\n\n```\n    @Dao\n    public interface UserDao{\n        //插入如果冲突则替换    \n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        public void insertUser(User ... users);\n    \n    }\n\n```\n\n### 用于对数据表中某一列进行更新\n\n```\n     @Query(\"UPDATE item SET quantity = quantity + 1 WHERE id = :id\")\n     void updateQuantity(int id)\n     //item为表名\n\n```\n\n\n\n\n\n\n","slug":"Android/框架/AAC/Room数据库","published":1,"date":"2019-09-30T07:19:02.871Z","updated":"2019-09-30T08:28:42.965Z","title":"Android/框架/AAC/Room数据库","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li15002bkguiasnsauij","content":"<h3 id=\"1、数据库在表中可以指定多个主键\"><a href=\"#1、数据库在表中可以指定多个主键\" class=\"headerlink\" title=\"1、数据库在表中可以指定多个主键\"></a>1、数据库在表中可以指定多个主键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span>(primaryKeys = &#123;<span class=\"string\">\"firstName\"</span>, <span class=\"string\">\"lastName\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> String firstName;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> String lastName;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//使用Ignore使得该变量不生成表段名</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"meta\">@Ignore</span></span><br><span class=\"line\">     Bitmap bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RemotePerson extends Person &#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean hasVpn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、Entity进行嵌套\"><a href=\"#2、Entity进行嵌套\" class=\"headerlink\" title=\"2、Entity进行嵌套\"></a>2、Entity进行嵌套</h3><p>如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Address &#123;</span><br><span class=\"line\">    public String street;</span><br><span class=\"line\">    public String state;</span><br><span class=\"line\">    public String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ColumnInfo(name &#x3D; &quot;post_code&quot;)</span><br><span class=\"line\">    public int postCode;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    public Address address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在Person表中有id,firstName,street,state,city,post_code等字段</p>\n<h3 id=\"3、插入数据产生冲突时操作\"><a href=\"#3、插入数据产生冲突时操作\" class=\"headerlink\" title=\"3、插入数据产生冲突时操作\"></a>3、插入数据产生冲突时操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface UserDao&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;插入如果冲突则替换    </span><br><span class=\"line\">    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)</span><br><span class=\"line\">    public void insertUser(User ... users);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用于对数据表中某一列进行更新\"><a href=\"#用于对数据表中某一列进行更新\" class=\"headerlink\" title=\"用于对数据表中某一列进行更新\"></a>用于对数据表中某一列进行更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Query(&quot;UPDATE item SET quantity &#x3D; quantity + 1 WHERE id &#x3D; :id&quot;)</span><br><span class=\"line\">void updateQuantity(int id)</span><br><span class=\"line\">&#x2F;&#x2F;item为表名</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1、数据库在表中可以指定多个主键\"><a href=\"#1、数据库在表中可以指定多个主键\" class=\"headerlink\" title=\"1、数据库在表中可以指定多个主键\"></a>1、数据库在表中可以指定多个主键</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity</span>(primaryKeys = &#123;<span class=\"string\">\"firstName\"</span>, <span class=\"string\">\"lastName\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> String firstName;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> String lastName;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//使用Ignore使得该变量不生成表段名</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"meta\">@Ignore</span></span><br><span class=\"line\">     Bitmap bitmap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RemotePerson extends Person &#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean hasVpn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、Entity进行嵌套\"><a href=\"#2、Entity进行嵌套\" class=\"headerlink\" title=\"2、Entity进行嵌套\"></a>2、Entity进行嵌套</h3><p>如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Address &#123;</span><br><span class=\"line\">    public String street;</span><br><span class=\"line\">    public String state;</span><br><span class=\"line\">    public String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ColumnInfo(name &#x3D; &quot;post_code&quot;)</span><br><span class=\"line\">    public int postCode;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    public Address address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在Person表中有id,firstName,street,state,city,post_code等字段</p>\n<h3 id=\"3、插入数据产生冲突时操作\"><a href=\"#3、插入数据产生冲突时操作\" class=\"headerlink\" title=\"3、插入数据产生冲突时操作\"></a>3、插入数据产生冲突时操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface UserDao&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;插入如果冲突则替换    </span><br><span class=\"line\">    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)</span><br><span class=\"line\">    public void insertUser(User ... users);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用于对数据表中某一列进行更新\"><a href=\"#用于对数据表中某一列进行更新\" class=\"headerlink\" title=\"用于对数据表中某一列进行更新\"></a>用于对数据表中某一列进行更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Query(&quot;UPDATE item SET quantity &#x3D; quantity + 1 WHERE id &#x3D; :id&quot;)</span><br><span class=\"line\">void updateQuantity(int id)</span><br><span class=\"line\">&#x2F;&#x2F;item为表名</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n"},{"_content":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","source":"_posts/Android/框架/AAC/Lifecycle和Room的使用.md","raw":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","slug":"Android/框架/AAC/Lifecycle和Room的使用","published":1,"date":"2019-09-30T07:19:02.859Z","updated":"2019-11-30T11:14:32.187Z","title":"Android/框架/AAC/Lifecycle和Room的使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li1b002ckgui4h0ncerw","content":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n"},{"_content":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","source":"_posts/Android/框架/AAC/Room和Lifecycle构建程序.md","raw":"# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","slug":"Android/框架/AAC/Room和Lifecycle构建程序","published":1,"date":"2019-09-19T09:41:14.749Z","updated":"2019-09-19T09:41:14.749Z","title":"Android/框架/AAC/Room和Lifecycle构建程序","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746li1b002dkgui7cfjejjx","content":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(@NonNull String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>(tableName = <span class=\"string\">\"word_table\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo</span>(name = <span class=\"string\">\"word\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query</span>(<span class=\"string\">\"SELECT * from word_table ORDER BY word ASC\"</span>)</span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase {}</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = {Word.class}, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database</span>(entities = &#123;Word<span class=\"class\">.<span class=\"keyword\">class</span>&#125;, <span class=\"title\">version</span> </span>= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, \"word_database\")</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图<del>~</del></p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db &#x3D; WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao &#x3D; db.wordDao();</span><br><span class=\"line\">       mAllWords &#x3D; mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao &#x3D; dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n"},{"_content":"# Android 蓝牙4.0开发\n\n这是一条优雅的分割线\n\n### 写在前面：\n\n本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0\n\n尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。\n\n\n### 首先对蓝牙进行非专业的介绍，\n\n蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！\n\n### 对GATT的介绍\n\n\n\n\n\n按照惯例先上代码\n\n优雅的代码\n\n##3 权限的获取\n\n蓝牙4.0有一个坑爹的权限是位置信息的获取\n\n\n### 蓝牙搜索\n蓝牙的搜索有三种方式\n* 方法一：`BluetoothAdapter.startDiscovery()`是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；\n蓝牙扫描广播接收器\n\n```java\n\n//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果\nprivate class DeviceReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if(BluetoothDevice.ACTION_FOUND.equals(action)){\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  \n        }\n    }\n}\n```\n\n* 方法二：`BluetoothAdapter.startScan(ScanCallback callback)`在`ScanCallback`的`onScanResult(int callbackType, ScanResult result)`方法中，通过`result.getDevice()`可获取扫描到的Ble设备\n* 方法三：`BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)`\n  该方法已经被舍弃\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Ble/Android ble 4.0.md","raw":"# Android 蓝牙4.0开发\n\n这是一条优雅的分割线\n\n### 写在前面：\n\n本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0\n\n尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。\n\n\n### 首先对蓝牙进行非专业的介绍，\n\n蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！\n\n### 对GATT的介绍\n\n\n\n\n\n按照惯例先上代码\n\n优雅的代码\n\n##3 权限的获取\n\n蓝牙4.0有一个坑爹的权限是位置信息的获取\n\n\n### 蓝牙搜索\n蓝牙的搜索有三种方式\n* 方法一：`BluetoothAdapter.startDiscovery()`是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；\n蓝牙扫描广播接收器\n\n```java\n\n//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果\nprivate class DeviceReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if(BluetoothDevice.ACTION_FOUND.equals(action)){\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  \n        }\n    }\n}\n```\n\n* 方法二：`BluetoothAdapter.startScan(ScanCallback callback)`在`ScanCallback`的`onScanResult(int callbackType, ScanResult result)`方法中，通过`result.getDevice()`可获取扫描到的Ble设备\n* 方法三：`BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)`\n  该方法已经被舍弃\n\n\n\n\n\n\n\n\n\n","slug":"Android/Ble/Android ble 4.0","published":1,"date":"2019-09-19T09:41:14.744Z","updated":"2019-09-19T09:41:14.745Z","title":"Android/Ble/Android ble 4.0","comments":1,"layout":"post","photos":[],"link":"","_id":"ck746oy0x002fkgui0vlc4hss","content":"<h1 id=\"Android-蓝牙4-0开发\"><a href=\"#Android-蓝牙4-0开发\" class=\"headerlink\" title=\"Android 蓝牙4.0开发\"></a>Android 蓝牙4.0开发</h1><p>这是一条优雅的分割线</p>\n<h3 id=\"写在前面：\"><a href=\"#写在前面：\" class=\"headerlink\" title=\"写在前面：\"></a>写在前面：</h3><p>本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0</p>\n<p>尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。</p>\n<h3 id=\"首先对蓝牙进行非专业的介绍，\"><a href=\"#首先对蓝牙进行非专业的介绍，\" class=\"headerlink\" title=\"首先对蓝牙进行非专业的介绍，\"></a>首先对蓝牙进行非专业的介绍，</h3><p>蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！</p>\n<h3 id=\"对GATT的介绍\"><a href=\"#对GATT的介绍\" class=\"headerlink\" title=\"对GATT的介绍\"></a>对GATT的介绍</h3><p>按照惯例先上代码</p>\n<p>优雅的代码</p>\n<p>##3 权限的获取</p>\n<p>蓝牙4.0有一个坑爹的权限是位置信息的获取</p>\n<h3 id=\"蓝牙搜索\"><a href=\"#蓝牙搜索\" class=\"headerlink\" title=\"蓝牙搜索\"></a>蓝牙搜索</h3><p>蓝牙的搜索有三种方式</p>\n<ul>\n<li>方法一：<code>BluetoothAdapter.startDiscovery()</code>是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；<br>蓝牙扫描广播接收器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeviceReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BluetoothDevice.ACTION_FOUND.equals(action))&#123;</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法二：<code>BluetoothAdapter.startScan(ScanCallback callback)</code>在<code>ScanCallback</code>的<code>onScanResult(int callbackType, ScanResult result)</code>方法中，通过<code>result.getDevice()</code>可获取扫描到的Ble设备</li>\n<li>方法三：<code>BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)</code><br>该方法已经被舍弃</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-蓝牙4-0开发\"><a href=\"#Android-蓝牙4-0开发\" class=\"headerlink\" title=\"Android 蓝牙4.0开发\"></a>Android 蓝牙4.0开发</h1><p>这是一条优雅的分割线</p>\n<h3 id=\"写在前面：\"><a href=\"#写在前面：\" class=\"headerlink\" title=\"写在前面：\"></a>写在前面：</h3><p>本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0</p>\n<p>尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。</p>\n<h3 id=\"首先对蓝牙进行非专业的介绍，\"><a href=\"#首先对蓝牙进行非专业的介绍，\" class=\"headerlink\" title=\"首先对蓝牙进行非专业的介绍，\"></a>首先对蓝牙进行非专业的介绍，</h3><p>蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！</p>\n<h3 id=\"对GATT的介绍\"><a href=\"#对GATT的介绍\" class=\"headerlink\" title=\"对GATT的介绍\"></a>对GATT的介绍</h3><p>按照惯例先上代码</p>\n<p>优雅的代码</p>\n<p>##3 权限的获取</p>\n<p>蓝牙4.0有一个坑爹的权限是位置信息的获取</p>\n<h3 id=\"蓝牙搜索\"><a href=\"#蓝牙搜索\" class=\"headerlink\" title=\"蓝牙搜索\"></a>蓝牙搜索</h3><p>蓝牙的搜索有三种方式</p>\n<ul>\n<li>方法一：<code>BluetoothAdapter.startDiscovery()</code>是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；<br>蓝牙扫描广播接收器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeviceReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BluetoothDevice.ACTION_FOUND.equals(action))&#123;</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法二：<code>BluetoothAdapter.startScan(ScanCallback callback)</code>在<code>ScanCallback</code>的<code>onScanResult(int callbackType, ScanResult result)</code>方法中，通过<code>result.getDevice()</code>可获取扫描到的Ble设备</li>\n<li>方法三：<code>BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)</code><br>该方法已经被舍弃</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}