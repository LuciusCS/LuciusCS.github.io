{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/assets/Android JNI.png","path":"assets/Android JNI.png","modified":0,"renderable":0},{"_id":"source/assets/Android JNI1.png","path":"assets/Android JNI1.png","modified":0,"renderable":0},{"_id":"source/assets/Android JNI2.png","path":"assets/Android JNI2.png","modified":0,"renderable":0},{"_id":"source/assets/Android JNI3.png","path":"assets/Android JNI3.png","modified":0,"renderable":0},{"_id":"source/assets/Android safe.png","path":"assets/Android safe.png","modified":0,"renderable":0},{"_id":"source/assets/Android safe1.png","path":"assets/Android safe1.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg1.png","path":"assets/GitImg1.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg2.png","path":"assets/GitImg2.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg3.png","path":"assets/GitImg3.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg4.png","path":"assets/GitImg4.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg5.png","path":"assets/GitImg5.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg6.png","path":"assets/GitImg6.png","modified":0,"renderable":0},{"_id":"source/assets/GitImg7.png","path":"assets/GitImg7.png","modified":0,"renderable":0},{"_id":"source/assets/Retrofit.png","path":"assets/Retrofit.png","modified":0,"renderable":0},{"_id":"source/assets/android_basis_permission.png","path":"assets/android_basis_permission.png","modified":0,"renderable":0},{"_id":"source/assets/lifecycle.png","path":"assets/lifecycle.png","modified":0,"renderable":0},{"_id":"source/assets/livedata.png","path":"assets/livedata.png","modified":0,"renderable":0},{"_id":"source/assets/proxy-design-pattern.jpg","path":"assets/proxy-design-pattern.jpg","modified":0,"renderable":0},{"_id":"source/img/20170726/Image1.png","path":"img/20170726/Image1.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image11.png","path":"img/20170726/Image11.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image12.png","path":"img/20170726/Image12.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image13.png","path":"img/20170726/Image13.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image14.png","path":"img/20170726/Image14.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image15.png","path":"img/20170726/Image15.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image16.png","path":"img/20170726/Image16.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image17.png","path":"img/20170726/Image17.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image18.png","path":"img/20170726/Image18.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image2.png","path":"img/20170726/Image2.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image3.png","path":"img/20170726/Image3.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image4.png","path":"img/20170726/Image4.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image5.png","path":"img/20170726/Image5.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image6.png","path":"img/20170726/Image6.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image7.png","path":"img/20170726/Image7.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image8.png","path":"img/20170726/Image8.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Image9.png","path":"img/20170726/Image9.png","modified":0,"renderable":0},{"_id":"source/img/20170726/Thumbs.db","path":"img/20170726/Thumbs.db","modified":0,"renderable":0},{"_id":"source/img/Android/Android safe1.png","path":"img/Android/Android safe1.png","modified":0,"renderable":0},{"_id":"source/img/Android/AndroidJNI.png","path":"img/Android/AndroidJNI.png","modified":0,"renderable":0},{"_id":"source/img/Android/AndroidJNI1.png","path":"img/Android/AndroidJNI1.png","modified":0,"renderable":0},{"_id":"source/img/Android/AndroidJNI2.png","path":"img/Android/AndroidJNI2.png","modified":0,"renderable":0},{"_id":"source/img/Android/AndroidJNI3.png","path":"img/Android/AndroidJNI3.png","modified":0,"renderable":0},{"_id":"source/img/Android/Android_performance.png","path":"img/Android/Android_performance.png","modified":0,"renderable":0},{"_id":"source/img/Android/Androidsafe.png","path":"img/Android/Androidsafe.png","modified":0,"renderable":0},{"_id":"source/img/Android/Retrofit.png","path":"img/Android/Retrofit.png","modified":0,"renderable":0},{"_id":"source/img/Android/android_base_binder1.png","path":"img/Android/android_base_binder1.png","modified":0,"renderable":0},{"_id":"source/img/Android/android_base_binder2.png","path":"img/Android/android_base_binder2.png","modified":0,"renderable":0},{"_id":"source/img/Android/android_base_binder3.png","path":"img/Android/android_base_binder3.png","modified":0,"renderable":0},{"_id":"source/img/Android/android_base_binder4.png","path":"img/Android/android_base_binder4.png","modified":0,"renderable":0},{"_id":"source/img/Android/android_basis_permission.png","path":"img/Android/android_basis_permission.png","modified":0,"renderable":0},{"_id":"source/img/Android/application_start.png","path":"img/Android/application_start.png","modified":0,"renderable":0},{"_id":"source/img/Android/collection.png","path":"img/Android/collection.png","modified":0,"renderable":0},{"_id":"source/img/Android/livedata.png","path":"img/Android/livedata.png","modified":0,"renderable":0},{"_id":"source/img/Android/lifecycle.png","path":"img/Android/lifecycle.png","modified":0,"renderable":0},{"_id":"source/img/Android/service_lifecycle.png","path":"img/Android/service_lifecycle.png","modified":0,"renderable":0},{"_id":"source/img/Android/view_model.png","path":"img/Android/view_model.png","modified":0,"renderable":0},{"_id":"source/img/Android/view_model1.png","path":"img/Android/view_model1.png","modified":0,"renderable":0},{"_id":"source/img/Android/view_model2.png","path":"img/Android/view_model2.png","modified":0,"renderable":0},{"_id":"source/img/Java/proxy-design-pattern.jpg","path":"img/Java/proxy-design-pattern.jpg","modified":0,"renderable":0},{"_id":"source/img/other/GitImg1.png","path":"img/other/GitImg1.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg2.png","path":"img/other/GitImg2.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg3.png","path":"img/other/GitImg3.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg4.png","path":"img/other/GitImg4.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg5.png","path":"img/other/GitImg5.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg6.png","path":"img/other/GitImg6.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg7.png","path":"img/other/GitImg7.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg8.png","path":"img/other/GitImg8.png","modified":0,"renderable":0},{"_id":"source/img/other/GitImg9.png","path":"img/other/GitImg9.png","modified":0,"renderable":0},{"_id":"source/img/other/Image1.png","path":"img/other/Image1.png","modified":0,"renderable":0},{"_id":"source/img/other/Image3.png","path":"img/other/Image3.png","modified":0,"renderable":0},{"_id":"source/img/other/Image4.png","path":"img/other/Image4.png","modified":0,"renderable":0},{"_id":"source/img/other/Image5.png","path":"img/other/Image5.png","modified":0,"renderable":0},{"_id":"source/img/other/Image6.png","path":"img/other/Image6.png","modified":0,"renderable":0},{"_id":"source/img/other/blog1.png","path":"img/other/blog1.png","modified":0,"renderable":0},{"_id":"source/img/other/blog2.png","path":"img/other/blog2.png","modified":0,"renderable":0},{"_id":"source/img/other/blog3.png","path":"img/other/blog3.png","modified":0,"renderable":0},{"_id":"source/img/other/ubuntu_file_share1.png","path":"img/other/ubuntu_file_share1.png","modified":0,"renderable":0},{"_id":"source/img/other/ubuntu_file_share2.png","path":"img/other/ubuntu_file_share2.png","modified":0,"renderable":0},{"_id":"source/img/other/ubuntu_file_share3.png","path":"img/other/ubuntu_file_share3.png","modified":0,"renderable":0},{"_id":"source/img/other/ubuntu_file_share4.png","path":"img/other/ubuntu_file_share4.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/001.gif","path":"img/DataStructure/001.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/001.png","path":"img/DataStructure/001.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/002.gif","path":"img/DataStructure/002.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/003.jpg","path":"img/DataStructure/003.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/004.jpg","path":"img/DataStructure/004.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/Merge_sort.gif","path":"img/DataStructure/Merge_sort.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/Merge_sort_01.gif","path":"img/DataStructure/Merge_sort_01.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_list.jpg","path":"img/DataStructure/adjacency_list.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_list1.png","path":"img/DataStructure/adjacency_list1.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix.jpg","path":"img/DataStructure/adjacency_matrix.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix1.png","path":"img/DataStructure/adjacency_matrix1.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix2.png","path":"img/DataStructure/adjacency_matrix2.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/adjacency_matrix3.png","path":"img/DataStructure/adjacency_matrix3.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/binary_tree_result.png","path":"img/DataStructure/binary_tree_result.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/binary_tree.jpg","path":"img/DataStructure/binary_tree.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap.jpg","path":"img/DataStructure/heap.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap1.jpg","path":"img/DataStructure/heap1.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap2.jpg","path":"img/DataStructure/heap2.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap3.jpg","path":"img/DataStructure/heap3.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap5.jpg","path":"img/DataStructure/heap5.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap7.jpg","path":"img/DataStructure/heap7.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap6.jpg","path":"img/DataStructure/heap6.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap8.jpg","path":"img/DataStructure/heap8.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/heap_sort.jpg","path":"img/DataStructure/heap_sort.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree.png","path":"img/DataStructure/huffman_tree.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree1.png","path":"img/DataStructure/huffman_tree1.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree2.jpg","path":"img/DataStructure/huffman_tree2.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/huffman_tree3.png","path":"img/DataStructure/huffman_tree3.png","modified":0,"renderable":0},{"_id":"source/img/DataStructure/insertsort.gif","path":"img/DataStructure/insertsort.gif","modified":0,"renderable":0},{"_id":"source/img/DataStructure/quick_sort.jpg","path":"img/DataStructure/quick_sort.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/thread_binary_tree.jpg","path":"img/DataStructure/thread_binary_tree.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/quick_sort_01.jpg","path":"img/DataStructure/quick_sort_01.jpg","modified":0,"renderable":0},{"_id":"source/img/DataStructure/threaded_binary_tree.jpg","path":"img/DataStructure/threaded_binary_tree.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/cover/img1.jpg","path":"cover/img1.jpg","modified":0,"renderable":0},{"_id":"source/cover/img1.png","path":"cover/img1.png","modified":0,"renderable":0},{"_id":"source/cover/img10.jpg","path":"cover/img10.jpg","modified":0,"renderable":0},{"_id":"source/cover/img100.jpg","path":"cover/img100.jpg","modified":0,"renderable":0},{"_id":"source/cover/img101.jpg","path":"cover/img101.jpg","modified":0,"renderable":0},{"_id":"source/cover/img102.jpg","path":"cover/img102.jpg","modified":0,"renderable":0},{"_id":"source/cover/img103.jpg","path":"cover/img103.jpg","modified":0,"renderable":0},{"_id":"source/cover/img11.jpg","path":"cover/img11.jpg","modified":0,"renderable":0},{"_id":"source/cover/img12.jpg","path":"cover/img12.jpg","modified":0,"renderable":0},{"_id":"source/cover/img13.jpg","path":"cover/img13.jpg","modified":0,"renderable":0},{"_id":"source/cover/img14.jpg","path":"cover/img14.jpg","modified":0,"renderable":0},{"_id":"source/cover/img15.jpg","path":"cover/img15.jpg","modified":0,"renderable":0},{"_id":"source/cover/img16.jpg","path":"cover/img16.jpg","modified":0,"renderable":0},{"_id":"source/cover/img17.jpg","path":"cover/img17.jpg","modified":0,"renderable":0},{"_id":"source/cover/img18.jpg","path":"cover/img18.jpg","modified":0,"renderable":0},{"_id":"source/cover/img19.jpg","path":"cover/img19.jpg","modified":0,"renderable":0},{"_id":"source/cover/img2.jpg","path":"cover/img2.jpg","modified":0,"renderable":0},{"_id":"source/cover/img2.png","path":"cover/img2.png","modified":0,"renderable":0},{"_id":"source/cover/img20.jpg","path":"cover/img20.jpg","modified":0,"renderable":0},{"_id":"source/cover/img21.jpg","path":"cover/img21.jpg","modified":0,"renderable":0},{"_id":"source/cover/img22.jpg","path":"cover/img22.jpg","modified":0,"renderable":0},{"_id":"source/cover/img23.jpg","path":"cover/img23.jpg","modified":0,"renderable":0},{"_id":"source/cover/img24.jpg","path":"cover/img24.jpg","modified":0,"renderable":0},{"_id":"source/cover/img25.jpg","path":"cover/img25.jpg","modified":0,"renderable":0},{"_id":"source/cover/img26.jpg","path":"cover/img26.jpg","modified":0,"renderable":0},{"_id":"source/cover/img27.jpg","path":"cover/img27.jpg","modified":0,"renderable":0},{"_id":"source/cover/img28.jpg","path":"cover/img28.jpg","modified":0,"renderable":0},{"_id":"source/cover/img29.jpg","path":"cover/img29.jpg","modified":0,"renderable":0},{"_id":"source/cover/img3.jpg","path":"cover/img3.jpg","modified":0,"renderable":0},{"_id":"source/cover/img30.jpg","path":"cover/img30.jpg","modified":0,"renderable":0},{"_id":"source/cover/img31.jpg","path":"cover/img31.jpg","modified":0,"renderable":0},{"_id":"source/cover/img32.jpg","path":"cover/img32.jpg","modified":0,"renderable":0},{"_id":"source/cover/img33.jpg","path":"cover/img33.jpg","modified":0,"renderable":0},{"_id":"source/cover/img34.jpg","path":"cover/img34.jpg","modified":0,"renderable":0},{"_id":"source/cover/img35.jpg","path":"cover/img35.jpg","modified":0,"renderable":0},{"_id":"source/cover/img36.jpg","path":"cover/img36.jpg","modified":0,"renderable":0},{"_id":"source/cover/img37.jpg","path":"cover/img37.jpg","modified":0,"renderable":0},{"_id":"source/cover/img38.jpg","path":"cover/img38.jpg","modified":0,"renderable":0},{"_id":"source/cover/img39.jpg","path":"cover/img39.jpg","modified":0,"renderable":0},{"_id":"source/cover/img4.jpg","path":"cover/img4.jpg","modified":0,"renderable":0},{"_id":"source/cover/img40.jpg","path":"cover/img40.jpg","modified":0,"renderable":0},{"_id":"source/cover/img41.jpg","path":"cover/img41.jpg","modified":0,"renderable":0},{"_id":"source/cover/img42.jpg","path":"cover/img42.jpg","modified":0,"renderable":0},{"_id":"source/cover/img43.jpg","path":"cover/img43.jpg","modified":0,"renderable":0},{"_id":"source/cover/img44.jpg","path":"cover/img44.jpg","modified":0,"renderable":0},{"_id":"source/cover/img45.jpg","path":"cover/img45.jpg","modified":0,"renderable":0},{"_id":"source/cover/img46.jpg","path":"cover/img46.jpg","modified":0,"renderable":0},{"_id":"source/cover/img48.jpg","path":"cover/img48.jpg","modified":0,"renderable":0},{"_id":"source/cover/img47.jpg","path":"cover/img47.jpg","modified":0,"renderable":0},{"_id":"source/cover/img49.jpg","path":"cover/img49.jpg","modified":0,"renderable":0},{"_id":"source/cover/img5.jpg","path":"cover/img5.jpg","modified":0,"renderable":0},{"_id":"source/cover/img50.jpg","path":"cover/img50.jpg","modified":0,"renderable":0},{"_id":"source/cover/img51.jpg","path":"cover/img51.jpg","modified":0,"renderable":0},{"_id":"source/cover/img52.jpg","path":"cover/img52.jpg","modified":0,"renderable":0},{"_id":"source/cover/img53.jpg","path":"cover/img53.jpg","modified":0,"renderable":0},{"_id":"source/cover/img54.jpg","path":"cover/img54.jpg","modified":0,"renderable":0},{"_id":"source/cover/img55.jpg","path":"cover/img55.jpg","modified":0,"renderable":0},{"_id":"source/cover/img56.jpg","path":"cover/img56.jpg","modified":0,"renderable":0},{"_id":"source/cover/img57.jpg","path":"cover/img57.jpg","modified":0,"renderable":0},{"_id":"source/cover/img58.jpg","path":"cover/img58.jpg","modified":0,"renderable":0},{"_id":"source/cover/img59.jpg","path":"cover/img59.jpg","modified":0,"renderable":0},{"_id":"source/cover/img6.jpg","path":"cover/img6.jpg","modified":0,"renderable":0},{"_id":"source/cover/img60.jpg","path":"cover/img60.jpg","modified":0,"renderable":0},{"_id":"source/cover/img61.jpg","path":"cover/img61.jpg","modified":0,"renderable":0},{"_id":"source/cover/img62.jpg","path":"cover/img62.jpg","modified":0,"renderable":0},{"_id":"source/cover/img63.jpg","path":"cover/img63.jpg","modified":0,"renderable":0},{"_id":"source/cover/img64.jpg","path":"cover/img64.jpg","modified":0,"renderable":0},{"_id":"source/cover/img65.jpg","path":"cover/img65.jpg","modified":0,"renderable":0},{"_id":"source/cover/img66.jpg","path":"cover/img66.jpg","modified":0,"renderable":0},{"_id":"source/cover/img67.jpg","path":"cover/img67.jpg","modified":0,"renderable":0},{"_id":"source/cover/img68.jpg","path":"cover/img68.jpg","modified":0,"renderable":0},{"_id":"source/cover/img69.jpg","path":"cover/img69.jpg","modified":0,"renderable":0},{"_id":"source/cover/img7.jpg","path":"cover/img7.jpg","modified":0,"renderable":0},{"_id":"source/cover/img70.jpg","path":"cover/img70.jpg","modified":0,"renderable":0},{"_id":"source/cover/img71.jpg","path":"cover/img71.jpg","modified":0,"renderable":0},{"_id":"source/cover/img72.jpg","path":"cover/img72.jpg","modified":0,"renderable":0},{"_id":"source/cover/img73.jpg","path":"cover/img73.jpg","modified":0,"renderable":0},{"_id":"source/cover/img74.jpg","path":"cover/img74.jpg","modified":0,"renderable":0},{"_id":"source/cover/img75.jpg","path":"cover/img75.jpg","modified":0,"renderable":0},{"_id":"source/cover/img76.jpg","path":"cover/img76.jpg","modified":0,"renderable":0},{"_id":"source/cover/img77.jpg","path":"cover/img77.jpg","modified":0,"renderable":0},{"_id":"source/cover/img78.jpg","path":"cover/img78.jpg","modified":0,"renderable":0},{"_id":"source/cover/img79.jpg","path":"cover/img79.jpg","modified":0,"renderable":0},{"_id":"source/cover/img8.jpg","path":"cover/img8.jpg","modified":0,"renderable":0},{"_id":"source/cover/img80.jpg","path":"cover/img80.jpg","modified":0,"renderable":0},{"_id":"source/cover/img81.jpg","path":"cover/img81.jpg","modified":0,"renderable":0},{"_id":"source/cover/img82.jpg","path":"cover/img82.jpg","modified":0,"renderable":0},{"_id":"source/cover/img83.jpg","path":"cover/img83.jpg","modified":0,"renderable":0},{"_id":"source/cover/img84.jpg","path":"cover/img84.jpg","modified":0,"renderable":0},{"_id":"source/cover/img85.jpg","path":"cover/img85.jpg","modified":0,"renderable":0},{"_id":"source/cover/img86.jpg","path":"cover/img86.jpg","modified":0,"renderable":0},{"_id":"source/cover/img87.jpg","path":"cover/img87.jpg","modified":0,"renderable":0},{"_id":"source/cover/img88.jpg","path":"cover/img88.jpg","modified":0,"renderable":0},{"_id":"source/cover/img89.jpg","path":"cover/img89.jpg","modified":0,"renderable":0},{"_id":"source/cover/img9.jpg","path":"cover/img9.jpg","modified":0,"renderable":0},{"_id":"source/cover/img90.jpg","path":"cover/img90.jpg","modified":0,"renderable":0},{"_id":"source/cover/img91.jpg","path":"cover/img91.jpg","modified":0,"renderable":0},{"_id":"source/cover/img92.jpg","path":"cover/img92.jpg","modified":0,"renderable":0},{"_id":"source/cover/img93.jpg","path":"cover/img93.jpg","modified":0,"renderable":0},{"_id":"source/cover/img94.jpg","path":"cover/img94.jpg","modified":0,"renderable":0},{"_id":"source/cover/img95.jpg","path":"cover/img95.jpg","modified":0,"renderable":0},{"_id":"source/cover/img96.jpg","path":"cover/img96.jpg","modified":0,"renderable":0},{"_id":"source/cover/img97.jpg","path":"cover/img97.jpg","modified":0,"renderable":0},{"_id":"source/cover/img98.jpg","path":"cover/img98.jpg","modified":0,"renderable":0},{"_id":"source/cover/img99.jpg","path":"cover/img99.jpg","modified":0,"renderable":0},{"_id":"source/cover/astronaut.jpg","path":"cover/astronaut.jpg","modified":0,"renderable":0},{"_id":"source/cover/img104.jpg","path":"cover/img104.jpg","modified":0,"renderable":0},{"_id":"source/cover/img105.jpg","path":"cover/img105.jpg","modified":0,"renderable":0},{"_id":"source/cover/img106.jpg","path":"cover/img106.jpg","modified":0,"renderable":0},{"_id":"source/cover/img107.jpg","path":"cover/img107.jpg","modified":0,"renderable":0},{"_id":"source/cover/img108.jpg","path":"cover/img108.jpg","modified":0,"renderable":0},{"_id":"source/cover/img109.jpg","path":"cover/img109.jpg","modified":0,"renderable":0},{"_id":"source/cover/img110.jpg","path":"cover/img110.jpg","modified":0,"renderable":0},{"_id":"source/cover/img111.jpg","path":"cover/img111.jpg","modified":0,"renderable":0},{"_id":"source/cover/img112.jpg","path":"cover/img112.jpg","modified":0,"renderable":0},{"_id":"source/cover/img113.jpg","path":"cover/img113.jpg","modified":0,"renderable":0},{"_id":"source/cover/img114.jpg","path":"cover/img114.jpg","modified":0,"renderable":0},{"_id":"source/cover/img115.jpg","path":"cover/img115.jpg","modified":0,"renderable":0},{"_id":"source/cover/img116.jpg","path":"cover/img116.jpg","modified":0,"renderable":0},{"_id":"source/cover/img117.jpg","path":"cover/img117.jpg","modified":0,"renderable":0},{"_id":"source/cover/img118.jpg","path":"cover/img118.jpg","modified":0,"renderable":0},{"_id":"source/cover/img119.jpg","path":"cover/img119.jpg","modified":0,"renderable":0},{"_id":"source/cover/img120.jpg","path":"cover/img120.jpg","modified":0,"renderable":0},{"_id":"source/cover/img121.jpg","path":"cover/img121.jpg","modified":0,"renderable":0},{"_id":"source/cover/img122.jpg","path":"cover/img122.jpg","modified":0,"renderable":0},{"_id":"source/cover/img123.jpg","path":"cover/img123.jpg","modified":0,"renderable":0},{"_id":"source/cover/img124.jpg","path":"cover/img124.jpg","modified":0,"renderable":0},{"_id":"source/cover/img125.jpg","path":"cover/img125.jpg","modified":0,"renderable":0},{"_id":"source/cover/img126.jpg","path":"cover/img126.jpg","modified":0,"renderable":0},{"_id":"source/cover/img127.jpg","path":"cover/img127.jpg","modified":0,"renderable":0},{"_id":"source/cover/img128.jpg","path":"cover/img128.jpg","modified":0,"renderable":0},{"_id":"source/cover/img129.jpg","path":"cover/img129.jpg","modified":0,"renderable":0},{"_id":"source/cover/img130.jpg","path":"cover/img130.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1609738555468},{"_id":"themes/butterfly/README_CN.md","hash":"c785124cd3ab1360baa5d7b18d979b7400438669","modified":1609738555468},{"_id":"themes/butterfly/README.md","hash":"7e82a4b91ff9ca61e04aabe6e8c02227b49f5327","modified":1609738555468},{"_id":"themes/butterfly/_config.yml","hash":"37b85314d9997789de66bb5b23605f238849ff4c","modified":1609841587906},{"_id":"themes/butterfly/package.json","hash":"2dd7866b5ac7f64aa128ea3fc18e166d80b3a0a8","modified":1609738555508},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1609738555468},{"_id":"themes/butterfly/languages/default.yml","hash":"690fae93ee2e578e9085e988654ddb013d2fffd9","modified":1609738555468},{"_id":"themes/butterfly/languages/en.yml","hash":"948f4a29cd5fafdc46ad2008f60929acf76be2a3","modified":1609738555468},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"600ac62a76344d012c2b776e570a5e21c66683a8","modified":1609738555468},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"3a02788767ed6a751e1c350ec620354b50ac86b9","modified":1609738555468},{"_id":"themes/butterfly/layout/404.pug","hash":"10ce9b0764d975460069bf116bfceaaeb9691d3a","modified":1609738555468},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1609738555468},{"_id":"themes/butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1609738555478},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1609738555508},{"_id":"themes/butterfly/layout/page.pug","hash":"76536c903cabc8e4619759e3a8b6a384c0518716","modified":1609738555508},{"_id":"themes/butterfly/layout/post.pug","hash":"0277577f7fce2b830259e29d3a2a82f35addbf78","modified":1609738555508},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1609738555508},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1609738555468},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1609738555468},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"924e1fefc81f33f165a5fa9856712a98e7c83ad5","modified":1609738555478},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1609738555468},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"780566ea9155df8f503af4e80ec7eff10e00859a","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"b5f7e698ef44edd9227c0c0162c7270aac6bf031","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"012e46f5130a2ff312c28a4fcdc060195f92efde","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"86b2a4d500542fe764fdc5ff71cf029604325930","modified":1609738555488},{"_id":"themes/butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1609738555508},{"_id":"themes/butterfly/scripts/events/init.js","hash":"f7ab55363d05c945569d9ac4afc889f9706308c6","modified":1609738555508},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1609738555508},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"dbce193ba170e004790550fe4694de8e29b299b9","modified":1609738555508},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"1e2ac4d26df7cd18a92f1404329f8eb1c388dc18","modified":1609738555508},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d9cdeecfb0098ad9bf4814ea2f95167b637e015d","modified":1609738555508},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"f42b2358a44d91ef6c853ce75f23af6e8d3ff423","modified":1609738555508},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"ff3815e6923f248501ed76aebfa6e8e083edb9f7","modified":1609738555508},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"0745597f4ffadde037e57e0f66f7d984dc576dc6","modified":1609738555508},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"54c0c9c6d4d4ca754680cd24d7e204a745a6eec0","modified":1609738555508},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1609738555508},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1609738555518},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1609738555508},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1609738555518},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1609738555518},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1609738555528},{"_id":"themes/butterfly/source/css/var.styl","hash":"ae8193bd0107c823b8d2a123f1c301084c9c227a","modified":1609738555528},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1609738555538},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1609738555538},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1609738555539},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1609738555539},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1609738555539},{"_id":"themes/butterfly/source/js/main.js","hash":"7663c364a78c6ec16509e75cdd3647c16b2dd0ec","modified":1609738555539},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1609738555539},{"_id":"themes/butterfly/source/js/utils.js","hash":"ba7e672a7bed2aefb9174e8122d92a643814272a","modified":1609738555539},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"767b425f97e74a98002f4a435e36e8ec27e8a994","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"afe703c766b8717d119379ee27037481f1165af8","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"e33b993af0bfc521334dac8e3c8a227dfbf9fcaa","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/js.pug","hash":"473059d3a4a63fa95ea4d2ca71ae16c003502e0a","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e73488c6d7849407d39f35aaffedb46646a4e1a5","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"1ddbd09e1902da7fa4bf7824654f132e41622c42","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"9a6f8211cdcb4aa87ccb5fa4f62b89c245412c94","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"d22d4c98028272dfc6c2e721e469f572a6b62ed3","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"0060598ca1cf25619bdb110ea2c83c690e4d2939","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"96c06a8bf0cb9a19ba32e207613c8f240fa71d26","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1609738555478},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"81a34e9d642a68e77650609601a8096c6445daef","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2beb27e33e4492fa80e88c37dcb7a3ffd7da9e24","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"90b5c2600569f8cf769c5fb3a37c12536f71e375","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/page/artitalk.pug","hash":"a02e5d18f12844ac1fbfa04d03798ff9e73090bc","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1609738555485},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"7e7832aafdf5ca50e71a039ad3fc98d8ef6e7d30","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"d9b96f24c2439f263a606fd38a5517bd4bb162b7","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/baidu_push.pug","hash":"d3490e78bd2569423dc1844b9db0fbb6cd855022","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"21a7f17ff457c0cf8747f0847dee6df675482574","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"38504aec959c050c082db1c5aeaf99345f97bbee","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"e0e8bf00ef7a0a62ea2265bd5e4a33d0edab5946","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"1708fb171403a77966c86408092dd0f7dde629ae","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"51f3227814fd229ddb2c9a2dd75a4b8effee9ad5","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"92a5100eec2f10fe867a8a8f88d1e18fbd6d3b92","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"cabf9ee6a2886e6ede17f224dfbb161a9b1258e7","modified":1609738555508},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1609738555508},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"ff6d8dfc187d6e5e6139bbf3e0d831dbe1e9a530","modified":1609738555508},{"_id":"themes/butterfly/layout/includes/widget/card_self.pug","hash":"8318c7c9a6aef966afba44e283111e7ff0b2f04f","modified":1609738555508},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"b088fa11b89a05c2b49e6a27c2b862954e0b0ec2","modified":1609738555508},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1609738555508},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"6f92420429cded52255c165007b9f88910f36022","modified":1609738555508},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"56ce639b394ba195207ee00f5a2d6f22926b403f","modified":1609738555520},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"cfafb671a6ebad792e3636f03081f36e9799a5df","modified":1609738555520},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"d67ecb6c950e802a9c73975b13cab44f899eb192","modified":1609738555520},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"84c14368d3fab66d5fb7d03678766274e2e0d84f","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"b3bed148ec524b80377e34c11a4a55d1d8e8145e","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"9e66e9672eb6d60950024d5f73cb7b925b2549b2","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"c4ae9292d6b7e42943b1b11e109ed560dc3a7753","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"6c74997b89984db3696572efc7cbafdf59ce7803","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ba391266cd967fa96109677455dd6701292afd52","modified":1609738555520},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6149c50ad33b3feb3da8a9d0b9e6557d1137210","modified":1609738555528},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"e00d34774a0d5644bae9989f0e89743b5f9e2ea5","modified":1609738555528},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"78ef182c0f6711c8491a8ee421b708c8f2a63c30","modified":1609738555528},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"dc3a203aebff1420a0661f923a5001ef513f63ac","modified":1609738555528},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"767a0de8c54a67f679b36a86598d77f813f7db06","modified":1609738555528},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"cd50ccb2ebb0e4282298ce3a7e7073c327759eb0","modified":1609738555528},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1609738555528},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1609738555528},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4058ab759577efe280d5e38902be39054ed4b471","modified":1609738555528},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"3c7a7efbb14d8ce6538f612992aa1a62fd278991","modified":1609738555528},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"75c87cb69b2eb2a219eec9447cd79282ef612a68","modified":1609738555528},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1609738555528},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"a470029a157fbb8406ff72322a75ef63d6675431","modified":1609738555528},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"202b01db6ef3cca9e5a173e1a0dadfee8854a849","modified":1609738555528},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"92aa84cdec97729c86ba4674a355496eb37c986a","modified":1609738555528},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"5fe4235c038ed128819bd6918cd0781b372b598e","modified":1609738555528},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1609738555528},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1609738555528},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1609738555528},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1609738555528},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1609738555528},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1609738555528},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1609738555539},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3234942decaa1fde5b872766d4943a2e8cb9ef72","modified":1609738555539},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"663a298253eddb5126ca1a6139d69c7097ffb52e","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"47d5367d8308a5a134058f9f63c33c75890960f8","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"9b6b7b589ef7a8109d88ba439b2d8baf7286b961","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"a8d8be37236400508e97f75615f03cedccacddfb","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"c90cc8aab51dc3fb139335290b3c3a1aa38cb586","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"a715b6f69e477aec9f9f62afc24b9330726adb54","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"96f04c0e7a5dfc1980e69f9b0bf277342de6e303","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"1060d8e9258a55d7d453f49d9f78ad692f416221","modified":1609738555488},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"0322d640fd6a91853dec3ad39cc24c9b1291322b","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"407d88e4af099d5f1a3f44623ec276c999219ec3","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"6f92311afe60ca5f44055016db9cecce8fb2dc62","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"7ced4e62fc669b00c30bf5ffe814bd30d963a490","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"732f4ebf7a1be1c94917dec426acaa494348c0ef","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"7935e92db64ca047d94404e5fc390a207e857a87","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"f34ca24c03a9733bee253971ab69288d59b9969d","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"1a5da17848c6852fbbc5df6f6bb178c9b6a31085","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"5d2e411a6938677d70dd2a0241bd6d2b771f0b28","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"0622e955f3d2efef457f61d0cec0408376bd180a","modified":1609738555498},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1609738555498},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"ba3bdf02a6c78b15eada95638173a11445dac7ac","modified":1609738555520},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"1b2dc0ef768c9be9f18d1c1f93d88f916482c5df","modified":1609738555520},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1609738555520},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"ebae44a37ac143f4e35523ebd6809371958fb930","modified":1609738555520},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"c1747b8641303a1d9472ec94f2bc654885feb270","modified":1609738555520},{"_id":"source/_posts/Java/Java基础/Java 输入输出操作.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588931083212},{"_id":"source/_posts/Android/框架/RxJava2.0.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588931083195},{"_id":"source/_posts/Java/Java多线程/Java锁机制.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588931083222},{"_id":"source/_posts/Other/Git/Git仓库服务器配置.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588931083229},{"_id":"source/_posts/Other/Project/Project.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588931083230},{"_id":"source/_posts/.history/Android/Android基础/Android常用的库_20201127170723.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1606468717907},{"_id":"source/_posts/.history/Android/Android基础/Android集合_20200509113644.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1589004803162},{"_id":"source/_posts/.history/Android/框架/Retrofit/Retrofit 基础_20200509085623.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588994151902},{"_id":"source/assets/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1588931083239},{"_id":"source/assets/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1588931083239},{"_id":"source/assets/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1588931083240},{"_id":"source/assets/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1588931083240},{"_id":"source/assets/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1588931083241},{"_id":"source/assets/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1588931083241},{"_id":"source/assets/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1588931083242},{"_id":"source/assets/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1588931083243},{"_id":"source/assets/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1588931083243},{"_id":"source/assets/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1588931083244},{"_id":"source/assets/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1588931083244},{"_id":"source/assets/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1588931083245},{"_id":"source/assets/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1588931083245},{"_id":"source/assets/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1588931083247},{"_id":"source/assets/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1588931083247},{"_id":"source/assets/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1588931083248},{"_id":"source/assets/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1588931083250},{"_id":"source/thumbnail/img100.jpg","hash":"a1d505005b78b64a662337c19563a2092701deed","modified":1588931083340},{"_id":"source/thumbnail/img101.jpg","hash":"128d477046a09228cc81687a98ba86e9be6267c9","modified":1588931083341},{"_id":"source/thumbnail/img84.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1588931083506},{"_id":"source/thumbnail/img86.jpg","hash":"7a7b07f27672b73fd14262836d2949a6b81c13d4","modified":1588931083508},{"_id":"source/thumbnail/img91.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1588931083513},{"_id":"source/thumbnail/img92.jpg","hash":"8c5b2bb1012026b907c2d373523500aae774ba39","modified":1588931083514},{"_id":"source/thumbnail/img93.jpg","hash":"d5dc73161d76f70070894803f656fd165d3c06d4","modified":1588931083515},{"_id":"source/thumbnail/img95.jpg","hash":"6226a5462b7f020c1c6f00cc35f6ad9d5c83f60c","modified":1588931083518},{"_id":"source/thumbnail/img99.jpg","hash":"1a73da5187dd39502fdfbccbf5be67242b25285f","modified":1588931083521},{"_id":"source/_posts/C++/C++ 问题总结.md","hash":"6a0b0ad4b83d2bbf1a12de32028bcb47a7d7646c","modified":1609894930041},{"_id":"source/_posts/C++/C++基础.md","hash":"79cd48ac00b9d49083274357a0ddf4ae2cd677e6","modified":1609894964163},{"_id":"source/_posts/Data_Structure/2017-07-27-data-structure-stack.md","hash":"3e7c48af9cc8c1b9950be0e2efd2ab12b8925660","modified":1609848887221},{"_id":"source/_posts/Data_Structure/2017-07-31-data-structure-insert-sort.md","hash":"c0316cd30301a1a00ab1759f55cabb7b725fa936","modified":1609848889827},{"_id":"source/_posts/Data_Structure/2017-07-31-data-structure-search.md","hash":"0916835574bcb3f42d7fd26dad57b27c01c6a17c","modified":1609848891189},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-queue.md","hash":"555f3c9b354d38257569dac887e86f82221926a9","modified":1609848892235},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-radix-sort.md","hash":"113a17c59aa651314a5eef71c200d4142bf7d3f5","modified":1609848894321},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary.md","hash":"33e7efdeaf5d46e47313c8ef91c0b707b467ee05","modified":1609848895343},{"_id":"source/_posts/Data_Structure/2017-08-02-data-structure-stack-use.md","hash":"6508dd35b71212347be79bd24160317c986acad4","modified":1609848897134},{"_id":"source/_posts/Data_Structure/2017-08-04-data-structure-merge-sort.md","hash":"c8ea35c635bb4d3808bf362f5269a49ac15d5869","modified":1609848898971},{"_id":"source/_posts/Data_Structure/2017-08-04-data-structure-quick-sort.md","hash":"6621cb95ad345753811c192a318a62d38ede43d1","modified":1609848899838},{"_id":"source/_posts/Data_Structure/2017-08-08-data-structure-threaded-binary-tree.md","hash":"4b907d4815ea1dd7dc6167b8c48c7ce18c581511","modified":1609848901104},{"_id":"source/_posts/Data_Structure/2017-08-26-data-structure-adjaceny-matrix.md","hash":"542796baf724913001c3e3e8d507279e9573498d","modified":1609848903207},{"_id":"source/_posts/Data_Structure/2017-08-26-data-structure-build-heap.md","hash":"4542d7029d900b374e1a1617280e58da38238cc2","modified":1609848904902},{"_id":"source/_posts/Data_Structure/2017-08-27-data-structure-adjacency-list.md","hash":"0de6b6f8aca29abb463e712cbe594212bcb053b6","modified":1609848907406},{"_id":"source/_posts/Data_Structure/2017-08-27-data-structure-heap-sort.md","hash":"57e95fea98e9cee033b0685f9a48b1651ed08e10","modified":1609848909320},{"_id":"source/_posts/Data_Structure/2017-08-28-data-structure-huffman-tree.md","hash":"002969d86f0f784f6e56e61e5a33068467a3d47c","modified":1609848910554},{"_id":"source/_posts/Flutter/Flutter基础.md","hash":"f8cf61fe08186878ec6dc3ed9288e2d0fffbd9d6","modified":1609894995070},{"_id":"source/_posts/Flutter/Flutter问题解决.md","hash":"5af0a4da0ee7070f2f7c50d314c4c87d4d39e129","modified":1609895369298},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1001.md","hash":"5fbde476c6a8efcc2efc8a3abbe1b3514c2bcd59","modified":1609848954273},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1002.md","hash":"870344e4890b9209a09e260ecad7851148a19a98","modified":1609848952768},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1005.md","hash":"27542d0ab604aa0d5e98f0ce8e6cb68296371de6","modified":1609848951743},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1007.md","hash":"fe14aeb7f23930eea41f59f163b44b5622330901","modified":1609848950573},{"_id":"source/_posts/PAT/2017-07-27-pat-advanced-1008.md","hash":"260d2d4ff2e05c454aaf2b4b4b475034d886e34b","modified":1609848949351},{"_id":"source/_posts/PAT/2017-07-31-pat-advanced-1006.md","hash":"d4a09dfe99c509206232e79565c9e63e58a08e8e","modified":1609848943823},{"_id":"source/_posts/PAT/2017-08-01-pat-advanced-1011.md","hash":"f4431c5a2276ac5ee1498a24ecaf3abfb009afa1","modified":1609848947718},{"_id":"source/_posts/PAT/2017-08-01-pat-advanced-1060.md","hash":"e695ff06dc1a4c07d4a809761c9b2f9f912c8b16","modified":1609848946701},{"_id":"source/img/20170726/Image1.png","hash":"a375dd730a00316fb9f483c48d01e75aded2c67e","modified":1588931083252},{"_id":"source/img/20170726/Image11.png","hash":"e0c11295b7c6577b35cd0823489efeb2e05c547c","modified":1588931083253},{"_id":"source/img/20170726/Image12.png","hash":"545907b9b1449448c3cadbfdd9da5aade1250ef4","modified":1588931083253},{"_id":"source/img/20170726/Image14.png","hash":"b24df030353b9fefae8015d044daf177fe05f5a1","modified":1588931083255},{"_id":"source/img/20170726/Image13.png","hash":"8d7cdf29bce3d2a83d6a14a688cc3c8f7cbed49d","modified":1588931083254},{"_id":"source/img/20170726/Image15.png","hash":"9fb214cc781a01dbb2dbe18fbc20fc800f6e8013","modified":1588931083255},{"_id":"source/img/20170726/Image16.png","hash":"90c9977aaafb00de1689593624021b02ad144a96","modified":1588931083256},{"_id":"source/img/20170726/Image17.png","hash":"8d41d9c4f3886a51d3f900edd6609fdd3d736890","modified":1588931083257},{"_id":"source/img/20170726/Image18.png","hash":"055331e05df5d64b605d2d58e5061672e108faaa","modified":1588931083258},{"_id":"source/img/20170726/Image2.png","hash":"43f9bfbfad80d540d57beda5480e67fc415f4b66","modified":1588931083258},{"_id":"source/img/20170726/Image3.png","hash":"127eccc0d73e654731ec779a7c28fb591b2ef28f","modified":1588931083259},{"_id":"source/img/20170726/Image4.png","hash":"e391f03b3787074d9f7be1ea7387848c350b0f35","modified":1588931083259},{"_id":"source/img/20170726/Image5.png","hash":"4eb6f78614962547a93913f98faf327203d1794f","modified":1588931083260},{"_id":"source/img/20170726/Image6.png","hash":"2b63aa98f0cedef44776a31e17fbc8cc0dbd84f3","modified":1588931083261},{"_id":"source/img/20170726/Image7.png","hash":"46ce3306766c3f5f19b4c97dea961e75b735ed9b","modified":1588931083262},{"_id":"source/img/20170726/Image8.png","hash":"fa5f08785a32a1982f4e1e8ce166ede400ad7958","modified":1588931083262},{"_id":"source/img/20170726/Image9.png","hash":"b9b8483009389028e67d0a5cd49731cf15f88e4b","modified":1588931083263},{"_id":"source/img/Android/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1588931083265},{"_id":"source/img/Android/AndroidJNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1588931083267},{"_id":"source/img/Android/AndroidJNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1588931083268},{"_id":"source/img/Android/AndroidJNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1588931083269},{"_id":"source/img/Android/Androidsafe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1588931083270},{"_id":"source/img/Android/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1588931083271},{"_id":"source/img/Android/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1588931083277},{"_id":"source/img/Android/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1588931083285},{"_id":"source/img/Android/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1588931083284},{"_id":"source/img/Android/service_lifecycle.png","hash":"5c1d2bf331a1475fccd7e91f29af4e5a7b26f9b4","modified":1588931083286},{"_id":"source/img/Android/view_model.png","hash":"ef194d46df905157b4c65466468fd4681f499270","modified":1588931083287},{"_id":"source/img/Android/view_model1.png","hash":"4ba78ac2452498f9e27df4bd91727f7eca4a7220","modified":1588931083287},{"_id":"source/img/Android/view_model2.png","hash":"3b13867ed6ef01bad9bd6d4d6678bb11d1be541c","modified":1588931083288},{"_id":"source/img/Java/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1588931083322},{"_id":"source/img/other/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1588931083322},{"_id":"source/img/other/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1588931083323},{"_id":"source/img/other/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1588931083324},{"_id":"source/img/other/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1588931083324},{"_id":"source/img/other/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1588931083325},{"_id":"source/img/other/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1588931083325},{"_id":"source/img/other/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1588931083326},{"_id":"source/img/other/GitImg8.png","hash":"3c96308898f43a0c93b4906ad425183fa9cf225c","modified":1588931083327},{"_id":"source/img/other/GitImg9.png","hash":"bc6458294e1966ff60f239bb2117bccb186a7784","modified":1588931083328},{"_id":"source/img/other/Image1.png","hash":"c1b937ef5f0ccffeb5f91696831af6d2deae2abf","modified":1588931083328},{"_id":"source/img/other/Image3.png","hash":"b6b42814093bbca53a964c22db752433097fed29","modified":1588931083329},{"_id":"source/img/other/Image4.png","hash":"36d2556b3af92a35ed0f937fd60c0fe5df28cdd3","modified":1588931083329},{"_id":"source/img/other/Image5.png","hash":"b327a63bb3e432fb28f3cd58950f172f3e9951d1","modified":1588931083330},{"_id":"source/img/other/Image6.png","hash":"b64ae70890b57d812838c5d8ee19583082087d6b","modified":1588931083331},{"_id":"source/img/other/blog1.png","hash":"bfee58d2d9caeed863f2dfd9a5de8020c80114f6","modified":1588931083331},{"_id":"source/img/other/blog2.png","hash":"1876a9b7917aef788aa438907cc1e4230fe54c93","modified":1588931083332},{"_id":"source/img/other/blog3.png","hash":"f79290efbb54eb504dfb898a222595a15ec2c7a6","modified":1588931083332},{"_id":"source/img/other/ubuntu_file_share1.png","hash":"098b17f62f1ffa4f79782f430e7b3d0420fb81af","modified":1588931083333},{"_id":"source/img/other/ubuntu_file_share2.png","hash":"1973c8b171c14677a5c37ef04c3fe34528ab88ab","modified":1588931083334},{"_id":"source/img/other/ubuntu_file_share3.png","hash":"7b33691e89204a933ac38791a584ce89e5b3fe75","modified":1588931083334},{"_id":"source/img/other/ubuntu_file_share4.png","hash":"c9661fa787d63184c745c757d6778518c5e0ddfd","modified":1588931083335},{"_id":"source/img/DataStructure/001.gif","hash":"e27cbb6e1860d72c6f980e717beaf1e51013b07e","modified":1588931083288},{"_id":"source/img/DataStructure/002.gif","hash":"ab765e2f86c6524c1c44597805966757e7628e6b","modified":1588931083290},{"_id":"source/img/DataStructure/004.jpg","hash":"011dc1b91ffc54c403dd3aa2eb00f6c405823fbb","modified":1588931083292},{"_id":"source/img/DataStructure/adjacency_list1.png","hash":"cb0b1017a9c47dc6cfae862436b34d7177e7aca3","modified":1588931083299},{"_id":"source/img/DataStructure/adjacency_matrix1.png","hash":"810a07fbc8e384a32fa69a556d22290b94343e14","modified":1588931083300},{"_id":"source/img/DataStructure/adjacency_matrix2.png","hash":"956ce82807f386760265152a560c21bb1a209e4c","modified":1588931083301},{"_id":"source/img/DataStructure/adjacency_matrix3.png","hash":"753eb3efbe2a104e3659a46f395e0e3e0c348ee9","modified":1588931083302},{"_id":"source/img/DataStructure/binary_tree_result.png","hash":"6e887cacde537b36a667ba915033e54138a1f396","modified":1588931083303},{"_id":"source/img/DataStructure/binary_tree.jpg","hash":"f124b7ead17dc866c7726d5c0095de35f0338231","modified":1588931083302},{"_id":"source/img/DataStructure/heap2.jpg","hash":"ff257b33be988c0f480fd2298d8b656b8e335198","modified":1588931083306},{"_id":"source/img/DataStructure/heap3.jpg","hash":"37a570aaa9ce98c1b619c55121297d9f689725b7","modified":1588931083306},{"_id":"source/img/DataStructure/heap7.jpg","hash":"1f62e84ec84a32f5cc47c21d6367a7bbc1f7940b","modified":1588931083312},{"_id":"source/img/DataStructure/heap_sort.jpg","hash":"eb5166b07005b4bbf2b5937b2e12eff1f5fdc396","modified":1588931083314},{"_id":"source/img/DataStructure/huffman_tree.png","hash":"8c4fa46aaf9c54f20a937ef0cac565e7c2422c61","modified":1588931083314},{"_id":"source/img/DataStructure/huffman_tree1.png","hash":"1bcf8ad33c94ff370c9e7a022c618bc108216d51","modified":1588931083315},{"_id":"source/img/DataStructure/huffman_tree3.png","hash":"0c3d5180fbfc7560effb45068ed45fd32993fe57","modified":1588931083316},{"_id":"source/img/DataStructure/quick_sort.jpg","hash":"a83f57425b47b1087d74a6c4ee22cc632a460eea","modified":1588931083319},{"_id":"source/img/DataStructure/thread_binary_tree.jpg","hash":"4eae3ccc3de99620b5c978925919e747efcff67c","modified":1588931083320},{"_id":"source/img/DataStructure/quick_sort_01.jpg","hash":"7bf4d9c95393f6f764a27c7b649ee0454859ee55","modified":1588931083319},{"_id":"source/img/DataStructure/threaded_binary_tree.jpg","hash":"42c53b95e0112e8b0407178fb6b83b2fe5e49105","modified":1588931083321},{"_id":"source/_posts/Android/Android JNI/Android JNI敏感信息保护.md","hash":"3a7aa1c1ac6f29e50f78503bebbcff943e993224","modified":1609848823215},{"_id":"source/_posts/Android/Android JNI/Android Studio JNI引入.md","hash":"462d383d7d3115e254c4044afe616e4c5e51e333","modified":1609848824520},{"_id":"source/_posts/Android/Android反编译/Android应用防止二次打包.md","hash":"9c06d703ad45dfd534c1b743e60495082f97dbae","modified":1609848827709},{"_id":"source/_posts/Android/Other/Groovy介绍.md","hash":"062cc710b9909eb8cddc380ee0f47d4f94a42c71","modified":1609847831260},{"_id":"source/_posts/Android/Other/Module的.gradle配置.md","hash":"84781ec2c6415e21864767ceb8d8b415613dac4e","modified":1609848843966},{"_id":"source/_posts/Android/Other/常用操作.md","hash":"6e06c6a909ade4f75a333953235d0f4440e7a45b","modified":1609848846410},{"_id":"source/_posts/Android/Android基础/Android 6.0动态权限获取.md","hash":"e4bb5cf8df339888c7b7034fb8f99776502e7afc","modified":1609848828423},{"_id":"source/_posts/Android/Android基础/Android Binder机制.md","hash":"431631a4f4722e1ef5f73311b80778da4a07b4d6","modified":1609848829002},{"_id":"source/_posts/Android/Android基础/Android Handler机制.md","hash":"0b05c241959e9da2ca25593afab3f21592cf134d","modified":1609848829269},{"_id":"source/_posts/Android/Android基础/Android 常用网站.md","hash":"0dccde65b09cabc3565d601f0df02e5ddfd32f18","modified":1609848829484},{"_id":"source/_posts/Android/Android基础/Android-ViewModel介绍.md","hash":"e66a645f7f25b7696b98737395f56700db07cd13","modified":1609848830642},{"_id":"source/_posts/Android/Android基础/Android-broadcast介绍.md","hash":"86b5a2df77fd2c26dee7c2d58a281609533e2fde","modified":1609848829721},{"_id":"source/_posts/Android/Android基础/Android-service介绍.md","hash":"560c2fff9aa918052b67097ad0f1b2375c35caf4","modified":1609848830183},{"_id":"source/_posts/Android/Android基础/Android后台任务.md","hash":"fe3dd9ace9707ef11628aaf22b49a6b4e6c618b6","modified":1609848830856},{"_id":"source/_posts/Android/Android基础/Android常用的库.md","hash":"32b673314ab016a846b77d51c8311031710b3e66","modified":1609894605014},{"_id":"source/_posts/Android/Android基础/Android序列化.md","hash":"86c88716363f9459a5704566dc55287a94d9f1e5","modified":1609848831952},{"_id":"source/_posts/Android/Android基础/Android文件操作.md","hash":"fe42545c0265e9ec8321f0b34e8228586a2b1bea","modified":1609848834706},{"_id":"source/_posts/Android/Android基础/Android集合.md","hash":"592b95898463680efbb78741264f058d0df34846","modified":1609894632822},{"_id":"source/_posts/Android/Android基础/getSystemService的使用.md","hash":"d3b5e6cd76f4dea29e0d412af0a94f4e46477ca6","modified":1609848838053},{"_id":"source/_posts/Android/Android基础/定位.md","hash":"48bbe03ca27278ff0d2b57273df62b38297af615","modified":1609848838656},{"_id":"source/_posts/Android/Android基础/开发过程中注意问题.md","hash":"0e8b7fd345b2228ff546083de7a11c51315eae55","modified":1609894682557},{"_id":"source/_posts/Android/Android基础/异步操作Asynctask.md","hash":"fd169a30c262fa89a1f2ce45eb687d733bba7d32","modified":1609848839686},{"_id":"source/_posts/Android/Ble/Android ble 4.0.md","hash":"154b190e2848cf40aa9583ab5c5d58d0f616de4c","modified":1609848840044},{"_id":"source/_posts/Android/Rtmp/RTMP集成","hash":"66928e6cbb59c3a3bce606959ef4a865fe04e642","modified":1605084517574},{"_id":"source/_posts/Android/Structure/架构设计.md","hash":"7acee0a4822dacba6421fcc4188fbe4c4b964413","modified":1609894760686},{"_id":"source/_posts/Android/View/ActionBar和ToolBar的使用.md","hash":"7d8afeda5533e86bdc6449e29de67ca401c7cd4e","modified":1609848851364},{"_id":"source/_posts/Android/View/Android多语言设置.md","hash":"fb95bd5859f49df63f4482fd1ff4a395ca7e79b9","modified":1609848851518},{"_id":"source/_posts/Android/View/CountDownView.md","hash":"52f0c794cc3592e914e1ff254a331e27b341a631","modified":1609848852476},{"_id":"source/_posts/Android/View/LayoutInflater使用.md","hash":"229540b248df053af754833a23b30ad1561a7dea","modified":1609848852672},{"_id":"source/_posts/Android/View/Materials Design.md","hash":"1ca583bd0710f33a76b17a4821bec9f41f594f7b","modified":1609848853740},{"_id":"source/_posts/Android/View/UI绘制流程.md","hash":"ba014409fafc92821edb1ac06542e28fc796623d","modified":1609848855188},{"_id":"source/_posts/Android/View/事件分发机制.md","hash":"52750eda10b18f9e905217deb85c04363a001b2d","modified":1609848856856},{"_id":"source/_posts/Android/View/使用RecyclerView和SearchView实现查找删除.md","hash":"e07daf38f9a795b7938338254396995d647e66ee","modified":1609848858078},{"_id":"source/_posts/Java/Java基础/Java关键字.md","hash":"a9e257f1ccfea11bcd7e3a3c1b9d8b1bcd9476d4","modified":1609848912868},{"_id":"source/_posts/Java/Java基础/Java内部类.md","hash":"62b27b8ad8ff0390e374ec67c376d9bf3142eaa8","modified":1609848914767},{"_id":"source/_posts/Java/Java基础/Java引用.md","hash":"956ac223cbddd1af6a3ac6c2bdb2d732907e6293","modified":1609848916009},{"_id":"source/_posts/Java/Java基础/Java文件操作.md","hash":"83d29bba1bc2163c7a46b7196ad12b60ce818abe","modified":1609848917151},{"_id":"source/_posts/Java/Java基础/Java泛型.md","hash":"e3f42dcf3cf820f3fe0945144eccdc0c2a172e61","modified":1609848919084},{"_id":"source/_posts/Java/Java基础/Java集合.md","hash":"2014851efb9ff5410dd0059a8c925dfd1643d122","modified":1609848921335},{"_id":"source/_posts/Java/Java基础/Lambda表达式.md","hash":"0ca8e6137c90e73abed1727ab442f98b253fe208","modified":1609895846501},{"_id":"source/_posts/Java/Java基础/String、StringBuffer、StringBuilder区别.md","hash":"23d101e5fef746ee6f1b43f8e82a713f7588001d","modified":1609848930025},{"_id":"source/_posts/Java/Java基础/加密算法.md","hash":"299179d2e28ba0ba8451875b4f145399398bf8e5","modified":1609848930272},{"_id":"source/_posts/Android/框架/Dagger2.md","hash":"283cd896a0d1d1d9c36d623cbc32ccd506008f07","modified":1609848859254},{"_id":"source/_posts/Android/框架/fastjson的使用.md","hash":"5d23a830f6dcd60f7256783a216bda8a7a407c4b","modified":1609848860223},{"_id":"source/_posts/Java/Java多线程/Java Queue.md","hash":"f20a5742f9a0d3a4d0c78bd3f53173062616b466","modified":1609848930589},{"_id":"source/_posts/Java/Java多线程/Java多线程与单例模式.md","hash":"0bf1804bd9bc70fc8853b87a3a1abfcba75e8586","modified":1609848930883},{"_id":"source/_posts/Java/Java多线程/Java多线程之间的协作.md","hash":"ab12a63cbc0c34b68aca7b9e05e92166ac17d03c","modified":1609848931188},{"_id":"source/_posts/Java/Java多线程/Java多线程基础.md","hash":"15de23fa27accc9f7af1e6a56158a4466c0d381c","modified":1609848931401},{"_id":"source/_posts/Java/Java多线程/Java线程间通信.md","hash":"cf0798d7d2f3dca296a182780a2cfeabc2fb82c0","modified":1609848932601},{"_id":"source/_posts/Kotlin/Kotlin基础/Lambda表达式.md","hash":"36df91328b9e51576b74d5f3ad94ea01c70584c8","modified":1609848934075},{"_id":"source/_posts/Java/设计模式/代理模式.md","hash":"fb2cb0ec7b24d4dc7555629b26cdb000fd8ff2a5","modified":1609895116006},{"_id":"source/_posts/Java/设计模式/工厂模式.md","hash":"4ab65c397f34ed56434a22468b26d22211b9a927","modified":1609895119818},{"_id":"source/_posts/Java/设计模式/观察者模式.md","hash":"523d31510963f1ce866ef35edb7cde0f41e10c06","modified":1609848933856},{"_id":"source/_posts/Other/Blog/云服务器搭建Hexo.md","hash":"d45405dac15f79917d147adad693ecc4bea7c126","modified":1609848934343},{"_id":"source/_posts/Other/Computer/函数式编程.md","hash":"bd3ebddd14b357aba702a556975902046704106b","modified":1609895195009},{"_id":"source/_posts/Other/Computer/操作符.md","hash":"865e1dae088017972e4a8351bb92c82e33a9b869","modified":1609848934649},{"_id":"source/_posts/Other/Git/Git.md","hash":"19f97c28fbfa1db801cc96e7ad5267be1d6c07af","modified":1609848934900},{"_id":"source/_posts/Other/Git/Git出现问题解决.md","hash":"98a0413b2badbebe7895be3b11b0d2bc952a2dfe","modified":1609848935089},{"_id":"source/_posts/Other/Tools/MarkDown使用.md","hash":"64648c5bf0fb0cebcd8a82a256d799152bab53db","modified":1609848935351},{"_id":"source/_posts/Other/Tools/常用工具软件.md","hash":"b1e801eeb0717520e4d80b4a7138fa56c02b66bd","modified":1609848938732},{"_id":"source/_posts/Other/Ubuntu 使用/Ubuntu 使用.md","hash":"e97452e4b991ce8b6f3a152ffd4d406b6d52654b","modified":1609848940684},{"_id":"source/_posts/.history/Android/Android基础/Android-service介绍_20200508174442.md","hash":"9a04def8878896b207de8eaa2c1dd8078803a020","modified":1609848799169},{"_id":"source/_posts/.history/Android/Android基础/Android-service介绍_20201010082833.md","hash":"560c2fff9aa918052b67097ad0f1b2375c35caf4","modified":1609848799767},{"_id":"source/_posts/.history/Android/Android基础/Android常用的库_20201127171837.md","hash":"064f7005438a2024ab4ebe33b5147ef6e4891a07","modified":1606468717933},{"_id":"source/_posts/.history/Android/Android基础/Android集合_20200509141323.md","hash":"ecb51cc59c2406af1e035c92e4d0f422471eebe2","modified":1589004803204},{"_id":"source/_posts/.history/Android/Android基础/定位_20200508174442.md","hash":"f050bb03b6b7c94869550807913ecdcc989a5a87","modified":1609848800215},{"_id":"source/_posts/.history/Android/Android基础/定位_20201010082836.md","hash":"48bbe03ca27278ff0d2b57273df62b38297af615","modified":1609848801504},{"_id":"source/_posts/.history/Android/Rtmp/RTMP集成_20201111164837","hash":"66928e6cbb59c3a3bce606959ef4a865fe04e642","modified":1605084517592},{"_id":"source/_posts/.history/Java/Java基础/加密算法_20200508174442.md","hash":"e21fcdaf28b8532990e3a8b66190858ff57e00e4","modified":1609848805719},{"_id":"source/_posts/.history/Java/Java基础/加密算法_20200513155032.md","hash":"58ce678c7eb1a7e8bb1749ac0dee2f187700b6e5","modified":1609848806334},{"_id":"source/_posts/.history/Java/Java基础/加密算法_20200513155047.md","hash":"941bee8939fd48ec1fec1a2e0cd531424bf1938a","modified":1609848806851},{"_id":"source/_posts/Android/Advanced/Android保活/Android 悦跑圈模式保活.md","hash":"fd828820a74b34263e596773bb79ed5385e48a84","modified":1609849063872},{"_id":"source/_posts/Android/Advanced/Android性能优化/Andorid内存优化.md","hash":"e7bcb253c7884f8e702a7a69acb3a08a75a6498c","modified":1609848807633},{"_id":"source/_posts/Android/Advanced/Android性能优化/Android视图优化.md","hash":"aea9bbfd440ead1094833d5b416a1ad382e87a07","modified":1609848807939},{"_id":"source/_posts/Android/Advanced/基础/AIDL介绍.md","hash":"3114b2fa67257ae344a287c83eb26b520a96c535","modified":1609848808300},{"_id":"source/_posts/Android/Advanced/基础/Android打包流程.md","hash":"d11e6eac029d6799429440ca2d21cbaa671d2afc","modified":1609894472172},{"_id":"source/_posts/Android/Advanced/基础/应用启动流程.md","hash":"c06e48e858eb6e9b11348ed3d2c5a0946f0b8c3a","modified":1609848808602},{"_id":"source/_posts/Android/Advanced/基础/编译时注解处理与使用.md","hash":"37f1fb968b9af1e17b4e772aaefe6552cf6f1771","modified":1609848814375},{"_id":"source/_posts/Android/Advanced/插件化/ActivityThread源码分析.md","hash":"301afa168dd92d8cd96af6a2f21d6c184542d109","modified":1609848820506},{"_id":"source/_posts/Android/Advanced/插件化/Android 9.0 Hook插件化.md","hash":"a3abde3af18d154455e6e594db8fd3bd99f504d0","modified":1609848821004},{"_id":"source/_posts/Android/Advanced/插件化/Android LoadAPK插件化.md","hash":"3aa06bd74667c1a7d4b472e8f5e9be3364a35381","modified":1609894487246},{"_id":"source/_posts/Android/Advanced/插件化/Android插件化介绍.md","hash":"bcdefdb5e68ade9403590e1ac8c1dd68c88c0eca","modified":1609848821855},{"_id":"source/_posts/Android/Advanced/插件化/Android插桩.md","hash":"4539f707fdd2ec857f1a9291203a091aa2bab3e5","modified":1609894532101},{"_id":"source/_posts/Android/Advanced/版本区别/不同版本区别.md","hash":"83a150c6753b36a9ab142d3ad0ea2a296abe405a","modified":1609848822150},{"_id":"source/_posts/Android/Advanced/组件化/Android组件化注意问题.md","hash":"c70d0c312c2401c15354b0fef038cc47e23d12a1","modified":1609848822963},{"_id":"source/_posts/Android/框架/AAC/Android Architecture Components.md","hash":"ed0fc00647e736a22548d73869caa33d600c552a","modified":1609848863170},{"_id":"source/_posts/Android/框架/AAC/Android Lifecycle-Aware组件详解.md","hash":"3571f5ed87122157fd78ea85671999d92e3268f4","modified":1609848863628},{"_id":"source/_posts/Android/框架/AAC/Android Livedata详解.md","hash":"ba048303f737f881a0379d81f8eb04bda9bba12a","modified":1609848864370},{"_id":"source/_posts/Android/框架/AAC/DataBinding的使用.md","hash":"93fcc5aad9f5ff771c0d903038951b9d049062e7","modified":1609848866202},{"_id":"source/_posts/Android/框架/AAC/Lifecycle和Room的使用.md","hash":"32054899f7ddf272bd3d9270a240be09cc17b5cc","modified":1609848868069},{"_id":"source/_posts/Android/框架/AAC/Paging和Room使用.md","hash":"1e9bc97e44edff6dc020f7bfc78c2e7b3de1a5e9","modified":1609848868976},{"_id":"source/_posts/Android/框架/AAC/Room和Lifecycle构建程序.md","hash":"5ece32cbae4957f6b2efb7a8195cc9ef4f18e536","modified":1609848869526},{"_id":"source/_posts/Android/框架/AAC/Room数据库.md","hash":"703f5b4dfc52499a2cc9b13754997e8fa5365eb3","modified":1609848870058},{"_id":"source/_posts/Android/框架/AAC/WorkManager介绍.md","hash":"f7153c40a2de9cdb55b77b3a497b937405228880","modified":1609848870488},{"_id":"source/_posts/Android/框架/Glide/Glide框架手写实现.md","hash":"0ece8e2abad66f6f2028218c088563bf48e1fdd9","modified":1609848871488},{"_id":"source/_posts/Android/框架/Retrofit/Retrofit 2.5 框架使用与源码分析.md","hash":"a7977438b4baf7f8135297e890d89214b6c995ef","modified":1609848872958},{"_id":"source/_posts/Android/框架/Retrofit/Retrofit 使用HTTPS请求.md","hash":"db69e2fc9454ef809e42cdfe4b270a0329e0d366","modified":1609894803279},{"_id":"source/_posts/Android/框架/Retrofit/Retrofit 基础.md","hash":"143138a02a1de622f389c5e74ec6ef7a5b9944a1","modified":1609894866518},{"_id":"source/_posts/.history/Android/Advanced/版本区别/不同版本区别_20201127170404.md","hash":"cadeea517d7b6c1642e4d1282cb1de7644b7529b","modified":1609848796609},{"_id":"source/_posts/.history/Android/Advanced/版本区别/不同版本区别_20201127170627.md","hash":"48b1b95e3a9d58587c342b646f4a3d02f00952c9","modified":1609848796836},{"_id":"source/_posts/.history/Android/框架/Retrofit/Retrofit 使用HTTPS请求_20200525182941.md","hash":"236d8dfc12587fc4e71546cebe6f02b976171803","modified":1590402595682},{"_id":"source/_posts/.history/Android/框架/Retrofit/Retrofit 使用HTTPS请求_20200525182955.md","hash":"236d8dfc12587fc4e71546cebe6f02b976171803","modified":1590402595687},{"_id":"source/_posts/.history/Android/框架/Retrofit/Retrofit 基础_20200509111552.md","hash":"7559d4727f2d420f558e669b98d0d221f460b151","modified":1588994152173},{"_id":"source/_posts/.history/Android/框架/Retrofit/Retrofit 基础_20200509111653.md","hash":"276263474645b70335a57a00472bc4f08360d1e2","modified":1588994213058},{"_id":"source/_posts/.history/Android/框架/Retrofit/Retrofit 基础_20200509141326.md","hash":"d02a850cb2a4bdcab7477ddf7d65e966f58e1719","modified":1589004806639},{"_id":"source/assets/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1588931083246},{"_id":"source/thumbnail/img102.jpg","hash":"2869ee2611f99d02019802cee8db70162ac19391","modified":1588931083342},{"_id":"source/thumbnail/img103.jpg","hash":"ff418bfdf3da9ee70bab1aa26306c8acbb62b582","modified":1588931083343},{"_id":"source/thumbnail/img42.jpg","hash":"aea9453168d0e085975de9c1b8f390ded5fe4652","modified":1588931083416},{"_id":"source/thumbnail/img49.jpg","hash":"92ae45a33edfc6158d25c602b684117ad5ec17af","modified":1588931083428},{"_id":"source/thumbnail/img59.jpg","hash":"3fbaa6878c25498d37e469edb2eeab806364ce42","modified":1588931083450},{"_id":"source/thumbnail/img60.jpg","hash":"7efd9ff40d9578251e3c7d740762f102bd846f82","modified":1588931083453},{"_id":"source/thumbnail/img72.jpg","hash":"105fc2a3d1127f8705bea82efb6c59402d23aed5","modified":1588931083481},{"_id":"source/thumbnail/img77.jpg","hash":"f891cdf167d4abc6b7cea6eb6d434ba4d46f5f98","modified":1588931083491},{"_id":"source/thumbnail/img85.jpg","hash":"f023eb09a94e10f006ac98f0aa94d960ed814f8f","modified":1588931083507},{"_id":"source/thumbnail/img87.jpg","hash":"45a156fb0c141d2c1b6ef4099dfd5bec93f12759","modified":1588931083509},{"_id":"source/thumbnail/img88.jpg","hash":"01de4f788f32df6f758a68394e80d72909cddda8","modified":1588931083510},{"_id":"source/thumbnail/img89.jpg","hash":"1cf54256ad251f96b6d2ca00d56b4b46107007c0","modified":1588931083510},{"_id":"source/thumbnail/img90.jpg","hash":"db53e6201cf2ff4e7c27e9e0ae27c788d634c6e5","modified":1588931083513},{"_id":"source/thumbnail/img94.jpg","hash":"e118fcfeb53c40ebbfc86654f8f6360bb70687c7","modified":1588931083517},{"_id":"source/thumbnail/img96.jpg","hash":"107c3f313b6e0c8ae3687eeaf2d981c53c07b52f","modified":1588931083519},{"_id":"source/thumbnail/img97.jpg","hash":"fa7ee526dd2bfb57718827aaaea1616522b4cf0b","modified":1588931083519},{"_id":"source/thumbnail/img98.jpg","hash":"8499e0602671c001678c5909dd0b5c519ae368b4","modified":1588931083520},{"_id":"source/_posts/Data_Structure/2017-07-27-data-structure-binary-tree-visit.md","hash":"1344b7a23771ed64a65b98d980b6e5493213e1a0","modified":1609848883840},{"_id":"source/img/Android/AndroidJNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1588931083267},{"_id":"source/img/Android/Android_performance.png","hash":"d3a30f425136bcc2581174f069d1138adfef24a7","modified":1588931083269},{"_id":"source/img/Android/collection.png","hash":"38dfaafd4896d4e584b8508aa9a1a86942170104","modified":1588931083282},{"_id":"source/img/DataStructure/001.png","hash":"a5205f3db29fe11646ad8c0c580daef28b2473c4","modified":1588931083290},{"_id":"source/img/DataStructure/Merge_sort.gif","hash":"8c074d46d4c96077d11f9e8cab9ff5d95bdc3da0","modified":1588931083294},{"_id":"source/img/DataStructure/adjacency_list.jpg","hash":"44905436617f72027e8001cc11f74694508e78a6","modified":1588931083298},{"_id":"source/img/DataStructure/adjacency_matrix.jpg","hash":"b9a9e2e34290fa182102bec682ae532be806025d","modified":1588931083299},{"_id":"source/img/DataStructure/heap.jpg","hash":"f2f37a05d4bda669871ad1efc123a69621657406","modified":1588931083304},{"_id":"source/img/DataStructure/heap1.jpg","hash":"96a7319b82d0dc5e949799cc57a1a272672f85b9","modified":1588931083305},{"_id":"source/img/DataStructure/heap5.jpg","hash":"74d134ee991b8afec74f5a9f9b18df3c28122bb4","modified":1588931083308},{"_id":"source/img/DataStructure/heap8.jpg","hash":"109e6c65abd6a6d02d127dd4c95bc0bd0972d3fd","modified":1588931083313},{"_id":"source/img/DataStructure/huffman_tree2.jpg","hash":"d6a9e2244379a111969c694004d7efb42a8a901b","modified":1588931083316},{"_id":"source/img/DataStructure/insertsort.gif","hash":"5fc8daa9296837453ccbc8c7f9c2494bbd1fcdda","modified":1588931083318},{"_id":"source/thumbnail/img16.jpg","hash":"acf5a7ed28f36c0a36f6d215bf9bf81419553458","modified":1588931083360},{"_id":"source/thumbnail/img19.jpg","hash":"256f0ff9b673f78b2ebba52673400a75475f6cbe","modified":1588931083366},{"_id":"source/thumbnail/img2.png","hash":"4b6bf0531edfef1c6f86f587474f96134ad16644","modified":1588931083369},{"_id":"source/thumbnail/img3.jpg","hash":"d2084ff7b1443dffc8dc015bf525a47f3c138a03","modified":1588931083392},{"_id":"source/thumbnail/img32.jpg","hash":"87745dbc48d71f90c6cb2c12faa7a51e133b880a","modified":1588931083396},{"_id":"source/thumbnail/img39.jpg","hash":"abcf23665b924cd7766a732586813ac8ecafae24","modified":1588931083410},{"_id":"source/thumbnail/img41.jpg","hash":"019e6a1a12affbb94014bf3288ee04d6dad175bd","modified":1588931083415},{"_id":"source/thumbnail/img43.jpg","hash":"454eb775ff0cbbec74688c9d8ce310938c01bef8","modified":1588931083418},{"_id":"source/thumbnail/img46.jpg","hash":"02a33f09beb81d8f9e8c68708d5c214244e8e886","modified":1588931083424},{"_id":"source/thumbnail/img51.jpg","hash":"4e28760a82af5ec8b55b4d6d0a9e082f8ec3eaa1","modified":1588931083435},{"_id":"source/thumbnail/img53.jpg","hash":"b2e82a4d062da593eed265abdc42a5cb1b6f01cc","modified":1588931083438},{"_id":"source/thumbnail/img54.jpg","hash":"4223492bd8e67c9d0c02a4834fe72f86391c75bd","modified":1588931083440},{"_id":"source/thumbnail/img58.jpg","hash":"f3d164c98aef2f2d0614a51fafb949242cdf7861","modified":1588931083448},{"_id":"source/thumbnail/img6.jpg","hash":"a4de0f5470b6591a5f157de6142408bb29abad15","modified":1588931083452},{"_id":"source/thumbnail/img63.jpg","hash":"65388a316a804f609ba8baf701d9d31d99714d7f","modified":1588931083458},{"_id":"source/thumbnail/img61.jpg","hash":"66caeb1741ff3dfb16e08b48ff094f69e1137be4","modified":1588931083454},{"_id":"source/thumbnail/img70.jpg","hash":"7f10838eb2237314a91b0e490ddc72c218c5d320","modified":1588931083478},{"_id":"source/thumbnail/img82.jpg","hash":"0998b64c59e30520179bff33b8689b90044cceef","modified":1588931083504},{"_id":"source/img/20170726/Thumbs.db","hash":"ee48e951388f6679a722e9f2ce67266926a35b05","modified":1588931083264},{"_id":"source/img/DataStructure/003.jpg","hash":"6f6cc25f13e0cdf862cd134b92e6feba89d86ea4","modified":1588931083292},{"_id":"source/thumbnail/img10.jpg","hash":"f6fe547ddcf9f4522e0cd53caf68dccfe4eecf7c","modified":1588931083340},{"_id":"source/thumbnail/img11.jpg","hash":"8f9f3b9c14bb54b280e14ae29d792c33076fda84","modified":1588931083344},{"_id":"source/thumbnail/img15.jpg","hash":"3013d423517be3d6c4d0c60d079af27547080175","modified":1588931083358},{"_id":"source/thumbnail/img17.jpg","hash":"ee18ec6c5fa554ce3ffc2a29c9266304b0a6c486","modified":1588931083362},{"_id":"source/thumbnail/img2.jpg","hash":"524c57c6096ff43f8d61f3b070165cf2a0876094","modified":1588931083368},{"_id":"source/thumbnail/img29.jpg","hash":"32d681874233f5bc0ceb8ccf6a47e85de562a5f4","modified":1588931083391},{"_id":"source/thumbnail/img30.jpg","hash":"f2b449b4e9b5ccc54ec1b03239ee484aecf61257","modified":1588931083394},{"_id":"source/thumbnail/img31.jpg","hash":"0d0b03e70781af33752cada32b6d7ebad6bed593","modified":1588931083395},{"_id":"source/thumbnail/img34.jpg","hash":"9fe5e99a9cac8e208a4676f4012934f9adc8eb4f","modified":1588931083401},{"_id":"source/thumbnail/img35.jpg","hash":"aebdf2870305c60899d70ab528e2a9ff269f1d4e","modified":1588931083402},{"_id":"source/thumbnail/img38.jpg","hash":"7ba9401279c0f7a4198bdba95b0e1132e9b8e5b5","modified":1588931083409},{"_id":"source/thumbnail/img4.jpg","hash":"814c8303e45ff71f27e8607d515bdaad3fc8460e","modified":1588931083412},{"_id":"source/thumbnail/img40.jpg","hash":"495071c77bf821edf27c71e37dac60c59f4cfe50","modified":1588931083413},{"_id":"source/thumbnail/img47.jpg","hash":"ab6b209923b0a12235766570d68c3b60e1d6759a","modified":1588931083426},{"_id":"source/thumbnail/img48.jpg","hash":"a1d037607fe8c55a18b0df004d82eae6427b183a","modified":1588931083427},{"_id":"source/thumbnail/img50.jpg","hash":"995cd5d2e5bb8e6469025e10e80ffbaa7a609e77","modified":1588931083433},{"_id":"source/thumbnail/img55.jpg","hash":"aad1976fdcde03395bdd91015572fcdcd958fdcb","modified":1588931083442},{"_id":"source/thumbnail/img64.jpg","hash":"b3471bed04e587574fcaa46932270d4f6d259d02","modified":1588931083460},{"_id":"source/thumbnail/img65.jpg","hash":"719d14d7fa450142f03c0b56e71f4c8c33a0ef96","modified":1588931083461},{"_id":"source/thumbnail/img68.jpg","hash":"691ca4cc80e6e581dfd547a333e2a685734ea048","modified":1588931083473},{"_id":"source/thumbnail/img7.jpg","hash":"e4bdad496612865336a49c3830daf7f63c3943de","modified":1588931083476},{"_id":"source/thumbnail/img71.jpg","hash":"152d1f6ce6415207a53e10e09d27d1e6d5fbb71c","modified":1588931083480},{"_id":"source/thumbnail/img79.jpg","hash":"3c599e665d669a36b9fedefc898b8ee3ea110d62","modified":1588931083495},{"_id":"source/thumbnail/img80.jpg","hash":"d72b97457e91a54f45df653d3dc83f6e6445c394","modified":1588931083500},{"_id":"source/thumbnail/img81.jpg","hash":"25262b33d00f581aa176099c2dcb0b4fff57537c","modified":1588931083502},{"_id":"source/thumbnail/img9.jpg","hash":"411c999655559df47ce7733b0a9489adb594d550","modified":1588931083512},{"_id":"source/img/Android/android_base_binder1.png","hash":"c33497757bf15a6f9fd484b49ad0ed4bbd3bf69c","modified":1588931083272},{"_id":"source/img/Android/android_base_binder2.png","hash":"f27bac80713ff06d2b8c5808792a8034c22070b3","modified":1588931083273},{"_id":"source/img/Android/android_base_binder4.png","hash":"293d0aa0830903a4d2596024bd0aece00015e64a","modified":1588931083276},{"_id":"source/thumbnail/img1.jpg","hash":"76977f264e6ffe588ee803fdeb5b46dc143de70c","modified":1588931083336},{"_id":"source/thumbnail/img12.jpg","hash":"e3bd470ec5051891864a882b3489626000d3b2e8","modified":1588931083346},{"_id":"source/thumbnail/img13.jpg","hash":"5feaf1a92a25db3d5914e559d9a9d5653895f96f","modified":1588931083349},{"_id":"source/thumbnail/img21.jpg","hash":"ae7be5ed01fdae812a8f861425c4f1602b49155e","modified":1588931083374},{"_id":"source/thumbnail/img22.jpg","hash":"a4678d65efec9e2d62c63d2492d9808e332ea96b","modified":1588931083377},{"_id":"source/thumbnail/img23.jpg","hash":"39670a257584e60cb661ff0a83f0550648e0bdf8","modified":1588931083378},{"_id":"source/thumbnail/img26.jpg","hash":"33371e319195f1daa4204e39bbfcb893606b2e1a","modified":1588931083384},{"_id":"source/thumbnail/img28.jpg","hash":"a131a70863b8b2b1d3da23c6309935fafe1b1c3d","modified":1588931083390},{"_id":"source/thumbnail/img37.jpg","hash":"efda0ac5c50f95d1bd43e6cc3818c68371de3af0","modified":1588931083407},{"_id":"source/thumbnail/img44.jpg","hash":"af282e240fad7c5610be1ea1ac83be46e8e260cf","modified":1588931083421},{"_id":"source/thumbnail/img75.jpg","hash":"9f4d31a453f84a3cb6f77653800197e3e8d8e3ae","modified":1588931083488},{"_id":"source/thumbnail/img76.jpg","hash":"b4749958cae12a01c2b8f7310bc2accf12c3d5f4","modified":1588931083489},{"_id":"source/thumbnail/img8.jpg","hash":"d8df1416b30e70da2d6a6ae16c08d969693787ad","modified":1588931083498},{"_id":"source/thumbnail/img1.png","hash":"8342602c9c639b562393b3b6c3d9406b682956f5","modified":1588931083338},{"_id":"source/thumbnail/img20.jpg","hash":"64222fbd6980078546dfb3d13ee7b6457b85a1aa","modified":1588931083372},{"_id":"source/thumbnail/img24.jpg","hash":"1c2e7305e718d07b6f9859794451154149575f46","modified":1588931083380},{"_id":"source/thumbnail/img25.jpg","hash":"f1d457db29eaed235e837f851b1c088cb3adc883","modified":1588931083382},{"_id":"source/thumbnail/img36.jpg","hash":"ddf85d6ebd01455c340bd5842f9cf962f19e6b1a","modified":1588931083405},{"_id":"source/thumbnail/img52.jpg","hash":"5eaa2893e04d23e544cc8645b1293b5e128d0fca","modified":1588931083436},{"_id":"source/thumbnail/img69.jpg","hash":"948cd729a613e9341af7c37bab585fb5ac19c85d","modified":1588931083475},{"_id":"source/thumbnail/img73.jpg","hash":"21f32c4e676260681ed24235deacd04d5486856f","modified":1588931083483},{"_id":"source/thumbnail/img74.jpg","hash":"87b1e6a1531b906c8b2f6607b33573a8cad86b03","modified":1588931083486},{"_id":"source/thumbnail/img78.jpg","hash":"43d5e4baa62349004fd70709d302bcf43bc6fe71","modified":1588931083492},{"_id":"source/img/Android/android_base_binder3.png","hash":"c6c80d3d29cb49c5ce3d8271b28e827bb77d9c16","modified":1588931083275},{"_id":"source/img/DataStructure/Merge_sort_01.gif","hash":"cd1e80c9283020a8c465236497cbcd06e2a27fcc","modified":1588931083297},{"_id":"source/thumbnail/img27.jpg","hash":"acfd44755ebf9e8098df99dd6d21714f2e0ef41c","modified":1588931083388},{"_id":"source/thumbnail/img33.jpg","hash":"287f25151a159fa157b6c74f8178d501538463d8","modified":1588931083399},{"_id":"source/thumbnail/img56.jpg","hash":"906df206b77d00c6815fada62236ff99ed7550f6","modified":1588931083445},{"_id":"source/thumbnail/img83.jpg","hash":"eee8e2cadc8ac2ee192b9b10ebd22172b0b4c294","modified":1588931083506},{"_id":"source/thumbnail/img45.jpg","hash":"2e542e1d2fed0bf4e2e57ba742b090c84321ce3f","modified":1588931083423},{"_id":"source/thumbnail/img57.jpg","hash":"23bd5c90ed4c759ade026809069b1e9519bda970","modified":1588931083446},{"_id":"source/thumbnail/img18.jpg","hash":"2b5270beab1df53147febbcbd1ae736271cf7ce2","modified":1588931083364},{"_id":"source/thumbnail/img67.jpg","hash":"a2c4fdd119d3bc0bf6dcd8f04bba67fc62e15b62","modified":1588931083472},{"_id":"source/thumbnail/img62.jpg","hash":"0fe6bd960118d0d3c2e1d52e9487127ed3302b7e","modified":1588931083457},{"_id":"source/img/DataStructure/heap6.jpg","hash":"0912d02ba1bab1c5dfada1787bc6a3a8f175b951","modified":1588931083311},{"_id":"source/thumbnail/img5.jpg","hash":"b21012fab284b4893c1f74b1db439d11f640ac5c","modified":1588931083431},{"_id":"source/img/Android/application_start.png","hash":"6395d26d20169517eabbbb36f2a4c010a7be6b7f","modified":1588931083281},{"_id":"source/thumbnail/img14.jpg","hash":"4737d1db939cff23e1a94aa8bf469d4bc5461041","modified":1588931083356},{"_id":"source/thumbnail/img66.jpg","hash":"e3fdb5d66c203030720dc9c64ed1b10002a018b6","modified":1588931083469},{"_id":"public/2020/12/25/Flutter/Flutter问题解决/index.html","hash":"4f7037fe86008b830bcc28ca3cbefa7cec2ea3ac","modified":1609848990688},{"_id":"public/2020/12/24/Android/Advanced/插件化/Android插桩/index.html","hash":"bb5199c13197dc82789a9efbee5517091e9bee58","modified":1609848990688},{"_id":"public/2020/12/24/Android/Advanced/基础/Android打包流程/index.html","hash":"4df036213b02397ecb5ffd74e8e4d4acfe396806","modified":1609848990688},{"_id":"public/2020/12/23/Flutter/Flutter基础/index.html","hash":"0e6820fcbdd2edb68e2a573409a4c1f40c8aa2ca","modified":1609848990688},{"_id":"public/2020/11/27/Android/Android基础/Android常用的库/index.html","hash":"9cbac10693b066f449eb6f452a0e31b441eb81a1","modified":1609848990688},{"_id":"public/2020/05/21/Android/框架/Retrofit/Retrofit 使用HTTPS请求/index.html","hash":"54dac29adaf84bff9d0572f79a9f227c80ad5bfa","modified":1609848990688},{"_id":"public/2020/05/09/Android/Android基础/Android集合/index.html","hash":"30faf5db3b4f27162268e97f02195b279e9f22e0","modified":1609848990688},{"_id":"public/2020/05/09/Android/框架/Retrofit/Retrofit 基础/index.html","hash":"90346812d264ec6137eac064aedc87d3a77bfc56","modified":1609848990688},{"_id":"public/2020/05/08/Other/Project/Project/index.html","hash":"b02c2cc79841dea91615d8920722073f52646f6a","modified":1609895265890},{"_id":"public/2020/05/08/Other/Git/Git仓库服务器配置/index.html","hash":"d598beb8cfbaff982ec9030623dfc734d79f9d13","modified":1609895265890},{"_id":"public/2020/05/08/Other/Computer/函数式编程/index.html","hash":"11952f049a35cfefb454a8d0b4600613341bc7da","modified":1609848990688},{"_id":"public/2020/05/08/Java/设计模式/工厂模式/index.html","hash":"63b0adbab3dc489e616da5df92e68a57d19b71fa","modified":1609848990688},{"_id":"public/2020/05/08/Java/设计模式/代理模式/index.html","hash":"d65f333d60b504717c38cfc8823b7841dd25b841","modified":1609848990688},{"_id":"public/2020/05/08/Java/Java多线程/Java锁机制/index.html","hash":"b611ecd0a307cdb41c0404d43e9e31ac176fe07e","modified":1609895265890},{"_id":"public/2020/05/08/Java/Java基础/加密算法/index.html","hash":"9023fe4d818ba577551d30e38eb92fbdc7ff0794","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/Lambda表达式/index.html","hash":"497ea659218ce67b4749d7b36d9b14dbae2e3450","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/String、StringBuffer、StringBuilder区别/index.html","hash":"110a9e1fa2e05a8d5141fc8b9f7c367bf1605a4a","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/Java集合/index.html","hash":"28a674ff654c54b52d07b90060d0670c748d4879","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/Java泛型/index.html","hash":"62a2660df4bec1c50ee09c8ce72e8ff980b2ca99","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/Java引用/index.html","hash":"4d8a99a2a9a04e2805b068108d39eabc4f1448a4","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/Java内部类/index.html","hash":"b955f2dbcf31d5695f72692697a6d34a370a714b","modified":1609910322067},{"_id":"public/2020/05/08/Java/Java基础/Java 输入输出操作/index.html","hash":"ccd109244995504e44cf1fcaac1eb572bdc919d3","modified":1609895265890},{"_id":"public/2020/05/08/Java/Java基础/Java关键字/index.html","hash":"febdb34477f9980063dc4a8f3f224d6e6fd5091b","modified":1609910322067},{"_id":"public/2020/05/08/C++/C++基础/index.html","hash":"9349e60b7c18ab7d3278720ee54ca93b7fe382e9","modified":1609848990688},{"_id":"public/2020/05/08/C++/C++ 问题总结/index.html","hash":"3d9fe20e8832c2b73963615b97ba0cdfb9dc4b2b","modified":1609848990688},{"_id":"public/2020/05/08/Android/框架/RxJava2.0/index.html","hash":"7e40e7dae8bcc53c128437556a415c565cd75a8a","modified":1609848990688},{"_id":"public/2020/05/08/Android/Android基础/开发过程中注意问题/index.html","hash":"ceca0d1d1e43e37c242227968a5388858485cc17","modified":1609848990688},{"_id":"public/2020/03/25/Other/Blog/云服务器搭建Hexo/index.html","hash":"f8d3407310d395e0f7f8c615c0e7339a50225d77","modified":1609910322067},{"_id":"public/2020/03/20/Android/Advanced/Android保活/Android 悦跑圈模式保活/index.html","hash":"60d45a7d8faf822083d61e20d5d5743ec76d7604","modified":1609910322067},{"_id":"public/2020/03/05/Android/Advanced/插件化/Android插件化介绍/index.html","hash":"ae696dee457851227ef81a88d5f0371a869c9e16","modified":1609910322067},{"_id":"public/2020/03/02/Android/Advanced/插件化/Android 9.0 Hook插件化/index.html","hash":"d6d6d8207796c9ed8a52464546ba8e7457d7aebc","modified":1609910322067},{"_id":"public/2020/02/28/Android/Advanced/插件化/Android LoadAPK插件化/index.html","hash":"2229d3cfdbfa34558e09819ba03f002de12832e0","modified":1609910322067},{"_id":"public/2020/01/09/Android/Advanced/基础/编译时注解处理与使用/index.html","hash":"973a2253468b7ac25ffb27ab6dec1991a888dbb2","modified":1609910322067},{"_id":"public/2020/01/08/Android/Advanced/组件化/Android组件化注意问题/index.html","hash":"45bf10e3715b4acd0cb5514e28be1ea5da75dccb","modified":1609910322067},{"_id":"public/2020/01/06/Android/View/Android多语言设置/index.html","hash":"6dc7cbbae5d74ddccf910a809caa64fb3a78885b","modified":1609910322067},{"_id":"public/2019/12/20/Android/框架/Retrofit/Retrofit 2.5 框架使用与源码分析/index.html","hash":"4c86949e44724e226f539172b884b3bc329c79f0","modified":1609910322067},{"_id":"public/2019/10/30/Android/Advanced/基础/AIDL介绍/index.html","hash":"42065fa893df1515fbaef0df27195760248c6643","modified":1609910322067},{"_id":"public/2019/10/10/Android/框架/Dagger2/index.html","hash":"738aa50f52f00d7d59c863585345327093dedb13","modified":1609910322067},{"_id":"public/2019/09/30/Android/Android反编译/Android应用防止二次打包/index.html","hash":"7a7af718bad8ab1e782e6db3ca0d858c3d25bd60","modified":1609910322067},{"_id":"public/2019/09/30/Android/Android基础/Android Handler机制/index.html","hash":"91f6204cea325d7514b9dceff5c862807b4cad05","modified":1609910322067},{"_id":"public/2019/09/30/Android/Android基础/Android后台任务/index.html","hash":"ab90392696b770597b06915955f4c6abb101334c","modified":1609910322067},{"_id":"public/2019/09/30/Android/Android基础/getSystemService的使用/index.html","hash":"61e03d56ca239950f851ba9645bbebfb0ca59f28","modified":1609910322067},{"_id":"public/2019/09/30/Android/View/ActionBar和ToolBar的使用/index.html","hash":"6c59f0be1f806dec06b6ff55b2acd6cd0947ad6d","modified":1609910322067},{"_id":"public/2019/09/30/Android/Advanced/基础/应用启动流程/index.html","hash":"4a8c14d371ff43308f9087afd2d897610bc1addd","modified":1609910322067},{"_id":"public/2019/09/21/Android/Android JNI/Android JNI敏感信息保护/index.html","hash":"7a44bb988b8c56360a19fd3cb5aef62828e00a8f","modified":1609910322067},{"_id":"public/2019/09/21/Android/Android JNI/Android Studio JNI引入/index.html","hash":"6aec3dea0a6283c90d5a64288e43964eb87644df","modified":1609910322067},{"_id":"public/2019/09/19/Android/Android基础/Android 6.0动态权限获取/index.html","hash":"3060d77b6366e05ea129198650315e7d29855e89","modified":1609910322067},{"_id":"public/2019/09/19/Android/Android基础/Android文件操作/index.html","hash":"8dae36ee06f544109dd859fd01dd64827f9554a7","modified":1609910322067},{"_id":"public/2019/09/19/Android/Ble/Android ble 4.0/index.html","hash":"0d137b9ad011823c264d389b745dff6ae09c2df0","modified":1609910322067},{"_id":"public/2019/09/01/Android/Advanced/Android性能优化/Andorid内存优化/index.html","hash":"64a4c7891b8c60dca1cba4756ac1f959298d4eb2","modified":1609910322067},{"_id":"public/2019/08/25/Java/设计模式/观察者模式/index.html","hash":"f14488b00c410d30102b1a0815714cc2498128db","modified":1609910322067},{"_id":"public/2019/08/20/Android/Android基础/异步操作Asynctask/index.html","hash":"fa19233e877ad85573f0477813312ad6f6dbe49d","modified":1609910322067},{"_id":"public/2019/08/19/Android/框架/AAC/Android Architecture Components/index.html","hash":"c0efec86083a5828417e64e5b58e824c20b40edb","modified":1609910322067},{"_id":"public/2019/08/16/Android/Advanced/Android性能优化/Android视图优化/index.html","hash":"821c04a825be3cbc6d62d6924944258599d13403","modified":1609910322067},{"_id":"public/2019/08/15/Android/Other/常用操作/index.html","hash":"917d3c0633542900f457207e40df42b70b0fc438","modified":1609910322067},{"_id":"public/2019/08/10/Android/Other/Module的.gradle配置/index.html","hash":"f32ffcc689a9f47bc16a5c6cf51796391494be13","modified":1609910322067},{"_id":"public/2019/08/10/Android/Advanced/插件化/ActivityThread源码分析/index.html","hash":"8b6c1a31cbc8560c34ec2c9f9a3022f358864c8f","modified":1609910322067},{"_id":"public/2019/08/09/Android/Android基础/Android 常用网站/index.html","hash":"39b808260e1628a85202db650899e45e76c29466","modified":1609910322067},{"_id":"public/2019/08/05/Android/Other/Groovy介绍/index.html","hash":"8efd4b33b9a0d8a99a03472ce7e49cbc29f37ebc","modified":1609910322067},{"_id":"public/2019/07/30/Kotlin/Kotlin基础/Lambda表达式/index.html","hash":"270ce0d0d0a61233b9cb3b446d9d3c20dbadc482","modified":1609910322067},{"_id":"public/2019/06/05/Android/Advanced/版本区别/不同版本区别/index.html","hash":"a41fb977c1f8660cdea99c7f144932bd9d326ad2","modified":1609910322067},{"_id":"public/2019/05/08/Android/框架/Glide/Glide框架手写实现/index.html","hash":"93803e9beb9b28f5407fa5faa19b2de695603021","modified":1609910322067},{"_id":"public/2019/04/23/Android/框架/AAC/Android Livedata详解/index.html","hash":"5e9a1e7a67b68322e31e102830efb4e44719fdc2","modified":1609910322067},{"_id":"public/2019/04/05/Android/Android基础/定位/index.html","hash":"6177441656d762739d795aeb16466ea6b0890c18","modified":1609910322067},{"_id":"public/2019/04/03/Java/Java多线程/Java Queue/index.html","hash":"b1f545912288eb31e1f8294be222092542feb74c","modified":1609910322067},{"_id":"public/2019/03/25/Java/Java多线程/Java多线程与单例模式/index.html","hash":"115eed4c319bf6b3309dfb0ea2a18114ca883e86","modified":1609910322067},{"_id":"public/2019/02/15/Java/Java多线程/Java多线程之间的协作/index.html","hash":"51e6583438a08ff097f4f10b6c18cb1db62ce542","modified":1609910322067},{"_id":"public/2018/12/20/Android/框架/AAC/Lifecycle和Room的使用/index.html","hash":"6702f3f191f037006c1a13e31e354941ac141348","modified":1609910322067},{"_id":"public/2018/12/20/Android/框架/AAC/WorkManager介绍/index.html","hash":"566682a2680b2dfa694fa20b65c24eb8575e9918","modified":1609910322067},{"_id":"public/2018/12/10/Java/Java基础/Java文件操作/index.html","hash":"f57a6b73fd4c5b3fca740c364832b4ab87d040d9","modified":1609910322067},{"_id":"public/2018/12/05/Android/框架/AAC/Paging和Room使用/index.html","hash":"52e34a22def251d3ebda175ff394b6d790d65c2b","modified":1609910322067},{"_id":"public/2018/11/25/Java/Java多线程/Java多线程基础/index.html","hash":"88572e40e5909dae8a2afc48a5c00565da06537c","modified":1609910322067},{"_id":"public/2018/11/19/Android/框架/AAC/Room和Lifecycle构建程序/index.html","hash":"19fced8eda780463877af8cd2cdcdc2b8910eee1","modified":1609910322067},{"_id":"public/2018/11/05/Android/框架/AAC/Room数据库/index.html","hash":"cbb957d5a12987e42ad7e77baab72e6ad35c5f73","modified":1609910322067},{"_id":"public/2018/10/22/Android/View/LayoutInflater使用/index.html","hash":"71b3706e60c9df3ce65c18faa219b2121798f030","modified":1609910322067},{"_id":"public/2018/10/05/Java/Java多线程/Java线程间通信/index.html","hash":"e9f1ca01a91e59fafcf96c27a776b4d8108e1fcb","modified":1609910322067},{"_id":"public/2018/09/10/Android/Android基础/Android序列化/index.html","hash":"2dc36489c67b29abd516367ed4e0fdff88929bc8","modified":1609910322067},{"_id":"public/2018/09/01/Android/View/Materials Design/index.html","hash":"648aa4e63f0bbc73fcc4a9444578f669537265e3","modified":1609910322067},{"_id":"public/2018/08/25/Android/Structure/架构设计/index.html","hash":"47bcc55391621db0e712bd2cf5cf49286bb0fbbf","modified":1609910322067},{"_id":"public/2018/08/15/Other/Tools/常用工具软件/index.html","hash":"8c51c5e7f2b277efe9d5cd55f7beba81c72713bf","modified":1609910322067},{"_id":"public/2018/08/09/Android/Android基础/Android-ViewModel介绍/index.html","hash":"af9822def4f9d55ca11e11d13fc5883909c8c7ea","modified":1609910322067},{"_id":"public/2018/08/09/Other/Computer/操作符/index.html","hash":"9aacad1e786d4d2bc77c8e2f0820769108ff39ad","modified":1609910322067},{"_id":"public/2018/08/01/Android/Android基础/Android-broadcast介绍/index.html","hash":"90fdd32792702d0897aea5ff8db944d336fa12de","modified":1609910322067},{"_id":"public/2018/07/31/Android/Android基础/Android-service介绍/index.html","hash":"6958838bef411cc80e29eed070529e0803ae7f10","modified":1609910322067},{"_id":"public/2018/07/30/Android/View/使用RecyclerView和SearchView实现查找删除/index.html","hash":"d10a105f505e59257821d21ed8f428f94efce145","modified":1609910322067},{"_id":"public/2018/07/20/Android/View/事件分发机制/index.html","hash":"875ba7ea8657190623c284abdbc442bed67fa80d","modified":1609910322067},{"_id":"public/2018/07/08/Other/Ubuntu 使用/Ubuntu 使用/index.html","hash":"0c72d412a2669436975c0e785b6154e679abe027","modified":1609910322067},{"_id":"public/2018/07/08/Android/框架/AAC/Android Lifecycle-Aware组件详解/index.html","hash":"9f5fbd196ee0e1a5ce8ac28e874ebbabd0d15369","modified":1609910322067},{"_id":"public/2018/06/30/Other/Tools/MarkDown使用/index.html","hash":"e7c381bf4f3d78c7b801a8400cda9d1896366929","modified":1609910322067},{"_id":"public/2018/06/27/Other/Git/Git/index.html","hash":"a1112831113ccefb5226a772b8712992a8363498","modified":1609910322067},{"_id":"public/2018/06/20/Android/View/CountDownView/index.html","hash":"14dc58f4fa94162c1999827cb396554bad6f7a56","modified":1609910322067},{"_id":"public/2018/06/15/Android/View/UI绘制流程/index.html","hash":"a6801065d32c14ae029f669ccfbb37e1b09853fa","modified":1609910322067},{"_id":"public/2018/05/06/Android/框架/fastjson的使用/index.html","hash":"65b82816a6a78a0c4f057bca31407bb97cda0aed","modified":1609910322067},{"_id":"public/2018/04/06/Android/框架/AAC/DataBinding的使用/index.html","hash":"9f76979ab58c73461547014f7cb754045c7de79b","modified":1609910322067},{"_id":"public/2017/08/28/Data_Structure/2017-08-28-data-structure-huffman-tree/index.html","hash":"c9dca7e83099792fb1ae2a58e521bd4416f9d594","modified":1609910322067},{"_id":"public/2017/08/27/Data_Structure/2017-08-27-data-structure-adjacency-list/index.html","hash":"6097fb144c58e65705719779b0b836173e91f69b","modified":1609910322067},{"_id":"public/2017/08/27/Data_Structure/2017-08-27-data-structure-heap-sort/index.html","hash":"05d9755055739a8555602ca489157cb1724ccbec","modified":1609910322067},{"_id":"public/2017/08/26/Data_Structure/2017-08-26-data-structure-adjaceny-matrix/index.html","hash":"7a0a63fd4ded7107777bb8f0473c2fcddda8dde9","modified":1609910322067},{"_id":"public/2017/08/26/Data_Structure/2017-08-26-data-structure-build-heap/index.html","hash":"680d2ef9b6ef0ec45390cf00fe73597042c73f93","modified":1609910322067},{"_id":"public/2017/08/08/Data_Structure/2017-08-08-data-structure-threaded-binary-tree/index.html","hash":"764f66106e39590bc554a5764befb6845346053c","modified":1609910322067},{"_id":"public/2017/08/04/Data_Structure/2017-08-04-data-structure-merge-sort/index.html","hash":"e325af97b56033fdff077c89698a519516405f53","modified":1609910322067},{"_id":"public/2017/08/04/Data_Structure/2017-08-04-data-structure-quick-sort/index.html","hash":"7a3ca0aa480bfd5439d21e233220260db6ccd3ec","modified":1609910322067},{"_id":"public/2017/08/02/Data_Structure/2017-08-02-data-structure-queue/index.html","hash":"7a27f23ccf40d0a88eea84bfbeb5036e1d9c6f39","modified":1609910322067},{"_id":"public/2017/08/02/Data_Structure/2017-08-02-data-structure-radix-sort/index.html","hash":"071898823984b1b8d7937b5fa987cd30f2edf720","modified":1609910322067},{"_id":"public/2017/08/02/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary/index.html","hash":"540962916f6f58ecee5226ab33c1a90e11091b79","modified":1609910322067},{"_id":"public/2017/08/02/Data_Structure/2017-08-02-data-structure-stack-use/index.html","hash":"e1b19c2d586d7c59b64ac3e200fdf4aed4dabcd8","modified":1609910322067},{"_id":"public/2017/08/01/PAT/2017-08-01-pat-advanced-1011/index.html","hash":"60660f2e998a3b5d790415db5ac942d1691ebdb8","modified":1609910322067},{"_id":"public/2017/08/01/PAT/2017-08-01-pat-advanced-1060/index.html","hash":"d9a9c38671073116b727bcc1a6cc3461ef0dc192","modified":1609910322067},{"_id":"public/2017/08/01/Android/Android基础/Android Binder机制/index.html","hash":"1b6c4ac2f3d710291b100ce29028654948513987","modified":1609910322067},{"_id":"public/2017/07/31/Data_Structure/2017-07-31-data-structure-insert-sort/index.html","hash":"1b3a0c020b521b1960a1d3b1f541d42c4bbda74f","modified":1609910322067},{"_id":"public/2017/07/31/Data_Structure/2017-07-31-data-structure-search/index.html","hash":"783c08d1b9bacf2a669d194c68b847e679d68504","modified":1609910322067},{"_id":"public/2017/07/31/PAT/2017-07-31-pat-advanced-1006/index.html","hash":"845c725ef1741cdccd271dbd3a7a943c1ff66b93","modified":1609910322067},{"_id":"public/2017/07/28/PAT/2017-07-27-pat-advanced-1007/index.html","hash":"0f7a308fc8a120f9844bde9e1bfd349a1151979e","modified":1609910322067},{"_id":"public/2017/07/27/Data_Structure/2017-07-27-data-structure-stack/index.html","hash":"bff27cff87a808dbe4320bddad5ac94cdaa8360f","modified":1609910322067},{"_id":"public/2017/07/27/Data_Structure/2017-07-27-data-structure-binary-tree-visit/index.html","hash":"cec407a773269c578849655052eaf7e4dde46dc4","modified":1609910322067},{"_id":"public/2017/07/27/PAT/2017-07-27-pat-advanced-1001/index.html","hash":"39519bc20bc7f3a8be3963294ef0651c663ef58e","modified":1609910322067},{"_id":"public/2017/07/27/PAT/2017-07-27-pat-advanced-1002/index.html","hash":"688f5931c264d2a9ea4f6dc4848df51c4e4c5c66","modified":1609910322067},{"_id":"public/2017/07/27/PAT/2017-07-27-pat-advanced-1005/index.html","hash":"723044ce2e1b77dd4d30f5c448764c6e2226b50c","modified":1609910322067},{"_id":"public/2017/07/27/PAT/2017-07-27-pat-advanced-1008/index.html","hash":"8179a610bc5b6a1cfb673d996d133c4c4f2d371c","modified":1609910322067},{"_id":"public/2017/07/27/Other/Git/Git出现问题解决/index.html","hash":"24986cafa42ded91421a4b19013fe320ee475435","modified":1609910322067},{"_id":"public/archives/index.html","hash":"fbb174e361983bfc183c1c84a96c144b53d23fdb","modified":1609911083332},{"_id":"public/archives/page/2/index.html","hash":"ab69849f487a4bc3ce7f021e8b8bc980eb41b514","modified":1609911083332},{"_id":"public/archives/page/3/index.html","hash":"fdbdd0704563e354277d22ead3907e929b9edac3","modified":1609911083332},{"_id":"public/archives/page/4/index.html","hash":"f7bb6a48be4581ac759e0b7aedc1223390c678fd","modified":1609911083332},{"_id":"public/archives/page/5/index.html","hash":"7f2715afa8c9a75c09a0a803ab3438d72c364f7d","modified":1609911083332},{"_id":"public/archives/page/6/index.html","hash":"381f60995ca56471f6625ee8d1513b383ff89e21","modified":1609911083332},{"_id":"public/archives/page/7/index.html","hash":"c60949e0664c5727b739d247f1042f5219f6b422","modified":1609911083332},{"_id":"public/archives/page/8/index.html","hash":"9e2e8d58789bc3d19b31b7e54ee3ca0ef91dec69","modified":1609911083332},{"_id":"public/archives/page/9/index.html","hash":"3468206c4ca690785d609b1db03552bb3dbcae1c","modified":1609911083332},{"_id":"public/archives/page/10/index.html","hash":"b4428b466d9726b8d42c441838ddca8db3a1fb64","modified":1609911083332},{"_id":"public/archives/page/11/index.html","hash":"772c59c9ec2536c8dd49e67c77803214dcbd7a67","modified":1609911083332},{"_id":"public/archives/page/12/index.html","hash":"a3828f80518938552ccca733030522fabcdb9c5e","modified":1609911083332},{"_id":"public/archives/2017/index.html","hash":"7d2717af0dc2c451903b2d5ab85d952ac58cf343","modified":1609911083332},{"_id":"public/archives/2017/page/2/index.html","hash":"f7ceeb5fa5e34c918c088fb166aaacc58993ad91","modified":1609911083332},{"_id":"public/archives/2017/page/3/index.html","hash":"0affc1c4f3e92ed33da0e466c5cbd038d37097b9","modified":1609911083332},{"_id":"public/archives/2017/07/index.html","hash":"711039ffc64574ef0e5fdf0a9fbd1201771713a3","modified":1609911083332},{"_id":"public/archives/2017/07/page/2/index.html","hash":"5eb446d4e0416677ba83140579057dc84523fa15","modified":1609911083332},{"_id":"public/archives/2017/08/index.html","hash":"c7e72f3414435c8189df706f68d1da4e6374378b","modified":1609911083332},{"_id":"public/archives/2017/08/page/2/index.html","hash":"a5eacc615339e1bffc7369c9d438d65cc7f8230c","modified":1609911083332},{"_id":"public/archives/2018/index.html","hash":"02c3640b1f26f69dac9aef42732a408283b24f92","modified":1609911083332},{"_id":"public/archives/2018/page/2/index.html","hash":"8fea2c71a65cb18f7775af0f7438cd0f10e6e5cc","modified":1609911083332},{"_id":"public/archives/2018/page/3/index.html","hash":"0cbffb935b39fea3bc90ca2534d0f3afc71813a5","modified":1609911083332},{"_id":"public/archives/2018/04/index.html","hash":"3f115934f0dc7088fbfd9d5d739cf066836c34a6","modified":1609911083332},{"_id":"public/archives/2018/05/index.html","hash":"ac90db6703b56b60c93f293f9991722bd8ae427c","modified":1609911083332},{"_id":"public/archives/2018/06/index.html","hash":"4f64f846013b8197c0269ed7bc1a5512d62bf096","modified":1609911083332},{"_id":"public/archives/2018/07/index.html","hash":"16143b5f3372604c400c580cab02671a2c861277","modified":1609911083332},{"_id":"public/archives/2018/08/index.html","hash":"7e3fe398072d94416030091c5a94e84a42b4c5f1","modified":1609911083332},{"_id":"public/archives/2018/09/index.html","hash":"4ba91104c1e0c7920f828a4179deecd935e1ec61","modified":1609911083332},{"_id":"public/archives/2018/10/index.html","hash":"dc920de609144c782d8549cafdf5da0074a7f91f","modified":1609911083332},{"_id":"public/archives/2018/11/index.html","hash":"c5a6a09e5cc859c412b5dbde34cb69082cfe45ce","modified":1609911083332},{"_id":"public/archives/2018/12/index.html","hash":"c1e8ce24e972b07dfc1ff491fe6f47885e6cfbb5","modified":1609911083332},{"_id":"public/archives/2019/index.html","hash":"bab976a13a35c6aef1e63e4f858997fd34e1a324","modified":1609911083332},{"_id":"public/archives/2019/page/2/index.html","hash":"1fdf18938ab05dd8c1a2fd2d31f61e19a7733417","modified":1609911083332},{"_id":"public/archives/2019/page/3/index.html","hash":"c15f4803a507ed2314e016f1341542fff0682bb6","modified":1609911083332},{"_id":"public/archives/2019/page/4/index.html","hash":"93b185fc3f2e77e2e136ca66eded146d38a73e15","modified":1609911083332},{"_id":"public/archives/2019/02/index.html","hash":"5c46f3955f465f7c96696db1ec24de689dc8a174","modified":1609911083332},{"_id":"public/archives/2019/03/index.html","hash":"f4aa03c197caecc21e41470dbab04484a66bddc3","modified":1609911083332},{"_id":"public/archives/2019/04/index.html","hash":"657b57bf6e9c2a73d4771e71795419f3eaebaeb5","modified":1609911083332},{"_id":"public/archives/2019/05/index.html","hash":"c317c7e882749ea3a48bb56f12fbcb2ca74b3e29","modified":1609911083332},{"_id":"public/archives/2019/06/index.html","hash":"ec31f41e979ba2f826f231011af7401786607058","modified":1609911083332},{"_id":"public/archives/2019/07/index.html","hash":"55adedc65eddff361a1d1c48926893c4dae337e9","modified":1609911083332},{"_id":"public/archives/2019/08/index.html","hash":"e84c4fd38b4921c018006af3cc65bdcc292d1ce8","modified":1609911083332},{"_id":"public/archives/2019/09/index.html","hash":"8e9215d0b6e3840700e9175493aec35c957d4822","modified":1609911083332},{"_id":"public/archives/2019/09/page/2/index.html","hash":"2ed1b6c7b583d79f7952772ef5f5a70ccba76179","modified":1609911083332},{"_id":"public/archives/2019/10/index.html","hash":"54e633850aa0260ec955e718bfd84d88c792ca3a","modified":1609911083332},{"_id":"public/archives/2019/12/index.html","hash":"ef968990bfdd120f9cb4f2aec22c6017b2e24522","modified":1609911083332},{"_id":"public/archives/2020/index.html","hash":"8a1784caa02e3ca53dd2b6e7b5db32098946064f","modified":1609911083332},{"_id":"public/archives/2020/page/2/index.html","hash":"c1deb00c079ca3e8c4cdcb76c94c7a6ad09aef55","modified":1609911083332},{"_id":"public/archives/2020/page/3/index.html","hash":"f19ac23f299d8307946efadf1a9068010f486972","modified":1609911083332},{"_id":"public/archives/2020/page/4/index.html","hash":"679ab180a073ed7054d01b1eac815c9862d8b7d3","modified":1609848990688},{"_id":"public/archives/2020/01/index.html","hash":"fb59eb116dc24d53352685450ba92f249009d76d","modified":1609911083332},{"_id":"public/archives/2020/02/index.html","hash":"24c4d9b4d4a208997d2c336d492028c9bc11ae4d","modified":1609911083332},{"_id":"public/archives/2020/03/index.html","hash":"4cff34d93303a7be093b8b6229e9b6036ec7add9","modified":1609911083332},{"_id":"public/archives/2020/05/index.html","hash":"d0b05f4e6683654f26e8c601d36f218047e3e89c","modified":1609911083332},{"_id":"public/archives/2020/05/page/2/index.html","hash":"f733bff2f3e73b71f9a4eb421851e0a87b61ebf3","modified":1609895265890},{"_id":"public/archives/2020/05/page/3/index.html","hash":"b552da15846b3723d1d4f97508a5f6e7e4932fef","modified":1609848990688},{"_id":"public/archives/2020/11/index.html","hash":"83db464dba09867579adf2bda2891a4c233be841","modified":1609848990688},{"_id":"public/archives/2020/12/index.html","hash":"b83d310478a64627e3910e998ccf5bd8be0e8465","modified":1609911083332},{"_id":"public/categories/数据结构/index.html","hash":"109f15813692f58f3ff2650306368ad6d09d2cba","modified":1609911083332},{"_id":"public/categories/数据结构/page/2/index.html","hash":"2fd13c17289fa9b3f31f747c8791b6d68bf6bfca","modified":1609911083332},{"_id":"public/categories/PAT/index.html","hash":"025b0c34eaa4750fbb005c882ef126ee6ac9f684","modified":1609911083332},{"_id":"public/categories/Android/index.html","hash":"033005e662f583faf819bcb6a3ef909111a223d9","modified":1609911083332},{"_id":"public/categories/Android/page/2/index.html","hash":"7dd8a4251282deda0e82c8a1ff523631d3f2942e","modified":1609911083332},{"_id":"public/categories/Android/page/3/index.html","hash":"9456c0ffa891788f39028a354b1b4831db20acd8","modified":1609911083332},{"_id":"public/categories/Android/page/4/index.html","hash":"f4ac9cb7e75aaf842f2a8e5b6d513f15147149d2","modified":1609911083332},{"_id":"public/categories/Android/page/5/index.html","hash":"e8af82e85070716fd0c63a7db796b550f0c3e640","modified":1609911083332},{"_id":"public/categories/Android/page/6/index.html","hash":"ab4620abf157e19271e9a1249274a7c96e31534c","modified":1609911083332},{"_id":"public/categories/Java/index.html","hash":"10a9ad0bfd12a739e42a021859f9c16a7099da5c","modified":1609911083332},{"_id":"public/categories/Java/page/2/index.html","hash":"f792b1fce0f418ec88bb3089f29ff9955b1cc554","modified":1609911083332},{"_id":"public/categories/Kotlin/index.html","hash":"6f985a146a5f61e0f590fbbeedc0ac8ed7edd6a0","modified":1609911083332},{"_id":"public/categories/Other/index.html","hash":"dc8960220c79f977d6e62b6eed4ad667000cce1a","modified":1609911083332},{"_id":"public/index.html","hash":"25b0a4a8505a0eda3ad1de14904b424853b0e627","modified":1609911083332},{"_id":"public/page/2/index.html","hash":"bf12565f49197751960e945e1f2b5f2a8011696e","modified":1609911083332},{"_id":"public/page/3/index.html","hash":"e40b388ce28d339d928624d2d4bf0fba12ef2812","modified":1609911083332},{"_id":"public/page/4/index.html","hash":"2fbf2beca2f7b1c258db29ef6ada08c3d0ab6415","modified":1609911083332},{"_id":"public/page/5/index.html","hash":"68630e725e6d5f743030aa2d4ad1497d9ca117c9","modified":1609911083332},{"_id":"public/page/6/index.html","hash":"0132d1041280660e070bd76780d052279d8f482b","modified":1609911083332},{"_id":"public/page/7/index.html","hash":"b789f5723c9c77f4cd45390fdb2048b00cb2b6f0","modified":1609911083332},{"_id":"public/page/8/index.html","hash":"2b48829fcaba972940d78b408f60ffc19b2e28f1","modified":1609911083332},{"_id":"public/page/9/index.html","hash":"8838779aa890a7fafbad267f3c6e1c745b2cfe3f","modified":1609911083332},{"_id":"public/page/10/index.html","hash":"1b4d4705fedd8087c7c0211e447a5361ab4a3b19","modified":1609911083332},{"_id":"public/page/11/index.html","hash":"2e890fcb5fa4e5bc4d354af83f3a10bc5d3063e9","modified":1609911083332},{"_id":"public/page/12/index.html","hash":"068f961b260fa7e5a8e59184d9368800f9c1637d","modified":1609911083332},{"_id":"public/tags/数据结构/index.html","hash":"c22a5d6895c66e4d4f7e6ca8c1033868a02cd044","modified":1609848031916},{"_id":"public/tags/数据结构/page/2/index.html","hash":"e98090b46a1c15309fe58416c300b35c5fff61c8","modified":1609848031916},{"_id":"public/tags/pat/index.html","hash":"88e581565c6c65c14d1753d9f8d8d0e65d099efd","modified":1609848031916},{"_id":"public/tags/JNI/index.html","hash":"8a66c829b276e9cdec7b035b11276601475ca5eb","modified":1609848031916},{"_id":"public/tags/Android/index.html","hash":"98945ac361e89d1d9a0c7a440f380d4878951b1b","modified":1609848031916},{"_id":"public/tags/Android/page/2/index.html","hash":"0a4ef911fdbe3e56c369d76dad73e2d39012f52c","modified":1609848031916},{"_id":"public/tags/Android/page/3/index.html","hash":"af6347f5a233d59408b7febe48aa67ba9f401ea9","modified":1609848031916},{"_id":"public/tags/Android/page/4/index.html","hash":"8fe1b74d8052120b1d3684f15440f8a813ee64fa","modified":1609848031916},{"_id":"public/tags/Android/page/5/index.html","hash":"e8bcbe16bdab37d96d38b3a222316c411bdad90f","modified":1609848031916},{"_id":"public/tags/Android/page/6/index.html","hash":"073f2fac84f0ef265e0e36332e58ba62ba636bb1","modified":1609848031916},{"_id":"public/tags/Java/index.html","hash":"83a569632789339464667ffe00cbbc5c3a78b63c","modified":1609848031916},{"_id":"public/tags/Java/page/2/index.html","hash":"119bf80d9ff5766b09cf697b98bc54d6b323b79a","modified":1609848031916},{"_id":"public/tags/Kotlin/index.html","hash":"ae48f2417656313147df945d266a846583832470","modified":1609848031916},{"_id":"public/tags/Other/index.html","hash":"61a40be6b1956d6fc3bc7a1e53e814242cc7f61f","modified":1609848031916},{"_id":"public/tags/Git/index.html","hash":"429e5689f1c21e24e64d29f7baa9e03dbb178455","modified":1609848031916},{"_id":"public/tags/Ubuntu/index.html","hash":"7dc7b160f62304b639304844ce8e951a027d3b32","modified":1609848031916},{"_id":"public/tags/性能优化/index.html","hash":"544443595fc6277904ae716c05cc03373b98dc95","modified":1609848031916},{"_id":"public/tags/优化/index.html","hash":"d16584e0442b9ce6422c99026713fe7eeadc5407","modified":1609848031916},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1609841419868},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1609841419868},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1609841419868},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1609841419868},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1609841419868},{"_id":"public/assets/Android JNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1609841419868},{"_id":"public/assets/Android JNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1609841419868},{"_id":"public/assets/Android JNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1609841419868},{"_id":"public/assets/Android JNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1609841419868},{"_id":"public/assets/Android safe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1609841419868},{"_id":"public/assets/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1609841419868},{"_id":"public/assets/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1609841419868},{"_id":"public/assets/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1609841419868},{"_id":"public/assets/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1609841419868},{"_id":"public/assets/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1609841419868},{"_id":"public/assets/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1609841419868},{"_id":"public/assets/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1609841419868},{"_id":"public/assets/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1609841419868},{"_id":"public/assets/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1609841419868},{"_id":"public/assets/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1609841419868},{"_id":"public/assets/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1609841419868},{"_id":"public/assets/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1609841419868},{"_id":"public/thumbnail/img100.jpg","hash":"a1d505005b78b64a662337c19563a2092701deed","modified":1609841419868},{"_id":"public/thumbnail/img101.jpg","hash":"128d477046a09228cc81687a98ba86e9be6267c9","modified":1609841419868},{"_id":"public/thumbnail/img84.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1609841419868},{"_id":"public/thumbnail/img86.jpg","hash":"7a7b07f27672b73fd14262836d2949a6b81c13d4","modified":1609841419868},{"_id":"public/thumbnail/img99.jpg","hash":"1a73da5187dd39502fdfbccbf5be67242b25285f","modified":1609841419868},{"_id":"public/img/20170726/Image1.png","hash":"a375dd730a00316fb9f483c48d01e75aded2c67e","modified":1609841419868},{"_id":"public/img/20170726/Image11.png","hash":"e0c11295b7c6577b35cd0823489efeb2e05c547c","modified":1609841419868},{"_id":"public/img/20170726/Image12.png","hash":"545907b9b1449448c3cadbfdd9da5aade1250ef4","modified":1609841419868},{"_id":"public/img/20170726/Image13.png","hash":"8d7cdf29bce3d2a83d6a14a688cc3c8f7cbed49d","modified":1609841419868},{"_id":"public/img/20170726/Image14.png","hash":"b24df030353b9fefae8015d044daf177fe05f5a1","modified":1609841419868},{"_id":"public/img/20170726/Image15.png","hash":"9fb214cc781a01dbb2dbe18fbc20fc800f6e8013","modified":1609841419868},{"_id":"public/img/20170726/Image16.png","hash":"90c9977aaafb00de1689593624021b02ad144a96","modified":1609841419868},{"_id":"public/img/20170726/Image17.png","hash":"8d41d9c4f3886a51d3f900edd6609fdd3d736890","modified":1609841419868},{"_id":"public/img/20170726/Image18.png","hash":"055331e05df5d64b605d2d58e5061672e108faaa","modified":1609841419868},{"_id":"public/img/20170726/Image4.png","hash":"e391f03b3787074d9f7be1ea7387848c350b0f35","modified":1609841419868},{"_id":"public/img/20170726/Image3.png","hash":"127eccc0d73e654731ec779a7c28fb591b2ef28f","modified":1609841419868},{"_id":"public/img/20170726/Image2.png","hash":"43f9bfbfad80d540d57beda5480e67fc415f4b66","modified":1609841419868},{"_id":"public/img/20170726/Image5.png","hash":"4eb6f78614962547a93913f98faf327203d1794f","modified":1609841419868},{"_id":"public/img/20170726/Image6.png","hash":"2b63aa98f0cedef44776a31e17fbc8cc0dbd84f3","modified":1609841419868},{"_id":"public/img/20170726/Image7.png","hash":"46ce3306766c3f5f19b4c97dea961e75b735ed9b","modified":1609841419868},{"_id":"public/img/20170726/Image8.png","hash":"fa5f08785a32a1982f4e1e8ce166ede400ad7958","modified":1609841419868},{"_id":"public/img/20170726/Image9.png","hash":"b9b8483009389028e67d0a5cd49731cf15f88e4b","modified":1609841419868},{"_id":"public/img/Android/Android safe1.png","hash":"9b42f3492a5e8ba447bf0040a3963d66c6017da8","modified":1609841419868},{"_id":"public/img/Android/AndroidJNI1.png","hash":"7c0c1bff05a3c8b40628767cb7114f54884a0140","modified":1609841419868},{"_id":"public/img/Android/AndroidJNI2.png","hash":"b65d36c898f3b85991abf8512f56ba7bf829dbcb","modified":1609841419868},{"_id":"public/img/Android/AndroidJNI.png","hash":"34337c6d744aa04b782b0f06395f1967ba5cf5c8","modified":1609841419868},{"_id":"public/img/Android/AndroidJNI3.png","hash":"5d210c9a6ee73a1acf18c2310e1fcad63fde2c62","modified":1609841419868},{"_id":"public/img/Android/Androidsafe.png","hash":"183a8e3fce8d8f18f77e382db03c29472b04e0b3","modified":1609841419868},{"_id":"public/img/Android/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1609841419868},{"_id":"public/img/Android/android_basis_permission.png","hash":"c82ea0190ff6699c3ec1220214c31fbd7ae73415","modified":1609841419868},{"_id":"public/img/Android/lifecycle.png","hash":"be23b363577bdb1910d5d7f133f5d776d9a67438","modified":1609841419868},{"_id":"public/img/Android/livedata.png","hash":"8b6a0304fe4030b25a30483ab9c92943b82abb66","modified":1609841419868},{"_id":"public/img/Android/service_lifecycle.png","hash":"5c1d2bf331a1475fccd7e91f29af4e5a7b26f9b4","modified":1609841419868},{"_id":"public/img/Android/view_model.png","hash":"ef194d46df905157b4c65466468fd4681f499270","modified":1609841419868},{"_id":"public/img/Android/view_model2.png","hash":"3b13867ed6ef01bad9bd6d4d6678bb11d1be541c","modified":1609841419868},{"_id":"public/img/Android/view_model1.png","hash":"4ba78ac2452498f9e27df4bd91727f7eca4a7220","modified":1609841419868},{"_id":"public/img/Java/proxy-design-pattern.jpg","hash":"1e3f5d82fba0bf49caa2bb1378a8ecbcd6452ba1","modified":1609841419868},{"_id":"public/img/other/GitImg2.png","hash":"2d30d9767f05b664ee235d4991fcc3a4ad90f5e1","modified":1609841419868},{"_id":"public/img/other/GitImg1.png","hash":"fa83f3d15bfee69870815272f455b9c7c1908249","modified":1609841419868},{"_id":"public/img/other/GitImg3.png","hash":"c65c451eeb11ded06bf4e7719a30a59e9f2b5910","modified":1609841419868},{"_id":"public/img/other/GitImg4.png","hash":"09a8a5177592e3a463e96067627964d55c960496","modified":1609841419868},{"_id":"public/img/other/GitImg5.png","hash":"c5aa4e653db27b507a4cb780cd48c15dc9ae36ab","modified":1609841419868},{"_id":"public/img/other/GitImg8.png","hash":"3c96308898f43a0c93b4906ad425183fa9cf225c","modified":1609841419868},{"_id":"public/img/other/GitImg7.png","hash":"5161104f37a3dc4fd668ae341dfaa2e591c03772","modified":1609841419868},{"_id":"public/img/other/GitImg6.png","hash":"9768d7de7c71d5f4373a6e9b400bf77fbe26e393","modified":1609841419868},{"_id":"public/img/other/GitImg9.png","hash":"bc6458294e1966ff60f239bb2117bccb186a7784","modified":1609841419868},{"_id":"public/img/other/Image4.png","hash":"36d2556b3af92a35ed0f937fd60c0fe5df28cdd3","modified":1609841419868},{"_id":"public/img/other/Image3.png","hash":"b6b42814093bbca53a964c22db752433097fed29","modified":1609841419868},{"_id":"public/img/other/Image1.png","hash":"c1b937ef5f0ccffeb5f91696831af6d2deae2abf","modified":1609841419868},{"_id":"public/img/other/Image5.png","hash":"b327a63bb3e432fb28f3cd58950f172f3e9951d1","modified":1609841419868},{"_id":"public/img/other/blog1.png","hash":"bfee58d2d9caeed863f2dfd9a5de8020c80114f6","modified":1609841419868},{"_id":"public/img/other/Image6.png","hash":"b64ae70890b57d812838c5d8ee19583082087d6b","modified":1609841419868},{"_id":"public/img/other/blog3.png","hash":"f79290efbb54eb504dfb898a222595a15ec2c7a6","modified":1609841419868},{"_id":"public/img/other/blog2.png","hash":"1876a9b7917aef788aa438907cc1e4230fe54c93","modified":1609841419868},{"_id":"public/img/other/ubuntu_file_share1.png","hash":"098b17f62f1ffa4f79782f430e7b3d0420fb81af","modified":1609841419868},{"_id":"public/img/other/ubuntu_file_share3.png","hash":"7b33691e89204a933ac38791a584ce89e5b3fe75","modified":1609841419868},{"_id":"public/img/other/ubuntu_file_share4.png","hash":"c9661fa787d63184c745c757d6778518c5e0ddfd","modified":1609841419868},{"_id":"public/img/other/ubuntu_file_share2.png","hash":"1973c8b171c14677a5c37ef04c3fe34528ab88ab","modified":1609841419868},{"_id":"public/img/DataStructure/001.gif","hash":"e27cbb6e1860d72c6f980e717beaf1e51013b07e","modified":1609841419868},{"_id":"public/img/DataStructure/002.gif","hash":"ab765e2f86c6524c1c44597805966757e7628e6b","modified":1609841419868},{"_id":"public/img/DataStructure/004.jpg","hash":"011dc1b91ffc54c403dd3aa2eb00f6c405823fbb","modified":1609841419868},{"_id":"public/img/DataStructure/adjacency_list1.png","hash":"cb0b1017a9c47dc6cfae862436b34d7177e7aca3","modified":1609841419868},{"_id":"public/img/DataStructure/adjacency_matrix3.png","hash":"753eb3efbe2a104e3659a46f395e0e3e0c348ee9","modified":1609841419868},{"_id":"public/img/DataStructure/adjacency_matrix2.png","hash":"956ce82807f386760265152a560c21bb1a209e4c","modified":1609841419868},{"_id":"public/img/DataStructure/adjacency_matrix1.png","hash":"810a07fbc8e384a32fa69a556d22290b94343e14","modified":1609841419868},{"_id":"public/img/DataStructure/binary_tree_result.png","hash":"6e887cacde537b36a667ba915033e54138a1f396","modified":1609841419868},{"_id":"public/img/DataStructure/binary_tree.jpg","hash":"f124b7ead17dc866c7726d5c0095de35f0338231","modified":1609841419868},{"_id":"public/img/DataStructure/heap2.jpg","hash":"ff257b33be988c0f480fd2298d8b656b8e335198","modified":1609841419868},{"_id":"public/img/DataStructure/heap3.jpg","hash":"37a570aaa9ce98c1b619c55121297d9f689725b7","modified":1609841419868},{"_id":"public/img/DataStructure/heap_sort.jpg","hash":"eb5166b07005b4bbf2b5937b2e12eff1f5fdc396","modified":1609841419868},{"_id":"public/img/DataStructure/heap7.jpg","hash":"1f62e84ec84a32f5cc47c21d6367a7bbc1f7940b","modified":1609841419868},{"_id":"public/img/DataStructure/huffman_tree.png","hash":"8c4fa46aaf9c54f20a937ef0cac565e7c2422c61","modified":1609841419868},{"_id":"public/img/DataStructure/huffman_tree1.png","hash":"1bcf8ad33c94ff370c9e7a022c618bc108216d51","modified":1609841419868},{"_id":"public/img/DataStructure/huffman_tree3.png","hash":"0c3d5180fbfc7560effb45068ed45fd32993fe57","modified":1609841419868},{"_id":"public/img/DataStructure/quick_sort.jpg","hash":"a83f57425b47b1087d74a6c4ee22cc632a460eea","modified":1609841419868},{"_id":"public/img/DataStructure/thread_binary_tree.jpg","hash":"4eae3ccc3de99620b5c978925919e747efcff67c","modified":1609841419868},{"_id":"public/img/DataStructure/quick_sort_01.jpg","hash":"7bf4d9c95393f6f764a27c7b649ee0454859ee55","modified":1609841419868},{"_id":"public/img/DataStructure/threaded_binary_tree.jpg","hash":"42c53b95e0112e8b0407178fb6b83b2fe5e49105","modified":1609841419868},{"_id":"public/assets/Retrofit.png","hash":"0f2a36782646ae2fc84ea18a39877809a7f6bbdf","modified":1609841419868},{"_id":"public/thumbnail/img102.jpg","hash":"2869ee2611f99d02019802cee8db70162ac19391","modified":1609841419868},{"_id":"public/thumbnail/img103.jpg","hash":"ff418bfdf3da9ee70bab1aa26306c8acbb62b582","modified":1609841419868},{"_id":"public/thumbnail/img42.jpg","hash":"aea9453168d0e085975de9c1b8f390ded5fe4652","modified":1609841419868},{"_id":"public/thumbnail/img59.jpg","hash":"3fbaa6878c25498d37e469edb2eeab806364ce42","modified":1609841419868},{"_id":"public/thumbnail/img72.jpg","hash":"105fc2a3d1127f8705bea82efb6c59402d23aed5","modified":1609841419868},{"_id":"public/thumbnail/img85.jpg","hash":"f023eb09a94e10f006ac98f0aa94d960ed814f8f","modified":1609841419868},{"_id":"public/thumbnail/img87.jpg","hash":"45a156fb0c141d2c1b6ef4099dfd5bec93f12759","modified":1609841419868},{"_id":"public/thumbnail/img88.jpg","hash":"01de4f788f32df6f758a68394e80d72909cddda8","modified":1609841419868},{"_id":"public/thumbnail/img89.jpg","hash":"1cf54256ad251f96b6d2ca00d56b4b46107007c0","modified":1609841419868},{"_id":"public/thumbnail/img90.jpg","hash":"db53e6201cf2ff4e7c27e9e0ae27c788d634c6e5","modified":1609841419868},{"_id":"public/thumbnail/img92.jpg","hash":"8c5b2bb1012026b907c2d373523500aae774ba39","modified":1609841419868},{"_id":"public/thumbnail/img91.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1609841419868},{"_id":"public/thumbnail/img93.jpg","hash":"d5dc73161d76f70070894803f656fd165d3c06d4","modified":1609841419868},{"_id":"public/thumbnail/img95.jpg","hash":"6226a5462b7f020c1c6f00cc35f6ad9d5c83f60c","modified":1609841419868},{"_id":"public/thumbnail/img98.jpg","hash":"8499e0602671c001678c5909dd0b5c519ae368b4","modified":1609841419868},{"_id":"public/img/Android/Android_performance.png","hash":"d3a30f425136bcc2581174f069d1138adfef24a7","modified":1609841419868},{"_id":"public/img/Android/collection.png","hash":"38dfaafd4896d4e584b8508aa9a1a86942170104","modified":1609841419868},{"_id":"public/img/DataStructure/001.png","hash":"a5205f3db29fe11646ad8c0c580daef28b2473c4","modified":1609841419868},{"_id":"public/img/DataStructure/Merge_sort.gif","hash":"8c074d46d4c96077d11f9e8cab9ff5d95bdc3da0","modified":1609841419868},{"_id":"public/img/DataStructure/adjacency_list.jpg","hash":"44905436617f72027e8001cc11f74694508e78a6","modified":1609841419868},{"_id":"public/img/DataStructure/adjacency_matrix.jpg","hash":"b9a9e2e34290fa182102bec682ae532be806025d","modified":1609841419868},{"_id":"public/img/DataStructure/heap1.jpg","hash":"96a7319b82d0dc5e949799cc57a1a272672f85b9","modified":1609841419868},{"_id":"public/img/DataStructure/heap.jpg","hash":"f2f37a05d4bda669871ad1efc123a69621657406","modified":1609841419868},{"_id":"public/img/DataStructure/heap5.jpg","hash":"74d134ee991b8afec74f5a9f9b18df3c28122bb4","modified":1609841419868},{"_id":"public/img/DataStructure/heap8.jpg","hash":"109e6c65abd6a6d02d127dd4c95bc0bd0972d3fd","modified":1609841419868},{"_id":"public/img/DataStructure/huffman_tree2.jpg","hash":"d6a9e2244379a111969c694004d7efb42a8a901b","modified":1609841419868},{"_id":"public/img/DataStructure/insertsort.gif","hash":"5fc8daa9296837453ccbc8c7f9c2494bbd1fcdda","modified":1609841419868},{"_id":"public/thumbnail/img16.jpg","hash":"acf5a7ed28f36c0a36f6d215bf9bf81419553458","modified":1609841419868},{"_id":"public/thumbnail/img3.jpg","hash":"d2084ff7b1443dffc8dc015bf525a47f3c138a03","modified":1609841419868},{"_id":"public/thumbnail/img32.jpg","hash":"87745dbc48d71f90c6cb2c12faa7a51e133b880a","modified":1609841419868},{"_id":"public/thumbnail/img39.jpg","hash":"abcf23665b924cd7766a732586813ac8ecafae24","modified":1609841419868},{"_id":"public/thumbnail/img43.jpg","hash":"454eb775ff0cbbec74688c9d8ce310938c01bef8","modified":1609841419868},{"_id":"public/thumbnail/img41.jpg","hash":"019e6a1a12affbb94014bf3288ee04d6dad175bd","modified":1609841419868},{"_id":"public/thumbnail/img49.jpg","hash":"92ae45a33edfc6158d25c602b684117ad5ec17af","modified":1609841419868},{"_id":"public/thumbnail/img54.jpg","hash":"4223492bd8e67c9d0c02a4834fe72f86391c75bd","modified":1609841419868},{"_id":"public/thumbnail/img60.jpg","hash":"7efd9ff40d9578251e3c7d740762f102bd846f82","modified":1609841419868},{"_id":"public/thumbnail/img63.jpg","hash":"65388a316a804f609ba8baf701d9d31d99714d7f","modified":1609841419868},{"_id":"public/thumbnail/img70.jpg","hash":"7f10838eb2237314a91b0e490ddc72c218c5d320","modified":1609841419868},{"_id":"public/thumbnail/img77.jpg","hash":"f891cdf167d4abc6b7cea6eb6d434ba4d46f5f98","modified":1609841419868},{"_id":"public/thumbnail/img82.jpg","hash":"0998b64c59e30520179bff33b8689b90044cceef","modified":1609841419868},{"_id":"public/thumbnail/img96.jpg","hash":"107c3f313b6e0c8ae3687eeaf2d981c53c07b52f","modified":1609841419868},{"_id":"public/thumbnail/img97.jpg","hash":"fa7ee526dd2bfb57718827aaaea1616522b4cf0b","modified":1609841419868},{"_id":"public/img/20170726/Thumbs.db","hash":"ee48e951388f6679a722e9f2ce67266926a35b05","modified":1609841419868},{"_id":"public/img/DataStructure/003.jpg","hash":"6f6cc25f13e0cdf862cd134b92e6feba89d86ea4","modified":1609841419868},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1609841419868},{"_id":"public/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1609841419868},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1609841419868},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1609841419868},{"_id":"public/css/index.css","hash":"c4b8d53384d9611576705a5b9adb8b9e74aded95","modified":1609841419868},{"_id":"public/thumbnail/img10.jpg","hash":"f6fe547ddcf9f4522e0cd53caf68dccfe4eecf7c","modified":1609841419868},{"_id":"public/thumbnail/img11.jpg","hash":"8f9f3b9c14bb54b280e14ae29d792c33076fda84","modified":1609841419868},{"_id":"public/thumbnail/img15.jpg","hash":"3013d423517be3d6c4d0c60d079af27547080175","modified":1609841419868},{"_id":"public/thumbnail/img21.jpg","hash":"ae7be5ed01fdae812a8f861425c4f1602b49155e","modified":1609841419868},{"_id":"public/thumbnail/img35.jpg","hash":"aebdf2870305c60899d70ab528e2a9ff269f1d4e","modified":1609841419868},{"_id":"public/thumbnail/img38.jpg","hash":"7ba9401279c0f7a4198bdba95b0e1132e9b8e5b5","modified":1609841419868},{"_id":"public/thumbnail/img4.jpg","hash":"814c8303e45ff71f27e8607d515bdaad3fc8460e","modified":1609841419868},{"_id":"public/thumbnail/img46.jpg","hash":"02a33f09beb81d8f9e8c68708d5c214244e8e886","modified":1609841419868},{"_id":"public/thumbnail/img50.jpg","hash":"995cd5d2e5bb8e6469025e10e80ffbaa7a609e77","modified":1609841419868},{"_id":"public/thumbnail/img51.jpg","hash":"4e28760a82af5ec8b55b4d6d0a9e082f8ec3eaa1","modified":1609841419868},{"_id":"public/thumbnail/img53.jpg","hash":"b2e82a4d062da593eed265abdc42a5cb1b6f01cc","modified":1609841419868},{"_id":"public/thumbnail/img61.jpg","hash":"66caeb1741ff3dfb16e08b48ff094f69e1137be4","modified":1609841419868},{"_id":"public/thumbnail/img65.jpg","hash":"719d14d7fa450142f03c0b56e71f4c8c33a0ef96","modified":1609841419868},{"_id":"public/thumbnail/img64.jpg","hash":"b3471bed04e587574fcaa46932270d4f6d259d02","modified":1609841419868},{"_id":"public/thumbnail/img68.jpg","hash":"691ca4cc80e6e581dfd547a333e2a685734ea048","modified":1609841419868},{"_id":"public/thumbnail/img7.jpg","hash":"e4bdad496612865336a49c3830daf7f63c3943de","modified":1609841419868},{"_id":"public/thumbnail/img71.jpg","hash":"152d1f6ce6415207a53e10e09d27d1e6d5fbb71c","modified":1609841419868},{"_id":"public/thumbnail/img79.jpg","hash":"3c599e665d669a36b9fedefc898b8ee3ea110d62","modified":1609841419868},{"_id":"public/thumbnail/img94.jpg","hash":"e118fcfeb53c40ebbfc86654f8f6360bb70687c7","modified":1609841419868},{"_id":"public/img/Android/android_base_binder1.png","hash":"c33497757bf15a6f9fd484b49ad0ed4bbd3bf69c","modified":1609841419868},{"_id":"public/img/Android/android_base_binder2.png","hash":"f27bac80713ff06d2b8c5808792a8034c22070b3","modified":1609841419868},{"_id":"public/img/Android/android_base_binder4.png","hash":"293d0aa0830903a4d2596024bd0aece00015e64a","modified":1609841419868},{"_id":"public/js/main.js","hash":"4e526092321b8c4e93837e716ef4f587ffff9a60","modified":1609841419868},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1609841419868},{"_id":"public/thumbnail/img1.jpg","hash":"76977f264e6ffe588ee803fdeb5b46dc143de70c","modified":1609841419868},{"_id":"public/thumbnail/img2.png","hash":"4b6bf0531edfef1c6f86f587474f96134ad16644","modified":1609841419868},{"_id":"public/thumbnail/img17.jpg","hash":"ee18ec6c5fa554ce3ffc2a29c9266304b0a6c486","modified":1609841419868},{"_id":"public/thumbnail/img22.jpg","hash":"a4678d65efec9e2d62c63d2492d9808e332ea96b","modified":1609841419868},{"_id":"public/thumbnail/img30.jpg","hash":"f2b449b4e9b5ccc54ec1b03239ee484aecf61257","modified":1609841419868},{"_id":"public/thumbnail/img28.jpg","hash":"a131a70863b8b2b1d3da23c6309935fafe1b1c3d","modified":1609841419868},{"_id":"public/thumbnail/img25.jpg","hash":"f1d457db29eaed235e837f851b1c088cb3adc883","modified":1609841419868},{"_id":"public/thumbnail/img31.jpg","hash":"0d0b03e70781af33752cada32b6d7ebad6bed593","modified":1609841419868},{"_id":"public/thumbnail/img40.jpg","hash":"495071c77bf821edf27c71e37dac60c59f4cfe50","modified":1609841419868},{"_id":"public/thumbnail/img37.jpg","hash":"efda0ac5c50f95d1bd43e6cc3818c68371de3af0","modified":1609841419868},{"_id":"public/thumbnail/img44.jpg","hash":"af282e240fad7c5610be1ea1ac83be46e8e260cf","modified":1609841419868},{"_id":"public/thumbnail/img47.jpg","hash":"ab6b209923b0a12235766570d68c3b60e1d6759a","modified":1609841419868},{"_id":"public/thumbnail/img48.jpg","hash":"a1d037607fe8c55a18b0df004d82eae6427b183a","modified":1609841419868},{"_id":"public/thumbnail/img55.jpg","hash":"aad1976fdcde03395bdd91015572fcdcd958fdcb","modified":1609841419868},{"_id":"public/thumbnail/img52.jpg","hash":"5eaa2893e04d23e544cc8645b1293b5e128d0fca","modified":1609841419868},{"_id":"public/thumbnail/img58.jpg","hash":"f3d164c98aef2f2d0614a51fafb949242cdf7861","modified":1609841419868},{"_id":"public/thumbnail/img6.jpg","hash":"a4de0f5470b6591a5f157de6142408bb29abad15","modified":1609841419868},{"_id":"public/thumbnail/img69.jpg","hash":"948cd729a613e9341af7c37bab585fb5ac19c85d","modified":1609841419868},{"_id":"public/thumbnail/img75.jpg","hash":"9f4d31a453f84a3cb6f77653800197e3e8d8e3ae","modified":1609841419868},{"_id":"public/thumbnail/img76.jpg","hash":"b4749958cae12a01c2b8f7310bc2accf12c3d5f4","modified":1609841419868},{"_id":"public/thumbnail/img8.jpg","hash":"d8df1416b30e70da2d6a6ae16c08d969693787ad","modified":1609841419868},{"_id":"public/thumbnail/img80.jpg","hash":"d72b97457e91a54f45df653d3dc83f6e6445c394","modified":1609841419868},{"_id":"public/thumbnail/img81.jpg","hash":"25262b33d00f581aa176099c2dcb0b4fff57537c","modified":1609841419868},{"_id":"public/thumbnail/img9.jpg","hash":"411c999655559df47ce7733b0a9489adb594d550","modified":1609841419868},{"_id":"public/img/DataStructure/Merge_sort_01.gif","hash":"cd1e80c9283020a8c465236497cbcd06e2a27fcc","modified":1609841419868},{"_id":"public/thumbnail/img12.jpg","hash":"e3bd470ec5051891864a882b3489626000d3b2e8","modified":1609841419868},{"_id":"public/thumbnail/img13.jpg","hash":"5feaf1a92a25db3d5914e559d9a9d5653895f96f","modified":1609841419868},{"_id":"public/thumbnail/img19.jpg","hash":"256f0ff9b673f78b2ebba52673400a75475f6cbe","modified":1609841419868},{"_id":"public/thumbnail/img2.jpg","hash":"524c57c6096ff43f8d61f3b070165cf2a0876094","modified":1609841419868},{"_id":"public/thumbnail/img23.jpg","hash":"39670a257584e60cb661ff0a83f0550648e0bdf8","modified":1609841419868},{"_id":"public/thumbnail/img24.jpg","hash":"1c2e7305e718d07b6f9859794451154149575f46","modified":1609841419868},{"_id":"public/thumbnail/img29.jpg","hash":"32d681874233f5bc0ceb8ccf6a47e85de562a5f4","modified":1609841419868},{"_id":"public/thumbnail/img34.jpg","hash":"9fe5e99a9cac8e208a4676f4012934f9adc8eb4f","modified":1609841419868},{"_id":"public/thumbnail/img36.jpg","hash":"ddf85d6ebd01455c340bd5842f9cf962f19e6b1a","modified":1609841419868},{"_id":"public/thumbnail/img56.jpg","hash":"906df206b77d00c6815fada62236ff99ed7550f6","modified":1609841419868},{"_id":"public/thumbnail/img57.jpg","hash":"23bd5c90ed4c759ade026809069b1e9519bda970","modified":1609841419868},{"_id":"public/thumbnail/img73.jpg","hash":"21f32c4e676260681ed24235deacd04d5486856f","modified":1609841419868},{"_id":"public/thumbnail/img78.jpg","hash":"43d5e4baa62349004fd70709d302bcf43bc6fe71","modified":1609841419868},{"_id":"public/thumbnail/img62.jpg","hash":"0fe6bd960118d0d3c2e1d52e9487127ed3302b7e","modified":1609841419868},{"_id":"public/thumbnail/img74.jpg","hash":"87b1e6a1531b906c8b2f6607b33573a8cad86b03","modified":1609841419868},{"_id":"public/thumbnail/img83.jpg","hash":"eee8e2cadc8ac2ee192b9b10ebd22172b0b4c294","modified":1609841419868},{"_id":"public/thumbnail/img20.jpg","hash":"64222fbd6980078546dfb3d13ee7b6457b85a1aa","modified":1609841419868},{"_id":"public/thumbnail/img26.jpg","hash":"33371e319195f1daa4204e39bbfcb893606b2e1a","modified":1609841419868},{"_id":"public/thumbnail/img27.jpg","hash":"acfd44755ebf9e8098df99dd6d21714f2e0ef41c","modified":1609841419868},{"_id":"public/img/Android/android_base_binder3.png","hash":"c6c80d3d29cb49c5ce3d8271b28e827bb77d9c16","modified":1609841419868},{"_id":"public/thumbnail/img1.png","hash":"8342602c9c639b562393b3b6c3d9406b682956f5","modified":1609841419868},{"_id":"public/thumbnail/img18.jpg","hash":"2b5270beab1df53147febbcbd1ae736271cf7ce2","modified":1609841419868},{"_id":"public/thumbnail/img33.jpg","hash":"287f25151a159fa157b6c74f8178d501538463d8","modified":1609841419868},{"_id":"public/thumbnail/img67.jpg","hash":"a2c4fdd119d3bc0bf6dcd8f04bba67fc62e15b62","modified":1609841419868},{"_id":"public/thumbnail/img5.jpg","hash":"b21012fab284b4893c1f74b1db439d11f640ac5c","modified":1609841419868},{"_id":"public/img/DataStructure/heap6.jpg","hash":"0912d02ba1bab1c5dfada1787bc6a3a8f175b951","modified":1609841419868},{"_id":"public/thumbnail/img45.jpg","hash":"2e542e1d2fed0bf4e2e57ba742b090c84321ce3f","modified":1609841419868},{"_id":"public/img/Android/application_start.png","hash":"6395d26d20169517eabbbb36f2a4c010a7be6b7f","modified":1609841419868},{"_id":"public/thumbnail/img14.jpg","hash":"4737d1db939cff23e1a94aa8bf469d4bc5461041","modified":1609841419868},{"_id":"public/thumbnail/img66.jpg","hash":"e3fdb5d66c203030720dc9c64ed1b10002a018b6","modified":1609841419868},{"_id":"themes/hexo-theme-butterfly/README_CN.md","hash":"c785124cd3ab1360baa5d7b18d979b7400438669","modified":1609843424917},{"_id":"themes/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1609843424914},{"_id":"themes/hexo-theme-butterfly/README.md","hash":"7e82a4b91ff9ca61e04aabe6e8c02227b49f5327","modified":1609843424917},{"_id":"themes/hexo-theme-butterfly/_config.yml","hash":"4a26f4383144d62f17ed22809b77c85f15b87399","modified":1609911068912},{"_id":"themes/hexo-theme-butterfly/package.json","hash":"2dd7866b5ac7f64aa128ea3fc18e166d80b3a0a8","modified":1609843424958},{"_id":"themes/hexo-theme-butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1609843424914},{"_id":"themes/hexo-theme-butterfly/languages/default.yml","hash":"690fae93ee2e578e9085e988654ddb013d2fffd9","modified":1609843424918},{"_id":"themes/hexo-theme-butterfly/languages/en.yml","hash":"948f4a29cd5fafdc46ad2008f60929acf76be2a3","modified":1609843424919},{"_id":"themes/hexo-theme-butterfly/languages/zh-CN.yml","hash":"600ac62a76344d012c2b776e570a5e21c66683a8","modified":1609843424919},{"_id":"themes/hexo-theme-butterfly/languages/zh-TW.yml","hash":"3a02788767ed6a751e1c350ec620354b50ac86b9","modified":1609843424919},{"_id":"themes/hexo-theme-butterfly/layout/404.pug","hash":"10ce9b0764d975460069bf116bfceaaeb9691d3a","modified":1609843424920},{"_id":"themes/hexo-theme-butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1609843424920},{"_id":"themes/hexo-theme-butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1609843424921},{"_id":"themes/hexo-theme-butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1609843424957},{"_id":"themes/hexo-theme-butterfly/layout/page.pug","hash":"76536c903cabc8e4619759e3a8b6a384c0518716","modified":1609843424957},{"_id":"themes/hexo-theme-butterfly/layout/post.pug","hash":"0277577f7fce2b830259e29d3a2a82f35addbf78","modified":1609843424957},{"_id":"themes/hexo-theme-butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1609843424958},{"_id":"themes/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1609843424913},{"_id":"themes/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1609843424914},{"_id":"themes/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1609843424914},{"_id":"themes/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"924e1fefc81f33f165a5fa9856712a98e7c83ad5","modified":1609843424921},{"_id":"themes/hexo-theme-butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1609843424922},{"_id":"themes/hexo-theme-butterfly/layout/includes/head.pug","hash":"780566ea9155df8f503af4e80ec7eff10e00859a","modified":1609843424922},{"_id":"themes/hexo-theme-butterfly/layout/includes/layout.pug","hash":"b5f7e698ef44edd9227c0c0162c7270aac6bf031","modified":1609843424929},{"_id":"themes/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"012e46f5130a2ff312c28a4fcdc060195f92efde","modified":1609843424933},{"_id":"themes/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1609843424935},{"_id":"themes/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"86b2a4d500542fe764fdc5ff71cf029604325930","modified":1609843424936},{"_id":"themes/hexo-theme-butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1609843424959},{"_id":"themes/hexo-theme-butterfly/scripts/events/init.js","hash":"f7ab55363d05c945569d9ac4afc889f9706308c6","modified":1609843424959},{"_id":"themes/hexo-theme-butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1609843424960},{"_id":"themes/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"1e2ac4d26df7cd18a92f1404329f8eb1c388dc18","modified":1609843424960},{"_id":"themes/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"dbce193ba170e004790550fe4694de8e29b299b9","modified":1609843424960},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"d9cdeecfb0098ad9bf4814ea2f95167b637e015d","modified":1609843424961},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"ff3815e6923f248501ed76aebfa6e8e083edb9f7","modified":1609843424961},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/page.js","hash":"f42b2358a44d91ef6c853ce75f23af6e8d3ff423","modified":1609843424962},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"0745597f4ffadde037e57e0f66f7d984dc576dc6","modified":1609843424962},{"_id":"themes/hexo-theme-butterfly/scripts/tag/button.js","hash":"54c0c9c6d4d4ca754680cd24d7e204a745a6eec0","modified":1609843424963},{"_id":"themes/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1609843424963},{"_id":"themes/hexo-theme-butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1609843424964},{"_id":"themes/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1609843424964},{"_id":"themes/hexo-theme-butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1609843424964},{"_id":"themes/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1609843424965},{"_id":"themes/hexo-theme-butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1609843424985},{"_id":"themes/hexo-theme-butterfly/source/css/var.styl","hash":"ae8193bd0107c823b8d2a123f1c301084c9c227a","modified":1609843424985},{"_id":"themes/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1609843424986},{"_id":"themes/hexo-theme-butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1609843424986},{"_id":"themes/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1609843424986},{"_id":"themes/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1609843424987},{"_id":"themes/hexo-theme-butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1609843424987},{"_id":"themes/hexo-theme-butterfly/source/js/main.js","hash":"7663c364a78c6ec16509e75cdd3647c16b2dd0ec","modified":1609843424988},{"_id":"themes/hexo-theme-butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1609843424989},{"_id":"themes/hexo-theme-butterfly/source/js/utils.js","hash":"ba7e672a7bed2aefb9174e8122d92a643814272a","modified":1609843424990},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"767b425f97e74a98002f4a435e36e8ec27e8a994","modified":1609843424923},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1609843424923},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"afe703c766b8717d119379ee27037481f1165af8","modified":1609843424924},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"e33b993af0bfc521334dac8e3c8a227dfbf9fcaa","modified":1609843424924},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1609843424924},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/js.pug","hash":"473059d3a4a63fa95ea4d2ca71ae16c003502e0a","modified":1609843424925},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1609843424925},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"e73488c6d7849407d39f35aaffedb46646a4e1a5","modified":1609843424925},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1609843424926},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"1ddbd09e1902da7fa4bf7824654f132e41622c42","modified":1609843424926},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"9a6f8211cdcb4aa87ccb5fa4f62b89c245412c94","modified":1609843424927},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"d22d4c98028272dfc6c2e721e469f572a6b62ed3","modified":1609843424927},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"0060598ca1cf25619bdb110ea2c83c690e4d2939","modified":1609843424928},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"96c06a8bf0cb9a19ba32e207613c8f240fa71d26","modified":1609843424928},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1609843424928},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"81a34e9d642a68e77650609601a8096c6445daef","modified":1609843424930},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1609843424930},{"_id":"themes/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2beb27e33e4492fa80e88c37dcb7a3ffd7da9e24","modified":1609843424930},{"_id":"themes/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"90b5c2600569f8cf769c5fb3a37c12536f71e375","modified":1609843424931},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/artitalk.pug","hash":"a02e5d18f12844ac1fbfa04d03798ff9e73090bc","modified":1609843424931},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1609843424932},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1609843424932},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"7e7832aafdf5ca50e71a039ad3fc98d8ef6e7d30","modified":1609843424932},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1609843424933},{"_id":"themes/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1609843424934},{"_id":"themes/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"d9b96f24c2439f263a606fd38a5517bd4bb162b7","modified":1609843424934},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1609843424936},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/baidu_push.pug","hash":"d3490e78bd2569423dc1844b9db0fbb6cd855022","modified":1609843424936},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1609843424944},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"21a7f17ff457c0cf8747f0847dee6df675482574","modified":1609843424948},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"38504aec959c050c082db1c5aeaf99345f97bbee","modified":1609843424949},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1609843424949},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"e0e8bf00ef7a0a62ea2265bd5e4a33d0edab5946","modified":1609843424952},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1609843424952},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1609843424953},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"51f3227814fd229ddb2c9a2dd75a4b8effee9ad5","modified":1609843424954},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"1708fb171403a77966c86408092dd0f7dde629ae","modified":1609843424953},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"92a5100eec2f10fe867a8a8f88d1e18fbd6d3b92","modified":1609843424954},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"cabf9ee6a2886e6ede17f224dfbb161a9b1258e7","modified":1609843424955},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1609843424955},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"ff6d8dfc187d6e5e6139bbf3e0d831dbe1e9a530","modified":1609843424955},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"b088fa11b89a05c2b49e6a27c2b862954e0b0ec2","modified":1609843424956},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_self.pug","hash":"8318c7c9a6aef966afba44e283111e7ff0b2f04f","modified":1609843424956},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1609843424956},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"6f92420429cded52255c165007b9f88910f36022","modified":1609843424956},{"_id":"themes/hexo-theme-butterfly/source/css/_global/function.styl","hash":"56ce639b394ba195207ee00f5a2d6f22926b403f","modified":1609843424966},{"_id":"themes/hexo-theme-butterfly/source/css/_global/index.styl","hash":"cfafb671a6ebad792e3636f03081f36e9799a5df","modified":1609843424967},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"d67ecb6c950e802a9c73975b13cab44f899eb192","modified":1609843424967},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1609843424970},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/404.styl","hash":"84c14368d3fab66d5fb7d03678766274e2e0d84f","modified":1609843424971},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"b3bed148ec524b80377e34c11a4a55d1d8e8145e","modified":1609843424971},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1609843424971},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1609843424973},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1609843424973},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"9e66e9672eb6d60950024d5f73cb7b925b2549b2","modified":1609843424973},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1609843424973},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"c4ae9292d6b7e42943b1b11e109ed560dc3a7753","modified":1609843424974},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"6c74997b89984db3696572efc7cbafdf59ce7803","modified":1609843424974},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"ba391266cd967fa96109677455dd6701292afd52","modified":1609843424974},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"d6149c50ad33b3feb3da8a9d0b9e6557d1137210","modified":1609843424975},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"e00d34774a0d5644bae9989f0e89743b5f9e2ea5","modified":1609843424976},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"78ef182c0f6711c8491a8ee421b708c8f2a63c30","modified":1609843424976},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"dc3a203aebff1420a0661f923a5001ef513f63ac","modified":1609843424976},{"_id":"themes/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"767a0de8c54a67f679b36a86598d77f813f7db06","modified":1609843424977},{"_id":"themes/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"cd50ccb2ebb0e4282298ce3a7e7073c327759eb0","modified":1609843424977},{"_id":"themes/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1609843424978},{"_id":"themes/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1609843424978},{"_id":"themes/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4058ab759577efe280d5e38902be39054ed4b471","modified":1609843424979},{"_id":"themes/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"3c7a7efbb14d8ce6538f612992aa1a62fd278991","modified":1609843424979},{"_id":"themes/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"75c87cb69b2eb2a219eec9447cd79282ef612a68","modified":1609843424980},{"_id":"themes/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1609843424980},{"_id":"themes/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"a470029a157fbb8406ff72322a75ef63d6675431","modified":1609843424980},{"_id":"themes/hexo-theme-butterfly/source/css/_search/index.styl","hash":"202b01db6ef3cca9e5a173e1a0dadfee8854a849","modified":1609843424981},{"_id":"themes/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"92aa84cdec97729c86ba4674a355496eb37c986a","modified":1609843424981},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"5fe4235c038ed128819bd6918cd0781b372b598e","modified":1609843424982},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1609843424982},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1609843424982},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1609843424983},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1609843424983},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1609843424983},{"_id":"themes/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1609843424983},{"_id":"themes/hexo-theme-butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1609843424989},{"_id":"themes/hexo-theme-butterfly/source/js/search/local-search.js","hash":"3234942decaa1fde5b872766d4943a2e8cb9ef72","modified":1609843424989},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1609843424937},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1609843424937},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1609843424937},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1609843424938},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1609843424939},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1609843424939},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"663a298253eddb5126ca1a6139d69c7097ffb52e","modified":1609843424939},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"47d5367d8308a5a134058f9f63c33c75890960f8","modified":1609843424940},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"9b6b7b589ef7a8109d88ba439b2d8baf7286b961","modified":1609843424940},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"a8d8be37236400508e97f75615f03cedccacddfb","modified":1609843424940},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1609843424941},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"c90cc8aab51dc3fb139335290b3c3a1aa38cb586","modified":1609843424941},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1609843424941},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"a715b6f69e477aec9f9f62afc24b9330726adb54","modified":1609843424942},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1609843424942},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"96f04c0e7a5dfc1980e69f9b0bf277342de6e303","modified":1609843424943},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"1060d8e9258a55d7d453f49d9f78ad692f416221","modified":1609843424943},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"0322d640fd6a91853dec3ad39cc24c9b1291322b","modified":1609843424944},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"407d88e4af099d5f1a3f44623ec276c999219ec3","modified":1609843424944},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"6f92311afe60ca5f44055016db9cecce8fb2dc62","modified":1609843424944},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1609843424945},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"7ced4e62fc669b00c30bf5ffe814bd30d963a490","modified":1609843424946},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"732f4ebf7a1be1c94917dec426acaa494348c0ef","modified":1609843424946},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"7935e92db64ca047d94404e5fc390a207e857a87","modified":1609843424947},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"f34ca24c03a9733bee253971ab69288d59b9969d","modified":1609843424947},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"1a5da17848c6852fbbc5df6f6bb178c9b6a31085","modified":1609843424947},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"5d2e411a6938677d70dd2a0241bd6d2b771f0b28","modified":1609843424948},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1609843424951},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1609843424951},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"0622e955f3d2efef457f61d0cec0408376bd180a","modified":1609843424951},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1609843424952},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1609843424949},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1609843424950},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1609843424950},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"ba3bdf02a6c78b15eada95638173a11445dac7ac","modified":1609843424968},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"1b2dc0ef768c9be9f18d1c1f93d88f916482c5df","modified":1609843424969},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1609843424969},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"ebae44a37ac143f4e35523ebd6809371958fb930","modified":1609843424970},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"c1747b8641303a1d9472ec94f2bc654885feb270","modified":1609843424970},{"_id":"source/_posts/.vscode/settings.json","hash":"ba7cd1c4d9258631c2dd525ff797cbb78da8250e","modified":1609843626940},{"_id":"source/cover/img100.jpg","hash":"a1d505005b78b64a662337c19563a2092701deed","modified":1588931083340},{"_id":"source/cover/img101.jpg","hash":"128d477046a09228cc81687a98ba86e9be6267c9","modified":1588931083341},{"_id":"source/cover/img84.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1588931083506},{"_id":"source/cover/img86.jpg","hash":"7a7b07f27672b73fd14262836d2949a6b81c13d4","modified":1588931083508},{"_id":"source/cover/img91.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1588931083513},{"_id":"source/cover/img92.jpg","hash":"8c5b2bb1012026b907c2d373523500aae774ba39","modified":1588931083514},{"_id":"source/cover/img93.jpg","hash":"d5dc73161d76f70070894803f656fd165d3c06d4","modified":1588931083515},{"_id":"source/cover/img95.jpg","hash":"6226a5462b7f020c1c6f00cc35f6ad9d5c83f60c","modified":1588931083518},{"_id":"source/cover/img99.jpg","hash":"1a73da5187dd39502fdfbccbf5be67242b25285f","modified":1588931083521},{"_id":"source/cover/img102.jpg","hash":"2869ee2611f99d02019802cee8db70162ac19391","modified":1588931083342},{"_id":"source/cover/img103.jpg","hash":"ff418bfdf3da9ee70bab1aa26306c8acbb62b582","modified":1588931083343},{"_id":"source/cover/img42.jpg","hash":"aea9453168d0e085975de9c1b8f390ded5fe4652","modified":1588931083416},{"_id":"source/cover/img49.jpg","hash":"92ae45a33edfc6158d25c602b684117ad5ec17af","modified":1588931083428},{"_id":"source/cover/img59.jpg","hash":"3fbaa6878c25498d37e469edb2eeab806364ce42","modified":1588931083450},{"_id":"source/cover/img60.jpg","hash":"7efd9ff40d9578251e3c7d740762f102bd846f82","modified":1588931083453},{"_id":"source/cover/img72.jpg","hash":"105fc2a3d1127f8705bea82efb6c59402d23aed5","modified":1588931083481},{"_id":"source/cover/img77.jpg","hash":"f891cdf167d4abc6b7cea6eb6d434ba4d46f5f98","modified":1588931083491},{"_id":"source/cover/img85.jpg","hash":"f023eb09a94e10f006ac98f0aa94d960ed814f8f","modified":1588931083507},{"_id":"source/cover/img87.jpg","hash":"45a156fb0c141d2c1b6ef4099dfd5bec93f12759","modified":1588931083509},{"_id":"source/cover/img88.jpg","hash":"01de4f788f32df6f758a68394e80d72909cddda8","modified":1588931083510},{"_id":"source/cover/img89.jpg","hash":"1cf54256ad251f96b6d2ca00d56b4b46107007c0","modified":1588931083510},{"_id":"source/cover/img90.jpg","hash":"db53e6201cf2ff4e7c27e9e0ae27c788d634c6e5","modified":1588931083513},{"_id":"source/cover/img94.jpg","hash":"e118fcfeb53c40ebbfc86654f8f6360bb70687c7","modified":1588931083517},{"_id":"source/cover/img96.jpg","hash":"107c3f313b6e0c8ae3687eeaf2d981c53c07b52f","modified":1588931083519},{"_id":"source/cover/img98.jpg","hash":"8499e0602671c001678c5909dd0b5c519ae368b4","modified":1588931083520},{"_id":"source/cover/img97.jpg","hash":"fa7ee526dd2bfb57718827aaaea1616522b4cf0b","modified":1588931083519},{"_id":"source/cover/img10.jpg","hash":"f6fe547ddcf9f4522e0cd53caf68dccfe4eecf7c","modified":1588931083340},{"_id":"source/cover/img16.jpg","hash":"acf5a7ed28f36c0a36f6d215bf9bf81419553458","modified":1588931083360},{"_id":"source/cover/img19.jpg","hash":"256f0ff9b673f78b2ebba52673400a75475f6cbe","modified":1588931083366},{"_id":"source/cover/img2.jpg","hash":"524c57c6096ff43f8d61f3b070165cf2a0876094","modified":1588931083368},{"_id":"source/cover/img2.png","hash":"4b6bf0531edfef1c6f86f587474f96134ad16644","modified":1588931083369},{"_id":"source/cover/img3.jpg","hash":"d2084ff7b1443dffc8dc015bf525a47f3c138a03","modified":1588931083392},{"_id":"source/cover/img32.jpg","hash":"87745dbc48d71f90c6cb2c12faa7a51e133b880a","modified":1588931083396},{"_id":"source/cover/img39.jpg","hash":"abcf23665b924cd7766a732586813ac8ecafae24","modified":1588931083410},{"_id":"source/cover/img41.jpg","hash":"019e6a1a12affbb94014bf3288ee04d6dad175bd","modified":1588931083415},{"_id":"source/cover/img43.jpg","hash":"454eb775ff0cbbec74688c9d8ce310938c01bef8","modified":1588931083418},{"_id":"source/cover/img46.jpg","hash":"02a33f09beb81d8f9e8c68708d5c214244e8e886","modified":1588931083424},{"_id":"source/cover/img51.jpg","hash":"4e28760a82af5ec8b55b4d6d0a9e082f8ec3eaa1","modified":1588931083435},{"_id":"source/cover/img53.jpg","hash":"b2e82a4d062da593eed265abdc42a5cb1b6f01cc","modified":1588931083438},{"_id":"source/cover/img54.jpg","hash":"4223492bd8e67c9d0c02a4834fe72f86391c75bd","modified":1588931083440},{"_id":"source/cover/img58.jpg","hash":"f3d164c98aef2f2d0614a51fafb949242cdf7861","modified":1588931083448},{"_id":"source/cover/img6.jpg","hash":"a4de0f5470b6591a5f157de6142408bb29abad15","modified":1588931083452},{"_id":"source/cover/img61.jpg","hash":"66caeb1741ff3dfb16e08b48ff094f69e1137be4","modified":1588931083454},{"_id":"source/cover/img63.jpg","hash":"65388a316a804f609ba8baf701d9d31d99714d7f","modified":1588931083458},{"_id":"source/cover/img7.jpg","hash":"e4bdad496612865336a49c3830daf7f63c3943de","modified":1588931083476},{"_id":"source/cover/img70.jpg","hash":"7f10838eb2237314a91b0e490ddc72c218c5d320","modified":1588931083478},{"_id":"source/cover/img82.jpg","hash":"0998b64c59e30520179bff33b8689b90044cceef","modified":1588931083504},{"_id":"source/cover/img11.jpg","hash":"8f9f3b9c14bb54b280e14ae29d792c33076fda84","modified":1588931083344},{"_id":"source/cover/img21.jpg","hash":"ae7be5ed01fdae812a8f861425c4f1602b49155e","modified":1588931083374},{"_id":"source/cover/img23.jpg","hash":"39670a257584e60cb661ff0a83f0550648e0bdf8","modified":1588931083378},{"_id":"source/cover/img26.jpg","hash":"33371e319195f1daa4204e39bbfcb893606b2e1a","modified":1588931083384},{"_id":"source/cover/img29.jpg","hash":"32d681874233f5bc0ceb8ccf6a47e85de562a5f4","modified":1588931083391},{"_id":"source/cover/img30.jpg","hash":"f2b449b4e9b5ccc54ec1b03239ee484aecf61257","modified":1588931083394},{"_id":"source/cover/img31.jpg","hash":"0d0b03e70781af33752cada32b6d7ebad6bed593","modified":1588931083395},{"_id":"source/cover/img34.jpg","hash":"9fe5e99a9cac8e208a4676f4012934f9adc8eb4f","modified":1588931083401},{"_id":"source/cover/img35.jpg","hash":"aebdf2870305c60899d70ab528e2a9ff269f1d4e","modified":1588931083402},{"_id":"source/cover/img37.jpg","hash":"efda0ac5c50f95d1bd43e6cc3818c68371de3af0","modified":1588931083407},{"_id":"source/cover/img38.jpg","hash":"7ba9401279c0f7a4198bdba95b0e1132e9b8e5b5","modified":1588931083409},{"_id":"source/cover/img4.jpg","hash":"814c8303e45ff71f27e8607d515bdaad3fc8460e","modified":1588931083412},{"_id":"source/cover/img40.jpg","hash":"495071c77bf821edf27c71e37dac60c59f4cfe50","modified":1588931083413},{"_id":"source/cover/img48.jpg","hash":"a1d037607fe8c55a18b0df004d82eae6427b183a","modified":1588931083427},{"_id":"source/cover/img47.jpg","hash":"ab6b209923b0a12235766570d68c3b60e1d6759a","modified":1588931083426},{"_id":"source/cover/img50.jpg","hash":"995cd5d2e5bb8e6469025e10e80ffbaa7a609e77","modified":1588931083433},{"_id":"source/cover/img52.jpg","hash":"5eaa2893e04d23e544cc8645b1293b5e128d0fca","modified":1588931083436},{"_id":"source/cover/img55.jpg","hash":"aad1976fdcde03395bdd91015572fcdcd958fdcb","modified":1588931083442},{"_id":"source/cover/img64.jpg","hash":"b3471bed04e587574fcaa46932270d4f6d259d02","modified":1588931083460},{"_id":"source/cover/img65.jpg","hash":"719d14d7fa450142f03c0b56e71f4c8c33a0ef96","modified":1588931083461},{"_id":"source/cover/img68.jpg","hash":"691ca4cc80e6e581dfd547a333e2a685734ea048","modified":1588931083473},{"_id":"source/cover/img71.jpg","hash":"152d1f6ce6415207a53e10e09d27d1e6d5fbb71c","modified":1588931083480},{"_id":"source/cover/img76.jpg","hash":"b4749958cae12a01c2b8f7310bc2accf12c3d5f4","modified":1588931083489},{"_id":"source/cover/img79.jpg","hash":"3c599e665d669a36b9fedefc898b8ee3ea110d62","modified":1588931083495},{"_id":"source/cover/img80.jpg","hash":"d72b97457e91a54f45df653d3dc83f6e6445c394","modified":1588931083500},{"_id":"source/cover/img81.jpg","hash":"25262b33d00f581aa176099c2dcb0b4fff57537c","modified":1588931083502},{"_id":"source/cover/img9.jpg","hash":"411c999655559df47ce7733b0a9489adb594d550","modified":1588931083512},{"_id":"source/cover/img1.jpg","hash":"76977f264e6ffe588ee803fdeb5b46dc143de70c","modified":1588931083336},{"_id":"source/cover/img13.jpg","hash":"5feaf1a92a25db3d5914e559d9a9d5653895f96f","modified":1588931083349},{"_id":"source/cover/img15.jpg","hash":"3013d423517be3d6c4d0c60d079af27547080175","modified":1588931083358},{"_id":"source/cover/img20.jpg","hash":"64222fbd6980078546dfb3d13ee7b6457b85a1aa","modified":1588931083372},{"_id":"source/cover/img22.jpg","hash":"a4678d65efec9e2d62c63d2492d9808e332ea96b","modified":1588931083377},{"_id":"source/cover/img24.jpg","hash":"1c2e7305e718d07b6f9859794451154149575f46","modified":1588931083380},{"_id":"source/cover/img25.jpg","hash":"f1d457db29eaed235e837f851b1c088cb3adc883","modified":1588931083382},{"_id":"source/cover/img28.jpg","hash":"a131a70863b8b2b1d3da23c6309935fafe1b1c3d","modified":1588931083390},{"_id":"source/cover/img36.jpg","hash":"ddf85d6ebd01455c340bd5842f9cf962f19e6b1a","modified":1588931083405},{"_id":"source/cover/img44.jpg","hash":"af282e240fad7c5610be1ea1ac83be46e8e260cf","modified":1588931083421},{"_id":"source/cover/img75.jpg","hash":"9f4d31a453f84a3cb6f77653800197e3e8d8e3ae","modified":1588931083488},{"_id":"source/cover/img8.jpg","hash":"d8df1416b30e70da2d6a6ae16c08d969693787ad","modified":1588931083498},{"_id":"source/cover/img12.jpg","hash":"e3bd470ec5051891864a882b3489626000d3b2e8","modified":1588931083346},{"_id":"source/cover/img17.jpg","hash":"ee18ec6c5fa554ce3ffc2a29c9266304b0a6c486","modified":1588931083362},{"_id":"source/cover/img18.jpg","hash":"2b5270beab1df53147febbcbd1ae736271cf7ce2","modified":1588931083364},{"_id":"source/cover/img45.jpg","hash":"2e542e1d2fed0bf4e2e57ba742b090c84321ce3f","modified":1588931083423},{"_id":"source/cover/img69.jpg","hash":"948cd729a613e9341af7c37bab585fb5ac19c85d","modified":1588931083475},{"_id":"source/cover/img73.jpg","hash":"21f32c4e676260681ed24235deacd04d5486856f","modified":1588931083483},{"_id":"source/cover/img83.jpg","hash":"eee8e2cadc8ac2ee192b9b10ebd22172b0b4c294","modified":1588931083506},{"_id":"source/cover/img1.png","hash":"8342602c9c639b562393b3b6c3d9406b682956f5","modified":1588931083338},{"_id":"source/cover/img33.jpg","hash":"287f25151a159fa157b6c74f8178d501538463d8","modified":1588931083399},{"_id":"source/cover/img57.jpg","hash":"23bd5c90ed4c759ade026809069b1e9519bda970","modified":1588931083446},{"_id":"source/cover/img56.jpg","hash":"906df206b77d00c6815fada62236ff99ed7550f6","modified":1588931083445},{"_id":"source/cover/img67.jpg","hash":"a2c4fdd119d3bc0bf6dcd8f04bba67fc62e15b62","modified":1588931083472},{"_id":"source/cover/img74.jpg","hash":"87b1e6a1531b906c8b2f6607b33573a8cad86b03","modified":1588931083486},{"_id":"source/cover/img78.jpg","hash":"43d5e4baa62349004fd70709d302bcf43bc6fe71","modified":1588931083492},{"_id":"source/cover/img27.jpg","hash":"acfd44755ebf9e8098df99dd6d21714f2e0ef41c","modified":1588931083388},{"_id":"source/cover/img62.jpg","hash":"0fe6bd960118d0d3c2e1d52e9487127ed3302b7e","modified":1588931083457},{"_id":"source/cover/img5.jpg","hash":"b21012fab284b4893c1f74b1db439d11f640ac5c","modified":1588931083431},{"_id":"source/cover/img14.jpg","hash":"4737d1db939cff23e1a94aa8bf469d4bc5461041","modified":1588931083356},{"_id":"source/cover/img66.jpg","hash":"e3fdb5d66c203030720dc9c64ed1b10002a018b6","modified":1588931083469},{"_id":"public/cover/img100.jpg","hash":"a1d505005b78b64a662337c19563a2092701deed","modified":1609848031916},{"_id":"public/cover/img101.jpg","hash":"128d477046a09228cc81687a98ba86e9be6267c9","modified":1609848031916},{"_id":"public/cover/img84.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1609848031916},{"_id":"public/cover/img86.jpg","hash":"7a7b07f27672b73fd14262836d2949a6b81c13d4","modified":1609848031916},{"_id":"public/cover/img91.jpg","hash":"b3b599c9d20fd85a12e4081a5bfb89cfc3771274","modified":1609848031916},{"_id":"public/cover/img92.jpg","hash":"8c5b2bb1012026b907c2d373523500aae774ba39","modified":1609848031916},{"_id":"public/cover/img93.jpg","hash":"d5dc73161d76f70070894803f656fd165d3c06d4","modified":1609848031916},{"_id":"public/cover/img95.jpg","hash":"6226a5462b7f020c1c6f00cc35f6ad9d5c83f60c","modified":1609848031916},{"_id":"public/cover/img99.jpg","hash":"1a73da5187dd39502fdfbccbf5be67242b25285f","modified":1609848031916},{"_id":"public/cover/img102.jpg","hash":"2869ee2611f99d02019802cee8db70162ac19391","modified":1609848031916},{"_id":"public/cover/img103.jpg","hash":"ff418bfdf3da9ee70bab1aa26306c8acbb62b582","modified":1609848031916},{"_id":"public/cover/img42.jpg","hash":"aea9453168d0e085975de9c1b8f390ded5fe4652","modified":1609848031916},{"_id":"public/cover/img49.jpg","hash":"92ae45a33edfc6158d25c602b684117ad5ec17af","modified":1609848031916},{"_id":"public/cover/img59.jpg","hash":"3fbaa6878c25498d37e469edb2eeab806364ce42","modified":1609848031916},{"_id":"public/cover/img60.jpg","hash":"7efd9ff40d9578251e3c7d740762f102bd846f82","modified":1609848031916},{"_id":"public/cover/img72.jpg","hash":"105fc2a3d1127f8705bea82efb6c59402d23aed5","modified":1609848031916},{"_id":"public/cover/img77.jpg","hash":"f891cdf167d4abc6b7cea6eb6d434ba4d46f5f98","modified":1609848031916},{"_id":"public/cover/img85.jpg","hash":"f023eb09a94e10f006ac98f0aa94d960ed814f8f","modified":1609848031916},{"_id":"public/cover/img87.jpg","hash":"45a156fb0c141d2c1b6ef4099dfd5bec93f12759","modified":1609848031916},{"_id":"public/cover/img88.jpg","hash":"01de4f788f32df6f758a68394e80d72909cddda8","modified":1609848031916},{"_id":"public/cover/img89.jpg","hash":"1cf54256ad251f96b6d2ca00d56b4b46107007c0","modified":1609848031916},{"_id":"public/cover/img90.jpg","hash":"db53e6201cf2ff4e7c27e9e0ae27c788d634c6e5","modified":1609848031916},{"_id":"public/cover/img94.jpg","hash":"e118fcfeb53c40ebbfc86654f8f6360bb70687c7","modified":1609848031916},{"_id":"public/cover/img96.jpg","hash":"107c3f313b6e0c8ae3687eeaf2d981c53c07b52f","modified":1609848031916},{"_id":"public/cover/img97.jpg","hash":"fa7ee526dd2bfb57718827aaaea1616522b4cf0b","modified":1609848031916},{"_id":"public/cover/img98.jpg","hash":"8499e0602671c001678c5909dd0b5c519ae368b4","modified":1609848031916},{"_id":"public/cover/img16.jpg","hash":"acf5a7ed28f36c0a36f6d215bf9bf81419553458","modified":1609848031916},{"_id":"public/cover/img2.png","hash":"4b6bf0531edfef1c6f86f587474f96134ad16644","modified":1609848031916},{"_id":"public/cover/img2.jpg","hash":"524c57c6096ff43f8d61f3b070165cf2a0876094","modified":1609848031916},{"_id":"public/cover/img19.jpg","hash":"256f0ff9b673f78b2ebba52673400a75475f6cbe","modified":1609848031916},{"_id":"public/cover/img3.jpg","hash":"d2084ff7b1443dffc8dc015bf525a47f3c138a03","modified":1609848031916},{"_id":"public/cover/img32.jpg","hash":"87745dbc48d71f90c6cb2c12faa7a51e133b880a","modified":1609848031916},{"_id":"public/cover/img39.jpg","hash":"abcf23665b924cd7766a732586813ac8ecafae24","modified":1609848031916},{"_id":"public/cover/img41.jpg","hash":"019e6a1a12affbb94014bf3288ee04d6dad175bd","modified":1609848031916},{"_id":"public/cover/img43.jpg","hash":"454eb775ff0cbbec74688c9d8ce310938c01bef8","modified":1609848031916},{"_id":"public/cover/img46.jpg","hash":"02a33f09beb81d8f9e8c68708d5c214244e8e886","modified":1609848031916},{"_id":"public/cover/img51.jpg","hash":"4e28760a82af5ec8b55b4d6d0a9e082f8ec3eaa1","modified":1609848031916},{"_id":"public/cover/img53.jpg","hash":"b2e82a4d062da593eed265abdc42a5cb1b6f01cc","modified":1609848031916},{"_id":"public/cover/img54.jpg","hash":"4223492bd8e67c9d0c02a4834fe72f86391c75bd","modified":1609848031916},{"_id":"public/cover/img58.jpg","hash":"f3d164c98aef2f2d0614a51fafb949242cdf7861","modified":1609848031916},{"_id":"public/cover/img6.jpg","hash":"a4de0f5470b6591a5f157de6142408bb29abad15","modified":1609848031916},{"_id":"public/cover/img61.jpg","hash":"66caeb1741ff3dfb16e08b48ff094f69e1137be4","modified":1609848031916},{"_id":"public/cover/img63.jpg","hash":"65388a316a804f609ba8baf701d9d31d99714d7f","modified":1609848031916},{"_id":"public/cover/img7.jpg","hash":"e4bdad496612865336a49c3830daf7f63c3943de","modified":1609848031916},{"_id":"public/cover/img70.jpg","hash":"7f10838eb2237314a91b0e490ddc72c218c5d320","modified":1609848031916},{"_id":"public/cover/img82.jpg","hash":"0998b64c59e30520179bff33b8689b90044cceef","modified":1609848031916},{"_id":"public/cover/img11.jpg","hash":"8f9f3b9c14bb54b280e14ae29d792c33076fda84","modified":1609848031916},{"_id":"public/cover/img17.jpg","hash":"ee18ec6c5fa554ce3ffc2a29c9266304b0a6c486","modified":1609848031916},{"_id":"public/cover/img21.jpg","hash":"ae7be5ed01fdae812a8f861425c4f1602b49155e","modified":1609848031916},{"_id":"public/cover/img23.jpg","hash":"39670a257584e60cb661ff0a83f0550648e0bdf8","modified":1609848031916},{"_id":"public/cover/img26.jpg","hash":"33371e319195f1daa4204e39bbfcb893606b2e1a","modified":1609848031916},{"_id":"public/cover/img29.jpg","hash":"32d681874233f5bc0ceb8ccf6a47e85de562a5f4","modified":1609848031916},{"_id":"public/cover/img30.jpg","hash":"f2b449b4e9b5ccc54ec1b03239ee484aecf61257","modified":1609848031916},{"_id":"public/cover/img31.jpg","hash":"0d0b03e70781af33752cada32b6d7ebad6bed593","modified":1609848031916},{"_id":"public/cover/img34.jpg","hash":"9fe5e99a9cac8e208a4676f4012934f9adc8eb4f","modified":1609848031916},{"_id":"public/cover/img35.jpg","hash":"aebdf2870305c60899d70ab528e2a9ff269f1d4e","modified":1609848031916},{"_id":"public/cover/img37.jpg","hash":"efda0ac5c50f95d1bd43e6cc3818c68371de3af0","modified":1609848031916},{"_id":"public/cover/img38.jpg","hash":"7ba9401279c0f7a4198bdba95b0e1132e9b8e5b5","modified":1609848031916},{"_id":"public/cover/img4.jpg","hash":"814c8303e45ff71f27e8607d515bdaad3fc8460e","modified":1609848031916},{"_id":"public/cover/img40.jpg","hash":"495071c77bf821edf27c71e37dac60c59f4cfe50","modified":1609848031916},{"_id":"public/cover/img48.jpg","hash":"a1d037607fe8c55a18b0df004d82eae6427b183a","modified":1609848031916},{"_id":"public/cover/img47.jpg","hash":"ab6b209923b0a12235766570d68c3b60e1d6759a","modified":1609848031916},{"_id":"public/cover/img50.jpg","hash":"995cd5d2e5bb8e6469025e10e80ffbaa7a609e77","modified":1609848031916},{"_id":"public/cover/img52.jpg","hash":"5eaa2893e04d23e544cc8645b1293b5e128d0fca","modified":1609848031916},{"_id":"public/cover/img55.jpg","hash":"aad1976fdcde03395bdd91015572fcdcd958fdcb","modified":1609848031916},{"_id":"public/cover/img64.jpg","hash":"b3471bed04e587574fcaa46932270d4f6d259d02","modified":1609848031916},{"_id":"public/cover/img65.jpg","hash":"719d14d7fa450142f03c0b56e71f4c8c33a0ef96","modified":1609848031916},{"_id":"public/cover/img68.jpg","hash":"691ca4cc80e6e581dfd547a333e2a685734ea048","modified":1609848031916},{"_id":"public/cover/img71.jpg","hash":"152d1f6ce6415207a53e10e09d27d1e6d5fbb71c","modified":1609848031916},{"_id":"public/cover/img76.jpg","hash":"b4749958cae12a01c2b8f7310bc2accf12c3d5f4","modified":1609848031916},{"_id":"public/cover/img79.jpg","hash":"3c599e665d669a36b9fedefc898b8ee3ea110d62","modified":1609848031916},{"_id":"public/cover/img80.jpg","hash":"d72b97457e91a54f45df653d3dc83f6e6445c394","modified":1609848031916},{"_id":"public/cover/img81.jpg","hash":"25262b33d00f581aa176099c2dcb0b4fff57537c","modified":1609848031916},{"_id":"public/cover/img9.jpg","hash":"411c999655559df47ce7733b0a9489adb594d550","modified":1609848031916},{"_id":"public/cover/img10.jpg","hash":"f6fe547ddcf9f4522e0cd53caf68dccfe4eecf7c","modified":1609848031916},{"_id":"public/cover/img13.jpg","hash":"5feaf1a92a25db3d5914e559d9a9d5653895f96f","modified":1609848031916},{"_id":"public/cover/img12.jpg","hash":"e3bd470ec5051891864a882b3489626000d3b2e8","modified":1609848031916},{"_id":"public/cover/img15.jpg","hash":"3013d423517be3d6c4d0c60d079af27547080175","modified":1609848031916},{"_id":"public/cover/img24.jpg","hash":"1c2e7305e718d07b6f9859794451154149575f46","modified":1609848031916},{"_id":"public/cover/img22.jpg","hash":"a4678d65efec9e2d62c63d2492d9808e332ea96b","modified":1609848031916},{"_id":"public/cover/img20.jpg","hash":"64222fbd6980078546dfb3d13ee7b6457b85a1aa","modified":1609848031916},{"_id":"public/cover/img25.jpg","hash":"f1d457db29eaed235e837f851b1c088cb3adc883","modified":1609848031916},{"_id":"public/cover/img28.jpg","hash":"a131a70863b8b2b1d3da23c6309935fafe1b1c3d","modified":1609848031916},{"_id":"public/cover/img36.jpg","hash":"ddf85d6ebd01455c340bd5842f9cf962f19e6b1a","modified":1609848031916},{"_id":"public/cover/img44.jpg","hash":"af282e240fad7c5610be1ea1ac83be46e8e260cf","modified":1609848031916},{"_id":"public/cover/img75.jpg","hash":"9f4d31a453f84a3cb6f77653800197e3e8d8e3ae","modified":1609848031916},{"_id":"public/cover/img8.jpg","hash":"d8df1416b30e70da2d6a6ae16c08d969693787ad","modified":1609848031916},{"_id":"public/cover/img1.jpg","hash":"76977f264e6ffe588ee803fdeb5b46dc143de70c","modified":1609848031916},{"_id":"public/cover/img1.png","hash":"8342602c9c639b562393b3b6c3d9406b682956f5","modified":1609848031916},{"_id":"public/cover/img45.jpg","hash":"2e542e1d2fed0bf4e2e57ba742b090c84321ce3f","modified":1609848031916},{"_id":"public/cover/img69.jpg","hash":"948cd729a613e9341af7c37bab585fb5ac19c85d","modified":1609848031916},{"_id":"public/cover/img73.jpg","hash":"21f32c4e676260681ed24235deacd04d5486856f","modified":1609848031916},{"_id":"public/cover/img83.jpg","hash":"eee8e2cadc8ac2ee192b9b10ebd22172b0b4c294","modified":1609848031916},{"_id":"public/cover/img33.jpg","hash":"287f25151a159fa157b6c74f8178d501538463d8","modified":1609848031916},{"_id":"public/cover/img27.jpg","hash":"acfd44755ebf9e8098df99dd6d21714f2e0ef41c","modified":1609848031916},{"_id":"public/cover/img67.jpg","hash":"a2c4fdd119d3bc0bf6dcd8f04bba67fc62e15b62","modified":1609848031916},{"_id":"public/cover/img56.jpg","hash":"906df206b77d00c6815fada62236ff99ed7550f6","modified":1609848031916},{"_id":"public/cover/img74.jpg","hash":"87b1e6a1531b906c8b2f6607b33573a8cad86b03","modified":1609848031916},{"_id":"public/cover/img18.jpg","hash":"2b5270beab1df53147febbcbd1ae736271cf7ce2","modified":1609848031916},{"_id":"public/cover/img57.jpg","hash":"23bd5c90ed4c759ade026809069b1e9519bda970","modified":1609848031916},{"_id":"public/cover/img78.jpg","hash":"43d5e4baa62349004fd70709d302bcf43bc6fe71","modified":1609848031916},{"_id":"public/cover/img62.jpg","hash":"0fe6bd960118d0d3c2e1d52e9487127ed3302b7e","modified":1609848031916},{"_id":"public/cover/img5.jpg","hash":"b21012fab284b4893c1f74b1db439d11f640ac5c","modified":1609848031916},{"_id":"public/cover/img14.jpg","hash":"4737d1db939cff23e1a94aa8bf469d4bc5461041","modified":1609848031916},{"_id":"public/cover/img66.jpg","hash":"e3fdb5d66c203030720dc9c64ed1b10002a018b6","modified":1609848031916},{"_id":"source/categories/index.md","hash":"df4e5c4b4350bf53d1fe328b30d8b4d483bcaf2c","modified":1609848636591},{"_id":"source/tags/index.md","hash":"16b0b21447541bec7d8b478d8b3f5833423b087c","modified":1609896150612},{"_id":"public/categories/index.html","hash":"28146a1e726e0041b4b2ade6fdacc0b46bab9962","modified":1609911083332},{"_id":"public/tags/index.html","hash":"d1efb1124b1125e39718800748a7da73d1083499","modified":1609911083332},{"_id":"source/categories/index-1.md","hash":"5f892ea12b37e9efcf072d4bf5c837b32cc91bdb","modified":1609849006869},{"_id":"source/tags/index-1.md","hash":"72d3435852fc15498418bfecfb6c445b0862c87f","modified":1609849010830},{"_id":"source/categories/index-2.md","hash":"f7734fbb0de251e5088b80fc8a2414e42da04fb8","modified":1609849079493},{"_id":"source/tags/index-2.md","hash":"c5aa2dcd5443c03290ea959e93a67dfb16494f28","modified":1609849075448},{"_id":"source/_posts/Android/Rtmp/RTMP集成.md","hash":"fbaf73aa4c6afa3225c801d2610de875cf14c94c","modified":1609894750513},{"_id":"source/_posts/Other/Blog/相关资料.md","hash":"bc19e33c3f55ae67d1eadb28f798b510c8188aa6","modified":1609895249002},{"_id":"source/cover/img116.jpg","hash":"74aeda292f1fe190dbdd806d0975563e0d6a9b51","modified":1609893792705},{"_id":"source/cover/img118.jpg","hash":"6beb8326757db7438771f846faf09c3d26cf75f7","modified":1609893984154},{"_id":"source/cover/img124.jpg","hash":"c2d10ba6682a3e9f4d9e10d6b7e09fffce998de1","modified":1609894031317},{"_id":"source/cover/img119.jpg","hash":"4e8e992ea616f4d7e578aaf680b5f485e917d4df","modified":1609893961950},{"_id":"source/cover/img117.jpg","hash":"637c6d27b6b058d261925b768f3db3c88c868157","modified":1609893972248},{"_id":"source/cover/astronaut.jpg","hash":"9474e12adaa9939b6ae7df03ce592c2fa7b4062f","modified":1609893583964},{"_id":"source/cover/img114.jpg","hash":"a9506a8bb1c4c7eb33116ebf60337a269bea8ddb","modified":1609893841244},{"_id":"source/cover/img110.jpg","hash":"7cac9d352fbd2d1047304617a10f38edc59def73","modified":1609893844109},{"_id":"source/cover/img126.jpg","hash":"5546aaedcd3225d75f78ffd27c8e64d784d55ecf","modified":1609894077098},{"_id":"source/cover/img123.jpg","hash":"c6e84542b823455e43fdfbd43cec0f13d4ec828e","modified":1609894064160},{"_id":"source/cover/img120.jpg","hash":"3766caa553e0e77b2a1afab7c3c5671ea1247911","modified":1609893821354},{"_id":"source/cover/img130.jpg","hash":"5ff58969dba633b638857f1a70fc778cf2aee59b","modified":1609893913418},{"_id":"source/cover/img121.jpg","hash":"17f7ea2a8c644570d8004481a3a0d99a2151711c","modified":1609893901064},{"_id":"source/cover/img127.jpg","hash":"5940abd3a9d5b591daa53a75ee2d483eb2790c94","modified":1609893921673},{"_id":"source/cover/img108.jpg","hash":"ac7eed26494c144b7634f3cc848d26bb261f527a","modified":1609893886350},{"_id":"source/cover/img109.jpg","hash":"ac7eed26494c144b7634f3cc848d26bb261f527a","modified":1609850124360},{"_id":"source/cover/img104.jpg","hash":"1c5a739e3756a192e2ec371551063da77f462982","modified":1609894078766},{"_id":"source/cover/img122.jpg","hash":"bb3ac4e9ff095988e87f3a591cb4f5e52a6200b4","modified":1609894055404},{"_id":"source/cover/img129.jpg","hash":"42f6d1236372a693be5bf1e380d75ea59559ce40","modified":1609850074315},{"_id":"source/cover/img111.jpg","hash":"6ed6942bd96745978e8d35aa998a340e1f0a374c","modified":1609893894111},{"_id":"source/cover/img105.jpg","hash":"41d2e2cfafe268ce70f793f49b00de2832638a14","modified":1609894058601},{"_id":"source/cover/img115.jpg","hash":"729cf81a6bdab37d658edcc9a582ba50c523c65d","modified":1609893901619},{"_id":"source/cover/img113.jpg","hash":"dc614d83540e72b8db5accc052ee6ede3bca041e","modified":1609893930139},{"_id":"source/cover/img112.jpg","hash":"795209ebf7773a145f399e99aadda2dc0029c312","modified":1609893926075},{"_id":"source/cover/img106.jpg","hash":"44e5b80e83a0449c38ea0a3484ce9bf576ae2296","modified":1609893880686},{"_id":"source/cover/img125.jpg","hash":"16825b21b97107c5c81cbf5ad8b217b9285952d3","modified":1609893910101},{"_id":"source/cover/img107.jpg","hash":"008bb1ce614d13ccd2c8f14480a466e577c7808f","modified":1609893851729},{"_id":"source/cover/img128.jpg","hash":"64a92bb6e67922328bdaaa4092ef64befc939687","modified":1609893861476},{"_id":"public/tags/index-1.html","hash":"b7045c85141a010d1342846cf9ae193daa4fc410","modified":1609911083332},{"_id":"public/categories/index-1.html","hash":"65cba2af4cf41e09040460ef543a8760e08f0fae","modified":1609911083332},{"_id":"public/tags/index-2.html","hash":"5a259fa81c8505a41d59d564354db805fbbe4bf5","modified":1609911083332},{"_id":"public/categories/index-2.html","hash":"2dfb35f4c42fbd64b01049bdaf8357a213e6c738","modified":1609911083332},{"_id":"public/2020/12/11/Flutter/Flutter问题解决/index.html","hash":"00fb237a49c1fc54219eba8484ee7c79f83747ff","modified":1609910322067},{"_id":"public/2021/01/05/Other/Blog/相关资料/index.html","hash":"24b999eb1ae8993dd8ce9830dce33215d7076e78","modified":1609910322067},{"_id":"public/2020/12/10/Flutter/Flutter基础/index.html","hash":"7ee7eb0b2fd28bfa41a7b388399dd91a07c3173f","modified":1609910322067},{"_id":"public/2020/07/06/Android/框架/Retrofit/Retrofit 使用HTTPS请求/index.html","hash":"ccbf7d64a924704033ff799101e0343e761fd528","modified":1609910322067},{"_id":"public/2020/07/06/Android/Rtmp/RTMP集成/index.html","hash":"c5e8ffca1b2977b1fb7d825b375473e405dbf848","modified":1609910322067},{"_id":"public/2020/06/15/Android/Advanced/插件化/Android插桩/index.html","hash":"7de8692788b31d9583f2155e763e7f3563989064","modified":1609910322067},{"_id":"public/2020/05/30/Android/Advanced/基础/Android打包流程/index.html","hash":"aec0fbc3134a7c718090cdb6bfe5b81dc30f7634","modified":1609910322067},{"_id":"public/2019/10/11/Other/Computer/函数式编程/index.html","hash":"4cfde1fdea44cc811b2e231d53b1f84ace9cfe02","modified":1609910322067},{"_id":"public/2019/08/29/Java/设计模式/工厂模式/index.html","hash":"6f6edd8493efd0f2912b6c3fc7469510d099a191","modified":1609910322067},{"_id":"public/2019/08/20/Java/设计模式/代理模式/index.html","hash":"d7e97419e9ceb0157f7818117bea92b5e66ee1b1","modified":1609910322067},{"_id":"public/2019/06/15/Android/Android基础/Android常用的库/index.html","hash":"d941582e0c6afb9e2ebdeeb49ff6ee787c8998c7","modified":1609910322067},{"_id":"public/2019/05/16/Android/Android基础/Android集合/index.html","hash":"b2104fdfbdaeb5c11b9090a2adb99eea67e0c4a1","modified":1609910322067},{"_id":"public/2019/05/16/Android/Android基础/开发过程中注意问题/index.html","hash":"0f1dc782b4b280d308183fca293f4b73aa536cbd","modified":1609910322067},{"_id":"public/2019/05/12/Android/框架/Retrofit/Retrofit 基础/index.html","hash":"ff8fafa9ebcbf114951d1481d7cd6f86799538c6","modified":1609910322067},{"_id":"public/2018/07/25/C++/C++ 问题总结/index.html","hash":"63e7c3d072d3a23a629f45f512b200ff0134406f","modified":1609910322067},{"_id":"public/2017/09/25/C++/C++基础/index.html","hash":"908b7d35eb99f1799dfaf08dd8cd420dec7ef156","modified":1609910322067},{"_id":"public/archives/page/13/index.html","hash":"b5463194c2671c878d3104bb894a1efb0e460fb0","modified":1609895265890},{"_id":"public/archives/2017/09/index.html","hash":"ff536807140b35007dee6d5adc93dcea28a75613","modified":1609911083332},{"_id":"public/archives/2019/08/page/2/index.html","hash":"106e6c55b9e5da156196cb127ddcdd2b018c7308","modified":1609911083332},{"_id":"public/archives/2020/06/index.html","hash":"253e2e6d0911503ee79dfb0b3ca12cd07cba5ca4","modified":1609911083332},{"_id":"public/archives/2020/07/index.html","hash":"06f39e8a02c7bcee408a5b682d5229a7e89cd500","modified":1609911083332},{"_id":"public/archives/2021/01/index.html","hash":"963ed30e8558b8a7bb44b76795e3105cc4c966dc","modified":1609911083332},{"_id":"public/archives/2021/index.html","hash":"0f81870c24f74cdc417120619e8d66718a0b3a94","modified":1609911083332},{"_id":"public/categories/Android/page/7/index.html","hash":"bc4333f34935687c0d64d14e65fe29dbef3c935e","modified":1609911083332},{"_id":"public/categories/编程/index.html","hash":"e8d5d363fa5863b7416fc76579fc2a68a205cc21","modified":1609911083332},{"_id":"public/categories/Blog/index.html","hash":"4def4a380f0939d8f6394474289de451955a8323","modified":1609911083332},{"_id":"public/page/13/index.html","hash":"8896ea8e9f1c4078bac0dfa69b1f328990bd530a","modified":1609895265890},{"_id":"public/cover/img116.jpg","hash":"74aeda292f1fe190dbdd806d0975563e0d6a9b51","modified":1609895265890},{"_id":"public/cover/img118.jpg","hash":"6beb8326757db7438771f846faf09c3d26cf75f7","modified":1609895265890},{"_id":"public/cover/img124.jpg","hash":"c2d10ba6682a3e9f4d9e10d6b7e09fffce998de1","modified":1609895265890},{"_id":"public/cover/img117.jpg","hash":"637c6d27b6b058d261925b768f3db3c88c868157","modified":1609895265890},{"_id":"public/cover/img119.jpg","hash":"4e8e992ea616f4d7e578aaf680b5f485e917d4df","modified":1609895265890},{"_id":"public/cover/astronaut.jpg","hash":"9474e12adaa9939b6ae7df03ce592c2fa7b4062f","modified":1609895265890},{"_id":"public/cover/img114.jpg","hash":"a9506a8bb1c4c7eb33116ebf60337a269bea8ddb","modified":1609895265890},{"_id":"public/cover/img110.jpg","hash":"7cac9d352fbd2d1047304617a10f38edc59def73","modified":1609895265890},{"_id":"public/cover/img126.jpg","hash":"5546aaedcd3225d75f78ffd27c8e64d784d55ecf","modified":1609895265890},{"_id":"public/cover/img123.jpg","hash":"c6e84542b823455e43fdfbd43cec0f13d4ec828e","modified":1609895265890},{"_id":"public/cover/img120.jpg","hash":"3766caa553e0e77b2a1afab7c3c5671ea1247911","modified":1609895265890},{"_id":"public/cover/img130.jpg","hash":"5ff58969dba633b638857f1a70fc778cf2aee59b","modified":1609895265890},{"_id":"public/cover/img121.jpg","hash":"17f7ea2a8c644570d8004481a3a0d99a2151711c","modified":1609895265890},{"_id":"public/cover/img127.jpg","hash":"5940abd3a9d5b591daa53a75ee2d483eb2790c94","modified":1609895265890},{"_id":"public/cover/img109.jpg","hash":"ac7eed26494c144b7634f3cc848d26bb261f527a","modified":1609895265890},{"_id":"public/cover/img104.jpg","hash":"1c5a739e3756a192e2ec371551063da77f462982","modified":1609895265890},{"_id":"public/cover/img108.jpg","hash":"ac7eed26494c144b7634f3cc848d26bb261f527a","modified":1609895265890},{"_id":"public/cover/img122.jpg","hash":"bb3ac4e9ff095988e87f3a591cb4f5e52a6200b4","modified":1609895265890},{"_id":"public/cover/img129.jpg","hash":"42f6d1236372a693be5bf1e380d75ea59559ce40","modified":1609895265890},{"_id":"public/cover/img111.jpg","hash":"6ed6942bd96745978e8d35aa998a340e1f0a374c","modified":1609895265890},{"_id":"public/cover/img105.jpg","hash":"41d2e2cfafe268ce70f793f49b00de2832638a14","modified":1609895265890},{"_id":"public/cover/img113.jpg","hash":"dc614d83540e72b8db5accc052ee6ede3bca041e","modified":1609895265890},{"_id":"public/cover/img115.jpg","hash":"729cf81a6bdab37d658edcc9a582ba50c523c65d","modified":1609895265890},{"_id":"public/cover/img112.jpg","hash":"795209ebf7773a145f399e99aadda2dc0029c312","modified":1609895265890},{"_id":"public/cover/img106.jpg","hash":"44e5b80e83a0449c38ea0a3484ce9bf576ae2296","modified":1609895265890},{"_id":"public/cover/img125.jpg","hash":"16825b21b97107c5c81cbf5ad8b217b9285952d3","modified":1609895265890},{"_id":"public/cover/img107.jpg","hash":"008bb1ce614d13ccd2c8f14480a466e577c7808f","modified":1609895265890},{"_id":"public/cover/img128.jpg","hash":"64a92bb6e67922328bdaaa4092ef64befc939687","modified":1609895265890},{"_id":"source/_posts/Flutter/Flutter常用的开源库.md","hash":"41e9d7691f985ea9e73c04aee6faf8e2afd34e57","modified":1609897113505},{"_id":"public/2021/01/06/Flutter/Flutter常用的开源库/index.html","hash":"9c80f1e12b99e6878291b3affc31b1dcbb9bf0a1","modified":1609910322067}],"Category":[{"name":"数据结构","_id":"ckjju0m05000920uagwnqcjm7"},{"name":"PAT","_id":"ckjju0m0n001q20uagcxdaye5"},{"name":"Android","_id":"ckjju0m0v002g20ua6ka6fhqk"},{"name":"Java","_id":"ckjju0m1n005920uabpgq7sot"},{"name":"Kotlin","_id":"ckjju0m1y006n20ua298i63jo"},{"name":"Other","_id":"ckjju0m20007120uaazpf9aoj"},{"name":"函数式编程","_id":"ckjkq0y0d000l3wuahyq35pkz"},{"name":"编程","_id":"ckjkq16kl000n3wua5n6z1vep"},{"name":"Blog","_id":"ckjkq1lpv000p3wua8e3m0anx"}],"Data":[],"Page":[{"title":"categories","date":"2021-01-05T12:10:36.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-01-05 20:10:36\n---\n","updated":"2021-01-05T12:10:36.591Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckjjybjxt0000tsuafh3s1sei","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"tags","date":"2021-01-05T12:10:22.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-01-05 20:10:22\ntype: tags\n---\n","updated":"2021-01-06T01:22:30.612Z","path":"tags/index.html","_id":"ckjjybjxw0001tsua34wk8ycr","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"categories","date":"2021-01-05T12:16:46.000Z","_content":"","source":"categories/index-1.md","raw":"---\ntitle: categories\ndate: 2021-01-05 20:16:46\n---\n","updated":"2021-01-05T12:16:46.869Z","path":"categories/index-1.html","comments":1,"layout":"page","_id":"ckjjyjgfi000080ua6sz5d298","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"tags","date":"2021-01-05T12:16:50.000Z","_content":"","source":"tags/index-1.md","raw":"---\ntitle: tags\ndate: 2021-01-05 20:16:50\n---\n","updated":"2021-01-05T12:16:50.830Z","path":"tags/index-1.html","comments":1,"layout":"page","_id":"ckjjyjgfl000180ua54sp0977","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"tags","date":"2021-01-05T12:17:55.000Z","_content":"","source":"tags/index-2.md","raw":"---\ntitle: tags\ndate: 2021-01-05 20:17:55\n---\n","updated":"2021-01-05T12:17:55.448Z","path":"tags/index-2.html","comments":1,"layout":"page","_id":"ckjjykxe600003wua8ulc5u40","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"categories","date":"2021-01-05T12:17:59.000Z","_content":"","source":"categories/index-2.md","raw":"---\ntitle: categories\ndate: 2021-01-05 20:17:59\n---\n","updated":"2021-01-05T12:17:59.493Z","path":"categories/index-2.html","comments":1,"layout":"page","_id":"ckjjykxea00013wuahj7j3quy","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""}],"Post":[{"title":"C++ 问题总结","description":"C++问题总结","type":["Android"],"toc":true,"cover":"/cover/img106.jpg","date":"2018-07-24T16:00:00.000Z","_content":"\n\n## pthread和std::thread\n\n* `std::thread` 是ISO C++ 标准提供的特性，可以在C++ 11 编译下使用；`pthread` 是IEEE标准，而非C++ 标准的一部分。\n\n* 如果代码需要在多个平台下运行，则使用`std::thread`，如果没有多平台问题，则使用`pthread`。\n\n* `pthread`是POSIX的一部分，可以在多种 linux 系统下运行，但不能再Windows的native中调用\n\n* `pthread` 是C语言的API，在C语言中可以方便调用，但在C++中使用没有优势\n\n* `std::thread`是一个标准的C++ API，所以可以任何有C++ 编译器的系统中使用\n\n* `std::thread`是一个标准的C++ API，使得其不能在C语言中进行调用。 \n","source":"_posts/C++/C++ 问题总结.md","raw":"---\ntitle: \"C++ 问题总结\"\ndescription: \"C++问题总结\"\ntype: [Android]\ntoc: true\ncover:  /cover/img106.jpg\ncategories: Android\ndate: 2018/7/25\n---\n\n\n## pthread和std::thread\n\n* `std::thread` 是ISO C++ 标准提供的特性，可以在C++ 11 编译下使用；`pthread` 是IEEE标准，而非C++ 标准的一部分。\n\n* 如果代码需要在多个平台下运行，则使用`std::thread`，如果没有多平台问题，则使用`pthread`。\n\n* `pthread`是POSIX的一部分，可以在多种 linux 系统下运行，但不能再Windows的native中调用\n\n* `pthread` 是C语言的API，在C语言中可以方便调用，但在C++中使用没有优势\n\n* `std::thread`是一个标准的C++ API，所以可以任何有C++ 编译器的系统中使用\n\n* `std::thread`是一个标准的C++ API，使得其不能在C语言中进行调用。 \n","slug":"C++/C++ 问题总结","published":1,"updated":"2021-01-06T01:02:10.041Z","_id":"ckjju0m02000520ua5hie20hf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"pthread和std-thread\"><a href=\"#pthread和std-thread\" class=\"headerlink\" title=\"pthread和std::thread\"></a>pthread和std::thread</h2><ul>\n<li><p><code>std::thread</code> 是ISO C++ 标准提供的特性，可以在C++ 11 编译下使用；<code>pthread</code> 是IEEE标准，而非C++ 标准的一部分。</p>\n</li>\n<li><p>如果代码需要在多个平台下运行，则使用<code>std::thread</code>，如果没有多平台问题，则使用<code>pthread</code>。</p>\n</li>\n<li><p><code>pthread</code>是POSIX的一部分，可以在多种 linux 系统下运行，但不能再Windows的native中调用</p>\n</li>\n<li><p><code>pthread</code> 是C语言的API，在C语言中可以方便调用，但在C++中使用没有优势</p>\n</li>\n<li><p><code>std::thread</code>是一个标准的C++ API，所以可以任何有C++ 编译器的系统中使用</p>\n</li>\n<li><p><code>std::thread</code>是一个标准的C++ API，使得其不能在C语言中进行调用。 </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"pthread和std-thread\"><a href=\"#pthread和std-thread\" class=\"headerlink\" title=\"pthread和std::thread\"></a>pthread和std::thread</h2><ul>\n<li><p><code>std::thread</code> 是ISO C++ 标准提供的特性，可以在C++ 11 编译下使用；<code>pthread</code> 是IEEE标准，而非C++ 标准的一部分。</p>\n</li>\n<li><p>如果代码需要在多个平台下运行，则使用<code>std::thread</code>，如果没有多平台问题，则使用<code>pthread</code>。</p>\n</li>\n<li><p><code>pthread</code>是POSIX的一部分，可以在多种 linux 系统下运行，但不能再Windows的native中调用</p>\n</li>\n<li><p><code>pthread</code> 是C语言的API，在C语言中可以方便调用，但在C++中使用没有优势</p>\n</li>\n<li><p><code>std::thread</code>是一个标准的C++ API，所以可以任何有C++ 编译器的系统中使用</p>\n</li>\n<li><p><code>std::thread</code>是一个标准的C++ API，使得其不能在C语言中进行调用。 </p>\n</li>\n</ul>\n"},{"title":"C++ 基础","description":"C++开发基础","type":["Android"],"toc":true,"cover":"/cover/img107.jpg","date":"2017-09-24T16:00:00.000Z","_content":"\n## 指针\n\n```c++\n    // arr 表示一个数组，同时代表一个指针\n    int arr[] ={1,2,3};\n\n    int *p=arr;\n    //修改数组的第一个值\n    *p=4;\n    //修改数组第二个值\n    *(p+1)=5;\n\n```\n\n## 数组指针(也称为行指针)\n\n`int (*p)[n]` 首先p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n；执行p+1时，p要跨过n个整型数据的长度。\n\n```c++\n\n    int a[3][4];\n    int (*p)[4]; //该语句是定义一个数组指针，指向含四个元素的一维数组\n    p=a;         //将该二维数组的首地址赋值给p，也就是a[0]或&a[0][0];\n    p++:       //该语句执行过后，也就是 p=p+1; p跨过行 a[0][]指向了 a[1][];\n\n```\n\n\n\n## 指针数组\n\n```c++\n    int arr[] ={1,2,3};\n    int *p[3];\n    for(int i=0;i<3;i++){\n        p[i]=&arr[i];\n    }\n\n    printf(\"数组%d\",*p[0]);\n\n```\n\n## 指针函数\n\n带指针的函数，本质是一个函数。函数的返回值是某一类型的指针；\n\n```c++\n\n    //    void* wParam 表示传入的参数可以是任一类型，只需要是指针即可\n    int* int add_func(void* wParams){\n        printf(\"指针函数\");\n        int b=10;\n        int *c=&b;\n        return *c;\n    }\n\n```\n\n## 函数指针\n\n函数指针是指向函数的指针变量，即本质是一个指针变量\n\n```c++\n    //int(*f)表示返回值， int x表示方法的参数类型\n    int(*func)(int x); //声明一个函数指针\n\n    void point_func(int x){\n           printf(\"函数指针\");\n    }\n\n    int main(){\n        func=point_func;\n        //调用函数指针，会直接调用函数\n        func(10);\n        return 0;\n    }\n\n```\n\n\n## 结构体\n\n```c++\n\n    struct Student{\n        char name[50];\n        int age;\n    }student,a;  //结构变量student和a可以不定义，其为Student类型\n    student.age=10;\n\n    //使用typedf定义\n    typedef struct{\n        char name[50];\n        int age;\n    }Student;\n\n    //施工\n    struct Student student1;\n    student.age=10;\n\n```\n\n### 结构体大小\n\n当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。\n\n### 结构体存储原则\n\n1、结构体变量中成员的偏移量必须是成员大小的整数倍。\n2、结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。\n\n\n### 内存对齐\n\n对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，它就被称为自然对齐。\n\n## 共用体\n\n共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，凡是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方法。\n\n共用体占用的内存应足够存储共用体中最大的成员，其大小取决于最大的成员变量\n\n```c++\n    union Data{\n        int i;\n        float f;\n        char str[20];\n    }data;\n\n```\n\n## 动态库和静态库\n\n在Linux下，动态库后缀为 .so 静态库为 .a\n\n在Windows下，动态库后缀为 .dll 静态库为 .lib\n\n区别：\n\n1、静态库比较大，动态库比较小；\n2、静态库需要在编译时，被链接在目标代码中，动态库在运行时才会被加载到目标代码；静态库在运行时的速度快；\n3、静态库类似于Android中的Module,一旦打包APK需要重新进行编译；\n4、动态库类似于jar包，打包不需要重新进行编译；\n\n\n## C++类的构造\n\nC++的类用 .cpp表示\n\n\n\n\n","source":"_posts/C++/C++基础.md","raw":"---\ntitle: \"C++ 基础\"\ndescription: \"C++开发基础\"\ntype: [Android]\ntoc: true\ncover:  /cover/img107.jpg\ncategories: Android\ndate: 2017/9/25\n---\n\n## 指针\n\n```c++\n    // arr 表示一个数组，同时代表一个指针\n    int arr[] ={1,2,3};\n\n    int *p=arr;\n    //修改数组的第一个值\n    *p=4;\n    //修改数组第二个值\n    *(p+1)=5;\n\n```\n\n## 数组指针(也称为行指针)\n\n`int (*p)[n]` 首先p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n；执行p+1时，p要跨过n个整型数据的长度。\n\n```c++\n\n    int a[3][4];\n    int (*p)[4]; //该语句是定义一个数组指针，指向含四个元素的一维数组\n    p=a;         //将该二维数组的首地址赋值给p，也就是a[0]或&a[0][0];\n    p++:       //该语句执行过后，也就是 p=p+1; p跨过行 a[0][]指向了 a[1][];\n\n```\n\n\n\n## 指针数组\n\n```c++\n    int arr[] ={1,2,3};\n    int *p[3];\n    for(int i=0;i<3;i++){\n        p[i]=&arr[i];\n    }\n\n    printf(\"数组%d\",*p[0]);\n\n```\n\n## 指针函数\n\n带指针的函数，本质是一个函数。函数的返回值是某一类型的指针；\n\n```c++\n\n    //    void* wParam 表示传入的参数可以是任一类型，只需要是指针即可\n    int* int add_func(void* wParams){\n        printf(\"指针函数\");\n        int b=10;\n        int *c=&b;\n        return *c;\n    }\n\n```\n\n## 函数指针\n\n函数指针是指向函数的指针变量，即本质是一个指针变量\n\n```c++\n    //int(*f)表示返回值， int x表示方法的参数类型\n    int(*func)(int x); //声明一个函数指针\n\n    void point_func(int x){\n           printf(\"函数指针\");\n    }\n\n    int main(){\n        func=point_func;\n        //调用函数指针，会直接调用函数\n        func(10);\n        return 0;\n    }\n\n```\n\n\n## 结构体\n\n```c++\n\n    struct Student{\n        char name[50];\n        int age;\n    }student,a;  //结构变量student和a可以不定义，其为Student类型\n    student.age=10;\n\n    //使用typedf定义\n    typedef struct{\n        char name[50];\n        int age;\n    }Student;\n\n    //施工\n    struct Student student1;\n    student.age=10;\n\n```\n\n### 结构体大小\n\n当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。\n\n### 结构体存储原则\n\n1、结构体变量中成员的偏移量必须是成员大小的整数倍。\n2、结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。\n\n\n### 内存对齐\n\n对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，它就被称为自然对齐。\n\n## 共用体\n\n共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，凡是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方法。\n\n共用体占用的内存应足够存储共用体中最大的成员，其大小取决于最大的成员变量\n\n```c++\n    union Data{\n        int i;\n        float f;\n        char str[20];\n    }data;\n\n```\n\n## 动态库和静态库\n\n在Linux下，动态库后缀为 .so 静态库为 .a\n\n在Windows下，动态库后缀为 .dll 静态库为 .lib\n\n区别：\n\n1、静态库比较大，动态库比较小；\n2、静态库需要在编译时，被链接在目标代码中，动态库在运行时才会被加载到目标代码；静态库在运行时的速度快；\n3、静态库类似于Android中的Module,一旦打包APK需要重新进行编译；\n4、动态库类似于jar包，打包不需要重新进行编译；\n\n\n## C++类的构造\n\nC++的类用 .cpp表示\n\n\n\n\n","slug":"C++/C++基础","published":1,"updated":"2021-01-06T01:02:44.163Z","_id":"ckjju0m02000620ua87f22pie","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr 表示一个数组，同时代表一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[] =&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p=arr;</span><br><span class=\"line\"><span class=\"comment\">//修改数组的第一个值</span></span><br><span class=\"line\">*p=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">//修改数组第二个值</span></span><br><span class=\"line\">*(p+<span class=\"number\">1</span>)=<span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组指针-也称为行指针\"><a href=\"#数组指针-也称为行指针\" class=\"headerlink\" title=\"数组指针(也称为行指针)\"></a>数组指针(也称为行指针)</h2><p><code>int (*p)[n]</code> 首先p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n；执行p+1时，p要跨过n个整型数据的长度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">3</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> (*p)[<span class=\"number\">4</span>]; <span class=\"comment\">//该语句是定义一个数组指针，指向含四个元素的一维数组</span></span><br><span class=\"line\">p=a;         <span class=\"comment\">//将该二维数组的首地址赋值给p，也就是a[0]或&amp;a[0][0];</span></span><br><span class=\"line\">p++:       <span class=\"comment\">//该语句执行过后，也就是 p=p+1; p跨过行 a[0][]指向了 a[1][];</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[] =&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">    p[i]=&amp;arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;数组%d&quot;</span>,*p[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"指针函数\"><a href=\"#指针函数\" class=\"headerlink\" title=\"指针函数\"></a>指针函数</h2><p>带指针的函数，本质是一个函数。函数的返回值是某一类型的指针；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    void* wParam 表示传入的参数可以是任一类型，只需要是指针即可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"keyword\">int</span> <span class=\"title\">add_func</span><span class=\"params\">(<span class=\"keyword\">void</span>* wParams)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;指针函数&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *c=&amp;b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>函数指针是指向函数的指针变量，即本质是一个指针变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//int(*f)表示返回值， int x表示方法的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>(*func)(<span class=\"keyword\">int</span> x); <span class=\"comment\">//声明一个函数指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">point_func</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;函数指针&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    func=point_func;</span><br><span class=\"line\">    <span class=\"comment\">//调用函数指针，会直接调用函数</span></span><br><span class=\"line\">    func(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;student,a;  <span class=\"comment\">//结构变量student和a可以不定义，其为Student类型</span></span><br><span class=\"line\">student.age=<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用typedf定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;Student;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//施工</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">student1</span>;</span></span><br><span class=\"line\">student.age=<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"结构体大小\"><a href=\"#结构体大小\" class=\"headerlink\" title=\"结构体大小\"></a>结构体大小</h3><p>当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。</p>\n<h3 id=\"结构体存储原则\"><a href=\"#结构体存储原则\" class=\"headerlink\" title=\"结构体存储原则\"></a>结构体存储原则</h3><p>1、结构体变量中成员的偏移量必须是成员大小的整数倍。<br>2、结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</p>\n<h3 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h3><p>对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，它就被称为自然对齐。</p>\n<h2 id=\"共用体\"><a href=\"#共用体\" class=\"headerlink\" title=\"共用体\"></a>共用体</h2><p>共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，凡是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方法。</p>\n<p>共用体占用的内存应足够存储共用体中最大的成员，其大小取决于最大的成员变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Data</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;data;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"动态库和静态库\"><a href=\"#动态库和静态库\" class=\"headerlink\" title=\"动态库和静态库\"></a>动态库和静态库</h2><p>在Linux下，动态库后缀为 .so 静态库为 .a</p>\n<p>在Windows下，动态库后缀为 .dll 静态库为 .lib</p>\n<p>区别：</p>\n<p>1、静态库比较大，动态库比较小；<br>2、静态库需要在编译时，被链接在目标代码中，动态库在运行时才会被加载到目标代码；静态库在运行时的速度快；<br>3、静态库类似于Android中的Module,一旦打包APK需要重新进行编译；<br>4、动态库类似于jar包，打包不需要重新进行编译；</p>\n<h2 id=\"C-类的构造\"><a href=\"#C-类的构造\" class=\"headerlink\" title=\"C++类的构造\"></a>C++类的构造</h2><p>C++的类用 .cpp表示</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arr 表示一个数组，同时代表一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> arr[] =&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p=arr;</span><br><span class=\"line\"><span class=\"comment\">//修改数组的第一个值</span></span><br><span class=\"line\">*p=<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">//修改数组第二个值</span></span><br><span class=\"line\">*(p+<span class=\"number\">1</span>)=<span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组指针-也称为行指针\"><a href=\"#数组指针-也称为行指针\" class=\"headerlink\" title=\"数组指针(也称为行指针)\"></a>数组指针(也称为行指针)</h2><p><code>int (*p)[n]</code> 首先p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n；执行p+1时，p要跨过n个整型数据的长度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">3</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> (*p)[<span class=\"number\">4</span>]; <span class=\"comment\">//该语句是定义一个数组指针，指向含四个元素的一维数组</span></span><br><span class=\"line\">p=a;         <span class=\"comment\">//将该二维数组的首地址赋值给p，也就是a[0]或&amp;a[0][0];</span></span><br><span class=\"line\">p++:       <span class=\"comment\">//该语句执行过后，也就是 p=p+1; p跨过行 a[0][]指向了 a[1][];</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[] =&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">    p[i]=&amp;arr[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;数组%d&quot;</span>,*p[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"指针函数\"><a href=\"#指针函数\" class=\"headerlink\" title=\"指针函数\"></a>指针函数</h2><p>带指针的函数，本质是一个函数。函数的返回值是某一类型的指针；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    void* wParam 表示传入的参数可以是任一类型，只需要是指针即可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"keyword\">int</span> <span class=\"title\">add_func</span><span class=\"params\">(<span class=\"keyword\">void</span>* wParams)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;指针函数&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *c=&amp;b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>函数指针是指向函数的指针变量，即本质是一个指针变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//int(*f)表示返回值， int x表示方法的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>(*func)(<span class=\"keyword\">int</span> x); <span class=\"comment\">//声明一个函数指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">point_func</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;函数指针&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    func=point_func;</span><br><span class=\"line\">    <span class=\"comment\">//调用函数指针，会直接调用函数</span></span><br><span class=\"line\">    func(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;student,a;  <span class=\"comment\">//结构变量student和a可以不定义，其为Student类型</span></span><br><span class=\"line\">student.age=<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用typedf定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;Student;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//施工</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">student1</span>;</span></span><br><span class=\"line\">student.age=<span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"结构体大小\"><a href=\"#结构体大小\" class=\"headerlink\" title=\"结构体大小\"></a>结构体大小</h3><p>当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。</p>\n<h3 id=\"结构体存储原则\"><a href=\"#结构体存储原则\" class=\"headerlink\" title=\"结构体存储原则\"></a>结构体存储原则</h3><p>1、结构体变量中成员的偏移量必须是成员大小的整数倍。<br>2、结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</p>\n<h3 id=\"内存对齐\"><a href=\"#内存对齐\" class=\"headerlink\" title=\"内存对齐\"></a>内存对齐</h3><p>对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，它就被称为自然对齐。</p>\n<h2 id=\"共用体\"><a href=\"#共用体\" class=\"headerlink\" title=\"共用体\"></a>共用体</h2><p>共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，凡是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方法。</p>\n<p>共用体占用的内存应足够存储共用体中最大的成员，其大小取决于最大的成员变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Data</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;data;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"动态库和静态库\"><a href=\"#动态库和静态库\" class=\"headerlink\" title=\"动态库和静态库\"></a>动态库和静态库</h2><p>在Linux下，动态库后缀为 .so 静态库为 .a</p>\n<p>在Windows下，动态库后缀为 .dll 静态库为 .lib</p>\n<p>区别：</p>\n<p>1、静态库比较大，动态库比较小；<br>2、静态库需要在编译时，被链接在目标代码中，动态库在运行时才会被加载到目标代码；静态库在运行时的速度快；<br>3、静态库类似于Android中的Module,一旦打包APK需要重新进行编译；<br>4、动态库类似于jar包，打包不需要重新进行编译；</p>\n<h2 id=\"C-类的构造\"><a href=\"#C-类的构造\" class=\"headerlink\" title=\"C++类的构造\"></a>C++类的构造</h2><p>C++的类用 .cpp表示</p>\n"},{"title":"顺序栈的表示与实现","description":null,"type":["数据结构"],"cover":"/cover/img37.jpg","toc":true,"date":"2017-07-26T16:00:00.000Z","_content":"\nmodified: 2017-7-28\n本文采用C语言，利用结构体来实现顺序栈\n\n* 用于定义栈的大小，以及再栈满的时候，扩充栈\n<!--more-->\n```c\n#define STACK_SIZE 50\n#define STACK_INCREMENT 10\n```\n\n* 采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈\n\n```c\ntypedef struct {\n\tint stackSize;  //栈容量\n\tint *base;      //栈底指针\n\tint *top;       //栈顶指针\n}SqStack, *pStack;\n\n```\n\n* 初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针\n\n```c\nvoid initStack(pStack p) {\n\tp->base = (int *)malloc(STACK_SIZE * sizeof(int));\n\tif (p->base != NULL)\n\t{\n\t\tp->top = p->base;\n\t\tp->stackSize = STACK_SIZE;\n\t}\n\telse\n\t{\n\t\tprintf(\"分配内存失败\");\n\t}\n}\n\n```\n\n* 栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false\n\n```c\nbool isEmpty(pStack p) {\n\treturn p->top == p->base ? true : false;\n}\n```\n\n* 栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较\n\n```c\nbool isFull(pStack p) {\n\treturn (p->top - p->base) >= STACK_SIZE ? true : false;\n}\n\n```\n\n* 入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；\n\n```c\nvoid push(pStack p, int topElement) {\n\tint *q = NULL;\n\tif (isFull(p))\n\t{\n\t\tq = (int *)realloc(p->base, STACK_INCREMENT * sizeof(int));  // 重新调整内存块的大小\n\n\t\tp->base = q;\n\t\tp->stackSize = p->stackSize + STACK_INCREMENT;\n\t}\n\t*(p->top)++ = topElement;\n}\n\n```\n\n* 出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；\n\n```c\nvoid pop(pStack p, int *topElement) {\n\tif (isEmpty(p))\n\t{\n\t\tprintf(\"空栈\");\n\n\t}\n\n\tp->top--;\n\t*topElement = *p->top;\n}\n\n\n```\n\n* 求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一\n\n```c\nint getStackTop(SqStack s) {\n\tint topElement;\n\tif (isEmpty(&s))\n\t{\n\t\treturn 0;\n\t}\n\ttopElement = *(s.top - 1);\n\treturn topElement;\n\n}\n\n```\n\n* 清空栈，不断将让栈中元素出栈，直至栈空\n\n```c\nvoid clearStack(SqStack s) {\n\twhile (!isEmpty(&s))\n\t{\n\t\tint tmp;\n\t\tpop(&s, &tmp);\n\t}\n\n}\n```\n\n* 求栈当前大小\n\n```c\nint getStackLength(SqStack s) {\n\tint i = 0;\n\tint *q = s.top;\n\n\twhile (q != s.base)\n\t{\n\t\tq--;\n\t\ti++;\n\t}\n\treturn i;\n}\n```\n\n","source":"_posts/Data_Structure/2017-07-27-data-structure-stack.md","raw":"---\ntitle: 顺序栈的表示与实现\ndescription:\ntype: [数据结构]\ncover: /cover/img37.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/07/27\n---\n\nmodified: 2017-7-28\n本文采用C语言，利用结构体来实现顺序栈\n\n* 用于定义栈的大小，以及再栈满的时候，扩充栈\n<!--more-->\n```c\n#define STACK_SIZE 50\n#define STACK_INCREMENT 10\n```\n\n* 采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈\n\n```c\ntypedef struct {\n\tint stackSize;  //栈容量\n\tint *base;      //栈底指针\n\tint *top;       //栈顶指针\n}SqStack, *pStack;\n\n```\n\n* 初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针\n\n```c\nvoid initStack(pStack p) {\n\tp->base = (int *)malloc(STACK_SIZE * sizeof(int));\n\tif (p->base != NULL)\n\t{\n\t\tp->top = p->base;\n\t\tp->stackSize = STACK_SIZE;\n\t}\n\telse\n\t{\n\t\tprintf(\"分配内存失败\");\n\t}\n}\n\n```\n\n* 栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false\n\n```c\nbool isEmpty(pStack p) {\n\treturn p->top == p->base ? true : false;\n}\n```\n\n* 栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较\n\n```c\nbool isFull(pStack p) {\n\treturn (p->top - p->base) >= STACK_SIZE ? true : false;\n}\n\n```\n\n* 入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；\n\n```c\nvoid push(pStack p, int topElement) {\n\tint *q = NULL;\n\tif (isFull(p))\n\t{\n\t\tq = (int *)realloc(p->base, STACK_INCREMENT * sizeof(int));  // 重新调整内存块的大小\n\n\t\tp->base = q;\n\t\tp->stackSize = p->stackSize + STACK_INCREMENT;\n\t}\n\t*(p->top)++ = topElement;\n}\n\n```\n\n* 出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；\n\n```c\nvoid pop(pStack p, int *topElement) {\n\tif (isEmpty(p))\n\t{\n\t\tprintf(\"空栈\");\n\n\t}\n\n\tp->top--;\n\t*topElement = *p->top;\n}\n\n\n```\n\n* 求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一\n\n```c\nint getStackTop(SqStack s) {\n\tint topElement;\n\tif (isEmpty(&s))\n\t{\n\t\treturn 0;\n\t}\n\ttopElement = *(s.top - 1);\n\treturn topElement;\n\n}\n\n```\n\n* 清空栈，不断将让栈中元素出栈，直至栈空\n\n```c\nvoid clearStack(SqStack s) {\n\twhile (!isEmpty(&s))\n\t{\n\t\tint tmp;\n\t\tpop(&s, &tmp);\n\t}\n\n}\n```\n\n* 求栈当前大小\n\n```c\nint getStackLength(SqStack s) {\n\tint i = 0;\n\tint *q = s.top;\n\n\twhile (q != s.base)\n\t{\n\t\tq--;\n\t\ti++;\n\t}\n\treturn i;\n}\n```\n\n","slug":"Data_Structure/2017-07-27-data-structure-stack","published":1,"updated":"2021-01-05T12:14:47.221Z","_id":"ckjju0m03000720uacxip4bds","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-7-28<br>本文采用C语言，利用结构体来实现顺序栈</p>\n<ul>\n<li>用于定义栈的大小，以及再栈满的时候，扩充栈<a id=\"more\"></a>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_SIZE 50</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_INCREMENT 10</span></span><br></pre></td></tr></table></figure></li>\n<li>采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize;  <span class=\"comment\">//栈容量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;      <span class=\"comment\">//栈底指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *top;       <span class=\"comment\">//栈顶指针</span></span><br><span class=\"line\">&#125;SqStack, *pStack;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initStack</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\tp-&gt;base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(STACK_SIZE * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p-&gt;base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tp-&gt;top = p-&gt;base;</span><br><span class=\"line\">\t\tp-&gt;stackSize = STACK_SIZE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;分配内存失败&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p-&gt;top == p-&gt;base ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (p-&gt;top - p-&gt;base) &gt;= STACK_SIZE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFull(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">realloc</span>(p-&gt;base, STACK_INCREMENT * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));  <span class=\"comment\">// 重新调整内存块的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tp-&gt;base = q;</span><br><span class=\"line\">\t\tp-&gt;stackSize = p-&gt;stackSize + STACK_INCREMENT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*(p-&gt;top)++ = topElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> *topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;空栈&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tp-&gt;top--;</span><br><span class=\"line\">\t*topElement = *p-&gt;top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackTop</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> topElement;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttopElement = *(s.top - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> topElement;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空栈，不断将让栈中元素出栈，直至栈空</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clearStack</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\tpop(&amp;s, &amp;tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>求栈当前大小</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackLength</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = s.top;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q != s.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq--;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-7-28<br>本文采用C语言，利用结构体来实现顺序栈</p>\n<ul>\n<li>用于定义栈的大小，以及再栈满的时候，扩充栈","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_SIZE 50</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_INCREMENT 10</span></span><br></pre></td></tr></table></figure></li>\n<li>采用顺序结构来实现栈，使用的是结构体，以一个结构体来表示栈</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stackSize;  <span class=\"comment\">//栈容量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;      <span class=\"comment\">//栈底指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *top;       <span class=\"comment\">//栈顶指针</span></span><br><span class=\"line\">&#125;SqStack, *pStack;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化栈，base和top相当于栈中的索引,Top是栈顶，Base是栈底,传入的参数是结构体指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initStack</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\tp-&gt;base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(STACK_SIZE * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p-&gt;base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tp-&gt;top = p-&gt;base;</span><br><span class=\"line\">\t\tp-&gt;stackSize = STACK_SIZE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;分配内存失败&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>栈判空，通过判断栈顶Top指针和栈底Base指针指向的地址是否相等,栈空返回true，否则返回false</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p-&gt;top == p-&gt;base ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>栈判满，通过栈顶指针的地址与栈底指针的差值与栈初始化的大小进行比较</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">(pStack p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (p-&gt;top - p-&gt;base) &gt;= STACK_SIZE ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>入栈，传入结构体指针和将要入栈的元素，先存储数据，然后再将栈顶指针地址加一（栈中数据存储的地址是由小至大）；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFull(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">realloc</span>(p-&gt;base, STACK_INCREMENT * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));  <span class=\"comment\">// 重新调整内存块的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tp-&gt;base = q;</span><br><span class=\"line\">\t\tp-&gt;stackSize = p-&gt;stackSize + STACK_INCREMENT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*(p-&gt;top)++ = topElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>出栈，传入结构体指针和保存栈顶元素的指针，先将栈顶指针的地址减一，然后再取址；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(pStack p, <span class=\"keyword\">int</span> *topElement)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(p))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;空栈&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tp-&gt;top--;</span><br><span class=\"line\">\t*topElement = *p-&gt;top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>求栈顶元素，与栈顶元素出栈相同，只是不需要讲栈顶指针的地址减一</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackTop</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> topElement;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttopElement = *(s.top - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> topElement;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空栈，不断将让栈中元素出栈，直至栈空</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clearStack</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;s))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\tpop(&amp;s, &amp;tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>求栈当前大小</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getStackLength</span><span class=\"params\">(SqStack s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *q = s.top;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q != s.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq--;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"二叉树的前序、中序、后序遍历","description":"递归构建二叉树、二叉树的三种遍历方式都是通过递归进行","type":["数据结构"],"cover":"/cover/img36.jpg","toc":true,"date":"2017-07-26T16:00:00.000Z","_content":"\n* 二叉树的结构体\nmodified: 2017-07-27\n<!--more-->\n```c\ntypedef struct binaryTree {\n\tchar item;\n\tstruct binaryTree *lChild;\n\tstruct binaryTree *rChild;\n\n}binaryTree, *pBinaryTree;\n\n```\n\n* 二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；'#'作为递归的结束；\n\n```c\npBinaryTree createBinaryTree() {\n\n\tchar tmp = '0';\n\tpBinaryTree treeNode = NULL;\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\t//为加入的节点分配新的内存空间\n\t\ttreeNode = (binaryTree*)malloc(sizeof(binaryTree));\n\t\ttreeNode->item = tmp;\n\n\t\t//递归调用产生二叉树\n\t\ttreeNode->lChild = createBinaryTree();\n\t\ttreeNode->rChild = createBinaryTree();\n\n\t}\n\treturn treeNode;\n\n}\n\n```\n\n* 先序遍历二叉树\n\n```c\nvoid preVisitBiTree(pBinaryTree root) {\n\tif (root)\n\t{\n\t\t//先遍历根节点\n\t\tprintf(\"%c\", root->item);\n\t\t//遍历左子树\n\t\tpreVisitBiTree(root->lChild);\n\t\t//遍历右子树\n\t\tpreVisitBiTree(root->rChild);\n\n\t}\n}\n```\n\n* 中序遍历二叉树\n\n```c\nvoid inVisitBiTree(pBinaryTree inRoot) {\n\n\tif (inRoot)\n\t{\n\t\t//先遍历左子树\n\t\tinVisitBiTree(inRoot -> lChild );\n\t\t//遍历根节点\n\t\tprintf(\"%c\", inRoot->item);\n\t\t//遍历右子树\n\t\tinVisitBiTree(inRoot->rChild);\n\t}\n\n}\n\n\n```\n\n* 后序遍历二叉树\n\n```c\nvoid lastVisitBiTree(pBinaryTree lastRoot) {\n\n\tif (lastRoot)\n\t{\n\t\t//遍历左子树\n\t\tinVisitBiTree(lastRoot->lChild);\n\t\t//遍历右子树\n\t\tinVisitBiTree(lastRoot->rChild);\n\t\t//遍历根节点\n\t\tprintf(\"%c\", lastRoot->item);\n\t}\n}\n\n```\n\n### 三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\n\n\n### 测试：\n\n测试用例：ABC##D##E#F##\n\n\n```c\n\nint main() {\n\n\t//构建一颗二叉树\n\tpBinaryTree binaryTree = createBinaryTree();\n\t//采用先序遍历的方式遍历输出二叉树\n\tpreVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\t//采用中序遍历的方式输出二叉树\n\tinVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\tlastVisitBiTree(binaryTree);\n\tprintf(\"测试二叉树\");\n\treturn 0;\n}\n\n```","source":"_posts/Data_Structure/2017-07-27-data-structure-binary-tree-visit.md","raw":"---\n\ntitle: \"二叉树的前序、中序、后序遍历\"\ndescription: \"递归构建二叉树、二叉树的三种遍历方式都是通过递归进行\"\ntype: [数据结构]\ncover: /cover/img36.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/07/27\n\n---\n\n* 二叉树的结构体\nmodified: 2017-07-27\n<!--more-->\n```c\ntypedef struct binaryTree {\n\tchar item;\n\tstruct binaryTree *lChild;\n\tstruct binaryTree *rChild;\n\n}binaryTree, *pBinaryTree;\n\n```\n\n* 二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；'#'作为递归的结束；\n\n```c\npBinaryTree createBinaryTree() {\n\n\tchar tmp = '0';\n\tpBinaryTree treeNode = NULL;\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\t//为加入的节点分配新的内存空间\n\t\ttreeNode = (binaryTree*)malloc(sizeof(binaryTree));\n\t\ttreeNode->item = tmp;\n\n\t\t//递归调用产生二叉树\n\t\ttreeNode->lChild = createBinaryTree();\n\t\ttreeNode->rChild = createBinaryTree();\n\n\t}\n\treturn treeNode;\n\n}\n\n```\n\n* 先序遍历二叉树\n\n```c\nvoid preVisitBiTree(pBinaryTree root) {\n\tif (root)\n\t{\n\t\t//先遍历根节点\n\t\tprintf(\"%c\", root->item);\n\t\t//遍历左子树\n\t\tpreVisitBiTree(root->lChild);\n\t\t//遍历右子树\n\t\tpreVisitBiTree(root->rChild);\n\n\t}\n}\n```\n\n* 中序遍历二叉树\n\n```c\nvoid inVisitBiTree(pBinaryTree inRoot) {\n\n\tif (inRoot)\n\t{\n\t\t//先遍历左子树\n\t\tinVisitBiTree(inRoot -> lChild );\n\t\t//遍历根节点\n\t\tprintf(\"%c\", inRoot->item);\n\t\t//遍历右子树\n\t\tinVisitBiTree(inRoot->rChild);\n\t}\n\n}\n\n\n```\n\n* 后序遍历二叉树\n\n```c\nvoid lastVisitBiTree(pBinaryTree lastRoot) {\n\n\tif (lastRoot)\n\t{\n\t\t//遍历左子树\n\t\tinVisitBiTree(lastRoot->lChild);\n\t\t//遍历右子树\n\t\tinVisitBiTree(lastRoot->rChild);\n\t\t//遍历根节点\n\t\tprintf(\"%c\", lastRoot->item);\n\t}\n}\n\n```\n\n### 三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\n\n\n### 测试：\n\n测试用例：ABC##D##E#F##\n\n\n```c\n\nint main() {\n\n\t//构建一颗二叉树\n\tpBinaryTree binaryTree = createBinaryTree();\n\t//采用先序遍历的方式遍历输出二叉树\n\tpreVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\t//采用中序遍历的方式输出二叉树\n\tinVisitBiTree(binaryTree);\n\tprintf(\"\\n\");\n\tlastVisitBiTree(binaryTree);\n\tprintf(\"测试二叉树\");\n\treturn 0;\n}\n\n```","slug":"Data_Structure/2017-07-27-data-structure-binary-tree-visit","published":1,"updated":"2021-01-05T12:14:43.840Z","_id":"ckjju0m04000820ua0gze8qs3","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>二叉树的结构体<br>modified: 2017-07-27<a id=\"more\"></a>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">lChild</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">rChild</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;binaryTree, *pBinaryTree;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；’#’作为递归的结束；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\tpBinaryTree treeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//为加入的节点分配新的内存空间</span></span><br><span class=\"line\">\t\ttreeNode = (binaryTree*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(binaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用产生二叉树</span></span><br><span class=\"line\">\t\ttreeNode-&gt;lChild = createBinaryTree();</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild = createBinaryTree();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>先序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preVisitBiTree</span><span class=\"params\">(pBinaryTree root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, root-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;rChild);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>中序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree inRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot -&gt; lChild );</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, inRoot-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>后序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lastVisitBiTree</span><span class=\"params\">(pBinaryTree lastRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lastRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;rChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, lastRoot-&gt;item);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"><a href=\"#三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\" class=\"headerlink\" title=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"></a>三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别</h3><h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><p>测试用例：ABC##D##E#F##</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//构建一颗二叉树</span></span><br><span class=\"line\">\tpBinaryTree binaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"comment\">//采用先序遍历的方式遍历输出二叉树</span></span><br><span class=\"line\">\tpreVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//采用中序遍历的方式输出二叉树</span></span><br><span class=\"line\">\tinVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\tlastVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;测试二叉树&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<ul>\n<li>二叉树的结构体<br>modified: 2017-07-27","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">lChild</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binaryTree</span> *<span class=\"title\">rChild</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;binaryTree, *pBinaryTree;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>二叉树的初始化创建，二叉树创建的过程中按照先序遍历的方式输入一颗满二叉树，缺失的节点元素使用#补足；构建的过程中先递归创建左子树，然后递归创建右子数；’#’作为递归的结束；</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\tpBinaryTree treeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//为加入的节点分配新的内存空间</span></span><br><span class=\"line\">\t\ttreeNode = (binaryTree*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(binaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//递归调用产生二叉树</span></span><br><span class=\"line\">\t\ttreeNode-&gt;lChild = createBinaryTree();</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild = createBinaryTree();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>先序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">preVisitBiTree</span><span class=\"params\">(pBinaryTree root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, root-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tpreVisitBiTree(root-&gt;rChild);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>中序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree inRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//先遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot -&gt; lChild );</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, inRoot-&gt;item);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(inRoot-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>后序遍历二叉树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lastVisitBiTree</span><span class=\"params\">(pBinaryTree lastRoot)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lastRoot)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历左子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">\t\tinVisitBiTree(lastRoot-&gt;rChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历根节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, lastRoot-&gt;item);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"><a href=\"#三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\" class=\"headerlink\" title=\"三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别\"></a>三种遍历二叉树的递归结构是相似的，只是递归遍历的先后有区别</h3><h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><p>测试用例：ABC##D##E#F##</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//构建一颗二叉树</span></span><br><span class=\"line\">\tpBinaryTree binaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"comment\">//采用先序遍历的方式遍历输出二叉树</span></span><br><span class=\"line\">\tpreVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//采用中序遍历的方式输出二叉树</span></span><br><span class=\"line\">\tinVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\tlastVisitBiTree(binaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;测试二叉树&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"排序算法","description":"插入排序","type":["数据结构"],"cover":"/cover/img38.jpg","toc":true,"date":"2017-07-30T16:00:00.000Z","_content":"\n# 排序算法\nmodified: 2017-08-02\n\n## 插入排序有直接插入排序、折半插入排序、希尔排序等\n<!--more-->\n### 直接插入排序\n\n直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。\n\n![](/public/img/DataStructure/insertsort.gif)\n\n\nC语言代码实现\n\n```c\n\nvoid StrightInsertSort(int array[], int length) {\n\n\tint tmp;     //用于保存将要插入的array[i]\n\tfor (int i = 1; i < length; i++) {\n\t\ttmp = array[i];\n\t\tfor (int j = i; j >= 0; j--)\n\t\t{\n\t\t\tif (tmp >= array[j - 1] || j == 0)\n\t\t\t{\n\t\t\t\tarray[j] = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 折半插入排序\n\n折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；\n\nC语言代码实现\n\n```c\nvoid BInsertSort(int array[], int length) {\n\tint tmp;\n\tint start, end, mid;\n\n\n\tfor (int i = 1; i < length; i++)\n\t{\n\t\ttmp = array[i];\n\t\tstart = 0; end = i - 1; mid = (end + start) / 2;\n\n\t\t//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值\n\t\tif (tmp >= array[i - 1])\n\t\t{\n\t\t\tarray[i] = tmp;\n\t\t}\n\t\telse if (tmp <= array[0]) {\n\t\t\tfor (int j = i; j > 0; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[0] = tmp;\n\t\t}\n        //进行折半查找排序\n\t\telse\n\t\t{\n\t\t\twhile (start < end)\n\t\t\t{\n\t\t\t\tif (tmp > array[mid])\n\t\t\t\t{\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t\telse if (tmp < array[mid])\n\t\t\t\t{\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i; j > start; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[start] = tmp;\n\n\t\t}\n\t}\n\n}\n\n```\n\n\n### 希尔排序\n\n希尔排序（Shell's Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；\n\n\n![](/public/img/DataStructure/001.png)\n\n\n* 颜色相同的为一个分组\n\nC语言代码实现\n\n```c\n\nvoid shell_sort(int arr[], int length) {\n\tint gap, i, j;\n\tint tmp;\n\tfor (gap = length / 2; gap > 0; gap /= 2)\n\t{\n        //下面两个for循环是对每一个分组进行插入排序\n\t\tfor (i = gap; i < length; i++)\n\t\t{\n\t\t\ttmp = arr[i];\n\t\t\tfor (j = i - gap; j >= 0 && arr[j] > tmp; j-=gap)\n\t\t\t{\n\t\t\t\tarr[j + gap] = arr[j];\n\t\t\t}\n\t\t\tarr[j + gap] = tmp;\n\t\t}\n\t}\n\n}\n\n```","source":"_posts/Data_Structure/2017-07-31-data-structure-insert-sort.md","raw":"---\ntitle: \"排序算法\"\ndescription: \"插入排序\"\ntype: [数据结构]\ncover: /cover/img38.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/07/31\n---\n\n# 排序算法\nmodified: 2017-08-02\n\n## 插入排序有直接插入排序、折半插入排序、希尔排序等\n<!--more-->\n### 直接插入排序\n\n直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。\n\n![](/public/img/DataStructure/insertsort.gif)\n\n\nC语言代码实现\n\n```c\n\nvoid StrightInsertSort(int array[], int length) {\n\n\tint tmp;     //用于保存将要插入的array[i]\n\tfor (int i = 1; i < length; i++) {\n\t\ttmp = array[i];\n\t\tfor (int j = i; j >= 0; j--)\n\t\t{\n\t\t\tif (tmp >= array[j - 1] || j == 0)\n\t\t\t{\n\t\t\t\tarray[j] = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 折半插入排序\n\n折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；\n\nC语言代码实现\n\n```c\nvoid BInsertSort(int array[], int length) {\n\tint tmp;\n\tint start, end, mid;\n\n\n\tfor (int i = 1; i < length; i++)\n\t{\n\t\ttmp = array[i];\n\t\tstart = 0; end = i - 1; mid = (end + start) / 2;\n\n\t\t//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值\n\t\tif (tmp >= array[i - 1])\n\t\t{\n\t\t\tarray[i] = tmp;\n\t\t}\n\t\telse if (tmp <= array[0]) {\n\t\t\tfor (int j = i; j > 0; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[0] = tmp;\n\t\t}\n        //进行折半查找排序\n\t\telse\n\t\t{\n\t\t\twhile (start < end)\n\t\t\t{\n\t\t\t\tif (tmp > array[mid])\n\t\t\t\t{\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t\telse if (tmp < array[mid])\n\t\t\t\t{\n\t\t\t\t\tend = mid - 1;\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = i; j > start; j--)\n\t\t\t{\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t}\n\t\t\tarray[start] = tmp;\n\n\t\t}\n\t}\n\n}\n\n```\n\n\n### 希尔排序\n\n希尔排序（Shell's Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；\n\n\n![](/public/img/DataStructure/001.png)\n\n\n* 颜色相同的为一个分组\n\nC语言代码实现\n\n```c\n\nvoid shell_sort(int arr[], int length) {\n\tint gap, i, j;\n\tint tmp;\n\tfor (gap = length / 2; gap > 0; gap /= 2)\n\t{\n        //下面两个for循环是对每一个分组进行插入排序\n\t\tfor (i = gap; i < length; i++)\n\t\t{\n\t\t\ttmp = arr[i];\n\t\t\tfor (j = i - gap; j >= 0 && arr[j] > tmp; j-=gap)\n\t\t\t{\n\t\t\t\tarr[j + gap] = arr[j];\n\t\t\t}\n\t\t\tarr[j + gap] = tmp;\n\t\t}\n\t}\n\n}\n\n```","slug":"Data_Structure/2017-07-31-data-structure-insert-sort","published":1,"updated":"2021-01-05T12:14:49.827Z","_id":"ckjju0m07000b20ua4qitdrmf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h1><p>modified: 2017-08-02</p>\n<h2 id=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"><a href=\"#插入排序有直接插入排序、折半插入排序、希尔排序等\" class=\"headerlink\" title=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"></a>插入排序有直接插入排序、折半插入排序、希尔排序等</h2><a id=\"more\"></a>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><p>直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。</p>\n<p><img src=\"/public/img/DataStructure/insertsort.gif\"></p>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrightInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;     <span class=\"comment\">//用于保存将要插入的array[i]</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>] || j == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = tmp;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><p>折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；</p>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start, end, mid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\tstart = <span class=\"number\">0</span>; end = i - <span class=\"number\">1</span>; mid = (end + start) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[i] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt;= <span class=\"built_in\">array</span>[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">//进行折半查找排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (start &lt; end)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (tmp &gt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tstart = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tend = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; start; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[start] = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>希尔排序（Shell’s Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；</p>\n<p><img src=\"/public/img/DataStructure/001.png\"></p>\n<ul>\n<li>颜色相同的为一个分组</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> gap, i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (gap = length / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面两个for循环是对每一个分组进行插入排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = gap; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; tmp; j-=gap)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tarr[j + gap] = arr[j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tarr[j + gap] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h1><p>modified: 2017-08-02</p>\n<h2 id=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"><a href=\"#插入排序有直接插入排序、折半插入排序、希尔排序等\" class=\"headerlink\" title=\"插入排序有直接插入排序、折半插入排序、希尔排序等\"></a>插入排序有直接插入排序、折半插入排序、希尔排序等</h2>","more":"<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><p>直接插入排序的核心是不断将后面的数字，不断插入前面已经排好序的数列中；在进行插入排序时需要不断将需要插入的元素与前面已经排好序的元素进行比较，并不断将已排好序的元素后移。</p>\n<p><img src=\"/public/img/DataStructure/insertsort.gif\"></p>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrightInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;     <span class=\"comment\">//用于保存将要插入的array[i]</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>] || j == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = tmp;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h3><p>折半插入排序是直接插入排序的一种优化，直接插入排序需要不断移动元素的位置；而折半插入排序是通过折半查找的方式，直接定位到插入元素的位置，然后进行一次元素平移；</p>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BInsertSort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start, end, mid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">\t\tstart = <span class=\"number\">0</span>; end = i - <span class=\"number\">1</span>; mid = (end + start) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//判断将要插入的元素是否大于已经排好序的元素的最大值，或者已经排好序的最小值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &gt;= <span class=\"built_in\">array</span>[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[i] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt;= <span class=\"built_in\">array</span>[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">//进行折半查找排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (start &lt; end)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (tmp &gt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tstart = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp &lt; <span class=\"built_in\">array</span>[mid])</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tend = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; start; j--)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">array</span>[j] = <span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">array</span>[start] = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>希尔排序（Shell’s Sort）又称为“最小增量排序”（Diminishing Increment Sort），基本思想是：先将整个序列中的记录“基本有序”再对全体记录进行一次直接插入排序（当gap=0时）；</p>\n<p><img src=\"/public/img/DataStructure/001.png\"></p>\n<ul>\n<li>颜色相同的为一个分组</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shell_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> gap, i, j;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (gap = length / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面两个for循环是对每一个分组进行插入排序</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = gap; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttmp = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; tmp; j-=gap)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tarr[j + gap] = arr[j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tarr[j + gap] = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"查找算法","description":"插入排序","type":["数据结构"],"cover":"/cover/img39.jpg","toc":true,"date":"2017-07-30T16:00:00.000Z","_content":"\n### 折半查找\nmodified: 2017-07-31\n折半查找即二分查找的实现\n<!--more-->\n```c\nint BinarySearch(int data[], int search,int length) {\n\tint end = length-1 ;\n\tint start = 0;\n\tint mid = (start + end) / 2;\n\n\twhile (start<=end)\n\t{\n\t\tif (data[mid] == search)\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (data[mid] > search)\n\t\t{\n\t\t\tend = mid-1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstart = mid+1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\n\t}\n\treturn -1;\n\n}\n\n```","source":"_posts/Data_Structure/2017-07-31-data-structure-search.md","raw":"---\n\ntitle: \"查找算法\"\ndescription: \"插入排序\"\ntype: [数据结构]\ncover: /cover/img39.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/07/31\n---\n\n### 折半查找\nmodified: 2017-07-31\n折半查找即二分查找的实现\n<!--more-->\n```c\nint BinarySearch(int data[], int search,int length) {\n\tint end = length-1 ;\n\tint start = 0;\n\tint mid = (start + end) / 2;\n\n\twhile (start<=end)\n\t{\n\t\tif (data[mid] == search)\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (data[mid] > search)\n\t\t{\n\t\t\tend = mid-1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstart = mid+1;\n\t\t\tmid = (start + end) / 2;\n\t\t}\n\n\t}\n\treturn -1;\n\n}\n\n```","slug":"Data_Structure/2017-07-31-data-structure-search","published":1,"updated":"2021-01-05T12:14:51.189Z","_id":"ckjju0m08000c20uaccga5zof","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><p>modified: 2017-07-31<br>折半查找即二分查找的实现</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BinarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> search,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> end = length<span class=\"number\">-1</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (start&lt;=end)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (data[mid] == search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[mid] &gt; search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tend = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstart = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><p>modified: 2017-07-31<br>折半查找即二分查找的实现</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BinarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span> data[], <span class=\"keyword\">int</span> search,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> end = length<span class=\"number\">-1</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (start&lt;=end)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (data[mid] == search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data[mid] &gt; search)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tend = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstart = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tmid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"队列的表示与实现","description":"数据结构中队列的实现","type":["数据结构"],"cover":"/cover/img40.jpg","toc":true,"date":"2017-08-01T16:00:00.000Z","_content":"\nmodified: 2017-08-02\n队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；\n<!--more-->\n## 链队列——队列的链式表示和实现\n\n链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。\n\n![](/public/img/DataStructure/002.gif)\n\n\n* 注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点\n\n\nC语言实现代码\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n//单链队列，队列的链式存储结构，队列是由队头指向队尾\ntypedef struct QNode {\n\tchar data;\n\tstruct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct {\n\tQueuePtr  front;   //队头指针\n\tQueuePtr rare;     //队尾指针\n}LinkQueue;\n\n\n//用于初始化队列\nvoid initQueue(LinkQueue &lq) {\n\tlq.front = lq.rare = (QueuePtr)malloc(sizeof(QNode));\n\tlq.rare->next = NULL;\n\n}\n//用于插入队列\nvoid enQueue(LinkQueue &lq,char data) {\n\t//插入元素为Q的新的队尾元素 data\n\tQueuePtr p;\n\tp = (QueuePtr)malloc(sizeof(QNode));\n\tp->data = data;\n\tp->next = NULL;\n\tlq.rare->next = p;\n\tlq.rare = lq.rare->next;\n}\n//用于取出头元素，在操作之前首先需要判断是不是空队列\nvoid reQueue(LinkQueue &lq) {\n\tif (lq.front==lq.rare)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\telse\n\t{\n\t\tQueuePtr q;\n        //因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值\n\t\tprintf(\"%c\",lq.front->next->data);  \n\t\tq = lq.front;\n\t\tlq.front = lq.front->next;\n\t\tfree(q);\n\t}\n}\nint main() {\n\tLinkQueue lq;\n\tinitQueue(lq);\n\tenQueue(lq,'a');\n\tenQueue(lq,'b');\n\treQueue(lq);\n\treQueue(lq);\n\treturn 0;\n}\n\n```\n\n## 循环队列——队列的顺序表示和实现\n\n队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；\n\n![](/public/img/DataStructure/004.jpg)\n\n\n* 初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；\n\n![](/public/img/DataStructure/003.jpg)\n\n\n* 当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。\n\nC语言代码实现\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#define maxsize 100\ntypedef struct {\n\tint *base;    //用于为队列分配空间\n\tint front;\n\tint rear;\n}sqqueue;\n\n//初始化队列\nvoid initqueue(sqqueue &sq) {\n\t//构造一个空队列\n\tsq.base = (int *)malloc(maxsize*sizeof(int));\n\tif (!sq.base)\n\t{\n\t\tprintf(\"构造队列失败\");\n\t}\n\tsq.front = sq.rear = 0;\n}\n\n//入队\nvoid enqueue(sqqueue &sq,int e) {\n\t//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头\n\tif ((sq.rear+1)%maxsize==sq.front)\n\t{\n\t\tprintf(\"队列为满\");\n\t}\n\tsq.base[sq.rear] = e;\n\tsq.rear = (sq.rear + 1) % maxsize;  //转了一圈后sq.rare会超过maxsize\n\n}\n\n//出队\nvoid requeue(sqqueue &sq) {\n\t//用于判断队是否为空\n\tif (sq.rear==sq.front)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\tprintf(\"%d\\n\",sq.base[sq.front]);\n\tsq.front = (sq.front + 1) % maxsize;\n}\n\nint main() {\n\tsqqueue sq;\n\tinitqueue(sq);\n\tenqueue(sq,10);\n\tenqueue(sq,15);\n\trequeue(sq);\n\trequeue(sq);\n\treturn 0;\n}\n\n```\n","source":"_posts/Data_Structure/2017-08-02-data-structure-queue.md","raw":"---\n\ntitle: \"队列的表示与实现\"\ndescription: \"数据结构中队列的实现\"\ntype: [数据结构]\ncover: /cover/img40.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/02\n---\n\nmodified: 2017-08-02\n队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；\n<!--more-->\n## 链队列——队列的链式表示和实现\n\n链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。\n\n![](/public/img/DataStructure/002.gif)\n\n\n* 注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点\n\n\nC语言实现代码\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n//单链队列，队列的链式存储结构，队列是由队头指向队尾\ntypedef struct QNode {\n\tchar data;\n\tstruct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct {\n\tQueuePtr  front;   //队头指针\n\tQueuePtr rare;     //队尾指针\n}LinkQueue;\n\n\n//用于初始化队列\nvoid initQueue(LinkQueue &lq) {\n\tlq.front = lq.rare = (QueuePtr)malloc(sizeof(QNode));\n\tlq.rare->next = NULL;\n\n}\n//用于插入队列\nvoid enQueue(LinkQueue &lq,char data) {\n\t//插入元素为Q的新的队尾元素 data\n\tQueuePtr p;\n\tp = (QueuePtr)malloc(sizeof(QNode));\n\tp->data = data;\n\tp->next = NULL;\n\tlq.rare->next = p;\n\tlq.rare = lq.rare->next;\n}\n//用于取出头元素，在操作之前首先需要判断是不是空队列\nvoid reQueue(LinkQueue &lq) {\n\tif (lq.front==lq.rare)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\telse\n\t{\n\t\tQueuePtr q;\n        //因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值\n\t\tprintf(\"%c\",lq.front->next->data);  \n\t\tq = lq.front;\n\t\tlq.front = lq.front->next;\n\t\tfree(q);\n\t}\n}\nint main() {\n\tLinkQueue lq;\n\tinitQueue(lq);\n\tenQueue(lq,'a');\n\tenQueue(lq,'b');\n\treQueue(lq);\n\treQueue(lq);\n\treturn 0;\n}\n\n```\n\n## 循环队列——队列的顺序表示和实现\n\n队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；\n\n![](/public/img/DataStructure/004.jpg)\n\n\n* 初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；\n\n![](/public/img/DataStructure/003.jpg)\n\n\n* 当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。\n\nC语言代码实现\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#define maxsize 100\ntypedef struct {\n\tint *base;    //用于为队列分配空间\n\tint front;\n\tint rear;\n}sqqueue;\n\n//初始化队列\nvoid initqueue(sqqueue &sq) {\n\t//构造一个空队列\n\tsq.base = (int *)malloc(maxsize*sizeof(int));\n\tif (!sq.base)\n\t{\n\t\tprintf(\"构造队列失败\");\n\t}\n\tsq.front = sq.rear = 0;\n}\n\n//入队\nvoid enqueue(sqqueue &sq,int e) {\n\t//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头\n\tif ((sq.rear+1)%maxsize==sq.front)\n\t{\n\t\tprintf(\"队列为满\");\n\t}\n\tsq.base[sq.rear] = e;\n\tsq.rear = (sq.rear + 1) % maxsize;  //转了一圈后sq.rare会超过maxsize\n\n}\n\n//出队\nvoid requeue(sqqueue &sq) {\n\t//用于判断队是否为空\n\tif (sq.rear==sq.front)\n\t{\n\t\tprintf(\"队列为空\");\n\t}\n\tprintf(\"%d\\n\",sq.base[sq.front]);\n\tsq.front = (sq.front + 1) % maxsize;\n}\n\nint main() {\n\tsqqueue sq;\n\tinitqueue(sq);\n\tenqueue(sq,10);\n\tenqueue(sq,15);\n\trequeue(sq);\n\trequeue(sq);\n\treturn 0;\n}\n\n```\n","slug":"Data_Structure/2017-08-02-data-structure-queue","published":1,"updated":"2021-01-05T12:14:52.235Z","_id":"ckjju0m09000d20ua5vnzdmej","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-02<br>队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；</p>\n<a id=\"more\"></a>\n<h2 id=\"链队列——队列的链式表示和实现\"><a href=\"#链队列——队列的链式表示和实现\" class=\"headerlink\" title=\"链队列——队列的链式表示和实现\"></a>链队列——队列的链式表示和实现</h2><p>链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。</p>\n<p><img src=\"/public/img/DataStructure/002.gif\"></p>\n<ul>\n<li>注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">//单链队列，队列的链式存储结构，队列是由队头指向队尾</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQueuePtr  front;   <span class=\"comment\">//队头指针</span></span><br><span class=\"line\">\tQueuePtr rare;     <span class=\"comment\">//队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\tlq.front = lq.rare = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tlq.rare-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于插入队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enQueue</span><span class=\"params\">(LinkQueue &amp;lq,<span class=\"keyword\">char</span> data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//插入元素为Q的新的队尾元素 data</span></span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\tp = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tp-&gt;data = data;</span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tlq.rare-&gt;next = p;</span><br><span class=\"line\">\tlq.rare = lq.rare-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于取出头元素，在操作之前首先需要判断是不是空队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lq.front==lq.rare)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;队列为空&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tQueuePtr q;</span><br><span class=\"line\">        <span class=\"comment\">//因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,lq.front-&gt;next-&gt;data);  </span><br><span class=\"line\">\t\tq = lq.front;</span><br><span class=\"line\">\t\tlq.front = lq.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tLinkQueue lq;</span><br><span class=\"line\">\tinitQueue(lq);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">&#x27;b&#x27;</span>);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"循环队列——队列的顺序表示和实现\"><a href=\"#循环队列——队列的顺序表示和实现\" class=\"headerlink\" title=\"循环队列——队列的顺序表示和实现\"></a>循环队列——队列的顺序表示和实现</h2><p>队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；</p>\n<p><img src=\"/public/img/DataStructure/004.jpg\"></p>\n<ul>\n<li>初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/003.jpg\"></p>\n<ul>\n<li>当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxsize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;    <span class=\"comment\">//用于为队列分配空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;sqqueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initqueue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空队列</span></span><br><span class=\"line\">\tsq.base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(maxsize*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sq.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;构造队列失败&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.front = sq.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(sqqueue &amp;sq,<span class=\"keyword\">int</span> e)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((sq.rear+<span class=\"number\">1</span>)%maxsize==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;队列为满&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.base[sq.rear] = e;</span><br><span class=\"line\">\tsq.rear = (sq.rear + <span class=\"number\">1</span>) % maxsize;  <span class=\"comment\">//转了一圈后sq.rare会超过maxsize</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">requeue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队是否为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sq.rear==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;队列为空&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sq.base[sq.front]);</span><br><span class=\"line\">\tsq.front = (sq.front + <span class=\"number\">1</span>) % maxsize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tsqqueue sq;</span><br><span class=\"line\">\tinitqueue(sq);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">10</span>);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">15</span>);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-02<br>队列是先进先出的（FIFO）的线性表，在具体应用中通常使用链表或者数组实现；只允许在一端插入，在另一端删除；在队列中允许插入的一端叫队尾，允许删除的一端叫队头；</p>","more":"<h2 id=\"链队列——队列的链式表示和实现\"><a href=\"#链队列——队列的链式表示和实现\" class=\"headerlink\" title=\"链队列——队列的链式表示和实现\"></a>链队列——队列的链式表示和实现</h2><p>链队列的本质是一个单向链表，头结点front相当于head,再增加一个尾结点。</p>\n<p><img src=\"/public/img/DataStructure/002.gif\"></p>\n<ul>\n<li>注意头结点指向的节点为空，在删除队列头节点时应该删除的是该空节点的下一个节点</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">//单链队列，队列的链式存储结构，队列是由队头指向队尾</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQueuePtr  front;   <span class=\"comment\">//队头指针</span></span><br><span class=\"line\">\tQueuePtr rare;     <span class=\"comment\">//队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\tlq.front = lq.rare = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tlq.rare-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于插入队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enQueue</span><span class=\"params\">(LinkQueue &amp;lq,<span class=\"keyword\">char</span> data)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//插入元素为Q的新的队尾元素 data</span></span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\tp = (QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\tp-&gt;data = data;</span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tlq.rare-&gt;next = p;</span><br><span class=\"line\">\tlq.rare = lq.rare-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//用于取出头元素，在操作之前首先需要判断是不是空队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reQueue</span><span class=\"params\">(LinkQueue &amp;lq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lq.front==lq.rare)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;队列为空&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tQueuePtr q;</span><br><span class=\"line\">        <span class=\"comment\">//因为lq.front为一个空节点，因为在初始化队列的时候没有给这一个节点赋值</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,lq.front-&gt;next-&gt;data);  </span><br><span class=\"line\">\t\tq = lq.front;</span><br><span class=\"line\">\t\tlq.front = lq.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tLinkQueue lq;</span><br><span class=\"line\">\tinitQueue(lq);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">\tenQueue(lq,<span class=\"string\">&#x27;b&#x27;</span>);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\treQueue(lq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"循环队列——队列的顺序表示和实现\"><a href=\"#循环队列——队列的顺序表示和实现\" class=\"headerlink\" title=\"循环队列——队列的顺序表示和实现\"></a>循环队列——队列的顺序表示和实现</h2><p>队列的顺序表示和实现，可以参照栈的顺序表示和实现；在c语言中不能使用动态数组来分实现循环队列，如果要使用循环队列则必须设定一个最大的长度；</p>\n<p><img src=\"/public/img/DataStructure/004.jpg\"></p>\n<ul>\n<li>初始化建空队列时，令front=rare=0,当插入新元素时rare+1;当删除头元素时front+1;在非空队列中头指针始终指向头元素，尾指针始终指向队尾元素的下一个元素；</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/003.jpg\"></p>\n<ul>\n<li>当Q.rare==Q.front队列有可能是满的，也有可能是空的；有两种处理办法：一是另设一个标志位以区别是空还是满；二是约定以“队列头指针在队尾指针的下一位时为满”。下面的代码采用的是第二种方法。</li>\n</ul>\n<p>C语言代码实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxsize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *base;    <span class=\"comment\">//用于为队列分配空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> front;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;sqqueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initqueue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空队列</span></span><br><span class=\"line\">\tsq.base = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(maxsize*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sq.base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;构造队列失败&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.front = sq.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(sqqueue &amp;sq,<span class=\"keyword\">int</span> e)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队列是否为满，通过查看队尾的下一个元素是不是队头</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((sq.rear+<span class=\"number\">1</span>)%maxsize==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;队列为满&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsq.base[sq.rear] = e;</span><br><span class=\"line\">\tsq.rear = (sq.rear + <span class=\"number\">1</span>) % maxsize;  <span class=\"comment\">//转了一圈后sq.rare会超过maxsize</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//出队</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">requeue</span><span class=\"params\">(sqqueue &amp;sq)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//用于判断队是否为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sq.rear==sq.front)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;队列为空&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,sq.base[sq.front]);</span><br><span class=\"line\">\tsq.front = (sq.front + <span class=\"number\">1</span>) % maxsize;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tsqqueue sq;</span><br><span class=\"line\">\tinitqueue(sq);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">10</span>);</span><br><span class=\"line\">\tenqueue(sq,<span class=\"number\">15</span>);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\trequeue(sq);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"基数排序（Radix Sort）","description":"基数排序","type":["数据结构"],"cover":"/cover/img41.jpg","toc":true,"date":"2017-08-01T16:00:00.000Z","_content":"modified: 2017-08-03\n\n桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；\n<!--more-->\n基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n基数排序可以看做是多次桶排序\n\n\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n//从个位开始，最低位优先（Least Significant Digital first）\nvoid radixSort(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 1;\n\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//第一次分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i]/index)% 10][0]++;\n\t\t\tradix[(num[i]/index) % 10][radix[(num[i]/index )% 10][0]] = num[i];\n\t\t}\n\t\t//第一次回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index * 10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\",num[i]);\n\t}\n\n}\n\n\n//从最高位开始，最高位优先（Most Significant Digit first）\nvoid radixSortMSD(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 10000\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i] / index) % 10][0]++;\n\t\t\tradix[(num[i] / index) % 10][radix[(num[i] / index) % 10][0]] = num[i];\n\t\t}\n\t\t//回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index /10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\", num[i]);\n\t}\n\n}\n\n\nint main() {\n\tint num[10] = {0,10,12,5665,285,125,554,26,7895,12};\n\tradixSortMSD(num, 10);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n```\n","source":"_posts/Data_Structure/2017-08-02-data-structure-radix-sort.md","raw":"---\n\ntitle: \"基数排序（Radix Sort）\"\ndescription: \"基数排序\"\ntype: [数据结构]\ncover: /cover/img41.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/02\n\n---\nmodified: 2017-08-03\n\n桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；\n<!--more-->\n基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n基数排序可以看做是多次桶排序\n\n\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n//从个位开始，最低位优先（Least Significant Digital first）\nvoid radixSort(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 1;\n\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//第一次分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i]/index)% 10][0]++;\n\t\t\tradix[(num[i]/index) % 10][radix[(num[i]/index )% 10][0]] = num[i];\n\t\t}\n\t\t//第一次回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index * 10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\",num[i]);\n\t}\n\n}\n\n\n//从最高位开始，最高位优先（Most Significant Digit first）\nvoid radixSortMSD(int num[], int length) {\n\n\tint *radix[10];\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tradix[i] = (int *)malloc(length * sizeof(int));\n\t\tradix[i][0] = 0;\n\t}\n\tint index = 10000\n\tfor (int i = 1; i < 5; i++)\n\t{\n\n\t\t//将num数组中的数据放入数组radix中\n\t\t//分配\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tradix[(num[i] / index) % 10][0]++;\n\t\t\tradix[(num[i] / index) % 10][radix[(num[i] / index) % 10][0]] = num[i];\n\t\t}\n\t\t//回收\n\t\tint length = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < radix[i][0] + 1; j++)\n\t\t\t{\n\t\t\t\tnum[length++] = radix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tradix[i][0] = 0;\n\t\t}\n\t\tindex = index /10;\n\t}\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tprintf(\"%d\\n\", num[i]);\n\t}\n\n}\n\n\nint main() {\n\tint num[10] = {0,10,12,5665,285,125,554,26,7895,12};\n\tradixSortMSD(num, 10);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n```\n","slug":"Data_Structure/2017-08-02-data-structure-radix-sort","published":1,"updated":"2021-01-05T12:14:54.321Z","_id":"ckjju0m0b000h20ua68yh6nxz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-03</p>\n<p>桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；</p>\n<a id=\"more\"></a>\n<p>基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<p>基数排序可以看做是多次桶排序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从个位开始，最低位优先（Least Significant Digital first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index)% <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index) % <span class=\"number\">10</span>][radix[(num[i]/index )% <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index * <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从最高位开始，最高位优先（Most Significant Digit first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSortMSD</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">10000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][radix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index /<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">10</span>,<span class=\"number\">12</span>,<span class=\"number\">5665</span>,<span class=\"number\">285</span>,<span class=\"number\">125</span>,<span class=\"number\">554</span>,<span class=\"number\">26</span>,<span class=\"number\">7895</span>,<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">\tradixSortMSD(num, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-03</p>\n<p>桶排序（Bucket Sort）工作原理是将数列分到有限的桶中，每个桶再分别进行排序；</p>","more":"<p>基数排序（Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<p>基数排序可以看做是多次桶排序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从个位开始，最低位优先（Least Significant Digital first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index)% <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i]/index) % <span class=\"number\">10</span>][radix[(num[i]/index )% <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一次回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index * <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从最高位开始，最高位优先（Most Significant Digit first）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">radixSortMSD</span><span class=\"params\">(<span class=\"keyword\">int</span> num[], <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *radix[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tradix[i] = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">10000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将num数组中的数据放入数组radix中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//分配</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]++;</span><br><span class=\"line\">\t\t\tradix[(num[i] / index) % <span class=\"number\">10</span>][radix[(num[i] / index) % <span class=\"number\">10</span>][<span class=\"number\">0</span>]] = num[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//回收</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; radix[i][<span class=\"number\">0</span>] + <span class=\"number\">1</span>; j++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tnum[length++] = radix[i][j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tradix[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tindex = index /<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, num[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">10</span>,<span class=\"number\">12</span>,<span class=\"number\">5665</span>,<span class=\"number\">285</span>,<span class=\"number\">125</span>,<span class=\"number\">554</span>,<span class=\"number\">26</span>,<span class=\"number\">7895</span>,<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">\tradixSortMSD(num, <span class=\"number\">10</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"排序算法总结","description":"","type":["数据结构"],"cover":"/cover/img42.jpg","toc":true,"date":"2017-08-01T16:00:00.000Z","_content":"\n\nmodified: 2017-08-02\n\n各种排序算法的总结\n<!--more-->\n## 插入排序\n\n## 非比较型排序\n\n### 桶排序\n\n### 基数排序\n\n### 计数排序","source":"_posts/Data_Structure/2017-08-02-data-structure-sort-algorithm-summary.md","raw":"---\n\ntitle: \"排序算法总结\"\ndescription: \"\"\ntype: [数据结构]\ncover: /cover/img42.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/02\n\n---\n\n\nmodified: 2017-08-02\n\n各种排序算法的总结\n<!--more-->\n## 插入排序\n\n## 非比较型排序\n\n### 桶排序\n\n### 基数排序\n\n### 计数排序","slug":"Data_Structure/2017-08-02-data-structure-sort-algorithm-summary","published":1,"updated":"2021-01-05T12:14:55.343Z","_id":"ckjju0m0c000j20ua8hdecrje","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-02</p>\n<p>各种排序算法的总结</p>\n<a id=\"more\"></a>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><h2 id=\"非比较型排序\"><a href=\"#非比较型排序\" class=\"headerlink\" title=\"非比较型排序\"></a>非比较型排序</h2><h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-02</p>\n<p>各种排序算法的总结</p>","more":"<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><h2 id=\"非比较型排序\"><a href=\"#非比较型排序\" class=\"headerlink\" title=\"非比较型排序\"></a>非比较型排序</h2><h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3>"},{"title":"栈的应用——需要再次进行编辑","description":"使用栈实现进制转换、括号匹配的检验、行编辑程序","type":["数据结构"],"cover":"/cover/img43.jpg","toc":true,"date":"2017-08-01T16:00:00.000Z","_content":"\nmodified: 2017-08-02\n##　使用栈实现进制转换、括号匹配的检验、行编辑程序\n\n### 使用栈实现进制的转换\n<!--more-->\n* 将十进制转换为二进制\n\nC语言实现代码\n\n```c\nvoid conversion(int num) {\n\tSqStack stack;\n\tinitStack(&stack);\n\twhile (num / 2)\n\t{\n\t\tpush(&stack, num % 2);\n\t\tnum /= 2;\n\t}\n\tpush(&stack, num);\n\n\tint tmp = 0;\n\twhile (!isEmpty(&stack))\n\t{\n\t\tpop(&stack, &tmp);\n\t\tprintf(\"%d\", tmp);\n\n\t}\n}\n\n```\n\n### 使用栈实现括号匹配的检验\n\n```c\nvoid check_symbol() {\n\tchar s[50] = { 0 };\n\tprintf(\"请输入一串括号\");\n\tscanf(\"%s\", s);\n\tSqStack stack;\n\tinitStack(&stack);\n\tpush(&stack, s[0]);\n\tfor (int i = 1; s[i] != 0; i++)\n\t{\n\t\tif (!isEmpty(&stack))\n\t\t{\n\t\t\tif (getStackTop(stack) == (int) '{'&&s[i] == (int)'}' || getStackTop(stack) == (int) '('&&s[i] == (int)')') {\n\t\t\t\tint tmp;\n\t\t\t\tpop(&stack, &tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpush(&stack, s[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp;\n\t\t\tpush(&stack, s[i]);\n\t\t}\n\n\n\t}\n\tif (isEmpty(&stack))\n\t{\n\t\tprintf(\"括号匹配\");\n\t}\n\telse\n\t{\n\t\tprintf(\"括号不匹配\");\n\t}\n\n}\n\n```\n\n### 使用栈实现行编辑器\n\n```c\n\nvoid lineEdit() {\n\t//首先初始化栈\n\tSqStack stack;\n\tinitStack(&stack);\n\tchar ch = getchar();\n\twhile (ch != EOF)\n\t{\n\t\twhile (ch != EOF&&ch!='\\n') {\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '@':clearStack(stack);\n\t\t\t\tbreak;\n\t\t\tcase '#':if (isEmpty(&stack))\n\t\t\t\tbreak;\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t int tmp;\n\t\t\t\t\t\t pop(&stack, &tmp);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\t\t\tdefault:\n\t\t\t\tpush(&stack, ch); break;\n\t\t\t}\n\t\t\tch = getchar();\n\t\t}\n\t\tch = getchar();\n\t}\n\n\t//用于将存储在栈中的内容输出\n\tif (ch == EOF) {\n\t\twhile (!isEmpty(&stack))\n\t\t{\n\t\t\tint tmp;\n\t\t\tpop(&stack, &tmp);\n\t\t\tprintf(\"%c\", tmp);\n\t\t}\n\t}\n}\n\n```","source":"_posts/Data_Structure/2017-08-02-data-structure-stack-use.md","raw":"---\ntitle: 栈的应用——需要再次进行编辑\ndescription: 使用栈实现进制转换、括号匹配的检验、行编辑程序\ntype: [数据结构]\ncover: /cover/img43.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/02\n---\n\nmodified: 2017-08-02\n##　使用栈实现进制转换、括号匹配的检验、行编辑程序\n\n### 使用栈实现进制的转换\n<!--more-->\n* 将十进制转换为二进制\n\nC语言实现代码\n\n```c\nvoid conversion(int num) {\n\tSqStack stack;\n\tinitStack(&stack);\n\twhile (num / 2)\n\t{\n\t\tpush(&stack, num % 2);\n\t\tnum /= 2;\n\t}\n\tpush(&stack, num);\n\n\tint tmp = 0;\n\twhile (!isEmpty(&stack))\n\t{\n\t\tpop(&stack, &tmp);\n\t\tprintf(\"%d\", tmp);\n\n\t}\n}\n\n```\n\n### 使用栈实现括号匹配的检验\n\n```c\nvoid check_symbol() {\n\tchar s[50] = { 0 };\n\tprintf(\"请输入一串括号\");\n\tscanf(\"%s\", s);\n\tSqStack stack;\n\tinitStack(&stack);\n\tpush(&stack, s[0]);\n\tfor (int i = 1; s[i] != 0; i++)\n\t{\n\t\tif (!isEmpty(&stack))\n\t\t{\n\t\t\tif (getStackTop(stack) == (int) '{'&&s[i] == (int)'}' || getStackTop(stack) == (int) '('&&s[i] == (int)')') {\n\t\t\t\tint tmp;\n\t\t\t\tpop(&stack, &tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpush(&stack, s[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp;\n\t\t\tpush(&stack, s[i]);\n\t\t}\n\n\n\t}\n\tif (isEmpty(&stack))\n\t{\n\t\tprintf(\"括号匹配\");\n\t}\n\telse\n\t{\n\t\tprintf(\"括号不匹配\");\n\t}\n\n}\n\n```\n\n### 使用栈实现行编辑器\n\n```c\n\nvoid lineEdit() {\n\t//首先初始化栈\n\tSqStack stack;\n\tinitStack(&stack);\n\tchar ch = getchar();\n\twhile (ch != EOF)\n\t{\n\t\twhile (ch != EOF&&ch!='\\n') {\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '@':clearStack(stack);\n\t\t\t\tbreak;\n\t\t\tcase '#':if (isEmpty(&stack))\n\t\t\t\tbreak;\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t int tmp;\n\t\t\t\t\t\t pop(&stack, &tmp);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\t\t\tdefault:\n\t\t\t\tpush(&stack, ch); break;\n\t\t\t}\n\t\t\tch = getchar();\n\t\t}\n\t\tch = getchar();\n\t}\n\n\t//用于将存储在栈中的内容输出\n\tif (ch == EOF) {\n\t\twhile (!isEmpty(&stack))\n\t\t{\n\t\t\tint tmp;\n\t\t\tpop(&stack, &tmp);\n\t\t\tprintf(\"%c\", tmp);\n\t\t}\n\t}\n}\n\n```","slug":"Data_Structure/2017-08-02-data-structure-stack-use","published":1,"updated":"2021-01-05T12:14:57.134Z","_id":"ckjju0m0d000o20ua592wcpvf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-02<br>##　使用栈实现进制转换、括号匹配的检验、行编辑程序</p>\n<h3 id=\"使用栈实现进制的转换\"><a href=\"#使用栈实现进制的转换\" class=\"headerlink\" title=\"使用栈实现进制的转换\"></a>使用栈实现进制的转换</h3><a id=\"more\"></a>\n<ul>\n<li>将十进制转换为二进制</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conversion</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (num / <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpush(&amp;<span class=\"built_in\">stack</span>, num % <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tnum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用栈实现括号匹配的检验\"><a href=\"#使用栈实现括号匹配的检验\" class=\"headerlink\" title=\"使用栈实现括号匹配的检验\"></a>使用栈实现括号匹配的检验</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check_symbol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入一串括号&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s);</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; s[i] != <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">&#x27;&#123;&#x27;</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">&#x27;&#125;&#x27;</span> || getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">&#x27;(&#x27;</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;括号匹配&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;括号不匹配&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用栈实现行编辑器\"><a href=\"#使用栈实现行编辑器\" class=\"headerlink\" title=\"使用栈实现行编辑器\"></a>使用栈实现行编辑器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lineEdit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//首先初始化栈</span></span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ch != EOF&amp;&amp;ch!=<span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;@&#x27;</span>:clearStack(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;#&#x27;</span>:<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\t\t\t pop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t &#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, ch); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tch = getchar();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于将存储在栈中的内容输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch == EOF) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-02<br>##　使用栈实现进制转换、括号匹配的检验、行编辑程序</p>\n<h3 id=\"使用栈实现进制的转换\"><a href=\"#使用栈实现进制的转换\" class=\"headerlink\" title=\"使用栈实现进制的转换\"></a>使用栈实现进制的转换</h3>","more":"<ul>\n<li>将十进制转换为二进制</li>\n</ul>\n<p>C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">conversion</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (num / <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpush(&amp;<span class=\"built_in\">stack</span>, num % <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tnum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, num);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用栈实现括号匹配的检验\"><a href=\"#使用栈实现括号匹配的检验\" class=\"headerlink\" title=\"使用栈实现括号匹配的检验\"></a>使用栈实现括号匹配的检验</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check_symbol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> s[<span class=\"number\">50</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入一串括号&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, s);</span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\tpush(&amp;<span class=\"built_in\">stack</span>, s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; s[i] != <span class=\"number\">0</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">&#x27;&#123;&#x27;</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">&#x27;&#125;&#x27;</span> || getStackTop(<span class=\"built_in\">stack</span>) == (<span class=\"keyword\">int</span>) <span class=\"string\">&#x27;(&#x27;</span>&amp;&amp;s[i] == (<span class=\"keyword\">int</span>)<span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, s[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;括号匹配&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;括号不匹配&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用栈实现行编辑器\"><a href=\"#使用栈实现行编辑器\" class=\"headerlink\" title=\"使用栈实现行编辑器\"></a>使用栈实现行编辑器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lineEdit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//首先初始化栈</span></span><br><span class=\"line\">\tSqStack <span class=\"built_in\">stack</span>;</span><br><span class=\"line\">\tinitStack(&amp;<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != EOF)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ch != EOF&amp;&amp;ch!=<span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;@&#x27;</span>:clearStack(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;#&#x27;</span>:<span class=\"keyword\">if</span> (isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t &#123;</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\t\t\t\t pop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t &#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\tpush(&amp;<span class=\"built_in\">stack</span>, ch); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tch = getchar();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于将存储在栈中的内容输出</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch == EOF) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!isEmpty(&amp;<span class=\"built_in\">stack</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t\t\tpop(&amp;<span class=\"built_in\">stack</span>, &amp;tmp);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"归并排序","description":"","type":["数据结构"],"cover":"/cover/img44.jpg","toc":true,"date":"2017-08-03T16:00:00.000Z","_content":"modified: 2017-08-04\n\n归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。\n<!--more-->\n归并排序的基本思路是\n\n* 将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；\n* 将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；\n* 重复步骤2，直到所有元素排序完毕；\n\n\n![](/public/img/DataStructure/Merge_sort.gif)\n\n\n\n![](/public/img/DataStructure/Merge_sort_01.gif)\n\n\n\n要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。\n\n使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列\n\n\n```c\n\n//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，\n//左右有序两部分的分界点，右侧有序部分的终点，\n//tmp[]是大小为last-first的数组，用于临时存放排序的数列\n\nvoid mergeArray(int a[],int first,int mid,int last,int tmp[]) {\n\tint i = first;\n\tint j = mid+1;\n\tint k = 0;    //K用作tmp[]的索引\n\n    //将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中\n\twhile (i<=mid&&j<=last)\n\t\ta[i] < a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];\n\twhile (i <= mid)\n\t\ttmp[k++] = a[i++];\n\twhile (j <= last)\n\t\ttmp[k++] = a[j++];\n   \n\twhile (k > 0)\n\t\ta[--j] = tmp[--k];\n}\n```\n\n\n```c\nvoid mergeSort(int a[],int first,int last,int tmp[]) {\n\tif (first<last)\n\t{\n\t\tint mid = (first + last) / 2;\n\t\tmergeSort(a,first,mid,tmp);  //左边有序\n\t\tmergeSort(a, mid+1, last, tmp);//右边有序\n\t\tmergeArray(a,first,mid,last,tmp);  //将两个数组合并\n\t}\n}\n\n````\n有序数组的归并以及归并排序的测试\n\n```c\n\nint main() {\n\n\tint a[7] = {7,8,9,10,1,2,3};\n\tint tmp[7];\n\tprintf(\"测试数组归并\\n\");\n\n\tmergeArray(a, 1, 3, 5, tmp);\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tprintf(\"测试数组归并排序\\n\");\n\tmergeSort(a,0,6,tmp);\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```","source":"_posts/Data_Structure/2017-08-04-data-structure-merge-sort.md","raw":"---\ntitle: \"归并排序\"\ndescription: \"\"\ntype: [数据结构]\n\ncover: /cover/img44.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/04\n---\nmodified: 2017-08-04\n\n归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。\n<!--more-->\n归并排序的基本思路是\n\n* 将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；\n* 将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；\n* 重复步骤2，直到所有元素排序完毕；\n\n\n![](/public/img/DataStructure/Merge_sort.gif)\n\n\n\n![](/public/img/DataStructure/Merge_sort_01.gif)\n\n\n\n要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。\n\n使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列\n\n\n```c\n\n//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，\n//左右有序两部分的分界点，右侧有序部分的终点，\n//tmp[]是大小为last-first的数组，用于临时存放排序的数列\n\nvoid mergeArray(int a[],int first,int mid,int last,int tmp[]) {\n\tint i = first;\n\tint j = mid+1;\n\tint k = 0;    //K用作tmp[]的索引\n\n    //将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中\n\twhile (i<=mid&&j<=last)\n\t\ta[i] < a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];\n\twhile (i <= mid)\n\t\ttmp[k++] = a[i++];\n\twhile (j <= last)\n\t\ttmp[k++] = a[j++];\n   \n\twhile (k > 0)\n\t\ta[--j] = tmp[--k];\n}\n```\n\n\n```c\nvoid mergeSort(int a[],int first,int last,int tmp[]) {\n\tif (first<last)\n\t{\n\t\tint mid = (first + last) / 2;\n\t\tmergeSort(a,first,mid,tmp);  //左边有序\n\t\tmergeSort(a, mid+1, last, tmp);//右边有序\n\t\tmergeArray(a,first,mid,last,tmp);  //将两个数组合并\n\t}\n}\n\n````\n有序数组的归并以及归并排序的测试\n\n```c\n\nint main() {\n\n\tint a[7] = {7,8,9,10,1,2,3};\n\tint tmp[7];\n\tprintf(\"测试数组归并\\n\");\n\n\tmergeArray(a, 1, 3, 5, tmp);\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tprintf(\"测试数组归并排序\\n\");\n\tmergeSort(a,0,6,tmp);\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```","slug":"Data_Structure/2017-08-04-data-structure-merge-sort","published":1,"updated":"2021-01-05T12:14:58.971Z","_id":"ckjju0m0e000r20uaagiv70kh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-04</p>\n<p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。</p>\n<a id=\"more\"></a>\n<p>归并排序的基本思路是</p>\n<ul>\n<li>将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；</li>\n<li>将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；</li>\n<li>重复步骤2，直到所有元素排序完毕；</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/Merge_sort.gif\"></p>\n<p><img src=\"/public/img/DataStructure/Merge_sort_01.gif\"></p>\n<p>要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。</p>\n<p>使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，</span></span><br><span class=\"line\"><span class=\"comment\">//左右有序两部分的分界点，右侧有序部分的终点，</span></span><br><span class=\"line\"><span class=\"comment\">//tmp[]是大小为last-first的数组，用于临时存放排序的数列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeArray</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = first;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;    <span class=\"comment\">//K用作tmp[]的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i&lt;=mid&amp;&amp;j&lt;=last)</span><br><span class=\"line\">\t\ta[i] &lt; a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= mid)</span><br><span class=\"line\">\t\ttmp[k++] = a[i++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt;= last)</span><br><span class=\"line\">\t\ttmp[k++] = a[j++];</span><br><span class=\"line\">   </span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\ta[--j] = tmp[--k];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (first&lt;last)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (first + last) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tmergeSort(a,first,mid,tmp);  <span class=\"comment\">//左边有序</span></span><br><span class=\"line\">\t\tmergeSort(a, mid+<span class=\"number\">1</span>, last, tmp);<span class=\"comment\">//右边有序</span></span><br><span class=\"line\">\t\tmergeArray(a,first,mid,last,tmp);  <span class=\"comment\">//将两个数组合并</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">````</span><br><span class=\"line\">有序数组的归并以及归并排序的测试</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;测试数组归并\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmergeArray(a, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;测试数组归并排序\\n&quot;</span>);</span><br><span class=\"line\">\tmergeSort(a,<span class=\"number\">0</span>,<span class=\"number\">6</span>,tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-04</p>\n<p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，效率为O（n log n）；该算法是采用分治法一种典型的应用，且各层分治递归可以同时进行。</p>","more":"<p>归并排序的基本思路是</p>\n<ul>\n<li>将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素；</li>\n<li>将上述序列再次归并，形成n/4个序列，每个序列包含四个元素；</li>\n<li>重复步骤2，直到所有元素排序完毕；</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/Merge_sort.gif\"></p>\n<p><img src=\"/public/img/DataStructure/Merge_sort_01.gif\"></p>\n<p>要理解归并算法首先要理解归并操作（Merge），归并操作（Merge）也叫归并算法，指的是将两个已经排好的序列合并成一个序列的操作；归并算法依赖于归并操作。</p>\n<p>使用C语言实现一个数组的左右两部分有序数列的归并操作，即将左右两部分看成两个有序数列合并成一个有序数列</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//a[]是要进行排序的数组，first、mid、last分别代表左侧有序部分数组的起始位置，</span></span><br><span class=\"line\"><span class=\"comment\">//左右有序两部分的分界点，右侧有序部分的终点，</span></span><br><span class=\"line\"><span class=\"comment\">//tmp[]是大小为last-first的数组，用于临时存放排序的数列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeArray</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = first;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;    <span class=\"comment\">//K用作tmp[]的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将a[]左右有序的两部分按照由小到大的顺序存入tmp[]中</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i&lt;=mid&amp;&amp;j&lt;=last)</span><br><span class=\"line\">\t\ta[i] &lt; a[j] ? tmp[k++] = a[i++] : tmp[k++] = a[j++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= mid)</span><br><span class=\"line\">\t\ttmp[k++] = a[i++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt;= last)</span><br><span class=\"line\">\t\ttmp[k++] = a[j++];</span><br><span class=\"line\">   </span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\ta[--j] = tmp[--k];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> first,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> tmp[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (first&lt;last)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (first + last) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tmergeSort(a,first,mid,tmp);  <span class=\"comment\">//左边有序</span></span><br><span class=\"line\">\t\tmergeSort(a, mid+<span class=\"number\">1</span>, last, tmp);<span class=\"comment\">//右边有序</span></span><br><span class=\"line\">\t\tmergeArray(a,first,mid,last,tmp);  <span class=\"comment\">//将两个数组合并</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">````</span><br><span class=\"line\">有序数组的归并以及归并排序的测试</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">7</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;测试数组归并\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmergeArray(a, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;测试数组归并排序\\n&quot;</span>);</span><br><span class=\"line\">\tmergeSort(a,<span class=\"number\">0</span>,<span class=\"number\">6</span>,tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"快速排序","description":"快速排序3","type":["数据结构"],"cover":"/cover/img45.jpg","toc":true,"date":"2017-08-03T16:00:00.000Z","_content":"modified: 2017-08-02\n快速排序可以理解为：快速排序=挖坑填数+分治算法；\n<!--more-->\n快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；\n\n步骤为：\n\n* 从数列中选出一个元素，作为基准（pivot）\n* 将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。\n* 递归地把小于基准元素的子序列和大于基准的子序列进行排序\n\n递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 \n\n\n* 进行一次排序的过程(挖坑填数)\n  \n\n![](/public/img/DataStructure/quick_sort.jpg)\n\n\n* 快速排序的全过程\n\n\n![](/public/img/DataStructure/quick_sort_01.jpg)\n\n\n使用C语言实现代码\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n//分治算法是基于递归的\n\nvoid quickSort(int arr[],int left,int right) {\n\tif (left<right)\n\t{\n\t\tint i = left, j = right, tmp = arr[left];   //将最左边的数选为基准数字\n\t\t//先从右向左搜索比tmp小的数\n\t\twhile (i<j)\n\t\t{\n\t\t\twhile (i<j&&tmp <= arr[j])\n\t\t\t\tj--;\n\t\t\tif (i<j)\n\t\t\t\tarr[i++] = arr[j];   //将右边的数挖出放到左边的位置\n\t\t\t//从左至右搜索比tmp大的数\n\t\t\twhile (i<j&&tmp >arr[i])\n\t\t\t\ti++;\n\t\t\tif (i<j)\n\t\t\t\tarr[j--] = arr[i];   //将左边的数挖出放入右边的空位\n\t\t}\n\t\tarr[i] = tmp;     \n\t\tquickSort(arr, left, i - 1);   //递归调用\n\t\tquickSort(arr, i + 1, right);  //递归调用\n\t}\n\n}\n\n\nint main() {\n\tint a[5] = { 5,4,3,2,1 };\n\tquickSort(a, 0, 4);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%d\",a[i]);\n\t}\n\t\t\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n```","source":"_posts/Data_Structure/2017-08-04-data-structure-quick-sort.md","raw":"---\ntitle: \"快速排序\"\ndescription: \"快速排序3\"\ntype: [数据结构]\ncover: /cover/img45.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/04\n---\nmodified: 2017-08-02\n快速排序可以理解为：快速排序=挖坑填数+分治算法；\n<!--more-->\n快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；\n\n步骤为：\n\n* 从数列中选出一个元素，作为基准（pivot）\n* 将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。\n* 递归地把小于基准元素的子序列和大于基准的子序列进行排序\n\n递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 \n\n\n* 进行一次排序的过程(挖坑填数)\n  \n\n![](/public/img/DataStructure/quick_sort.jpg)\n\n\n* 快速排序的全过程\n\n\n![](/public/img/DataStructure/quick_sort_01.jpg)\n\n\n使用C语言实现代码\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n//分治算法是基于递归的\n\nvoid quickSort(int arr[],int left,int right) {\n\tif (left<right)\n\t{\n\t\tint i = left, j = right, tmp = arr[left];   //将最左边的数选为基准数字\n\t\t//先从右向左搜索比tmp小的数\n\t\twhile (i<j)\n\t\t{\n\t\t\twhile (i<j&&tmp <= arr[j])\n\t\t\t\tj--;\n\t\t\tif (i<j)\n\t\t\t\tarr[i++] = arr[j];   //将右边的数挖出放到左边的位置\n\t\t\t//从左至右搜索比tmp大的数\n\t\t\twhile (i<j&&tmp >arr[i])\n\t\t\t\ti++;\n\t\t\tif (i<j)\n\t\t\t\tarr[j--] = arr[i];   //将左边的数挖出放入右边的空位\n\t\t}\n\t\tarr[i] = tmp;     \n\t\tquickSort(arr, left, i - 1);   //递归调用\n\t\tquickSort(arr, i + 1, right);  //递归调用\n\t}\n\n}\n\n\nint main() {\n\tint a[5] = { 5,4,3,2,1 };\n\tquickSort(a, 0, 4);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%d\",a[i]);\n\t}\n\t\t\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n```","slug":"Data_Structure/2017-08-04-data-structure-quick-sort","published":1,"updated":"2021-01-05T12:14:59.838Z","_id":"ckjju0m0f000u20uaahlqdrp5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-02<br>快速排序可以理解为：快速排序=挖坑填数+分治算法；</p>\n<a id=\"more\"></a>\n<p>快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；</p>\n<p>步骤为：</p>\n<ul>\n<li>从数列中选出一个元素，作为基准（pivot）</li>\n<li>将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。</li>\n<li>递归地把小于基准元素的子序列和大于基准的子序列进行排序</li>\n</ul>\n<p>递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 </p>\n<ul>\n<li>进行一次排序的过程(挖坑填数)</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/quick_sort.jpg\"></p>\n<ul>\n<li>快速排序的全过程</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/quick_sort_01.jpg\"></p>\n<p>使用C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">//分治算法是基于递归的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left&lt;right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = left, j = right, tmp = arr[left];   <span class=\"comment\">//将最左边的数选为基准数字</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//先从右向左搜索比tmp小的数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i&lt;j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &lt;= arr[j])</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[i++] = arr[j];   <span class=\"comment\">//将右边的数挖出放到左边的位置</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//从左至右搜索比tmp大的数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &gt;arr[i])</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[j--] = arr[i];   <span class=\"comment\">//将左边的数挖出放入右边的空位</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarr[i] = tmp;     </span><br><span class=\"line\">\t\tquickSort(arr, left, i - <span class=\"number\">1</span>);   <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\tquickSort(arr, i + <span class=\"number\">1</span>, right);  <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">5</span>] = &#123; <span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\tquickSort(a, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-02<br>快速排序可以理解为：快速排序=挖坑填数+分治算法；</p>","more":"<p>快速排序(Quick Sort)使用分治法（Divide and conquer）策略来把一个序列分为两个子序列，左右两个序列分别大于基准数和小于基准数，递归结束后所有的数都将有序；</p>\n<p>步骤为：</p>\n<ul>\n<li>从数列中选出一个元素，作为基准（pivot）</li>\n<li>将数列中比基准小的数放在基准前面，将数列中比基准大的数放在基准的后面；在这一次分割结束后将基准放在中间的位置。</li>\n<li>递归地把小于基准元素的子序列和大于基准的子序列进行排序</li>\n</ul>\n<p>递归到最底部时，数列的大小为零或一，也就是已经排好的序列；算法在每次迭代中，至少会把一个元素排到它最后的位置去。 </p>\n<ul>\n<li>进行一次排序的过程(挖坑填数)</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/quick_sort.jpg\"></p>\n<ul>\n<li>快速排序的全过程</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/quick_sort_01.jpg\"></p>\n<p>使用C语言实现代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">//分治算法是基于递归的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left&lt;right)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i = left, j = right, tmp = arr[left];   <span class=\"comment\">//将最左边的数选为基准数字</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//先从右向左搜索比tmp小的数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i&lt;j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &lt;= arr[j])</span><br><span class=\"line\">\t\t\t\tj--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[i++] = arr[j];   <span class=\"comment\">//将右边的数挖出放到左边的位置</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//从左至右搜索比tmp大的数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (i&lt;j&amp;&amp;tmp &gt;arr[i])</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;j)</span><br><span class=\"line\">\t\t\t\tarr[j--] = arr[i];   <span class=\"comment\">//将左边的数挖出放入右边的空位</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarr[i] = tmp;     </span><br><span class=\"line\">\t\tquickSort(arr, left, i - <span class=\"number\">1</span>);   <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\tquickSort(arr, i + <span class=\"number\">1</span>, right);  <span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">5</span>] = &#123; <span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\tquickSort(a, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"线索化二叉树","description":"","type":["数据结构"],"cover":"/cover/img46.jpg","toc":true,"date":"2017-08-07T16:00:00.000Z","_content":"\nmodified: 2017-08-04\n使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；\n<!--more-->\n在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。\n\n/source/img/DataStructure/threaded_binary_tree.jpg\n\n以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）\n\n根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。\n\n为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：[二叉线索树源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp)\n\n如果二叉树的构造、以及遍历不熟悉的可以先看[二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)；\n\n\n### 线索二叉树的结构体\n\n```c\n\n//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继\ntypedef enum {\n\tLink = 0, Thread = 1     //Link==0:指针，Thread==1,线索\n}PointerTag;\ntypedef struct BinaryTree {\n\tchar item;\n\tBinaryTree *lChild;\n\tBinaryTree *rChild;\n\tPointerTag lTag, rTag;\n}BinaryTree, *pBinaryTree;\n\n```\n\n### 二叉树的先序构造\n\n要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为'#'，第一个被遍历的结点不需要加上'#'\n\n如图：先序遍历的结果为：cba###d#e#f##\n/source/img/DataStructure/binary_tree.jpg\n\n```c\npBinaryTree createBinaryTree() {\n\tpBinaryTree treeNode=NULL;\n\tchar tmp = '0';\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\ttreeNode = (BinaryTree *)malloc(sizeof(BinaryTree));\n\t\ttreeNode->item = tmp;\n\t\t\n\t\ttreeNode->lChild=createBinaryTree();\n\t\tif (treeNode->lChild)\n\t\t\ttreeNode->lTag = Link;\n\t\ttreeNode->rChild=createBinaryTree();\n\t\tif (treeNode->rChild)\n\t\t\ttreeNode->rTag = Link;\n\t}\n\treturn treeNode;\n}\n```\n\n### 二叉树的线索化，代码过程说明：\n\n将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；\n\n<font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font>\n\n\n+ [二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)的中序遍历\n\n```c\nvoid inVisitBiTree(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tinVisitBiTree(biTree->lChild);\n\t\tprintf(\"%c\",biTree->item);\n\t\tinVisitBiTree(biTree->rChild);\n\t}\n}\n```\n\n\n+ 二叉树线索化函数的整体框架\n\n二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块；\n         }\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n\n+ 对访问结点记录，即对前驱的记录\n\n在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n         }\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n<font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font>\n\n如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n\t       \tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n         }\n        pre->biTree;\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n+ 对后继的记录\n\n如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；\n\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (binaryTree)\n\t{\n\t\tInThreading(binaryTree->lChild);\n\t\t//如果没有左孩子时前驱线索\n\t\tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n\t\t//当没有右孩子，后继线索\n\t\tif (!pre->rChild)\n\t\t{\n\t\t\tpre->rTag = Thread;\n\t\t\tpre->rChild = binaryTree;\n\t\t}\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n\n<font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font>\n<font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre->biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font>\n\n### 为已经线索化的二叉树添加头结点\n\n![](/public/img/DataStructure/thread_binary_tree.jpg)\n\n\n\n```c\nvoid InOrderThreading(pBinaryTree &binarytree,pBinaryTree &head) {\n\thead = (pBinaryTree )malloc(sizeof(BinaryTree));\n\n\t//初始化头结点\n\thead->lTag = Link;\n\thead->rTag = Thread;\n\thead->rChild = head;  //头指针回指\n\tif (!binarytree) {\n\t\t head->lChild =head;\n\t}\n\telse\n\t{\n\t\thead->lChild = binarytree;  //当binaryTree非空时，指向二叉树的根结点\n\t\tpre = head;   //定义的全局变量第一次赋值使用\n\t\tInThreading(binarytree);\n\t\t//对最后一个结点线索化\n\t\tpre->rTag = Thread;\n\t\tpre->rChild = head;\n\t\thead->rChild = pre;   //头结点指向中序遍历的最后一个结点\n\t}\n}\n\n```\n\n### 对于中序线索树的中序遍历\n\n先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继\n\n一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。\n\n\n![](/public/img/DataStructure/thread_binary_tree.jpg)\n\n\n```c\nvoid InVisitThreadTree(pBinaryTree binarytree) {\n\tpBinaryTree pBTree;\n\tpBTree = binarytree->lChild;\n\n\t//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree\n\twhile (pBTree != binarytree)\n\t{\n\t\t//找到最左元素\n\t\twhile (pBTree->lTag == Link)\n\t\t{\n\t\t\tpBTree = pBTree->lChild;\n\t\t}\n\t\tprintf(\"%c\", pBTree->item);\n\n\t\t//如果右孩子是线索，则其指向的是下一个访问的结点\n\t\twhile ((pBTree->rChild != binarytree) && (pBTree->rTag == Thread))\n\t\t{\n\t\t\tpBTree = pBTree->rChild;\n\t\t\tprintf(\"%c\", pBTree->item);\n\t\t}\n\t\tpBTree = pBTree->rChild;\n\n\t}\n}\n\n```\n\n### 测试:cba###d#e#f##\n\n<font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font>\n```c\n//定义全局变量\npBinaryTree pre;\n\n```\n\n```c\nint main() {\n\tpBinaryTree TbinaryTree, Head;\n\tTbinaryTree = createBinaryTree();\n\tprintf(\"二叉树的先序遍历\\n\");\n\tpreVisitBiTree(TbinaryTree);\n\tprintf(\"\\n二叉树的中序遍历\\n\");\n\tinVisitBiTree(TbinaryTree);\n\tInOrderThreading(TbinaryTree, Head);\n\tprintf(\"\\n中序线索二叉树的中序遍历\\n\");\n\tInVisitThreadTree(Head);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n测试结果：\n\n\n![](/public/img/DataStructure/binary_tree_result.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Data_Structure/2017-08-08-data-structure-threaded-binary-tree.md","raw":"---\ntitle: \"线索化二叉树\"\ndescription: \"\"\ntype: [数据结构]\ncover:  /cover/img46.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/08\n\n---\n\nmodified: 2017-08-04\n使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；\n<!--more-->\n在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。\n\n/source/img/DataStructure/threaded_binary_tree.jpg\n\n以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）\n\n根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。\n\n为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：[二叉线索树源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp)\n\n如果二叉树的构造、以及遍历不熟悉的可以先看[二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)；\n\n\n### 线索二叉树的结构体\n\n```c\n\n//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继\ntypedef enum {\n\tLink = 0, Thread = 1     //Link==0:指针，Thread==1,线索\n}PointerTag;\ntypedef struct BinaryTree {\n\tchar item;\n\tBinaryTree *lChild;\n\tBinaryTree *rChild;\n\tPointerTag lTag, rTag;\n}BinaryTree, *pBinaryTree;\n\n```\n\n### 二叉树的先序构造\n\n要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为'#'，第一个被遍历的结点不需要加上'#'\n\n如图：先序遍历的结果为：cba###d#e#f##\n/source/img/DataStructure/binary_tree.jpg\n\n```c\npBinaryTree createBinaryTree() {\n\tpBinaryTree treeNode=NULL;\n\tchar tmp = '0';\n\tscanf(\"%c\", &tmp);\n\tif (tmp == '#')\n\t{\n\t\ttreeNode = NULL;\n\t}\n\telse\n\t{\n\t\ttreeNode = (BinaryTree *)malloc(sizeof(BinaryTree));\n\t\ttreeNode->item = tmp;\n\t\t\n\t\ttreeNode->lChild=createBinaryTree();\n\t\tif (treeNode->lChild)\n\t\t\ttreeNode->lTag = Link;\n\t\ttreeNode->rChild=createBinaryTree();\n\t\tif (treeNode->rChild)\n\t\t\ttreeNode->rTag = Link;\n\t}\n\treturn treeNode;\n}\n```\n\n### 二叉树的线索化，代码过程说明：\n\n将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；\n\n<font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font>\n\n\n+ [二叉树](https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html)的中序遍历\n\n```c\nvoid inVisitBiTree(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tinVisitBiTree(biTree->lChild);\n\t\tprintf(\"%c\",biTree->item);\n\t\tinVisitBiTree(biTree->rChild);\n\t}\n}\n```\n\n\n+ 二叉树线索化函数的整体框架\n\n二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块；\n         }\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n\n+ 对访问结点记录，即对前驱的记录\n\n在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n         }\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n<font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font>\n\n如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (biTree)\n\t{\n\t\tInThreading(biTree->lChild);\n\t\t//printf(\"%c\",biTree->item);  \n         {\n           //进行指针修改的代码块，两个大括号是为了方便说明；\n\t       \tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n         }\n        pre->biTree;\n\t\tInThreading(biTree->rChild);\n\t}\n}\n```\n\n+ 对后继的记录\n\n如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；\n\n\n```c\nvoid InThreading(pBinaryTree biTree) {\n\tif (binaryTree)\n\t{\n\t\tInThreading(binaryTree->lChild);\n\t\t//如果没有左孩子时前驱线索\n\t\tif (!binaryTree->lChild)\n\t\t{\n\t\t\tbinaryTree->lTag = Thread;\n\t\t\tbinaryTree->lChild = pre;\n\t\t}\n\t\t//当没有右孩子，后继线索\n\t\tif (!pre->rChild)\n\t\t{\n\t\t\tpre->rTag = Thread;\n\t\t\tpre->rChild = binaryTree;\n\t\t}\n\t\tpre = binaryTree;   //保持pre指向前驱；\n\t\tInThreading(binaryTree->rChild);\n\t}\n}\n```\n\n<font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font>\n<font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre->biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font>\n\n### 为已经线索化的二叉树添加头结点\n\n![](/public/img/DataStructure/thread_binary_tree.jpg)\n\n\n\n```c\nvoid InOrderThreading(pBinaryTree &binarytree,pBinaryTree &head) {\n\thead = (pBinaryTree )malloc(sizeof(BinaryTree));\n\n\t//初始化头结点\n\thead->lTag = Link;\n\thead->rTag = Thread;\n\thead->rChild = head;  //头指针回指\n\tif (!binarytree) {\n\t\t head->lChild =head;\n\t}\n\telse\n\t{\n\t\thead->lChild = binarytree;  //当binaryTree非空时，指向二叉树的根结点\n\t\tpre = head;   //定义的全局变量第一次赋值使用\n\t\tInThreading(binarytree);\n\t\t//对最后一个结点线索化\n\t\tpre->rTag = Thread;\n\t\tpre->rChild = head;\n\t\thead->rChild = pre;   //头结点指向中序遍历的最后一个结点\n\t}\n}\n\n```\n\n### 对于中序线索树的中序遍历\n\n先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继\n\n一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。\n\n\n![](/public/img/DataStructure/thread_binary_tree.jpg)\n\n\n```c\nvoid InVisitThreadTree(pBinaryTree binarytree) {\n\tpBinaryTree pBTree;\n\tpBTree = binarytree->lChild;\n\n\t//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree\n\twhile (pBTree != binarytree)\n\t{\n\t\t//找到最左元素\n\t\twhile (pBTree->lTag == Link)\n\t\t{\n\t\t\tpBTree = pBTree->lChild;\n\t\t}\n\t\tprintf(\"%c\", pBTree->item);\n\n\t\t//如果右孩子是线索，则其指向的是下一个访问的结点\n\t\twhile ((pBTree->rChild != binarytree) && (pBTree->rTag == Thread))\n\t\t{\n\t\t\tpBTree = pBTree->rChild;\n\t\t\tprintf(\"%c\", pBTree->item);\n\t\t}\n\t\tpBTree = pBTree->rChild;\n\n\t}\n}\n\n```\n\n### 测试:cba###d#e#f##\n\n<font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font>\n```c\n//定义全局变量\npBinaryTree pre;\n\n```\n\n```c\nint main() {\n\tpBinaryTree TbinaryTree, Head;\n\tTbinaryTree = createBinaryTree();\n\tprintf(\"二叉树的先序遍历\\n\");\n\tpreVisitBiTree(TbinaryTree);\n\tprintf(\"\\n二叉树的中序遍历\\n\");\n\tinVisitBiTree(TbinaryTree);\n\tInOrderThreading(TbinaryTree, Head);\n\tprintf(\"\\n中序线索二叉树的中序遍历\\n\");\n\tInVisitThreadTree(Head);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n测试结果：\n\n\n![](/public/img/DataStructure/binary_tree_result.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Data_Structure/2017-08-08-data-structure-threaded-binary-tree","published":1,"updated":"2021-01-05T12:15:01.104Z","_id":"ckjju0m0h000x20ua7yju8jz1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-04<br>使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；</p>\n<a id=\"more\"></a>\n<p>在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。</p>\n<p>/source/img/DataStructure/threaded_binary_tree.jpg</p>\n<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）</p>\n<p>根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。</p>\n<p>为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp\">二叉线索树源码</a></p>\n<p>如果二叉树的构造、以及遍历不熟悉的可以先看<a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>；</p>\n<h3 id=\"线索二叉树的结构体\"><a href=\"#线索二叉树的结构体\" class=\"headerlink\" title=\"线索二叉树的结构体\"></a>线索二叉树的结构体</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\">\tLink = <span class=\"number\">0</span>, Thread = <span class=\"number\">1</span>     <span class=\"comment\">//Link==0:指针，Thread==1,线索</span></span><br><span class=\"line\">&#125;PointerTag;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\tBinaryTree *lChild;</span><br><span class=\"line\">\tBinaryTree *rChild;</span><br><span class=\"line\">\tPointerTag lTag, rTag;</span><br><span class=\"line\">&#125;BinaryTree, *pBinaryTree;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的先序构造\"><a href=\"#二叉树的先序构造\" class=\"headerlink\" title=\"二叉树的先序构造\"></a>二叉树的先序构造</h3><p>要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为’#’，第一个被遍历的结点不需要加上’#’</p>\n<p>如图：先序遍历的结果为：cba###d#e#f##<br>/source/img/DataStructure/binary_tree.jpg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree treeNode=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = (BinaryTree *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttreeNode-&gt;lChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;lChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;lTag = Link;</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;rChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;rTag = Link;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的线索化，代码过程说明：\"><a href=\"#二叉树的线索化，代码过程说明：\" class=\"headerlink\" title=\"二叉树的线索化，代码过程说明：\"></a>二叉树的线索化，代码过程说明：</h3><p>将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；</p>\n<p><font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font></p>\n<ul>\n<li><a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>的中序遍历</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,biTree-&gt;item);</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>二叉树线索化函数的整体框架</li>\n</ul>\n<p>二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%c&quot;,biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对访问结点记录，即对前驱的记录</li>\n</ul>\n<p>在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%c&quot;,biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font></p>\n<p>如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%c&quot;,biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">\t       \t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        pre-&gt;biTree;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对后继的记录</li>\n</ul>\n<p>如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (binaryTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果没有左孩子时前驱线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当没有右孩子，后继线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pre-&gt;rChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\t\tpre-&gt;rChild = binaryTree;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font><br><font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre-&gt;biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font></p>\n<h3 id=\"为已经线索化的二叉树添加头结点\"><a href=\"#为已经线索化的二叉树添加头结点\" class=\"headerlink\" title=\"为已经线索化的二叉树添加头结点\"></a>为已经线索化的二叉树添加头结点</h3><p><img src=\"/public/img/DataStructure/thread_binary_tree.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderThreading</span><span class=\"params\">(pBinaryTree &amp;binarytree,pBinaryTree &amp;head)</span> </span>&#123;</span><br><span class=\"line\">\thead = (pBinaryTree )<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化头结点</span></span><br><span class=\"line\">\thead-&gt;lTag = Link;</span><br><span class=\"line\">\thead-&gt;rTag = Thread;</span><br><span class=\"line\">\thead-&gt;rChild = head;  <span class=\"comment\">//头指针回指</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!binarytree) &#123;</span><br><span class=\"line\">\t\t head-&gt;lChild =head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thead-&gt;lChild = binarytree;  <span class=\"comment\">//当binaryTree非空时，指向二叉树的根结点</span></span><br><span class=\"line\">\t\tpre = head;   <span class=\"comment\">//定义的全局变量第一次赋值使用</span></span><br><span class=\"line\">\t\tInThreading(binarytree);</span><br><span class=\"line\">\t\t<span class=\"comment\">//对最后一个结点线索化</span></span><br><span class=\"line\">\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\tpre-&gt;rChild = head;</span><br><span class=\"line\">\t\thead-&gt;rChild = pre;   <span class=\"comment\">//头结点指向中序遍历的最后一个结点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"对于中序线索树的中序遍历\"><a href=\"#对于中序线索树的中序遍历\" class=\"headerlink\" title=\"对于中序线索树的中序遍历\"></a>对于中序线索树的中序遍历</h3><p>先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继</p>\n<p>一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。</p>\n<p><img src=\"/public/img/DataStructure/thread_binary_tree.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InVisitThreadTree</span><span class=\"params\">(pBinaryTree binarytree)</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree pBTree;</span><br><span class=\"line\">\tpBTree = binarytree-&gt;lChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pBTree != binarytree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到最左元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (pBTree-&gt;lTag == Link)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, pBTree-&gt;item);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果右孩子是线索，则其指向的是下一个访问的结点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((pBTree-&gt;rChild != binarytree) &amp;&amp; (pBTree-&gt;rTag == Thread))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, pBTree-&gt;item);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"测试-cba-d-e-f\"><a href=\"#测试-cba-d-e-f\" class=\"headerlink\" title=\"测试:cba###d#e#f##\"></a>测试:cba###d#e#f##</h3><p><font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义全局变量</span></span><br><span class=\"line\">pBinaryTree pre;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree TbinaryTree, Head;</span><br><span class=\"line\">\tTbinaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;二叉树的先序遍历\\n&quot;</span>);</span><br><span class=\"line\">\tpreVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n二叉树的中序遍历\\n&quot;</span>);</span><br><span class=\"line\">\tinVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\tInOrderThreading(TbinaryTree, Head);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n中序线索二叉树的中序遍历\\n&quot;</span>);</span><br><span class=\"line\">\tInVisitThreadTree(Head);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<p><img src=\"/public/img/DataStructure/binary_tree_result.png\"></p>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-08-04<br>使用二叉树作为存储结构时，只能找到结点的左、右孩子的信息，而不能直接得到结点的前驱和后继的信息；</p>","more":"<p>在有n个结点的二叉树中有n+1个空指针，利用这n+1个空指保存前驱和后继的信息；若结点有左子树，则其lChild指向其左孩子，否则指向其前驱；若结点有右子树，则其rChild指向其右孩子，否则指向其后继；为避免结点指向前驱与后继发生混淆，则在结点上增加两个标志域。</p>\n<p>/source/img/DataStructure/threaded_binary_tree.jpg</p>\n<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点的前驱和后继的指针叫做线索；加上线索的二叉树叫做线索二叉树（Threaded Binary Tree）</p>\n<p>根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树最左下的结点；在中序线索树中找结点前驱的规律是：若其左标志位‘1’，则左链为线索，指示其前驱，否则遍历左子树最后访问的一个结点(左子树最右下的结点)为其前驱。</p>\n<p>为了方便代码的解释可能不会直接将代码完整地贴在文章中，源码地址：<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.3ThreadingBinaryTree.cpp\">二叉线索树源码</a></p>\n<p>如果二叉树的构造、以及遍历不熟悉的可以先看<a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>；</p>\n<h3 id=\"线索二叉树的结构体\"><a href=\"#线索二叉树的结构体\" class=\"headerlink\" title=\"线索二叉树的结构体\"></a>线索二叉树的结构体</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明一个枚举类型来表示指针域的状态,Link=0表示指向左右孩子，Thread表示指向前驱或后继</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\">\tLink = <span class=\"number\">0</span>, Thread = <span class=\"number\">1</span>     <span class=\"comment\">//Link==0:指针，Thread==1,线索</span></span><br><span class=\"line\">&#125;PointerTag;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BinaryTree</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> item;</span><br><span class=\"line\">\tBinaryTree *lChild;</span><br><span class=\"line\">\tBinaryTree *rChild;</span><br><span class=\"line\">\tPointerTag lTag, rTag;</span><br><span class=\"line\">&#125;BinaryTree, *pBinaryTree;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的先序构造\"><a href=\"#二叉树的先序构造\" class=\"headerlink\" title=\"二叉树的先序构造\"></a>二叉树的先序构造</h3><p>要进行二叉树的线索化，需要先构造一棵二叉树；这里采用的是二叉树的先序构造法：在进行二叉树先序构造时，输入的序列为一个二叉树的先序遍历；在进行先序遍历时如果没有孩子，则将孩子置为’#’，第一个被遍历的结点不需要加上’#’</p>\n<p>如图：先序遍历的结果为：cba###d#e#f##<br>/source/img/DataStructure/binary_tree.jpg</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pBinaryTree <span class=\"title\">createBinaryTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree treeNode=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tmp = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tmp == <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttreeNode = (BinaryTree *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\">\t\ttreeNode-&gt;item = tmp;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttreeNode-&gt;lChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;lChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;lTag = Link;</span><br><span class=\"line\">\t\ttreeNode-&gt;rChild=createBinaryTree();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (treeNode-&gt;rChild)</span><br><span class=\"line\">\t\t\ttreeNode-&gt;rTag = Link;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> treeNode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的线索化，代码过程说明：\"><a href=\"#二叉树的线索化，代码过程说明：\" class=\"headerlink\" title=\"二叉树的线索化，代码过程说明：\"></a>二叉树的线索化，代码过程说明：</h3><p>将二叉树线索化的实质是将二叉链表中的空指针改为指向前驱或者后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化二叉树的过程即在遍历的过程中修改空指针的过程；</p>\n<p><font color=\"LightCoral\">注：由于二叉树的第一个结点没有前驱，最后一个结点没有后继，二叉树在线索化的过程中需要引入头结点；二叉树先序遍历的第一个结点的前驱是头结点，最后一个结点的后继的后继也是头结点。</font></p>\n<ul>\n<li><a href=\"https://luciuscs.github.io/2017/07/27/data-structure-binary-tree-visit.html\">二叉树</a>的中序遍历</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inVisitBiTree</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,biTree-&gt;item);</span><br><span class=\"line\">\t\tinVisitBiTree(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>二叉树线索化函数的整体框架</li>\n</ul>\n<p>二叉树的中序线索化的实质是在二叉树中序遍历的过程中，将空指针改为前驱或者后继的过程；首先进行的是二叉树的遍历（不需要输出结点的值）；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%c&quot;,biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对访问结点记录，即对前驱的记录</li>\n</ul>\n<p>在进行中序遍历过程中打印的操作其实就是后面结点的前驱；用一个全局变量pre指针记录前一个被访问过的结点；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%c&quot;,biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font color=\"LightCoral\">全局变量会被赋初值head，在下文中有介绍：</font></p>\n<p>如果访问过的结点没有左孩子，那么左孩子的指针应该指向前驱，即左孩子的指针指向pre，并将令lTag=Thread;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (biTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//printf(&quot;%c&quot;,biTree-&gt;item);  </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">           <span class=\"comment\">//进行指针修改的代码块，两个大括号是为了方便说明；</span></span><br><span class=\"line\">\t       \t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        pre-&gt;biTree;</span><br><span class=\"line\">\t\tInThreading(biTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对后继的记录</li>\n</ul>\n<p>如果访问过的结点没有右孩子，那么右孩子的指针应该指向后继；我们定义的全局变量pre对访问过的结点进行了记录,因此我们只需要将pre的右孩子指向下一个结点即可；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InThreading</span><span class=\"params\">(pBinaryTree biTree)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (binaryTree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;lChild);</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果没有左孩子时前驱线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!binaryTree-&gt;lChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lTag = Thread;</span><br><span class=\"line\">\t\t\tbinaryTree-&gt;lChild = pre;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当没有右孩子，后继线索</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pre-&gt;rChild)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\t\tpre-&gt;rChild = binaryTree;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpre = binaryTree;   <span class=\"comment\">//保持pre指向前驱；</span></span><br><span class=\"line\">\t\tInThreading(binaryTree-&gt;rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><font face=\"黑体\">在进行二叉树线索化时，其实是对每一个结点进行线索化，当每一个结点都线索化后，整个树的线索化也就做好了。</font><br><font color=\"LightCoral\">注：这里有一个疑问就是为什么在指向前驱结点的时候不使用pre记录的结点；在一次递归的结束时将pre-&gt;biTree，即pre一直指向的是刚刚访问的结点；在中序遍历中，pre所在的结点是是其左子树的后继；只有一次遍历结束时才进行判断，然后改变指针（这里有些绕，最好逐语句跑一下代码）</font></p>\n<h3 id=\"为已经线索化的二叉树添加头结点\"><a href=\"#为已经线索化的二叉树添加头结点\" class=\"headerlink\" title=\"为已经线索化的二叉树添加头结点\"></a>为已经线索化的二叉树添加头结点</h3><p><img src=\"/public/img/DataStructure/thread_binary_tree.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderThreading</span><span class=\"params\">(pBinaryTree &amp;binarytree,pBinaryTree &amp;head)</span> </span>&#123;</span><br><span class=\"line\">\thead = (pBinaryTree )<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(BinaryTree));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化头结点</span></span><br><span class=\"line\">\thead-&gt;lTag = Link;</span><br><span class=\"line\">\thead-&gt;rTag = Thread;</span><br><span class=\"line\">\thead-&gt;rChild = head;  <span class=\"comment\">//头指针回指</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!binarytree) &#123;</span><br><span class=\"line\">\t\t head-&gt;lChild =head;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\thead-&gt;lChild = binarytree;  <span class=\"comment\">//当binaryTree非空时，指向二叉树的根结点</span></span><br><span class=\"line\">\t\tpre = head;   <span class=\"comment\">//定义的全局变量第一次赋值使用</span></span><br><span class=\"line\">\t\tInThreading(binarytree);</span><br><span class=\"line\">\t\t<span class=\"comment\">//对最后一个结点线索化</span></span><br><span class=\"line\">\t\tpre-&gt;rTag = Thread;</span><br><span class=\"line\">\t\tpre-&gt;rChild = head;</span><br><span class=\"line\">\t\thead-&gt;rChild = pre;   <span class=\"comment\">//头结点指向中序遍历的最后一个结点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"对于中序线索树的中序遍历\"><a href=\"#对于中序线索树的中序遍历\" class=\"headerlink\" title=\"对于中序线索树的中序遍历\"></a>对于中序线索树的中序遍历</h3><p>先从线索树的根出发，一直沿左指针，找到“最左”（它一定是中序的第一个结点）；然后反复找结点的中序后继</p>\n<p>一个结点的右指针如果是线索，则右指针的下一个线索就是要遍历的结点，如果右指针不是线索，则它的中序后继是其右子树的“最左”结点。</p>\n<p><img src=\"/public/img/DataStructure/thread_binary_tree.jpg\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InVisitThreadTree</span><span class=\"params\">(pBinaryTree binarytree)</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree pBTree;</span><br><span class=\"line\">\tpBTree = binarytree-&gt;lChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//当未遍历迭代完整棵二叉树继续循环；空树或者遍历结束时，pBTree=binaryTree</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (pBTree != binarytree)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到最左元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (pBTree-&gt;lTag == Link)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;lChild;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, pBTree-&gt;item);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果右孩子是线索，则其指向的是下一个访问的结点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((pBTree-&gt;rChild != binarytree) &amp;&amp; (pBTree-&gt;rTag == Thread))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, pBTree-&gt;item);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpBTree = pBTree-&gt;rChild;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"测试-cba-d-e-f\"><a href=\"#测试-cba-d-e-f\" class=\"headerlink\" title=\"测试:cba###d#e#f##\"></a>测试:cba###d#e#f##</h3><p><font color=\"LightCoral\">需要定义一个全局变量，InVisitThreadTree()函数传入的参数是Head，因为线索二叉树的头结点是Head!!!</font></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义全局变量</span></span><br><span class=\"line\">pBinaryTree pre;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpBinaryTree TbinaryTree, Head;</span><br><span class=\"line\">\tTbinaryTree = createBinaryTree();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;二叉树的先序遍历\\n&quot;</span>);</span><br><span class=\"line\">\tpreVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n二叉树的中序遍历\\n&quot;</span>);</span><br><span class=\"line\">\tinVisitBiTree(TbinaryTree);</span><br><span class=\"line\">\tInOrderThreading(TbinaryTree, Head);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n中序线索二叉树的中序遍历\\n&quot;</span>);</span><br><span class=\"line\">\tInVisitThreadTree(Head);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试结果：</p>\n<p><img src=\"/public/img/DataStructure/binary_tree_result.png\"></p>"},{"title":"图的邻接矩阵表示","description":"图的邻接矩阵表示","type":["数据结构"],"cover":"/cover/img47.jpg","toc":true,"date":"2017-08-25T16:00:00.000Z","_content":"\nmodified: 2017-08-04\n### 邻接矩阵\n\n>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。\n<!--more-->\n有向图的邻接矩阵表示:\n\n![](/public/img/DataStructure/adjacency_matrix.jpg)\n\n无向图的邻接矩阵的表示(图中边的权重为1)：\n\n![](/public/img/DataStructure/adjacency_matrix1.png)\n\n\n### 带权无向图邻接矩阵的代码实现\n\n* 图的结构定义\n\n```c\ntypedef struct MGraph {\n\tint numVertices, numEdges;                          //图中实际顶点的个数和边的条数\n\tchar VerticesList[maxVertices];                     //顶点数组\n\tint Edge[maxVertices][maxVertices];                 //邻接矩阵，使用二维数组表示\n};\n```\n\n* 图的初始化\n\n```c\nvoid InitGraph(MGraph &G) {\n\tG.numVertices = 0;\n\tG.numEdges = 0;\n\tfor (int i = 0; i < maxVertices; i++)                //邻接矩阵初始化\n\t{\n\t\tG.VerticesList[i] = '0'; \n\t\tfor (int j = 0; j < maxVertices; j++)            //若为非带权图，全部赋值为0\n\t\t\tG.Edge[i][j] = ((i == j) ? 0 : maxWeight);   //maxWeight代表无穷大\n\t}\n}\n```\n\n* 从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1\n\n```c\nint GetVertexPos(MGraph G, char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i] == x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n```\n\n* 输入创建使用邻接矩阵表示的带权无向图\n\n```c\nvoid CreateGraph(MGraph &G, int numVertex, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图\n\tchar e;\n\tG.numVertices = numVertex;\n\tG.numEdges = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor (int i = 0; i < numVertex; i++)\n\t{\n\t\tscanf(\"%c\", &e);\n\t\tG.VerticesList[i] = e;\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();                  //如果不使用getchar(),则缓冲区内还会有回车键\n\t\tscanf(\"%c %c %d\", &e1, &e2, &weight);\n\t\tif (GetVertexPos(G, e1) !=-1&& GetVertexPos(G, e2) !=-1)\n\t\t{\n\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;\n\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     \n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"输入顶点错误，请重新输入\\n\");\n\t\t}\n\t}\n}\n```\n\n注：若需要带权的有向图只需将```G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;  ```注释即可\n\n* 以下图为例测试\n\n![](/public/img/DataStructure/adjacency_matrix2.png)\n\n\n\n```c\nint main() {\n\n\tMGraph G;\n\tInitGraph(G);\n\tCreateGraph(G, 5, 7);\n\tprintf(\"\\n结果输出\\n\");\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tfor (int j = 0; j < 7; j++)\n\t\t{\n\t\t\tprintf(\"%d \",G.Edge[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 测试结果\n![](/public/img/DataStructure/adjacency_matrix3.png)\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp)\n","source":"_posts/Data_Structure/2017-08-26-data-structure-adjaceny-matrix.md","raw":"---\ntitle: \"图的邻接矩阵表示\"\ndescription: \"图的邻接矩阵表示\"\ntype: [数据结构]\ncover:  /cover/img47.jpg\ntoc: true\ncategories: 数据结构\n\ndate: 2017/08/26\n\n---\n\nmodified: 2017-08-04\n### 邻接矩阵\n\n>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。\n<!--more-->\n有向图的邻接矩阵表示:\n\n![](/public/img/DataStructure/adjacency_matrix.jpg)\n\n无向图的邻接矩阵的表示(图中边的权重为1)：\n\n![](/public/img/DataStructure/adjacency_matrix1.png)\n\n\n### 带权无向图邻接矩阵的代码实现\n\n* 图的结构定义\n\n```c\ntypedef struct MGraph {\n\tint numVertices, numEdges;                          //图中实际顶点的个数和边的条数\n\tchar VerticesList[maxVertices];                     //顶点数组\n\tint Edge[maxVertices][maxVertices];                 //邻接矩阵，使用二维数组表示\n};\n```\n\n* 图的初始化\n\n```c\nvoid InitGraph(MGraph &G) {\n\tG.numVertices = 0;\n\tG.numEdges = 0;\n\tfor (int i = 0; i < maxVertices; i++)                //邻接矩阵初始化\n\t{\n\t\tG.VerticesList[i] = '0'; \n\t\tfor (int j = 0; j < maxVertices; j++)            //若为非带权图，全部赋值为0\n\t\t\tG.Edge[i][j] = ((i == j) ? 0 : maxWeight);   //maxWeight代表无穷大\n\t}\n}\n```\n\n* 从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1\n\n```c\nint GetVertexPos(MGraph G, char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i] == x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n```\n\n* 输入创建使用邻接矩阵表示的带权无向图\n\n```c\nvoid CreateGraph(MGraph &G, int numVertex, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图\n\tchar e;\n\tG.numVertices = numVertex;\n\tG.numEdges = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor (int i = 0; i < numVertex; i++)\n\t{\n\t\tscanf(\"%c\", &e);\n\t\tG.VerticesList[i] = e;\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();                  //如果不使用getchar(),则缓冲区内还会有回车键\n\t\tscanf(\"%c %c %d\", &e1, &e2, &weight);\n\t\tif (GetVertexPos(G, e1) !=-1&& GetVertexPos(G, e2) !=-1)\n\t\t{\n\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;\n\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     \n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"输入顶点错误，请重新输入\\n\");\n\t\t}\n\t}\n}\n```\n\n注：若需要带权的有向图只需将```G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;  ```注释即可\n\n* 以下图为例测试\n\n![](/public/img/DataStructure/adjacency_matrix2.png)\n\n\n\n```c\nint main() {\n\n\tMGraph G;\n\tInitGraph(G);\n\tCreateGraph(G, 5, 7);\n\tprintf(\"\\n结果输出\\n\");\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tfor (int j = 0; j < 7; j++)\n\t\t{\n\t\t\tprintf(\"%d \",G.Edge[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 测试结果\n![](/public/img/DataStructure/adjacency_matrix3.png)\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp)\n","slug":"Data_Structure/2017-08-26-data-structure-adjaceny-matrix","published":1,"updated":"2021-01-05T12:15:03.207Z","_id":"ckjju0m0h001020ua9m8rf5w7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-04</p>\n<h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><blockquote>\n<p>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>有向图的邻接矩阵表示:</p>\n<p><img src=\"/public/img/DataStructure/adjacency_matrix.jpg\"></p>\n<p>无向图的邻接矩阵的表示(图中边的权重为1)：</p>\n<p><img src=\"/public/img/DataStructure/adjacency_matrix1.png\"></p>\n<h3 id=\"带权无向图邻接矩阵的代码实现\"><a href=\"#带权无向图邻接矩阵的代码实现\" class=\"headerlink\" title=\"带权无向图邻接矩阵的代码实现\"></a>带权无向图邻接矩阵的代码实现</h3><ul>\n<li>图的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MGraph</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdges;                          <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> VerticesList[maxVertices];                     <span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Edge[maxVertices][maxVertices];                 <span class=\"comment\">//邻接矩阵，使用二维数组表示</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>图的初始化</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitGraph</span><span class=\"params\">(MGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numEdges = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)                <span class=\"comment\">//邻接矩阵初始化</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i] = <span class=\"string\">&#x27;0&#x27;</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; maxVertices; j++)            <span class=\"comment\">//若为非带权图，全部赋值为0</span></span><br><span class=\"line\">\t\t\tG.Edge[i][j] = ((i == j) ? <span class=\"number\">0</span> : maxWeight);   <span class=\"comment\">//maxWeight代表无穷大</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetVertexPos</span><span class=\"params\">(MGraph G, <span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i] == x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>输入创建使用邻接矩阵表示的带权无向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateGraph</span><span class=\"params\">(MGraph &amp;G, <span class=\"keyword\">int</span> numVertex, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> e;</span><br><span class=\"line\">\tG.numVertices = numVertex;</span><br><span class=\"line\">\tG.numEdges = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertex; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;e);</span><br><span class=\"line\">\t\tG.VerticesList[i] = e;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点和权重\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();                  <span class=\"comment\">//如果不使用getchar(),则缓冲区内还会有回车键</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c %c %d&quot;</span>, &amp;e1, &amp;e2, &amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GetVertexPos(G, e1) !=<span class=\"number\">-1</span>&amp;&amp; GetVertexPos(G, e2) !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     </span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入顶点错误，请重新输入\\n&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：若需要带权的有向图只需将<code>G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;  </code>注释即可</p>\n<ul>\n<li>以下图为例测试</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/adjacency_matrix2.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMGraph G;</span><br><span class=\"line\">\tInitGraph(G);</span><br><span class=\"line\">\tCreateGraph(G, <span class=\"number\">5</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n结果输出\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">7</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,G.Edge[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试结果<br><img src=\"/public/img/DataStructure/adjacency_matrix3.png\"></li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp\">源码下载</a></p>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-08-04</p>\n<h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><blockquote>\n<p>邻接矩阵（adjacency materix）表示又称为数组表示，它使用了两个数组存储图，首先将所有顶点的组织信息组织成一个顶点表，然后利用一个称之为邻接矩阵的二维数组来表示各顶点间的邻接关系。</p>\n</blockquote>","more":"<p>有向图的邻接矩阵表示:</p>\n<p><img src=\"/public/img/DataStructure/adjacency_matrix.jpg\"></p>\n<p>无向图的邻接矩阵的表示(图中边的权重为1)：</p>\n<p><img src=\"/public/img/DataStructure/adjacency_matrix1.png\"></p>\n<h3 id=\"带权无向图邻接矩阵的代码实现\"><a href=\"#带权无向图邻接矩阵的代码实现\" class=\"headerlink\" title=\"带权无向图邻接矩阵的代码实现\"></a>带权无向图邻接矩阵的代码实现</h3><ul>\n<li>图的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MGraph</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdges;                          <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> VerticesList[maxVertices];                     <span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Edge[maxVertices][maxVertices];                 <span class=\"comment\">//邻接矩阵，使用二维数组表示</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>图的初始化</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitGraph</span><span class=\"params\">(MGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numEdges = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)                <span class=\"comment\">//邻接矩阵初始化</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i] = <span class=\"string\">&#x27;0&#x27;</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; maxVertices; j++)            <span class=\"comment\">//若为非带权图，全部赋值为0</span></span><br><span class=\"line\">\t\t\tG.Edge[i][j] = ((i == j) ? <span class=\"number\">0</span> : maxWeight);   <span class=\"comment\">//maxWeight代表无穷大</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从顶点数组中找出顶点的位置，若输入的顶点不在数组中则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetVertexPos</span><span class=\"params\">(MGraph G, <span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i] == x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>输入创建使用邻接矩阵表示的带权无向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreateGraph</span><span class=\"params\">(MGraph &amp;G, <span class=\"keyword\">int</span> numVertex, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息，建立一个带权的无向图</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> e;</span><br><span class=\"line\">\tG.numVertices = numVertex;</span><br><span class=\"line\">\tG.numEdges = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertex; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>, &amp;e);</span><br><span class=\"line\">\t\tG.VerticesList[i] = e;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点和权重\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();                  <span class=\"comment\">//如果不使用getchar(),则缓冲区内还会有回车键</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c %c %d&quot;</span>, &amp;e1, &amp;e2, &amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (GetVertexPos(G, e1) !=<span class=\"number\">-1</span>&amp;&amp; GetVertexPos(G, e2) !=<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e1)][GetVertexPos(G, e2)] = weight;</span><br><span class=\"line\">\t\t\tG.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;     </span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入顶点错误，请重新输入\\n&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：若需要带权的有向图只需将<code>G.Edge[GetVertexPos(G, e2)][GetVertexPos(G, e1)] = weight;  </code>注释即可</p>\n<ul>\n<li>以下图为例测试</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/adjacency_matrix2.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMGraph G;</span><br><span class=\"line\">\tInitGraph(G);</span><br><span class=\"line\">\tCreateGraph(G, <span class=\"number\">5</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n结果输出\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">7</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,G.Edge[i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试结果<br><img src=\"/public/img/DataStructure/adjacency_matrix3.png\"></li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyMatrix.cpp\">源码下载</a></p>"},{"title":"创建大根堆与小根堆","description":"大根堆与小根堆的建立","type":["数据结构"],"cover":"/cover/img48.jpg","toc":true,"date":"2017-08-25T16:00:00.000Z","_content":"modified: 2017-08-26\n### 堆的概念\n\n> n个元素序列{k0,k1,k2...ki...kn-1},当且仅当满足下列关系时称之为堆：\n(ki <= k2i+1,ki <= k2i+2)或者(ki >= k2i+1,ki >= k2i+2), (i = 0,1,2,3,4...(n-2)/2)\n<!--more-->\n注：i从0开始与从1开始，需要改变末尾元素的下标值\n\n#### 堆的性质\n\n>* 堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n>* 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）\n\n\n大根堆与小根堆\n\n![](/public/img/DataStructure/DataStructure/heap.jpg)\n\n\n### 小根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp):\n\n#### 小根堆的建立过程\n\n如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：\n\n![](/public/img/DataStructure/heap1.jpg)\n\n\n\n* 小根堆的结构定义\n\n```c\ntypedef struct minHeap{\n    int heap[HeapSize];      //存放小根堆中元素的数组\n    int n;                  //小根堆当前元素的个数，初始值为0\n}minHeap;\n```\n\n* 自顶向下调整\n\n自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆\n\n```c\nvoid shifDown(minHeap &H, int m) {\n\t//m是开始调整的结点,n是调整结束的点\n\tint tmp = H.heap[m];  //j是i的左子女\n\tfor (int j = 2 * m + 1; j <= H.n-1; j=2*j+1) {\n\t\tif (j<H.n-1&&H.heap[j]>H.heap[j + 1])\n\t\t\tj++;\n\t\tif (tmp <= H.heap[j])\n\t\t\tbreak;\n\t\telse {\n\t\t\ttmp = H.heap[m];\n\t\t\tH.heap[m] = H.heap[j];\n\t\t\tH.heap[j] = tmp;\n\t\t\tm = j;\n\t\t}\n\t}\n}\n\n```\n\n* 构建小根堆\n\n构建的是从下到上，调整的时候是从上至下\n\n\n```c\nvoid createMinHeap(minHeap &H, int arr[], int n) {\n\tfor ( int i = 0; i < n; i++)\n\t\tH.heap[i] = arr[i];\n\tH.n = n;\n\tfor (int i = (H.n - 2) / 2; i >=0;i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H,i);                       //局部自上向下筛选\n\t}\n} \n```\n\n* 自底向上调整小根堆\n\n```c\nvoid shifUp(minHeap &H,int start) {\n\tint j= start;\n\tint i = (j - 1) / 2;\n\tint tmp = H.heap[start];\n\twhile (j>0)\n\t{\n\t\tif (H.heap[i] <= tmp) break;\n\t\telse\n\t\t{\n\t\t\tH.heap[j] = H.heap[i];\n\t\t\tj = i;\n\t\t\ti = (i - 1) / 2;\n\t\t}\n\n\t}\n\tH.heap[j] = tmp;\n}\n\n```\n\n* 小根堆的插入，采用局部自下向上调整\n\n小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用```shifUp```自下向上，一层一层向上调整；\n\n```c\nvoid Insert(minHeap &H,int x) {\n\tif (H.n==HeapSize)\n\t{\n\t\tprintf(\"堆满\");\n\t}\n\tH.heap[H.n] = x;\n\tshifUp(H, H.n);\n\tH.n++;\n}\n```\n\n* 小根堆的删除\n\n小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用```shiftDown```从堆顶向下进行调整\n\n```c\nint Remove(minHeap &H,int &x) {\n\tif (!H.n)\n\t\treturn 0;               //堆空返回0\n\tx = H.heap[0];\n\tH.heap[0] = H.heap[H.n - 1];\n\tH.n--;\n\tfor (int i = (H.n - 2) / 2; i >= 0; i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H, i);                          //局部自上向下筛选\n\t}\n\treturn 1;\n}\n```\n\n* 运行测试\n\n```c\n\n\nint main() {\n\tint arr[8] = { 53,17,78,9,45,65,87,23};\n\tminHeap H;\n\tcreateMinHeap(H,arr,8);\n\n\tprintf(\"小根堆的建立\\n\");\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tprintf(\"\\n小根堆的插入元素10\\n\");\n\tInsert(H,10);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tint x;\n\tx=Remove(H);\n\tprintf(\"\\n小根堆的删除\\n\");\n\tprintf(\"删除的元素为\\n%d\\n\",x);\n\tprintf(\"删除堆顶元素，进行调整后的元素为\\n\");\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n* 运行结果\n\n\n![](/public/img/DataStructure/heap8.jpg)\n\n\n\n\n### 大根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp)\n\n大根堆的建立过程与小根堆的建立过程是相似的；\n\n* 大根堆的结构定义\n\n```c\ntypedef struct MaxHeap {\n\tint heap[HeapSize];\n\tint n;\n}MaxHeap;\n\n```\n\n* 采用自上而下的调整方法\n\n```c\nvoid shiftHeap(MaxHeap &H,int m) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2*m+1; i <=H.n-1 ; i=i*2+1)\n\t{\n\t\tif (i<H.n-1&&H.heap[i]<H.heap[i+1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n\n```\n\n* 大根堆的建立\n\n```c\nvoid createHeap(MaxHeap &H, int arr[],int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\n\tfor (int i = (n-2)/2; i >=0; i--)\n\t{\n\t\tshiftHeap(H, i);\n\t}\n}\n\n```\n\n* 代码测试\n\n```c\nint main() {\n\tint arr[8] = {1,2,3,4,5,6,7,8};\n\tMaxHeap H;\n\tcreateHeap(H, arr,8);\n\tprintf(\"大根堆的创建结果\\n\");\n\tfor (int  i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n* 测试结果\n\n![](/public/img/DataStructure/heap3.jpg)\n\n\n* 结果以树的形式表示\n![](/public/img/DataStructure/heap2.jpg)\n\n\n\n\n\n","source":"_posts/Data_Structure/2017-08-26-data-structure-build-heap.md","raw":"---\ntitle: \"创建大根堆与小根堆\"\ndescription: \"大根堆与小根堆的建立\"\ntype: [数据结构]\n\ncover:  /cover/img48.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/26\n\n---\nmodified: 2017-08-26\n### 堆的概念\n\n> n个元素序列{k0,k1,k2...ki...kn-1},当且仅当满足下列关系时称之为堆：\n(ki <= k2i+1,ki <= k2i+2)或者(ki >= k2i+1,ki >= k2i+2), (i = 0,1,2,3,4...(n-2)/2)\n<!--more-->\n注：i从0开始与从1开始，需要改变末尾元素的下标值\n\n#### 堆的性质\n\n>* 堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。\n>* 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）\n\n\n大根堆与小根堆\n\n![](/public/img/DataStructure/DataStructure/heap.jpg)\n\n\n### 小根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp):\n\n#### 小根堆的建立过程\n\n如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：\n\n![](/public/img/DataStructure/heap1.jpg)\n\n\n\n* 小根堆的结构定义\n\n```c\ntypedef struct minHeap{\n    int heap[HeapSize];      //存放小根堆中元素的数组\n    int n;                  //小根堆当前元素的个数，初始值为0\n}minHeap;\n```\n\n* 自顶向下调整\n\n自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆\n\n```c\nvoid shifDown(minHeap &H, int m) {\n\t//m是开始调整的结点,n是调整结束的点\n\tint tmp = H.heap[m];  //j是i的左子女\n\tfor (int j = 2 * m + 1; j <= H.n-1; j=2*j+1) {\n\t\tif (j<H.n-1&&H.heap[j]>H.heap[j + 1])\n\t\t\tj++;\n\t\tif (tmp <= H.heap[j])\n\t\t\tbreak;\n\t\telse {\n\t\t\ttmp = H.heap[m];\n\t\t\tH.heap[m] = H.heap[j];\n\t\t\tH.heap[j] = tmp;\n\t\t\tm = j;\n\t\t}\n\t}\n}\n\n```\n\n* 构建小根堆\n\n构建的是从下到上，调整的时候是从上至下\n\n\n```c\nvoid createMinHeap(minHeap &H, int arr[], int n) {\n\tfor ( int i = 0; i < n; i++)\n\t\tH.heap[i] = arr[i];\n\tH.n = n;\n\tfor (int i = (H.n - 2) / 2; i >=0;i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H,i);                       //局部自上向下筛选\n\t}\n} \n```\n\n* 自底向上调整小根堆\n\n```c\nvoid shifUp(minHeap &H,int start) {\n\tint j= start;\n\tint i = (j - 1) / 2;\n\tint tmp = H.heap[start];\n\twhile (j>0)\n\t{\n\t\tif (H.heap[i] <= tmp) break;\n\t\telse\n\t\t{\n\t\t\tH.heap[j] = H.heap[i];\n\t\t\tj = i;\n\t\t\ti = (i - 1) / 2;\n\t\t}\n\n\t}\n\tH.heap[j] = tmp;\n}\n\n```\n\n* 小根堆的插入，采用局部自下向上调整\n\n小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用```shifUp```自下向上，一层一层向上调整；\n\n```c\nvoid Insert(minHeap &H,int x) {\n\tif (H.n==HeapSize)\n\t{\n\t\tprintf(\"堆满\");\n\t}\n\tH.heap[H.n] = x;\n\tshifUp(H, H.n);\n\tH.n++;\n}\n```\n\n* 小根堆的删除\n\n小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用```shiftDown```从堆顶向下进行调整\n\n```c\nint Remove(minHeap &H,int &x) {\n\tif (!H.n)\n\t\treturn 0;               //堆空返回0\n\tx = H.heap[0];\n\tH.heap[0] = H.heap[H.n - 1];\n\tH.n--;\n\tfor (int i = (H.n - 2) / 2; i >= 0; i--) {   //自底向上逐步扩大小根堆\n\t\tshifDown(H, i);                          //局部自上向下筛选\n\t}\n\treturn 1;\n}\n```\n\n* 运行测试\n\n```c\n\n\nint main() {\n\tint arr[8] = { 53,17,78,9,45,65,87,23};\n\tminHeap H;\n\tcreateMinHeap(H,arr,8);\n\n\tprintf(\"小根堆的建立\\n\");\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tprintf(\"\\n小根堆的插入元素10\\n\");\n\tInsert(H,10);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tint x;\n\tx=Remove(H);\n\tprintf(\"\\n小根堆的删除\\n\");\n\tprintf(\"删除的元素为\\n%d\\n\",x);\n\tprintf(\"删除堆顶元素，进行调整后的元素为\\n\");\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \", H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n* 运行结果\n\n\n![](/public/img/DataStructure/heap8.jpg)\n\n\n\n\n### 大根堆的建立[源码](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp)\n\n大根堆的建立过程与小根堆的建立过程是相似的；\n\n* 大根堆的结构定义\n\n```c\ntypedef struct MaxHeap {\n\tint heap[HeapSize];\n\tint n;\n}MaxHeap;\n\n```\n\n* 采用自上而下的调整方法\n\n```c\nvoid shiftHeap(MaxHeap &H,int m) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2*m+1; i <=H.n-1 ; i=i*2+1)\n\t{\n\t\tif (i<H.n-1&&H.heap[i]<H.heap[i+1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n\n```\n\n* 大根堆的建立\n\n```c\nvoid createHeap(MaxHeap &H, int arr[],int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\n\tfor (int i = (n-2)/2; i >=0; i--)\n\t{\n\t\tshiftHeap(H, i);\n\t}\n}\n\n```\n\n* 代码测试\n\n```c\nint main() {\n\tint arr[8] = {1,2,3,4,5,6,7,8};\n\tMaxHeap H;\n\tcreateHeap(H, arr,8);\n\tprintf(\"大根堆的创建结果\\n\");\n\tfor (int  i = 0; i < 8; i++)\n\t{\n\t\tprintf(\" %d \",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n* 测试结果\n\n![](/public/img/DataStructure/heap3.jpg)\n\n\n* 结果以树的形式表示\n![](/public/img/DataStructure/heap2.jpg)\n\n\n\n\n\n","slug":"Data_Structure/2017-08-26-data-structure-build-heap","published":1,"updated":"2021-01-05T12:15:04.902Z","_id":"ckjju0m0i001320ua3xo4cs3t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-26</p>\n<h3 id=\"堆的概念\"><a href=\"#堆的概念\" class=\"headerlink\" title=\"堆的概念\"></a>堆的概念</h3><blockquote>\n<p>n个元素序列{k0,k1,k2…ki…kn-1},当且仅当满足下列关系时称之为堆：<br>(ki &lt;= k2i+1,ki &lt;= k2i+2)或者(ki &gt;= k2i+1,ki &gt;= k2i+2), (i = 0,1,2,3,4…(n-2)/2)</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>注：i从0开始与从1开始，需要改变末尾元素的下标值</p>\n<h4 id=\"堆的性质\"><a href=\"#堆的性质\" class=\"headerlink\" title=\"堆的性质\"></a>堆的性质</h4><blockquote>\n<ul>\n<li>堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>\n<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）</li>\n</ul>\n</blockquote>\n<p>大根堆与小根堆</p>\n<p><img src=\"/public/img/DataStructure/DataStructure/heap.jpg\"></p>\n<h3 id=\"小根堆的建立源码\"><a href=\"#小根堆的建立源码\" class=\"headerlink\" title=\"小根堆的建立源码:\"></a>小根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp\">源码</a>:</h3><h4 id=\"小根堆的建立过程\"><a href=\"#小根堆的建立过程\" class=\"headerlink\" title=\"小根堆的建立过程\"></a>小根堆的建立过程</h4><p>如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：</p>\n<p><img src=\"/public/img/DataStructure/heap1.jpg\"></p>\n<ul>\n<li>小根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minHeap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap[HeapSize];      <span class=\"comment\">//存放小根堆中元素的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;                  <span class=\"comment\">//小根堆当前元素的个数，初始值为0</span></span><br><span class=\"line\">&#125;minHeap;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自顶向下调整</li>\n</ul>\n<p>自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifDown</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//m是开始调整的结点,n是调整结束的点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];  <span class=\"comment\">//j是i的左子女</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; j &lt;= H.n<span class=\"number\">-1</span>; j=<span class=\"number\">2</span>*j+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[j]&gt;H.heap[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &lt;= H.heap[j])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttmp = H.heap[m];</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[j];</span><br><span class=\"line\">\t\t\tH.heap[j] = tmp;</span><br><span class=\"line\">\t\t\tm = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>构建小根堆</li>\n</ul>\n<p>构建的是从下到上，调整的时候是从上至下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMinHeap</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>;i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H,i);                       <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>自底向上调整小根堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifUp</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j= start;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = (j - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (H.heap[i] &lt;= tmp) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[j] = H.heap[i];</span><br><span class=\"line\">\t\t\tj = i;</span><br><span class=\"line\">\t\t\ti = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[j] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>小根堆的插入，采用局部自下向上调整</li>\n</ul>\n<p>小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用<code>shifUp</code>自下向上，一层一层向上调整；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (H.n==HeapSize)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;堆满&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[H.n] = x;</span><br><span class=\"line\">\tshifUp(H, H.n);</span><br><span class=\"line\">\tH.n++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>小根堆的删除</li>\n</ul>\n<p>小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用<code>shiftDown</code>从堆顶向下进行调整</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Remove</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!H.n)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;               <span class=\"comment\">//堆空返回0</span></span><br><span class=\"line\">\tx = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tH.heap[<span class=\"number\">0</span>] = H.heap[H.n - <span class=\"number\">1</span>];</span><br><span class=\"line\">\tH.n--;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H, i);                          <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123; <span class=\"number\">53</span>,<span class=\"number\">17</span>,<span class=\"number\">78</span>,<span class=\"number\">9</span>,<span class=\"number\">45</span>,<span class=\"number\">65</span>,<span class=\"number\">87</span>,<span class=\"number\">23</span>&#125;;</span><br><span class=\"line\">\tminHeap H;</span><br><span class=\"line\">\tcreateMinHeap(H,arr,<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;小根堆的建立\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n小根堆的插入元素10\\n&quot;</span>);</span><br><span class=\"line\">\tInsert(H,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\tx=Remove(H);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n小根堆的删除\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除的元素为\\n%d\\n&quot;</span>,x);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除堆顶元素，进行调整后的元素为\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/heap8.jpg\"></p>\n<h3 id=\"大根堆的建立源码\"><a href=\"#大根堆的建立源码\" class=\"headerlink\" title=\"大根堆的建立源码\"></a>大根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp\">源码</a></h3><p>大根堆的建立过程与小根堆的建立过程是相似的；</p>\n<ul>\n<li>大根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MaxHeap</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> heap[HeapSize];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;MaxHeap;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>采用自上而下的调整方法</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeap</span><span class=\"params\">(MaxHeap &amp;H,<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>*m+<span class=\"number\">1</span>; i &lt;=H.n<span class=\"number\">-1</span> ; i=i*<span class=\"number\">2</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[i]&lt;H.heap[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>大根堆的建立</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeap</span><span class=\"params\">(MaxHeap &amp;H, <span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n<span class=\"number\">-2</span>)/<span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeap(H, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>代码测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">\tMaxHeap H;</span><br><span class=\"line\">\tcreateHeap(H, arr,<span class=\"number\">8</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;大根堆的创建结果\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试结果</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/heap3.jpg\"></p>\n<ul>\n<li>结果以树的形式表示<br><img src=\"/public/img/DataStructure/heap2.jpg\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-08-26</p>\n<h3 id=\"堆的概念\"><a href=\"#堆的概念\" class=\"headerlink\" title=\"堆的概念\"></a>堆的概念</h3><blockquote>\n<p>n个元素序列{k0,k1,k2…ki…kn-1},当且仅当满足下列关系时称之为堆：<br>(ki &lt;= k2i+1,ki &lt;= k2i+2)或者(ki &gt;= k2i+1,ki &gt;= k2i+2), (i = 0,1,2,3,4…(n-2)/2)</p>\n</blockquote>","more":"<p>注：i从0开始与从1开始，需要改变末尾元素的下标值</p>\n<h4 id=\"堆的性质\"><a href=\"#堆的性质\" class=\"headerlink\" title=\"堆的性质\"></a>堆的性质</h4><blockquote>\n<ul>\n<li>堆是一棵完全二叉树，即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>\n<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）</li>\n</ul>\n</blockquote>\n<p>大根堆与小根堆</p>\n<p><img src=\"/public/img/DataStructure/DataStructure/heap.jpg\"></p>\n<h3 id=\"小根堆的建立源码\"><a href=\"#小根堆的建立源码\" class=\"headerlink\" title=\"小根堆的建立源码:\"></a>小根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMinHeap.cpp\">源码</a>:</h3><h4 id=\"小根堆的建立过程\"><a href=\"#小根堆的建立过程\" class=\"headerlink\" title=\"小根堆的建立过程\"></a>小根堆的建立过程</h4><p>如果元素数组的初始排列是{53，17，78，09，45，65，87，23}，现在把它视为完全二叉树的顺序存储，从编号最大的分支结点i=」(n-2)/2 」=3开始，轮流以i=3,2,1,0为根，将它们控制的子树调整为小根堆，其过程如图所示：</p>\n<p><img src=\"/public/img/DataStructure/heap1.jpg\"></p>\n<ul>\n<li>小根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">minHeap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heap[HeapSize];      <span class=\"comment\">//存放小根堆中元素的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;                  <span class=\"comment\">//小根堆当前元素的个数，初始值为0</span></span><br><span class=\"line\">&#125;minHeap;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自顶向下调整</li>\n</ul>\n<p>自顶向下调整，在调整的过程中要将根结点的所有子树调节为最小堆</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifDown</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//m是开始调整的结点,n是调整结束的点</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];  <span class=\"comment\">//j是i的左子女</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; j &lt;= H.n<span class=\"number\">-1</span>; j=<span class=\"number\">2</span>*j+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[j]&gt;H.heap[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp &lt;= H.heap[j])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttmp = H.heap[m];</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[j];</span><br><span class=\"line\">\t\t\tH.heap[j] = tmp;</span><br><span class=\"line\">\t\t\tm = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>构建小根堆</li>\n</ul>\n<p>构建的是从下到上，调整的时候是从上至下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMinHeap</span><span class=\"params\">(minHeap &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>;i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H,i);                       <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>自底向上调整小根堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shifUp</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j= start;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = (j - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (H.heap[i] &lt;= tmp) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[j] = H.heap[i];</span><br><span class=\"line\">\t\t\tj = i;</span><br><span class=\"line\">\t\t\ti = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[j] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>小根堆的插入，采用局部自下向上调整</li>\n</ul>\n<p>小根堆的插入，应该插入堆的最后，堆中插入元素后应该使用<code>shifUp</code>自下向上，一层一层向上调整；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (H.n==HeapSize)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;堆满&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.heap[H.n] = x;</span><br><span class=\"line\">\tshifUp(H, H.n);</span><br><span class=\"line\">\tH.n++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>小根堆的删除</li>\n</ul>\n<p>小根堆的删除最小元素，即删除堆顶元素；在把最小元素删除后，一般以堆的最后一个结点填补取走的堆顶元素，并将堆的实际元素个数减1，删除一个元素后会破坏堆，采用<code>shiftDown</code>从堆顶向下进行调整</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Remove</span><span class=\"params\">(minHeap &amp;H,<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!H.n)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;               <span class=\"comment\">//堆空返回0</span></span><br><span class=\"line\">\tx = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tH.heap[<span class=\"number\">0</span>] = H.heap[H.n - <span class=\"number\">1</span>];</span><br><span class=\"line\">\tH.n--;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (H.n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;   <span class=\"comment\">//自底向上逐步扩大小根堆</span></span><br><span class=\"line\">\t\tshifDown(H, i);                          <span class=\"comment\">//局部自上向下筛选</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123; <span class=\"number\">53</span>,<span class=\"number\">17</span>,<span class=\"number\">78</span>,<span class=\"number\">9</span>,<span class=\"number\">45</span>,<span class=\"number\">65</span>,<span class=\"number\">87</span>,<span class=\"number\">23</span>&#125;;</span><br><span class=\"line\">\tminHeap H;</span><br><span class=\"line\">\tcreateMinHeap(H,arr,<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;小根堆的建立\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n小根堆的插入元素10\\n&quot;</span>);</span><br><span class=\"line\">\tInsert(H,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\tx=Remove(H);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n小根堆的删除\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除的元素为\\n%d\\n&quot;</span>,x);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除堆顶元素，进行调整后的元素为\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>, H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/heap8.jpg\"></p>\n<h3 id=\"大根堆的建立源码\"><a href=\"#大根堆的建立源码\" class=\"headerlink\" title=\"大根堆的建立源码\"></a>大根堆的建立<a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/BuildMaxHeap.cpp\">源码</a></h3><p>大根堆的建立过程与小根堆的建立过程是相似的；</p>\n<ul>\n<li>大根堆的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MaxHeap</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> heap[HeapSize];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;MaxHeap;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>采用自上而下的调整方法</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeap</span><span class=\"params\">(MaxHeap &amp;H,<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>*m+<span class=\"number\">1</span>; i &lt;=H.n<span class=\"number\">-1</span> ; i=i*<span class=\"number\">2</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;H.n<span class=\"number\">-1</span>&amp;&amp;H.heap[i]&lt;H.heap[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>大根堆的建立</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeap</span><span class=\"params\">(MaxHeap &amp;H, <span class=\"keyword\">int</span> arr[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n<span class=\"number\">-2</span>)/<span class=\"number\">2</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeap(H, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>代码测试</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> arr[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">\tMaxHeap H;</span><br><span class=\"line\">\tcreateHeap(H, arr,<span class=\"number\">8</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;大根堆的创建结果\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d &quot;</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试结果</li>\n</ul>\n<p><img src=\"/public/img/DataStructure/heap3.jpg\"></p>\n<ul>\n<li>结果以树的形式表示<br><img src=\"/public/img/DataStructure/heap2.jpg\"></li>\n</ul>"},{"title":"图的邻接表存储","description":"图的邻接表存储","type":["数据结构"],"cover":"/cover/img49.jpg","toc":true,"date":"2017-08-26T16:00:00.000Z","_content":"modified: 2017-08-27\n### 邻接表\n\n邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;\n<!--more-->\n![](/public/img/DataStructure/adjacency_list.jpg)\n\n\n* 使用邻接表表示图的数据结构\n\n```c\ntypedef struct EdgeNode {       //边结点的定义\n\tint dest;                   //边的另一个定点的位置\n\tint cost;                   //边上的权重\n\tstruct EdgeNode *link;      //下一条边链指针\n};\n\ntypedef struct VertexNode {       //顶点的定义\n\tchar data;              \n\tstruct  EdgeNode *first;     //边链表的头指针\n};\ntypedef struct ALGraph {          //图的定义\n\tVertexNode VerticesList[maxVertices];     //顶点表（各边链表的头结点）\n\tint numVertices, numEdge;      //图中实际顶点的个数和边的条数\n};\n\n```\n\n* 初始化邻接表\n\n```c\nvoid initGraph(ALGraph &G) {\n\tG.numEdge = 0;\n\tG.numVertices = 0;\n\tfor (int i = 0; i < maxVertices; i++)\n\t{\n\t\tG.VerticesList[i].first = NULL;\n\t}\n}\n\n```\n* 获取顶点在图的数组中的位置，如果不存在则返回-1\n\n```c\nint getVertices(ALGraph G,char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i].data==x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n* 创建一个带权的有向图\n\n```c\nvoid createGraph(ALGraph &G, int numVertices, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息\n\tG.numVertices = numVertices;\n\tG.numEdge = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor ( int i = 0; i < numVertices; i++)\n\t{\n\t\tscanf(\"%c\",&G.VerticesList[i].data);\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < G.numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();\n\t\tscanf(\"%c %c %d\",&e1,&e2,&weight);\n\t\tif (getVertices(G,e1)!=-1&& getVertices(G, e2) != -1)\n\t\t{\n\t\t\tEdgeNode *p, *q;\n\t\t\tp = G.VerticesList[getVertices(G, e1)].first;\n\t\t\tq = (EdgeNode *)malloc(sizeof(EdgeNode));\n\t\t\tif (p==NULL)\n\t\t\t{\n\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (p->link != NULL)\n\t\t\t\t{\n\t\t\t\t\tp = p->link;\n\t\t\t\t}\n\t\t\t\tp->link= q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t  printf(\"顶点输入错误，请重新输入\\n\");\n\t}\n}\n\n```\n\n\n* 测试代码（以上面的无向图为例，因为`createGraph`为构建有向图，只需将无向图看作双向有向图即可）\n\n```c\n\nint main() {\n\tALGraph G;\n\tinitGraph(G);\n\tcreateGraph(G, 4, 3);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"%c \",G.VerticesList[i]);\n\t\tEdgeNode *p = G.VerticesList[i].first;\n\t\twhile (p!= NULL)\n\t\t{\n\t\t\tprintf(\"%d \", p->dest);\n\t\t\tprintf(\"%d \",p->cost);\n\t\t\tp = p->link;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n![](/public/img/DataStructure/adjacency_list1.png)\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp)\n","source":"_posts/Data_Structure/2017-08-27-data-structure-adjacency-list.md","raw":"---\n\ntitle: \"图的邻接表存储\"\ndescription: \"图的邻接表存储\"\ntype: [数据结构]\n\ncover:  /cover/img49.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/27\n---\nmodified: 2017-08-27\n### 邻接表\n\n邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;\n<!--more-->\n![](/public/img/DataStructure/adjacency_list.jpg)\n\n\n* 使用邻接表表示图的数据结构\n\n```c\ntypedef struct EdgeNode {       //边结点的定义\n\tint dest;                   //边的另一个定点的位置\n\tint cost;                   //边上的权重\n\tstruct EdgeNode *link;      //下一条边链指针\n};\n\ntypedef struct VertexNode {       //顶点的定义\n\tchar data;              \n\tstruct  EdgeNode *first;     //边链表的头指针\n};\ntypedef struct ALGraph {          //图的定义\n\tVertexNode VerticesList[maxVertices];     //顶点表（各边链表的头结点）\n\tint numVertices, numEdge;      //图中实际顶点的个数和边的条数\n};\n\n```\n\n* 初始化邻接表\n\n```c\nvoid initGraph(ALGraph &G) {\n\tG.numEdge = 0;\n\tG.numVertices = 0;\n\tfor (int i = 0; i < maxVertices; i++)\n\t{\n\t\tG.VerticesList[i].first = NULL;\n\t}\n}\n\n```\n* 获取顶点在图的数组中的位置，如果不存在则返回-1\n\n```c\nint getVertices(ALGraph G,char x) {\n\tfor (int i = 0; i < G.numVertices; i++)\n\t{\n\t\tif (G.VerticesList[i].data==x)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n* 创建一个带权的有向图\n\n```c\nvoid createGraph(ALGraph &G, int numVertices, int numEdge) {\n\t//从键盘输入n个顶点和m条边的信息\n\tG.numVertices = numVertices;\n\tG.numEdge = numEdge;\n\tprintf(\"请输入顶点\\n\");\n\tfor ( int i = 0; i < numVertices; i++)\n\t{\n\t\tscanf(\"%c\",&G.VerticesList[i].data);\n\t}\n\tprintf(\"请输入顶点和权重\\n\");\n\tfor (int i = 0; i < G.numEdge;)\n\t{\n\t\tchar e1, e2;\n\t\tint weight;\n\t\tgetchar();\n\t\tscanf(\"%c %c %d\",&e1,&e2,&weight);\n\t\tif (getVertices(G,e1)!=-1&& getVertices(G, e2) != -1)\n\t\t{\n\t\t\tEdgeNode *p, *q;\n\t\t\tp = G.VerticesList[getVertices(G, e1)].first;\n\t\t\tq = (EdgeNode *)malloc(sizeof(EdgeNode));\n\t\t\tif (p==NULL)\n\t\t\t{\n\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (p->link != NULL)\n\t\t\t\t{\n\t\t\t\t\tp = p->link;\n\t\t\t\t}\n\t\t\t\tp->link= q;\n\t\t\t\tq->dest = getVertices(G, e2);\n\t\t\t\tq->cost = weight;\n\t\t\t\tq->link = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t  printf(\"顶点输入错误，请重新输入\\n\");\n\t}\n}\n\n```\n\n\n* 测试代码（以上面的无向图为例，因为`createGraph`为构建有向图，只需将无向图看作双向有向图即可）\n\n```c\n\nint main() {\n\tALGraph G;\n\tinitGraph(G);\n\tcreateGraph(G, 4, 3);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"%c \",G.VerticesList[i]);\n\t\tEdgeNode *p = G.VerticesList[i].first;\n\t\twhile (p!= NULL)\n\t\t{\n\t\t\tprintf(\"%d \", p->dest);\n\t\t\tprintf(\"%d \",p->cost);\n\t\t\tp = p->link;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n![](/public/img/DataStructure/adjacency_list1.png)\n\n\n[源码下载](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp)\n","slug":"Data_Structure/2017-08-27-data-structure-adjacency-list","published":1,"updated":"2021-01-05T12:15:07.406Z","_id":"ckjju0m0j001620ua6kn1df6p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-27</p>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;</p>\n<a id=\"more\"></a>\n<p><img src=\"/public/img/DataStructure/adjacency_list.jpg\"></p>\n<ul>\n<li>使用邻接表表示图的数据结构</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> &#123;</span>       <span class=\"comment\">//边结点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> dest;                   <span class=\"comment\">//边的另一个定点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cost;                   <span class=\"comment\">//边上的权重</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> *<span class=\"title\">link</span>;</span>      <span class=\"comment\">//下一条边链指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VertexNode</span> &#123;</span>       <span class=\"comment\">//顶点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">EdgeNode</span> *<span class=\"title\">first</span>;</span>     <span class=\"comment\">//边链表的头指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ALGraph</span> &#123;</span>          <span class=\"comment\">//图的定义</span></span><br><span class=\"line\">\tVertexNode VerticesList[maxVertices];     <span class=\"comment\">//顶点表（各边链表的头结点）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdge;      <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化邻接表</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initGraph</span><span class=\"params\">(ALGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numEdge = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i].first = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取顶点在图的数组中的位置，如果不存在则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getVertices</span><span class=\"params\">(ALGraph G,<span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i].data==x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个带权的有向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createGraph</span><span class=\"params\">(ALGraph &amp;G, <span class=\"keyword\">int</span> numVertices, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息</span></span><br><span class=\"line\">\tG.numVertices = numVertices;</span><br><span class=\"line\">\tG.numEdge = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>,&amp;G.VerticesList[i].data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点和权重\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c %c %d&quot;</span>,&amp;e1,&amp;e2,&amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (getVertices(G,e1)!=<span class=\"number\">-1</span>&amp;&amp; getVertices(G, e2) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tEdgeNode *p, *q;</span><br><span class=\"line\">\t\t\tp = G.VerticesList[getVertices(G, e1)].first;</span><br><span class=\"line\">\t\t\tq = (EdgeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(EdgeNode));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (p-&gt;link != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tp-&gt;link= q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;顶点输入错误，请重新输入\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>测试代码（以上面的无向图为例，因为<code>createGraph</code>为构建有向图，只需将无向图看作双向有向图即可）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tALGraph G;</span><br><span class=\"line\">\tinitGraph(G);</span><br><span class=\"line\">\tcreateGraph(G, <span class=\"number\">4</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>,G.VerticesList[i]);</span><br><span class=\"line\">\t\tEdgeNode *p = G.VerticesList[i].first;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p!= <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, p-&gt;dest);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,p-&gt;cost);</span><br><span class=\"line\">\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br><img src=\"/public/img/DataStructure/adjacency_list1.png\"></li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp\">源码下载</a></p>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-08-27</p>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表（Adjacency List）是图的一种链式存储结构，在邻接表中，对图的每一个顶点建立一个单链表;</p>","more":"<p><img src=\"/public/img/DataStructure/adjacency_list.jpg\"></p>\n<ul>\n<li>使用邻接表表示图的数据结构</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> &#123;</span>       <span class=\"comment\">//边结点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> dest;                   <span class=\"comment\">//边的另一个定点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cost;                   <span class=\"comment\">//边上的权重</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EdgeNode</span> *<span class=\"title\">link</span>;</span>      <span class=\"comment\">//下一条边链指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VertexNode</span> &#123;</span>       <span class=\"comment\">//顶点的定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">EdgeNode</span> *<span class=\"title\">first</span>;</span>     <span class=\"comment\">//边链表的头指针</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ALGraph</span> &#123;</span>          <span class=\"comment\">//图的定义</span></span><br><span class=\"line\">\tVertexNode VerticesList[maxVertices];     <span class=\"comment\">//顶点表（各边链表的头结点）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> numVertices, numEdge;      <span class=\"comment\">//图中实际顶点的个数和边的条数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化邻接表</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initGraph</span><span class=\"params\">(ALGraph &amp;G)</span> </span>&#123;</span><br><span class=\"line\">\tG.numEdge = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tG.numVertices = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tG.VerticesList[i].first = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取顶点在图的数组中的位置，如果不存在则返回-1</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getVertices</span><span class=\"params\">(ALGraph G,<span class=\"keyword\">char</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (G.VerticesList[i].data==x)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个带权的有向图</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createGraph</span><span class=\"params\">(ALGraph &amp;G, <span class=\"keyword\">int</span> numVertices, <span class=\"keyword\">int</span> numEdge)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从键盘输入n个顶点和m条边的信息</span></span><br><span class=\"line\">\tG.numVertices = numVertices;</span><br><span class=\"line\">\tG.numEdge = numEdge;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numVertices; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c&quot;</span>,&amp;G.VerticesList[i].data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;请输入顶点和权重\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.numEdge;)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> e1, e2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t\tgetchar();</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%c %c %d&quot;</span>,&amp;e1,&amp;e2,&amp;weight);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (getVertices(G,e1)!=<span class=\"number\">-1</span>&amp;&amp; getVertices(G, e2) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tEdgeNode *p, *q;</span><br><span class=\"line\">\t\t\tp = G.VerticesList[getVertices(G, e1)].first;</span><br><span class=\"line\">\t\t\tq = (EdgeNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(EdgeNode));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tG.VerticesList[getVertices(G, e1)].first = q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (p-&gt;link != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tp-&gt;link= q;</span><br><span class=\"line\">\t\t\t\tq-&gt;dest = getVertices(G, e2);</span><br><span class=\"line\">\t\t\t\tq-&gt;cost = weight;</span><br><span class=\"line\">\t\t\t\tq-&gt;link = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;顶点输入错误，请重新输入\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>测试代码（以上面的无向图为例，因为<code>createGraph</code>为构建有向图，只需将无向图看作双向有向图即可）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tALGraph G;</span><br><span class=\"line\">\tinitGraph(G);</span><br><span class=\"line\">\tcreateGraph(G, <span class=\"number\">4</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>,G.VerticesList[i]);</span><br><span class=\"line\">\t\tEdgeNode *p = G.VerticesList[i].first;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p!= <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, p-&gt;dest);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,p-&gt;cost);</span><br><span class=\"line\">\t\t\tp = p-&gt;link;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br><img src=\"/public/img/DataStructure/adjacency_list1.png\"></li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/7.2AdjacencyList.cpp\">源码下载</a></p>"},{"title":"堆排序","description":"堆排序","type":["数据结构"],"cover":"/cover/img50.jpg","toc":true,"date":"2017-08-26T16:00:00.000Z","_content":"modified: 2017-08-27\n\n### 堆排序原理\n<!--more-->\n在[建堆](https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html)完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。\n\n#### 使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\n\n* 采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素\n\n```c\nvoid shiftHeapSort(MaxHeapSort &H, int m,int n) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2 * m + 1; i <= n - 1; i = i * 2 + 1)\n\t{\n\t\tif (i<n - 1 && H.heap[i]<H.heap[i + 1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n```\n\n* 创建最大堆\n\n```c\nvoid createHeapSort(MaxHeapSort &H, int arr[], int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\tfor (int i = (n - 2) / 2; i >= 0; i--)\n\t{\n\t\tshiftHeapSort(H, i,H.n);\n\t}\n}\n```\n\n* 对最大堆进行排序\n\n```c\nint main(){\n\t \n\tint a[7] = {7,6,5,4,3,2,1};\n\t//首先构建最大堆\n\tMaxHeapSort H;\n\tcreateHeapSort(H, a, 7);\n\t//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆\n\tint tmp;\n\tfor (int i = H.n-1; i >=0; i--)\n\t{\n\t\ttmp = H.heap[0];\n\t\tH.heap[0] = H.heap[i];\n\t\tH.heap[i] = tmp;\n\t\t//将其再次调整为最大堆\n\t\tfor (int j = i/2; j >=0; j--)\n\t\t{\n\t\t\tshiftHeapSort(H,j,i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n* 运行结果\n![](/public/img/DataStructure/heap_sort.jpg)\n","source":"_posts/Data_Structure/2017-08-27-data-structure-heap-sort.md","raw":"---\n\ntitle: \"堆排序\"\ndescription: \"堆排序\"\ntype: [数据结构]\ncover:  /cover/img50.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/27\n---\nmodified: 2017-08-27\n\n### 堆排序原理\n<!--more-->\n在[建堆](https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html)完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。\n\n#### 使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\n\n* 采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素\n\n```c\nvoid shiftHeapSort(MaxHeapSort &H, int m,int n) {\n\tint tmp = H.heap[m];\n\tfor (int i = 2 * m + 1; i <= n - 1; i = i * 2 + 1)\n\t{\n\t\tif (i<n - 1 && H.heap[i]<H.heap[i + 1])\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (tmp>H.heap[i])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tH.heap[m] = H.heap[i];\n\t\t\tH.heap[i] = tmp;\n\t\t\tm = i;\n\t\t}\n\t}\n}\n```\n\n* 创建最大堆\n\n```c\nvoid createHeapSort(MaxHeapSort &H, int arr[], int n) {\n\t//将数组的内容赋值给堆中的元素\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tH.heap[i] = arr[i];\n\t}\n\tH.n = n;\n\tfor (int i = (n - 2) / 2; i >= 0; i--)\n\t{\n\t\tshiftHeapSort(H, i,H.n);\n\t}\n}\n```\n\n* 对最大堆进行排序\n\n```c\nint main(){\n\t \n\tint a[7] = {7,6,5,4,3,2,1};\n\t//首先构建最大堆\n\tMaxHeapSort H;\n\tcreateHeapSort(H, a, 7);\n\t//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆\n\tint tmp;\n\tfor (int i = H.n-1; i >=0; i--)\n\t{\n\t\ttmp = H.heap[0];\n\t\tH.heap[0] = H.heap[i];\n\t\tH.heap[i] = tmp;\n\t\t//将其再次调整为最大堆\n\t\tfor (int j = i/2; j >=0; j--)\n\t\t{\n\t\t\tshiftHeapSort(H,j,i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\tprintf(\"%d\\n\",H.heap[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n* 运行结果\n![](/public/img/DataStructure/heap_sort.jpg)\n","slug":"Data_Structure/2017-08-27-data-structure-heap-sort","published":1,"updated":"2021-01-05T12:15:09.320Z","_id":"ckjju0m0k001920uadgwdhj4c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-27</p>\n<h3 id=\"堆排序原理\"><a href=\"#堆排序原理\" class=\"headerlink\" title=\"堆排序原理\"></a>堆排序原理</h3><a id=\"more\"></a>\n<p>在<a href=\"https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html\">建堆</a>完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。</p>\n<h4 id=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"><a href=\"#使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\" class=\"headerlink\" title=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"></a>使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）</h4><ul>\n<li>采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;n - <span class=\"number\">1</span> &amp;&amp; H.heap[i]&lt;H.heap[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建最大堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeapSort(H, i,H.n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对最大堆进行排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//首先构建最大堆</span></span><br><span class=\"line\">\tMaxHeapSort H;</span><br><span class=\"line\">\tcreateHeapSort(H, a, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = H.n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tH.heap[<span class=\"number\">0</span>] = H.heap[i];</span><br><span class=\"line\">\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将其再次调整为最大堆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i/<span class=\"number\">2</span>; j &gt;=<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tshiftHeapSort(H,j,i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br><img src=\"/public/img/DataStructure/heap_sort.jpg\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-08-27</p>\n<h3 id=\"堆排序原理\"><a href=\"#堆排序原理\" class=\"headerlink\" title=\"堆排序原理\"></a>堆排序原理</h3>","more":"<p>在<a href=\"https://luciuscs.github.io/2017/08/26/data-structure-build-heap.html\">建堆</a>完毕后,堆排序就是每次将堆顶元素与最后一个元素进行交换，再进行一次针对堆顶元素向下（0，n-2）调整的过程，直至堆中只有一个元素为止。</p>\n<h4 id=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"><a href=\"#使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\" class=\"headerlink\" title=\"使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）\"></a>使用最大堆将元素按照从小到大的顺序进行排序（最小堆排序方式类似）</h4><ul>\n<li>采用自上而下的调整方法,M标记的是子树的根,这里比在构建最大堆多一个参数n是为了标记每次调整的最末尾元素</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shiftHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp = H.heap[m];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span> * m + <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&lt;n - <span class=\"number\">1</span> &amp;&amp; H.heap[i]&lt;H.heap[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&gt;H.heap[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tH.heap[m] = H.heap[i];</span><br><span class=\"line\">\t\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t\tm = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建最大堆</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHeapSort</span><span class=\"params\">(MaxHeapSort &amp;H, <span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将数组的内容赋值给堆中的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tH.heap[i] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tH.n = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tshiftHeapSort(H, i,H.n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对最大堆进行排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">7</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">//首先构建最大堆</span></span><br><span class=\"line\">\tMaxHeapSort H;</span><br><span class=\"line\">\tcreateHeapSort(H, a, <span class=\"number\">7</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//最大堆排序是将每次将堆定的元素与与最后一个元素进行交换，然后再将堆调整为最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = H.n<span class=\"number\">-1</span>; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp = H.heap[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\tH.heap[<span class=\"number\">0</span>] = H.heap[i];</span><br><span class=\"line\">\t\tH.heap[i] = tmp;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将其再次调整为最大堆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i/<span class=\"number\">2</span>; j &gt;=<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tshiftHeapSort(H,j,i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">7</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,H.heap[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br><img src=\"/public/img/DataStructure/heap_sort.jpg\"></li>\n</ul>"},{"title":"Huffman树的算法实现","description":"Huffman树的算法实现","type":["数据结构"],"cover":"/cover/img51.jpg","toc":true,"date":"2017-08-27T16:00:00.000Z","_content":"\nmodified  2017-08-27\n## Huffman树\n\nHuffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；\n<!--more-->\n### Huffman算法\n\n设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树\n/source/img/DataStructure/huffman_tree2.jpg\n\n\n### 构造Huffman树的算法实现\n* Huffman树的结点结构定义\n\n```c\ntypedef struct HuffmanNode {\n\tchar data;              //数据\n\tint weight;             //权重\n\tint lChild, rChild, parent; //指针\n};\n```\n* Huffman树的结构定义\n\n```c\ntypedef struct HuffmanTree {\n\tHuffmanNode elem[totalNumber];  //树的存储数组\n\tint n;                          //当前外结点的个数\n};\n```\n\n* 构造Huffman树\n\n```c\nvoid createHuffmanTree(HuffmanTree &HT,int weight[],int n) {\n\t//给出n个权重的数组，构造Huffman树HT\n\tint p1,p2, min1, min2;                   //p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值\n\tfor (int i = 0; i < n; i++)\n\t\tHT.elem[i].weight = weight[i];        //权重传到树中\n\tfor (int i = 0; i < 2*n-1; i++)            //元素初始化\n\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = -1;\n\tp1 = p2 = 0;\n\tfor ( int i = n; i <2*n-1; i++)          //逐个非叶节点构造\n\t{\n\t\tmin1 = min2 = 100;\n\t\tfor ( int j = 0; j < i; j++)          //寻找具有最小、次小值的根建树\n\t\t{\n\t\t\tif (HT.elem[j].parent== -1) {    //父指针为-1，则此时该节点没有父亲\n\t\t\t\tif (HT.elem[j].weight<min1)   //比原来最小的还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = p1;                   \n\t\t\t\t\tmin2 = min1;               //原来最小的变为最小\n\t\t\t\t\tp1 = j;\n\t\t\t\t\tmin1 = HT.elem[j].weight;   //记下新的最小值\n\t\t\t\t}\n\t\t\t\telse if (HT.elem[j].weight<min2) //比原来的次小还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tmin2 = HT.elem[j].weight;    //记下新的次小值\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHT.elem[i].lChild = p1;\n\t\tHT.elem[i].rChild = p2;        //左最小，右次小链接\n\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;\n\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          //链接父节点\n\t}\n\tHT.n = 2 * n - 1;\n}\n```\n##### 上图构建Huffman树之后的结果\n\n\n![](/public/img/DataStructure/huffman_tree.png)\n![](/public/img/DataStructure/huffman_tree1.png)\n\n\n* 上述代码运行\n\n```c\n\nint main() {\n\tint weight[5] = {7,5,2,4,6};\n\tHuffmanTree ht;\n    createHuffmanTree(ht,weight,5);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\"%d %d %d\\n\",ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n![](/public/img/DataStructure/huffman_tree3.png)\n\n\n\n[源码地址](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp)","source":"_posts/Data_Structure/2017-08-28-data-structure-huffman-tree.md","raw":"---\n\ntitle: \"Huffman树的算法实现\"\ndescription: \"Huffman树的算法实现\"\ntype: [数据结构]\ncover:  /cover/img51.jpg\ntoc: true\ncategories: 数据结构\ndate: 2017/08/28\n---\n\nmodified  2017-08-27\n## Huffman树\n\nHuffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；\n<!--more-->\n### Huffman算法\n\n设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树\n/source/img/DataStructure/huffman_tree2.jpg\n\n\n### 构造Huffman树的算法实现\n* Huffman树的结点结构定义\n\n```c\ntypedef struct HuffmanNode {\n\tchar data;              //数据\n\tint weight;             //权重\n\tint lChild, rChild, parent; //指针\n};\n```\n* Huffman树的结构定义\n\n```c\ntypedef struct HuffmanTree {\n\tHuffmanNode elem[totalNumber];  //树的存储数组\n\tint n;                          //当前外结点的个数\n};\n```\n\n* 构造Huffman树\n\n```c\nvoid createHuffmanTree(HuffmanTree &HT,int weight[],int n) {\n\t//给出n个权重的数组，构造Huffman树HT\n\tint p1,p2, min1, min2;                   //p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值\n\tfor (int i = 0; i < n; i++)\n\t\tHT.elem[i].weight = weight[i];        //权重传到树中\n\tfor (int i = 0; i < 2*n-1; i++)            //元素初始化\n\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = -1;\n\tp1 = p2 = 0;\n\tfor ( int i = n; i <2*n-1; i++)          //逐个非叶节点构造\n\t{\n\t\tmin1 = min2 = 100;\n\t\tfor ( int j = 0; j < i; j++)          //寻找具有最小、次小值的根建树\n\t\t{\n\t\t\tif (HT.elem[j].parent== -1) {    //父指针为-1，则此时该节点没有父亲\n\t\t\t\tif (HT.elem[j].weight<min1)   //比原来最小的还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = p1;                   \n\t\t\t\t\tmin2 = min1;               //原来最小的变为最小\n\t\t\t\t\tp1 = j;\n\t\t\t\t\tmin1 = HT.elem[j].weight;   //记下新的最小值\n\t\t\t\t}\n\t\t\t\telse if (HT.elem[j].weight<min2) //比原来的次小还要小\n\t\t\t\t{\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tmin2 = HT.elem[j].weight;    //记下新的次小值\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHT.elem[i].lChild = p1;\n\t\tHT.elem[i].rChild = p2;        //左最小，右次小链接\n\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;\n\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          //链接父节点\n\t}\n\tHT.n = 2 * n - 1;\n}\n```\n##### 上图构建Huffman树之后的结果\n\n\n![](/public/img/DataStructure/huffman_tree.png)\n![](/public/img/DataStructure/huffman_tree1.png)\n\n\n* 上述代码运行\n\n```c\n\nint main() {\n\tint weight[5] = {7,5,2,4,6};\n\tHuffmanTree ht;\n    createHuffmanTree(ht,weight,5);\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tprintf(\"%d %d %d\\n\",ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n* 运行结果\n![](/public/img/DataStructure/huffman_tree3.png)\n\n\n\n[源码地址](https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp)","slug":"Data_Structure/2017-08-28-data-structure-huffman-tree","published":1,"updated":"2021-01-05T12:15:10.554Z","_id":"ckjju0m0k001c20uags3b7xve","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified  2017-08-27</p>\n<h2 id=\"Huffman树\"><a href=\"#Huffman树\" class=\"headerlink\" title=\"Huffman树\"></a>Huffman树</h2><p>Huffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；</p>\n<a id=\"more\"></a>\n<h3 id=\"Huffman算法\"><a href=\"#Huffman算法\" class=\"headerlink\" title=\"Huffman算法\"></a>Huffman算法</h3><p>设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树<br>/source/img/DataStructure/huffman_tree2.jpg</p>\n<h3 id=\"构造Huffman树的算法实现\"><a href=\"#构造Huffman树的算法实现\" class=\"headerlink\" title=\"构造Huffman树的算法实现\"></a>构造Huffman树的算法实现</h3><ul>\n<li>Huffman树的结点结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;             <span class=\"comment\">//权重</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lChild, rChild, parent; <span class=\"comment\">//指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Huffman树的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanTree</span> &#123;</span></span><br><span class=\"line\">\tHuffmanNode elem[totalNumber];  <span class=\"comment\">//树的存储数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;                          <span class=\"comment\">//当前外结点的个数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造Huffman树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHuffmanTree</span><span class=\"params\">(HuffmanTree &amp;HT,<span class=\"keyword\">int</span> weight[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//给出n个权重的数组，构造Huffman树HT</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p1,p2, min1, min2;                   <span class=\"comment\">//p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tHT.elem[i].weight = weight[i];        <span class=\"comment\">//权重传到树中</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)            <span class=\"comment\">//元素初始化</span></span><br><span class=\"line\">\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tp1 = p2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = n; i &lt;<span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)          <span class=\"comment\">//逐个非叶节点构造</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmin1 = min2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)          <span class=\"comment\">//寻找具有最小、次小值的根建树</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].parent== <span class=\"number\">-1</span>) &#123;    <span class=\"comment\">//父指针为-1，则此时该节点没有父亲</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min1)   <span class=\"comment\">//比原来最小的还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = p1;                   </span><br><span class=\"line\">\t\t\t\t\tmin2 = min1;               <span class=\"comment\">//原来最小的变为最小</span></span><br><span class=\"line\">\t\t\t\t\tp1 = j;</span><br><span class=\"line\">\t\t\t\t\tmin1 = HT.elem[j].weight;   <span class=\"comment\">//记下新的最小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min2) <span class=\"comment\">//比原来的次小还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = j;</span><br><span class=\"line\">\t\t\t\t\tmin2 = HT.elem[j].weight;    <span class=\"comment\">//记下新的次小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tHT.elem[i].lChild = p1;</span><br><span class=\"line\">\t\tHT.elem[i].rChild = p2;        <span class=\"comment\">//左最小，右次小链接</span></span><br><span class=\"line\">\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;</span><br><span class=\"line\">\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          <span class=\"comment\">//链接父节点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHT.n = <span class=\"number\">2</span> * n - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"上图构建Huffman树之后的结果\"><a href=\"#上图构建Huffman树之后的结果\" class=\"headerlink\" title=\"上图构建Huffman树之后的结果\"></a>上图构建Huffman树之后的结果</h5><p><img src=\"/public/img/DataStructure/huffman_tree.png\"><br><img src=\"/public/img/DataStructure/huffman_tree1.png\"></p>\n<ul>\n<li>上述代码运行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight[<span class=\"number\">5</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">\tHuffmanTree ht;</span><br><span class=\"line\">    createHuffmanTree(ht,weight,<span class=\"number\">5</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d\\n&quot;</span>,ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br><img src=\"/public/img/DataStructure/huffman_tree3.png\"></li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"<p>modified  2017-08-27</p>\n<h2 id=\"Huffman树\"><a href=\"#Huffman树\" class=\"headerlink\" title=\"Huffman树\"></a>Huffman树</h2><p>Huffman树，又称最优二叉树或哈夫曼树，是一类加权路径长度最短的二叉树；</p>","more":"<h3 id=\"Huffman算法\"><a href=\"#Huffman算法\" class=\"headerlink\" title=\"Huffman算法\"></a>Huffman算法</h3><p>设给定的权重集合为{7，5，2，4，6}，构造Huffman树的过程如下图所示。首先构造每棵树只有一个结点的森林，然后每次选择两个根结点权重最小的二叉树，以它们为左、右子树构造新的二叉树，最后得到一棵二叉树<br>/source/img/DataStructure/huffman_tree2.jpg</p>\n<h3 id=\"构造Huffman树的算法实现\"><a href=\"#构造Huffman树的算法实现\" class=\"headerlink\" title=\"构造Huffman树的算法实现\"></a>构造Huffman树的算法实现</h3><ul>\n<li>Huffman树的结点结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;              <span class=\"comment\">//数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;             <span class=\"comment\">//权重</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lChild, rChild, parent; <span class=\"comment\">//指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Huffman树的结构定义</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HuffmanTree</span> &#123;</span></span><br><span class=\"line\">\tHuffmanNode elem[totalNumber];  <span class=\"comment\">//树的存储数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;                          <span class=\"comment\">//当前外结点的个数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造Huffman树</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createHuffmanTree</span><span class=\"params\">(HuffmanTree &amp;HT,<span class=\"keyword\">int</span> weight[],<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//给出n个权重的数组，构造Huffman树HT</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p1,p2, min1, min2;                   <span class=\"comment\">//p1记最小的位置，p2记次小的位置，min1是最小的值，min2是次小的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">\t\tHT.elem[i].weight = weight[i];        <span class=\"comment\">//权重传到树中</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)            <span class=\"comment\">//元素初始化</span></span><br><span class=\"line\">\t\tHT.elem[i].parent = HT.elem[i].lChild = HT.elem[i].rChild = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tp1 = p2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = n; i &lt;<span class=\"number\">2</span>*n<span class=\"number\">-1</span>; i++)          <span class=\"comment\">//逐个非叶节点构造</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tmin1 = min2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)          <span class=\"comment\">//寻找具有最小、次小值的根建树</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].parent== <span class=\"number\">-1</span>) &#123;    <span class=\"comment\">//父指针为-1，则此时该节点没有父亲</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min1)   <span class=\"comment\">//比原来最小的还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = p1;                   </span><br><span class=\"line\">\t\t\t\t\tmin2 = min1;               <span class=\"comment\">//原来最小的变为最小</span></span><br><span class=\"line\">\t\t\t\t\tp1 = j;</span><br><span class=\"line\">\t\t\t\t\tmin1 = HT.elem[j].weight;   <span class=\"comment\">//记下新的最小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (HT.elem[j].weight&lt;min2) <span class=\"comment\">//比原来的次小还要小</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tp2 = j;</span><br><span class=\"line\">\t\t\t\t\tmin2 = HT.elem[j].weight;    <span class=\"comment\">//记下新的次小值</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tHT.elem[i].lChild = p1;</span><br><span class=\"line\">\t\tHT.elem[i].rChild = p2;        <span class=\"comment\">//左最小，右次小链接</span></span><br><span class=\"line\">\t\tHT.elem[i].weight = HT.elem[p1].weight + HT.elem[p2].weight;</span><br><span class=\"line\">\t\tHT.elem[p1].parent = HT.elem[p2].parent =i ;          <span class=\"comment\">//链接父节点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHT.n = <span class=\"number\">2</span> * n - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"上图构建Huffman树之后的结果\"><a href=\"#上图构建Huffman树之后的结果\" class=\"headerlink\" title=\"上图构建Huffman树之后的结果\"></a>上图构建Huffman树之后的结果</h5><p><img src=\"/public/img/DataStructure/huffman_tree.png\"><br><img src=\"/public/img/DataStructure/huffman_tree1.png\"></p>\n<ul>\n<li>上述代码运行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight[<span class=\"number\">5</span>] = &#123;<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">\tHuffmanTree ht;</span><br><span class=\"line\">    createHuffmanTree(ht,weight,<span class=\"number\">5</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d\\n&quot;</span>,ht.elem[i].parent, ht.elem[i].lChild, ht.elem[i].rChild);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行结果<br><img src=\"/public/img/DataStructure/huffman_tree3.png\"></li>\n</ul>\n<p><a href=\"https://github.com/LuciusCS/DataStructure/blob/master/DataStructure/DataStructure/6.5HuffmanTree.cpp\">源码地址</a></p>"},{"title":"Flutter开发基础","description":"Flutter开发基础","type":["Android"],"toc":true,"cover":"/cover/img108.jpg","date":"2020-12-09T16:00:00.000Z","_content":"\n# Flutter基础\n\n\n## pubspec.yaml\n\nyaml文件格式严格控制，需要注意其中的空格； \n\n相当于gradle中配置文件 \n\n\n### 视图树\n\n树更新：\n    全局更新：调用runApp(rootWidget)，一般flutter启动时调用后不会再调用\n\n    局部子树更新：将子树座位StatefulWidget的一个子Widget，并创建对应的State类实例，通过调用State.setState()出发子树的刷新\n\n\n\n\n #### StatefulWidget\n\n * StatefulWidget：存在中间状态变化的widget\n\n   \n\n #### Scaffold脚手架\n\n 相当于TitleBar   \n\n\n #### Flutter手势\n\n 触摸","source":"_posts/Flutter/Flutter基础.md","raw":"---\ntitle: \"Flutter开发基础\"\ndescription: \"Flutter开发基础\"\ntype: [Android]\ntoc: true\ncover:  /cover/img108.jpg\ncategories: Android\ndate: 2020/12/10\n---\n\n# Flutter基础\n\n\n## pubspec.yaml\n\nyaml文件格式严格控制，需要注意其中的空格； \n\n相当于gradle中配置文件 \n\n\n### 视图树\n\n树更新：\n    全局更新：调用runApp(rootWidget)，一般flutter启动时调用后不会再调用\n\n    局部子树更新：将子树座位StatefulWidget的一个子Widget，并创建对应的State类实例，通过调用State.setState()出发子树的刷新\n\n\n\n\n #### StatefulWidget\n\n * StatefulWidget：存在中间状态变化的widget\n\n   \n\n #### Scaffold脚手架\n\n 相当于TitleBar   \n\n\n #### Flutter手势\n\n 触摸","slug":"Flutter/Flutter基础","published":1,"updated":"2021-01-06T01:03:15.070Z","_id":"ckjju0m0l001f20ua7xhg7r5j","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Flutter基础\"><a href=\"#Flutter基础\" class=\"headerlink\" title=\"Flutter基础\"></a>Flutter基础</h1><h2 id=\"pubspec-yaml\"><a href=\"#pubspec-yaml\" class=\"headerlink\" title=\"pubspec.yaml\"></a>pubspec.yaml</h2><p>yaml文件格式严格控制，需要注意其中的空格； </p>\n<p>相当于gradle中配置文件 </p>\n<h3 id=\"视图树\"><a href=\"#视图树\" class=\"headerlink\" title=\"视图树\"></a>视图树</h3><p>树更新：<br>    全局更新：调用runApp(rootWidget)，一般flutter启动时调用后不会再调用</p>\n<pre><code>局部子树更新：将子树座位StatefulWidget的一个子Widget，并创建对应的State类实例，通过调用State.setState()出发子树的刷新</code></pre>\n<h4 id=\"StatefulWidget\"><a href=\"#StatefulWidget\" class=\"headerlink\" title=\"StatefulWidget\"></a>StatefulWidget</h4><ul>\n<li>StatefulWidget：存在中间状态变化的widget</li>\n</ul>\n<h4 id=\"Scaffold脚手架\"><a href=\"#Scaffold脚手架\" class=\"headerlink\" title=\"Scaffold脚手架\"></a>Scaffold脚手架</h4><p> 相当于TitleBar   </p>\n<h4 id=\"Flutter手势\"><a href=\"#Flutter手势\" class=\"headerlink\" title=\"Flutter手势\"></a>Flutter手势</h4><p> 触摸</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter基础\"><a href=\"#Flutter基础\" class=\"headerlink\" title=\"Flutter基础\"></a>Flutter基础</h1><h2 id=\"pubspec-yaml\"><a href=\"#pubspec-yaml\" class=\"headerlink\" title=\"pubspec.yaml\"></a>pubspec.yaml</h2><p>yaml文件格式严格控制，需要注意其中的空格； </p>\n<p>相当于gradle中配置文件 </p>\n<h3 id=\"视图树\"><a href=\"#视图树\" class=\"headerlink\" title=\"视图树\"></a>视图树</h3><p>树更新：<br>    全局更新：调用runApp(rootWidget)，一般flutter启动时调用后不会再调用</p>\n<pre><code>局部子树更新：将子树座位StatefulWidget的一个子Widget，并创建对应的State类实例，通过调用State.setState()出发子树的刷新</code></pre>\n<h4 id=\"StatefulWidget\"><a href=\"#StatefulWidget\" class=\"headerlink\" title=\"StatefulWidget\"></a>StatefulWidget</h4><ul>\n<li>StatefulWidget：存在中间状态变化的widget</li>\n</ul>\n<h4 id=\"Scaffold脚手架\"><a href=\"#Scaffold脚手架\" class=\"headerlink\" title=\"Scaffold脚手架\"></a>Scaffold脚手架</h4><p> 相当于TitleBar   </p>\n<h4 id=\"Flutter手势\"><a href=\"#Flutter手势\" class=\"headerlink\" title=\"Flutter手势\"></a>Flutter手势</h4><p> 触摸</p>\n"},{"title":"Flutter开发问题解决","description":"Flutter开发问题解决","type":["Android"],"toc":true,"cover":"/cover/img113.jpg","date":"2020-12-10T16:00:00.000Z","_content":"\n## Flutter问题解决\n\n\n### Couldn't read file io\\flutter\\plugins\\pathprovider\\PathProviderPlugin.java even though it exists. Please verify that this file has read permission and try again.\n\n解决方法：https://stackoverflow.com/questions/60480786/flutter-packages-get-failes-with-error-couldnt-read-file-localfile\n\n\n```xml\n\n    flutter clean\n    flutter pub cache repair\n    flutter pub get\n```","source":"_posts/Flutter/Flutter问题解决.md","raw":"---\ntitle: \"Flutter开发问题解决\"\ndescription: \"Flutter开发问题解决\"\ntype: [Android]\ntoc: true\ncover:  /cover/img113.jpg\ncategories: Android\ndate: 2020/12/11\n---\n\n## Flutter问题解决\n\n\n### Couldn't read file io\\flutter\\plugins\\pathprovider\\PathProviderPlugin.java even though it exists. Please verify that this file has read permission and try again.\n\n解决方法：https://stackoverflow.com/questions/60480786/flutter-packages-get-failes-with-error-couldnt-read-file-localfile\n\n\n```xml\n\n    flutter clean\n    flutter pub cache repair\n    flutter pub get\n```","slug":"Flutter/Flutter问题解决","published":1,"updated":"2021-01-06T01:09:29.298Z","_id":"ckjju0m0m001i20uah48ihmoj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Flutter问题解决\"><a href=\"#Flutter问题解决\" class=\"headerlink\" title=\"Flutter问题解决\"></a>Flutter问题解决</h2><h3 id=\"Couldn’t-read-file-io-flutter-plugins-pathprovider-PathProviderPlugin-java-even-though-it-exists-Please-verify-that-this-file-has-read-permission-and-try-again\"><a href=\"#Couldn’t-read-file-io-flutter-plugins-pathprovider-PathProviderPlugin-java-even-though-it-exists-Please-verify-that-this-file-has-read-permission-and-try-again\" class=\"headerlink\" title=\"Couldn’t read file io\\flutter\\plugins\\pathprovider\\PathProviderPlugin.java even though it exists. Please verify that this file has read permission and try again.\"></a>Couldn’t read file io\\flutter\\plugins\\pathprovider\\PathProviderPlugin.java even though it exists. Please verify that this file has read permission and try again.</h3><p>解决方法：<a href=\"https://stackoverflow.com/questions/60480786/flutter-packages-get-failes-with-error-couldnt-read-file-localfile\">https://stackoverflow.com/questions/60480786/flutter-packages-get-failes-with-error-couldnt-read-file-localfile</a></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">flutter clean</span><br><span class=\"line\">flutter pub cache repair</span><br><span class=\"line\">flutter pub get</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Flutter问题解决\"><a href=\"#Flutter问题解决\" class=\"headerlink\" title=\"Flutter问题解决\"></a>Flutter问题解决</h2><h3 id=\"Couldn’t-read-file-io-flutter-plugins-pathprovider-PathProviderPlugin-java-even-though-it-exists-Please-verify-that-this-file-has-read-permission-and-try-again\"><a href=\"#Couldn’t-read-file-io-flutter-plugins-pathprovider-PathProviderPlugin-java-even-though-it-exists-Please-verify-that-this-file-has-read-permission-and-try-again\" class=\"headerlink\" title=\"Couldn’t read file io\\flutter\\plugins\\pathprovider\\PathProviderPlugin.java even though it exists. Please verify that this file has read permission and try again.\"></a>Couldn’t read file io\\flutter\\plugins\\pathprovider\\PathProviderPlugin.java even though it exists. Please verify that this file has read permission and try again.</h3><p>解决方法：<a href=\"https://stackoverflow.com/questions/60480786/flutter-packages-get-failes-with-error-couldnt-read-file-localfile\">https://stackoverflow.com/questions/60480786/flutter-packages-get-failes-with-error-couldnt-read-file-localfile</a></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">flutter clean</span><br><span class=\"line\">flutter pub cache repair</span><br><span class=\"line\">flutter pub get</span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1001. A+B Format","description":"Calculate a + b and output the sum in standard format.","type":["pat"],"toc":true,"cover":"/cover/img69.jpg","date":"2017-07-26T16:00:00.000Z","_content":"\nmodified: 2017-07-27\n\n* A+B Format (20)\n\nCalculate a + b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\n<!--more-->\nInput\n\nEach input file contains one test case. Each case contains a pair of integers a and b where -1000000 <= a, b <= 1000000. The numbers are separated by a space.\n\nOutput\n\nFor each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.\n\nSample Input\n-1000000 9\n\nSample Output\n-999,991\n\n### 题目要求：\n\n计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；\n\n输入：输入两个在[-1000000,1000000]的a,b两个数\n\n输出：应该在一行格式化输出\n\n### 解题思路：\n\na,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\nint main() {\n\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint num = 0;\n\tint tmp[3];\n\n\tscanf(\"%d%d\", &a, &b);\n\tc = a + b;\n\n\tif (c < 0)\n\t{\n\t\tprintf(\"%c\", '-');\n\t\tc = -c;\n\t}\n\n\twhile (c/1000>=1)\n\t{\n\t\ttmp[num] = c % 1000;\n\t\tnum++;\n\t\tc = c / 1000;\n\t\t\n\t}\n\ttmp[num] = c;\n\n\tfor (int  i = num; i >=0; i--)\n\t{\n\t\tif (i==num)\n\t\t{\n\t\t\tprintf(\"%d\", tmp[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tmp[i]<10)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",00\", tmp[i]);\n\t\t\t}\n\t\t\telse if (tmp[i]<100)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",0\", tmp[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",\", tmp[i]);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n","source":"_posts/PAT/2017-07-27-pat-advanced-1001.md","raw":"---\ntitle: \"PAT甲级1001. A+B Format\"\ndescription: \"Calculate a + b and output the sum in standard format.\"\ntype: [pat]\ntoc: true\ncover:  /cover/img69.jpg\ncategories: PAT\ndate: 2017/07/27\n---\n\nmodified: 2017-07-27\n\n* A+B Format (20)\n\nCalculate a + b and output the sum in standard format -- that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\n<!--more-->\nInput\n\nEach input file contains one test case. Each case contains a pair of integers a and b where -1000000 <= a, b <= 1000000. The numbers are separated by a space.\n\nOutput\n\nFor each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.\n\nSample Input\n-1000000 9\n\nSample Output\n-999,991\n\n### 题目要求：\n\n计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；\n\n输入：输入两个在[-1000000,1000000]的a,b两个数\n\n输出：应该在一行格式化输出\n\n### 解题思路：\n\na,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\nint main() {\n\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint num = 0;\n\tint tmp[3];\n\n\tscanf(\"%d%d\", &a, &b);\n\tc = a + b;\n\n\tif (c < 0)\n\t{\n\t\tprintf(\"%c\", '-');\n\t\tc = -c;\n\t}\n\n\twhile (c/1000>=1)\n\t{\n\t\ttmp[num] = c % 1000;\n\t\tnum++;\n\t\tc = c / 1000;\n\t\t\n\t}\n\ttmp[num] = c;\n\n\tfor (int  i = num; i >=0; i--)\n\t{\n\t\tif (i==num)\n\t\t{\n\t\t\tprintf(\"%d\", tmp[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tmp[i]<10)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",00\", tmp[i]);\n\t\t\t}\n\t\t\telse if (tmp[i]<100)\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",0\", tmp[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s%d\", \",\", tmp[i]);\n\t\t\t}\n\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n","slug":"PAT/2017-07-27-pat-advanced-1001","published":1,"updated":"2021-01-05T12:15:54.273Z","_id":"ckjju0m0m001l20ua2bsb13aq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27</p>\n<ul>\n<li>A+B Format (20)</li>\n</ul>\n<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>\n<a id=\"more\"></a>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p>\n<p>Output</p>\n<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>\n<p>Sample Input<br>-1000000 9</p>\n<p>Sample Output<br>-999,991</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；</p>\n<p>输入：输入两个在[-1000000,1000000]的a,b两个数</p>\n<p>输出：应该在一行格式化输出</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>a,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class=\"line\">\tc = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, <span class=\"string\">&#x27;-&#x27;</span>);</span><br><span class=\"line\">\t\tc = -c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (c/<span class=\"number\">1000</span>&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[num] = c % <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t\tc = c / <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttmp[num] = c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = num; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i==num)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, <span class=\"string\">&quot;,00&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">100</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, <span class=\"string\">&quot;,0&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, <span class=\"string\">&quot;,&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-07-27</p>\n<ul>\n<li>A+B Format (20)</li>\n</ul>\n<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>","more":"<p>Input</p>\n<p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p>\n<p>Output</p>\n<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>\n<p>Sample Input<br>-1000000 9</p>\n<p>Sample Output<br>-999,991</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>计算a+b然后格式化输出结果，格式化输出要求：结果如果超过四位，就用小数点每三位隔开输出；</p>\n<p>输入：输入两个在[-1000000,1000000]的a,b两个数</p>\n<p>输出：应该在一行格式化输出</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>a,b的和的取值范围为[-1000000,1000000]没有超过C语言int类型数据的范围，所以不用担心溢出的问题，结果每三位需要输出一个逗号，将结果不断除1000取余，就会没一次得到少于三位的余数，需要对余数进行判断，不足三位的需要用0补足最高位，但最后一次取余不需要用零来补位。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tmp[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class=\"line\">\tc = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>, <span class=\"string\">&#x27;-&#x27;</span>);</span><br><span class=\"line\">\t\tc = -c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (c/<span class=\"number\">1000</span>&gt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ttmp[num] = c % <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t\tc = c / <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttmp[num] = c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = num; i &gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i==num)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, <span class=\"string\">&quot;,00&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tmp[i]&lt;<span class=\"number\">100</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, <span class=\"string\">&quot;,0&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, <span class=\"string\">&quot;,&quot;</span>, tmp[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1002. A+B for Polynomials","description":"This time, you are supposed to find A+B where A and B are two polynomials. ","type":["pat"],"toc":true,"cover":"/cover/img70.jpg","date":"2017-07-26T16:00:00.000Z","_content":"\nmodified: 2017-07-27\n\nThis time, you are supposed to find A+B where A and B are two polynomials.\n<!--more-->\nInput\n\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively. It is given that 1 <= K <= 10，0 <= NK < ... < N2 < N1 <=1000.\n\nOutput\n\nFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.\n\nSample Input\n\n2 1 2.4 0 3.2\n\n2 2 1.5 1 0.5\n\nSample Output\n\n3 2 1.5 1 2.9 0 3.2\n\n### 题目要求：\n\n两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 ... 其中K代表项数，N1...代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；\n\n### 解题思路：\n\n定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；\n\n* 本题目采用C语言进行编写\n\n```c\n\nint main() {\n\n\tint k1, k2, k3, count1 = 0, count2 = 0, count3 = 0;\n\tfloat NA1[20] = { 0 };\n\tfloat NA2[20] = { 0 };\n\tfloat NA3[40] = { 0 };\n\tchar ch;\n\n\tscanf(\"%d\", &k1);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA1[count1++]);\n\t}\n\n\tscanf(\"%d\", &k2);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA2[count2++]);\n\t}\n\n\tcount1 = count2 = 0;\n\n\twhile (count1 < 2 * k1  && count2 < 2 * k2)\n\t{\n\t\tif (NA1[count1] == NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tcount2 += 1;\n\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];\n\t\t}\n\t\telse if (NA1[count1] > NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t}\n\t}\n\twhile (count1 < 2 * k1) {\n\t\tNA3[count3++] = NA1[count1++];\n\t\tNA3[count3++] = NA1[count1++];\n\t}\n\n\twhile (count2 < 2 * k2)\n\t{\n\t\tNA3[count3++] = NA2[count2++];\n\t\tNA3[count3++] = NA2[count2++];\n\t}\n\n\tk3 = (count3 + 1) / 2;\n\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tk3--;\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\", k3);\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\" \");\n\t\t\t\tprintf(\"%d\", (int)NA3[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(\" \");\n\t\t\tprintf(\"%.1f\", NA3[i]);\n\t\t}\n\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 总结：\n\n在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；\n","source":"_posts/PAT/2017-07-27-pat-advanced-1002.md","raw":"---\ntitle: \"PAT甲级1002. A+B for Polynomials\"\ndescription: \"This time, you are supposed to find A+B where A and B are two polynomials. \"\ntype: [pat]\ntoc: true\ncover:  /cover/img70.jpg\ncategories: PAT\ndate: 2017/07/27\n---\n\nmodified: 2017-07-27\n\nThis time, you are supposed to find A+B where A and B are two polynomials.\n<!--more-->\nInput\n\nEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 ... NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, ..., K) are the exponents and coefficients, respectively. It is given that 1 <= K <= 10，0 <= NK < ... < N2 < N1 <=1000.\n\nOutput\n\nFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.\n\nSample Input\n\n2 1 2.4 0 3.2\n\n2 2 1.5 1 0.5\n\nSample Output\n\n3 2 1.5 1 2.9 0 3.2\n\n### 题目要求：\n\n两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 ... 其中K代表项数，N1...代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；\n\n### 解题思路：\n\n定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；\n\n* 本题目采用C语言进行编写\n\n```c\n\nint main() {\n\n\tint k1, k2, k3, count1 = 0, count2 = 0, count3 = 0;\n\tfloat NA1[20] = { 0 };\n\tfloat NA2[20] = { 0 };\n\tfloat NA3[40] = { 0 };\n\tchar ch;\n\n\tscanf(\"%d\", &k1);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA1[count1++]);\n\t}\n\n\tscanf(\"%d\", &k2);\n\twhile (ch = getchar() != '\\n')\n\t{\n\t\tscanf(\"%f\", &NA2[count2++]);\n\t}\n\n\tcount1 = count2 = 0;\n\n\twhile (count1 < 2 * k1  && count2 < 2 * k2)\n\t{\n\t\tif (NA1[count1] == NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tcount2 += 1;\n\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];\n\t\t}\n\t\telse if (NA1[count1] > NA2[count2])\n\t\t{\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t\tNA3[count3++] = NA1[count1++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t\tNA3[count3++] = NA2[count2++];\n\t\t}\n\t}\n\twhile (count1 < 2 * k1) {\n\t\tNA3[count3++] = NA1[count1++];\n\t\tNA3[count3++] = NA1[count1++];\n\t}\n\n\twhile (count2 < 2 * k2)\n\t{\n\t\tNA3[count3++] = NA2[count2++];\n\t\tNA3[count3++] = NA2[count2++];\n\t}\n\n\tk3 = (count3 + 1) / 2;\n\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tk3--;\n\t\t\t}\n\n\t\t}\n\t}\n\tprintf(\"%d\", k3);\n\tfor (int i = 0; i < count3; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tif (NA3[i + 1] == 0)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\" \");\n\t\t\t\tprintf(\"%d\", (int)NA3[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(\" \");\n\t\t\tprintf(\"%.1f\", NA3[i]);\n\t\t}\n\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 总结：\n\n在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；\n","slug":"PAT/2017-07-27-pat-advanced-1002","published":1,"updated":"2021-01-05T12:15:52.768Z","_id":"ckjju0m0n001o20uag3cy14sw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27</p>\n<p>This time, you are supposed to find A+B where A and B are two polynomials.</p>\n<a id=\"more\"></a>\n<p>Input</p>\n<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>\n<p>Output</p>\n<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>\n<p>Sample Input</p>\n<p>2 1 2.4 0 3.2</p>\n<p>2 2 1.5 1 0.5</p>\n<p>Sample Output</p>\n<p>3 2 1.5 1 2.9 0 3.2</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 … 其中K代表项数，N1…代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；</p>\n<ul>\n<li>本题目采用C语言进行编写</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1, k2, k3, count1 = <span class=\"number\">0</span>, count2 = <span class=\"number\">0</span>, count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA1[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA2[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA3[<span class=\"number\">40</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;k1);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%f&quot;</span>, &amp;NA1[count1++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;k2);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%f&quot;</span>, &amp;NA2[count2++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcount1 = count2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1  &amp;&amp; count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (NA1[count1] == NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tcount2 += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (NA1[count1] &gt; NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1) &#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tk3 = (count3 + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t\tk3--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, k3);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, (<span class=\"keyword\">int</span>)NA3[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.1f&quot;</span>, NA3[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；</p>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-07-27</p>\n<p>This time, you are supposed to find A+B where A and B are two polynomials.</p>","more":"<p>Input</p>\n<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>\n<p>Output</p>\n<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>\n<p>Sample Input</p>\n<p>2 1 2.4 0 3.2</p>\n<p>2 2 1.5 1 0.5</p>\n<p>Sample Output</p>\n<p>3 2 1.5 1 2.9 0 3.2</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>两个多项式相加，多项式的输入为  K N1 aN1 N2 aN2 … 其中K代表项数，N1…代表指数，aN1代表系数，每个多项式的项数不超过10；要求将两个多项式相加后输出非零项，输出格式与输入格式相同，系数保留一位小数；相邻两个输出数字之间需要有空格，输出最后没有空格；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>定义三个float类型的数组，两个用于保存输入的多项式，一个用于保存输出的多项式；输入的奇数项是指数，偶数项是系数，所以可以对指数进行比较，如果相同则将指数和相加后的系数保存在第三个数组中，不同则将指数较大的项的指数和系数保存在第三个数组中；</p>\n<ul>\n<li>本题目采用C语言进行编写</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> k1, k2, k3, count1 = <span class=\"number\">0</span>, count2 = <span class=\"number\">0</span>, count3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA1[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA2[<span class=\"number\">20</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> NA3[<span class=\"number\">40</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;k1);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%f&quot;</span>, &amp;NA1[count1++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;k2);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch = getchar() != <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%f&quot;</span>, &amp;NA2[count2++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcount1 = count2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1  &amp;&amp; count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (NA1[count1] == NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tcount2 += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++] + NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (NA1[count1] &gt; NA2[count2])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count1 &lt; <span class=\"number\">2</span> * k1) &#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA1[count1++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (count2 &lt; <span class=\"number\">2</span> * k2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t\tNA3[count3++] = NA2[count2++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tk3 = (count3 + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t\tk3--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, k3);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count3; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (NA3[i + <span class=\"number\">1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, (<span class=\"keyword\">int</span>)NA3[i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.1f&quot;</span>, NA3[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>在多项式相加中易被忽略的测试实例有：相加后的第一项为零，相加后最后一项为零，相加后整体为0；数据输出若系数为4，则应输出4.0才可通过测试；输出空格的技巧，除了项数不需要输出空格，其他空格都在数据输出之前；</p>"},{"title":"PAT甲级1005. Spell It Right","description":"Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.","type":["pat"],"toc":true,"cover":"/cover/img71.jpg","date":"2017-07-26T16:00:00.000Z","_content":"\nmodified: 2017-07-27\nGiven a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\n<!--more-->\nInput Specification:\n\nEach input file contains one test case. Each case occupies one line which contains an N (<= 10100).\n\nOutput Specification:\n\nFor each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\n\nSample Input:\n12345\n\nSample Output:\none five\n\n### 题目要求：\n\n任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；\n\n输入：输入的N<=10100\n\n输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格\n\n### 解题思路：\n\n首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\nint main() {\n\tchar ch;\n\tint count = 0;\n\tint words[4];\n\tint sum = 0;\n\tch = getchar();\n\twhile (ch != '\\n')\n\t{\n\t\tsum += ch - '0';\n\t\tch = getchar();\n\t}\n\twhile (sum / 10 > 0)\n\t{\n\t\twords[count++] = sum % 10;\n\t\tsum = sum / 10;\n\t}\n\twords[count++] = sum % 10;\n\tfor (int i = count - 1; i >= 0; i--)\n\t{\n\t\tswitch (words[i])\n\t\t{\n\t\tcase 0:\n\t\t\tprintf(\"zero\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"one\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"two\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"three\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"four\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"five\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"six\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tprintf(\"seven\");\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf(\"eight\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tprintf(\"nine\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (i!=0)\n\t\t{\n\t\t\tprintf(\" \");\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n```","source":"_posts/PAT/2017-07-27-pat-advanced-1005.md","raw":"---\n\ntitle: \"PAT甲级1005. Spell It Right\"\ndescription: \"Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\"\ntype: [pat]\ntoc: true\ncover:  /cover/img71.jpg\ncategories: PAT\ndate: 2017/07/27\n---\n\nmodified: 2017-07-27\nGiven a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\n<!--more-->\nInput Specification:\n\nEach input file contains one test case. Each case occupies one line which contains an N (<= 10100).\n\nOutput Specification:\n\nFor each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\n\nSample Input:\n12345\n\nSample Output:\none five\n\n### 题目要求：\n\n任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；\n\n输入：输入的N<=10100\n\n输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格\n\n### 解题思路：\n\n首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\nint main() {\n\tchar ch;\n\tint count = 0;\n\tint words[4];\n\tint sum = 0;\n\tch = getchar();\n\twhile (ch != '\\n')\n\t{\n\t\tsum += ch - '0';\n\t\tch = getchar();\n\t}\n\twhile (sum / 10 > 0)\n\t{\n\t\twords[count++] = sum % 10;\n\t\tsum = sum / 10;\n\t}\n\twords[count++] = sum % 10;\n\tfor (int i = count - 1; i >= 0; i--)\n\t{\n\t\tswitch (words[i])\n\t\t{\n\t\tcase 0:\n\t\t\tprintf(\"zero\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintf(\"one\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"two\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"three\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"four\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"five\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"six\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tprintf(\"seven\");\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf(\"eight\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tprintf(\"nine\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (i!=0)\n\t\t{\n\t\t\tprintf(\" \");\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n```","slug":"PAT/2017-07-27-pat-advanced-1005","published":1,"updated":"2021-01-05T12:15:51.743Z","_id":"ckjju0m0o001t20uafcxf3yen","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27<br>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p>\n<a id=\"more\"></a>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100).</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>\n<p>Sample Input:<br>12345</p>\n<p>Sample Output:<br>one five</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；</p>\n<p>输入：输入的N&lt;=10100</p>\n<p>输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> words[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += ch - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sum / <span class=\"number\">10</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tsum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (words[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;zero&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;one&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;two&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;three&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;four&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;five&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;six&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;seven&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;eight&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nine&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i!=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-07-27<br>Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.</p>","more":"<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100).</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.</p>\n<p>Sample Input:<br>12345</p>\n<p>Sample Output:<br>one five</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>任给一个非负整数N，计算整数的每一位的和，并输出每一位的英文；</p>\n<p>输入：输入的N&lt;=10100</p>\n<p>输出：计算的每一位的和的每一位对应一个英文单词，而且英文单词之间需要有一个空格，最后一位之后没有空格</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将整数的每一位进行分离，然后计算出和，计算出和后也需要将每一位分离；将整数的每一位分离的方法采用除10取余的方式；和的每一位分离时，是从整数的最小位开始，而整数输出需要从最高位开始，因此需要将分离的数位存储在一个数组中；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> words[<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tch = getchar();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch != <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum += ch - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\tch = getchar();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sum / <span class=\"number\">10</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tsum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twords[count++] = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (words[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;zero&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;one&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;two&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;three&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;four&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;five&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;six&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;seven&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;eight&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nine&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i!=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1007. Maximum Subsequence Sum","description":"you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence","type":["pat"],"toc":true,"cover":"/cover/img72.jpg","date":"2017-07-27T16:00:00.000Z","_content":"\nmodified: 2017-07-27\nGiven a sequence of K integers { N1, N2, ..., NK }. A continuous subsequence is defined to be { Ni, Ni+1, ..., Nj } where 1 <= i <= j <= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\n<!--more-->\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\n\nInput Specification:\n\nEach input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (<= 10000). The second line contains K numbers, separated by a space.\n\nOutput Specification:\n\nFor each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\n\nSample Input:\n\n10\n\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:\n\n10 1 4\n\n### 题目要求：\n\n给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；\n\n### 解题思路：\n\nsum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp<0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp<0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；\n\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <stdbool.h>\n\nint main() {\n\n\tint count, sum = -1, sumTmp = 0, left = 0, leftTmp = 0, right = 0, input, first, last;\n\t\n\tint num[10000];\n\n\tbool positive = false, half_positive = false;\n\n\n\tscanf(\"%d\", &count);\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\n\t\tscanf(\"%d\", &input);\n\t\tnum[i] = input;\n\t\tif (input >= 0)\n\t\t{\n\t\t\tpositive = true;\n\t\t}\n\n\t\tsumTmp = sumTmp + input;\n\t\tif (sum < sumTmp)\n\t\t{\n\t\t\tleft = leftTmp;\n\t\t\tright = i;\n\t\t\tsum = sumTmp;\n\t\t}\n\t\telse if (sumTmp < 0)\n\t\t{\n\t\t\tleftTmp=i+1;\n\t\t\tsumTmp = 0;\n\t\t}\n\n\t}\n\n\tif (positive)\n\t{\n\t\tprintf(\"%d %d %d\", sum, num[left], num[right]);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d %d %d\", 0, num[0], num[count-1]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 总结：\n\n又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；\n\n本题中容易被忽略的数列类型有如下：\n\n* 连续0\n\n  5\n \n  0 0 -1 -1 0\n\n* 前面都为负、最后一位为0\n\n  5\n\n  -1 -1 -1 -1 0\n\n   \n\n","source":"_posts/PAT/2017-07-27-pat-advanced-1007.md","raw":"---\n\ntitle: \"PAT甲级1007. Maximum Subsequence Sum\"\ndescription: \"you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence\"\ntype: [pat]\ntoc: true\ncover:  /cover/img72.jpg\ncategories: PAT\ndate: 2017/07/28\n---\n\nmodified: 2017-07-27\nGiven a sequence of K integers { N1, N2, ..., NK }. A continuous subsequence is defined to be { Ni, Ni+1, ..., Nj } where 1 <= i <= j <= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\n<!--more-->\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\n\nInput Specification:\n\nEach input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (<= 10000). The second line contains K numbers, separated by a space.\n\nOutput Specification:\n\nFor each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\n\nSample Input:\n\n10\n\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:\n\n10 1 4\n\n### 题目要求：\n\n给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；\n\n### 解题思路：\n\nsum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp<0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp<0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；\n\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <stdbool.h>\n\nint main() {\n\n\tint count, sum = -1, sumTmp = 0, left = 0, leftTmp = 0, right = 0, input, first, last;\n\t\n\tint num[10000];\n\n\tbool positive = false, half_positive = false;\n\n\n\tscanf(\"%d\", &count);\n\n\tfor (int i = 0; i < count; i++)\n\t{\n\n\t\tscanf(\"%d\", &input);\n\t\tnum[i] = input;\n\t\tif (input >= 0)\n\t\t{\n\t\t\tpositive = true;\n\t\t}\n\n\t\tsumTmp = sumTmp + input;\n\t\tif (sum < sumTmp)\n\t\t{\n\t\t\tleft = leftTmp;\n\t\t\tright = i;\n\t\t\tsum = sumTmp;\n\t\t}\n\t\telse if (sumTmp < 0)\n\t\t{\n\t\t\tleftTmp=i+1;\n\t\t\tsumTmp = 0;\n\t\t}\n\n\t}\n\n\tif (positive)\n\t{\n\t\tprintf(\"%d %d %d\", sum, num[left], num[right]);\n\t}\n\telse\n\t{\n\t\tprintf(\"%d %d %d\", 0, num[0], num[count-1]);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 总结：\n\n又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；\n\n本题中容易被忽略的数列类型有如下：\n\n* 连续0\n\n  5\n \n  0 0 -1 -1 0\n\n* 前面都为负、最后一位为0\n\n  5\n\n  -1 -1 -1 -1 0\n\n   \n\n","slug":"PAT/2017-07-27-pat-advanced-1007","published":1,"updated":"2021-01-05T12:15:50.573Z","_id":"ckjju0m0p001v20uaa24wgqtq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27<br>Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>\n<a id=\"more\"></a>\n<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>\n<p>Sample Input:</p>\n<p>10</p>\n<p>-10 1 2 3 4 -5 -23 3 7 -21</p>\n<p>Sample Output:</p>\n<p>10 1 4</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>sum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp&lt;0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp&lt;0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count, sum = <span class=\"number\">-1</span>, sumTmp = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>, leftTmp = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>, input, first, last;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> positive = <span class=\"literal\">false</span>, half_positive = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);</span><br><span class=\"line\">\t\tnum[i] = input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (input &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpositive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsumTmp = sumTmp + input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sum &lt; sumTmp)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleft = leftTmp;</span><br><span class=\"line\">\t\t\tright = i;</span><br><span class=\"line\">\t\t\tsum = sumTmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sumTmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleftTmp=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tsumTmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (positive)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, sum, num[left], num[right]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, <span class=\"number\">0</span>, num[<span class=\"number\">0</span>], num[count<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；</p>\n<p>本题中容易被忽略的数列类型有如下：</p>\n<ul>\n<li><p>连续0</p>\n<p>5</p>\n<p>0 0 -1 -1 0</p>\n</li>\n<li><p>前面都为负、最后一位为0</p>\n<p>5</p>\n<p>-1 -1 -1 -1 0</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-07-27<br>Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>","more":"<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>\n<p>Sample Input:</p>\n<p>10</p>\n<p>-10 1 2 3 4 -5 -23 3 7 -21</p>\n<p>Sample Output:</p>\n<p>10 1 4</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>给定一列数，然后求出这一列数中和最大的子列；第一行为输入的数列的数字个数，第二行为给定的数列；要求输出最大和子列的和、最大和子列的首元素、最大和子列末尾元素；数与数之间使用空格隔开，最后一个数后面没有空格；若给定的子列有多个最大和子列，那么按照第一个和子列输出；若给定的数列全部是负数，那么最大子列的和为0，最大子列的首元素为给定数列的首元素，最大子列的末尾元素为给定子列的末尾元素；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>sum，为最大子列的的和，sumTemp为最大子列的临时值，leftTmp为sumTemp的下标；依次输入数字，sumTmp+=input,如果sumTmp&lt;0,都应该将leftTmp右移，并令sumTmp=0,相当于将临时子数列舍弃，重新构建一个临时子数列;因为sumTmp&lt;0时无论后面输入的数如何，前面的临时子数列和都会让整体的临时子数列的和减小；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count, sum = <span class=\"number\">-1</span>, sumTmp = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>, leftTmp = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>, input, first, last;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> positive = <span class=\"literal\">false</span>, half_positive = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;input);</span><br><span class=\"line\">\t\tnum[i] = input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (input &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpositive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsumTmp = sumTmp + input;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sum &lt; sumTmp)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleft = leftTmp;</span><br><span class=\"line\">\t\t\tright = i;</span><br><span class=\"line\">\t\t\tsum = sumTmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sumTmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tleftTmp=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tsumTmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (positive)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, sum, num[left], num[right]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, <span class=\"number\">0</span>, num[<span class=\"number\">0</span>], num[count<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>又一次看错了题目，以为输出的是最大子数列的和、最大子数列的下标和上标！！！！即使输出的是上标和下标也会通过测试用例，并且通过平台的部分测试；</p>\n<p>本题中容易被忽略的数列类型有如下：</p>\n<ul>\n<li><p>连续0</p>\n<p>5</p>\n<p>0 0 -1 -1 0</p>\n</li>\n<li><p>前面都为负、最后一位为0</p>\n<p>5</p>\n<p>-1 -1 -1 -1 0</p>\n</li>\n</ul>"},{"title":"PAT甲级1008. Elevator","description":"The highest building in our city has only one elevator. A request list is made up with N positive numbers. ","type":["pat"],"toc":true,"cover":"/cover/img73.jpg","date":"2017-07-26T16:00:00.000Z","_content":"\nmodified: 2017-07-27\nThe highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\n<!--more-->\nFor a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\n\nInput Specification:\n\nEach input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\n\nOutput Specification:\n\nFor each test case, print the total time on a single line.\n\nSample Input:\n3 2 3 1\n\nSample Output:\n41\n\n### 题目要求：\n\n一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；\n\n给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；\n\n每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；\n\n### 解题思路：\n\n首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n\n\nint main() {\n\n\tchar ch;\n\tint floor[101];\n\t//用于对输入的楼层数进行计数\n\tint count = 0;\n\tint time =0 ;\n\tscanf(\"%d\", &floor[count++]);\n\twhile (ch=getchar()!='\\n')\n\t{\n\t\tscanf(\"%d\", &floor[count++]);\n\t}\n\ttime += 6 * floor[1]+5;\n\n\tfor (int i = 2; i < count; i++)\n\t{\n\t\tif (floor[i]>floor[i-1])\n\t\t{\n\t\t\ttime += 6 * (floor[i] - floor[i - 1])+5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttime += 4 * (floor[i-1] - floor[i])+5;\n\t\t}\n\t}\n\n\tprintf(\"%d\",time);\n\treturn 0;\n}\n\n```","source":"_posts/PAT/2017-07-27-pat-advanced-1008.md","raw":"---\ntitle: \"PAT甲级1008. Elevator\"\ndescription: \"The highest building in our city has only one elevator. A request list is made up with N positive numbers. \"\ntype: [pat]\ntoc: true\ncover:  /cover/img73.jpg\ncategories: PAT\ndate: 2017/07/27\n---\n\nmodified: 2017-07-27\nThe highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\n<!--more-->\nFor a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\n\nInput Specification:\n\nEach input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\n\nOutput Specification:\n\nFor each test case, print the total time on a single line.\n\nSample Input:\n3 2 3 1\n\nSample Output:\n41\n\n### 题目要求：\n\n一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；\n\n给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；\n\n每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；\n\n### 解题思路：\n\n首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；\n\n\n```c\n#include \"stdlib.h\"\n#include \"stdio.h\"\n\n\nint main() {\n\n\tchar ch;\n\tint floor[101];\n\t//用于对输入的楼层数进行计数\n\tint count = 0;\n\tint time =0 ;\n\tscanf(\"%d\", &floor[count++]);\n\twhile (ch=getchar()!='\\n')\n\t{\n\t\tscanf(\"%d\", &floor[count++]);\n\t}\n\ttime += 6 * floor[1]+5;\n\n\tfor (int i = 2; i < count; i++)\n\t{\n\t\tif (floor[i]>floor[i-1])\n\t\t{\n\t\t\ttime += 6 * (floor[i] - floor[i - 1])+5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttime += 4 * (floor[i-1] - floor[i])+5;\n\t\t}\n\t}\n\n\tprintf(\"%d\",time);\n\treturn 0;\n}\n\n```","slug":"PAT/2017-07-27-pat-advanced-1008","published":1,"updated":"2021-01-05T12:15:49.351Z","_id":"ckjju0m0p001x20ua6vgucrls","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27<br>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>\n<a id=\"more\"></a>\n<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print the total time on a single line.</p>\n<p>Sample Input:<br>3 2 3 1</p>\n<p>Sample Output:<br>41</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；</p>\n<p>给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；</p>\n<p>每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">floor</span>[<span class=\"number\">101</span>];</span><br><span class=\"line\">\t<span class=\"comment\">//用于对输入的楼层数进行计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> time =<span class=\"number\">0</span> ;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch=getchar()!=<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime += <span class=\"number\">6</span> * <span class=\"built_in\">floor</span>[<span class=\"number\">1</span>]+<span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">floor</span>[i]&gt;<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">6</span> * (<span class=\"built_in\">floor</span>[i] - <span class=\"built_in\">floor</span>[i - <span class=\"number\">1</span>])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">4</span> * (<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>] - <span class=\"built_in\">floor</span>[i])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,time);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-07-27<br>The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>","more":"<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print the total time on a single line.</p>\n<p>Sample Input:<br>3 2 3 1</p>\n<p>Sample Output:<br>41</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>一部电梯，给N个正整数，表示电梯将依次在哪一层楼停止，上升一层楼需要6S，下降一层楼需要4S，电梯在每一层楼停止5S；</p>\n<p>给予的每一列数需要计算电梯停过每一层楼索要要的总的时间，开始时电梯在0层，且结束后电梯不要要回到0层；</p>\n<p>每一个输入包括，一个正整数N，在这个正整数之后是N个正整数这个是重点！！！坑爹的题目给了输入的例子：3X6+4X1+6X1+4X2+5=41！！！2X6+1x6+2X4+3x5=41！！！）</font>本宝宝才不会告诉你：我的神奇脑回路；所有的输入数不超过100个；</p>\n<h3 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h3><p>首先将输入的数字存储在一个数组中（题目给出的输入不超过100，所以可以定义长度为100的数组），然后循环比较数组的每一个元素与前后元素的大小，确定是上升还是下降；并计算时间；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"built_in\">floor</span>[<span class=\"number\">101</span>];</span><br><span class=\"line\">\t<span class=\"comment\">//用于对输入的楼层数进行计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> time =<span class=\"number\">0</span> ;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ch=getchar()!=<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;<span class=\"built_in\">floor</span>[count++]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime += <span class=\"number\">6</span> * <span class=\"built_in\">floor</span>[<span class=\"number\">1</span>]+<span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">floor</span>[i]&gt;<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">6</span> * (<span class=\"built_in\">floor</span>[i] - <span class=\"built_in\">floor</span>[i - <span class=\"number\">1</span>])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttime += <span class=\"number\">4</span> * (<span class=\"built_in\">floor</span>[i<span class=\"number\">-1</span>] - <span class=\"built_in\">floor</span>[i])+<span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,time);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1006. Sign In and Sign Out","description":"At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.","type":["pat"],"toc":true,"cover":"/cover/img74.jpg","date":"2017-07-30T16:00:00.000Z","_content":"\nmodified: 2017-07-31\nAt the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\n<!--more-->\nInput Specification:\n\nEach input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n\nID_number Sign_in_time Sign_out_time\n\nwhere times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.\n\nOutput Specification:\n\nFor each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.\n\nNote: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\n\nSample Input:\n\n3\n\nCS301111 15:30:28 17:00:10\n\nSC3021234 08:00:00 11:25:25\n\nCS301133 21:45:00 21:58:40\n\nSample Output:\n\nSC3021234 CS301133\n\n### 题目要求：\n\n每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；\n\n输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；\n\n输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；\n\n题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；\n\n### 解题思路\n\n方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"stdbool.h\"\ntypedef struct user {\n\tchar name[20];\n\tchar inTime[20];\n\tchar outTime[20];\n}user;\nint main() {\n\n\tuser user[100];\n\tint num;\n\tint unLockedIndex;\n\tint lockedIndex;\n\tchar inTimeTmp[20];\n\tstrcpy(inTimeTmp,\"23:59:59\");\n\tchar outTimeTmp[20];\n\tstrcpy(outTimeTmp, \"00:00:00\");\n\tunLockedIndex = 0;\n\tlockedIndex = 0;\n\tscanf(\"%d\",&num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",&user[i].name);\n\t\tscanf(\"%s\", &user[i].inTime);\n\t\t//大于零表示第二个字符串小于第一个\n\t\tif (strcmp(inTimeTmp, user[i].inTime)>0)\n\t\t{\n\t\t\tstrcpy(inTimeTmp, user[i].inTime);\n\t\t\tunLockedIndex = i;\n\t\t}\n\n\t\tscanf(\"%s\", &user[i].outTime);\n\t\t//表示第二个字符串大于第一个\n\t\tif (strcmp(outTimeTmp, user[i].outTime)<0)\n\t\t\t{\n\t\t\t\tstrcpy(outTimeTmp, user[i].outTime);\n\t\t\t\tlockedIndex = i;\n\t\t\t}\n\t\t\n\t}\n\tprintf(\"%s %s\",user[unLockedIndex].name,user[lockedIndex].name);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 方法二：将输入的时间转换为秒，然后再比较大小\n","source":"_posts/PAT/2017-07-31-pat-advanced-1006.md","raw":"---\ntitle: \"PAT甲级1006. Sign In and Sign Out\"\ndescription: \"At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\"\ntype: [pat]\ntoc: true\ncover:  /cover/img74.jpg\ncategories: PAT\ndate: 2017/07/31\n---\n\nmodified: 2017-07-31\nAt the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day.\n<!--more-->\nInput Specification:\n\nEach input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n\nID_number Sign_in_time Sign_out_time\n\nwhere times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.\n\nOutput Specification:\n\nFor each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.\n\nNote: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\n\nSample Input:\n\n3\n\nCS301111 15:30:28 17:00:10\n\nSC3021234 08:00:00 11:25:25\n\nCS301133 21:45:00 21:58:40\n\nSample Output:\n\nSC3021234 CS301133\n\n### 题目要求：\n\n每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；\n\n输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；\n\n输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；\n\n题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；\n\n### 解题思路\n\n方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一\n\n```c\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"stdbool.h\"\ntypedef struct user {\n\tchar name[20];\n\tchar inTime[20];\n\tchar outTime[20];\n}user;\nint main() {\n\n\tuser user[100];\n\tint num;\n\tint unLockedIndex;\n\tint lockedIndex;\n\tchar inTimeTmp[20];\n\tstrcpy(inTimeTmp,\"23:59:59\");\n\tchar outTimeTmp[20];\n\tstrcpy(outTimeTmp, \"00:00:00\");\n\tunLockedIndex = 0;\n\tlockedIndex = 0;\n\tscanf(\"%d\",&num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",&user[i].name);\n\t\tscanf(\"%s\", &user[i].inTime);\n\t\t//大于零表示第二个字符串小于第一个\n\t\tif (strcmp(inTimeTmp, user[i].inTime)>0)\n\t\t{\n\t\t\tstrcpy(inTimeTmp, user[i].inTime);\n\t\t\tunLockedIndex = i;\n\t\t}\n\n\t\tscanf(\"%s\", &user[i].outTime);\n\t\t//表示第二个字符串大于第一个\n\t\tif (strcmp(outTimeTmp, user[i].outTime)<0)\n\t\t\t{\n\t\t\t\tstrcpy(outTimeTmp, user[i].outTime);\n\t\t\t\tlockedIndex = i;\n\t\t\t}\n\t\t\n\t}\n\tprintf(\"%s %s\",user[unLockedIndex].name,user[lockedIndex].name);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### 方法二：将输入的时间转换为秒，然后再比较大小\n","slug":"PAT/2017-07-31-pat-advanced-1006","published":1,"updated":"2021-01-05T12:15:43.823Z","_id":"ckjju0m0q002120ua1tp70jrq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-31<br>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>\n<a id=\"more\"></a>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p>\n<p>ID_number Sign_in_time Sign_out_time</p>\n<p>where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>\n<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>\n<p>Sample Input:</p>\n<p>3</p>\n<p>CS301111 15:30:28 17:00:10</p>\n<p>SC3021234 08:00:00 11:25:25</p>\n<p>CS301133 21:45:00 21:58:40</p>\n<p>Sample Output:</p>\n<p>SC3021234 CS301133</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；</p>\n<p>输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；</p>\n<p>输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；</p>\n<p>题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;string.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdbool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;user;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuser user[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> unLockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(inTimeTmp,<span class=\"string\">&quot;23:59:59&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(outTimeTmp, <span class=\"string\">&quot;00:00:00&quot;</span>);</span><br><span class=\"line\">\tunLockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tlockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,&amp;user[i].name);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, &amp;user[i].inTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//大于零表示第二个字符串小于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(inTimeTmp, user[i].inTime)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(inTimeTmp, user[i].inTime);</span><br><span class=\"line\">\t\t\tunLockedIndex = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, &amp;user[i].outTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//表示第二个字符串大于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(outTimeTmp, user[i].outTime)&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">strcpy</span>(outTimeTmp, user[i].outTime);</span><br><span class=\"line\">\t\t\t\tlockedIndex = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s %s&quot;</span>,user[unLockedIndex].name,user[lockedIndex].name);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：将输入的时间转换为秒，然后再比较大小\"><a href=\"#方法二：将输入的时间转换为秒，然后再比较大小\" class=\"headerlink\" title=\"方法二：将输入的时间转换为秒，然后再比较大小\"></a>方法二：将输入的时间转换为秒，然后再比较大小</h3>","site":{"data":{}},"excerpt":"<p>modified: 2017-07-31<br>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>","more":"<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p>\n<p>ID_number Sign_in_time Sign_out_time</p>\n<p>where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters.</p>\n<p>Output Specification:</p>\n<p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>\n<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>\n<p>Sample Input:</p>\n<p>3</p>\n<p>CS301111 15:30:28 17:00:10</p>\n<p>SC3021234 08:00:00 11:25:25</p>\n<p>CS301133 21:45:00 21:58:40</p>\n<p>Sample Output:</p>\n<p>SC3021234 CS301133</p>\n<h3 id=\"题目要求：\"><a href=\"#题目要求：\" class=\"headerlink\" title=\"题目要求：\"></a>题目要求：</h3><p>每天，第一个登录电脑的人开门，最后一个退出电脑的人关门；已知每个人登录和退出电脑的时间，需要找出开门的人和关门的人；</p>\n<p>输入包括记录的条数，以及每个人的ID、登录、退出时间；ID字符串不超过15个字符，时间输入格式为HH:MM:SS；</p>\n<p>输出要求：输出开门的人和关门的人ID，ID之间使用空格隔开；</p>\n<p>题目的输入保证每个人登录时间早于退出时间，并且没有任何两个人的登录退出时间是相同的；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>方法一：直接使用int strcmp(const char *str1, const char *str2)比较输入的登录时间与输出时间的字符串的大小,因为数字对应的ASCII码是由小至大，所以可以用字符比较的方式，下面的代码即为方法一</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;string.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdbool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTime[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;user;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuser user[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> unLockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lockedIndex;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> inTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(inTimeTmp,<span class=\"string\">&quot;23:59:59&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outTimeTmp[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(outTimeTmp, <span class=\"string\">&quot;00:00:00&quot;</span>);</span><br><span class=\"line\">\tunLockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tlockedIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,&amp;user[i].name);</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, &amp;user[i].inTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//大于零表示第二个字符串小于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(inTimeTmp, user[i].inTime)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(inTimeTmp, user[i].inTime);</span><br><span class=\"line\">\t\t\tunLockedIndex = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, &amp;user[i].outTime);</span><br><span class=\"line\">\t\t<span class=\"comment\">//表示第二个字符串大于第一个</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(outTimeTmp, user[i].outTime)&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">strcpy</span>(outTimeTmp, user[i].outTime);</span><br><span class=\"line\">\t\t\t\tlockedIndex = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s %s&quot;</span>,user[unLockedIndex].name,user[lockedIndex].name);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：将输入的时间转换为秒，然后再比较大小\"><a href=\"#方法二：将输入的时间转换为秒，然后再比较大小\" class=\"headerlink\" title=\"方法二：将输入的时间转换为秒，然后再比较大小\"></a>方法二：将输入的时间转换为秒，然后再比较大小</h3>"},{"title":"PAT甲级1011. World Cup Betting ","description":"The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result.","type":["pat"],"toc":true,"cover":"/cover/img75.jpg","date":"2017-07-31T16:00:00.000Z","_content":"\nmodified: 2017-08-01\nWith the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.\n<!--more-->\nChinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%.\n\nFor example, 3 games' odds are given as the following:\n\n W    T    L\n\n1.1  2.5  1.7\n\n1.2  3.0  1.6\n\n4.1  1.2  1.1\n\nTo obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1*3.0*2.5*65%-1)*2 = 37.98 yuans (accurate up to 2 decimal places).\n\nInput\n\nEach input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.\n\nOutput\n\nFor each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.\n\nSample Input\n\n1.1 2.5 1.7\n\n1.2 3.0 1.6\n\n4.1 1.2 1.1\n\nSample Output\n\nT T W 37.98\n\n### 题目要求\n\n题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；\n\n### 解题思路\n\n设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n\nint main()\n{\n\tchar line[3] = {'W','T','L'};\n\tchar outChar[3];\n\n\tint index;\n\tfloat in,tmp;\n\tfloat result=1;\n\n\n\tfor (int  i = 0; i < 3; i++)\n\t{\n\t\tindex = 0;\n\t\ttmp = 0;\n\t\tfor (int j = 0; j <3; j++)\n\t\t{\n\t\t\tscanf(\"%f\",&in);\n\t\t\tif (tmp<in)\n\t\t\t{\n\t\t\t\ttmp = in;\n\t\t\t\tindex = j;\n\t\t\t}\n\n\t\t}\n\t\tresult *= tmp;\n\t\toutChar[i]=line[index];\n\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%c \",outChar[i]);\n\t}\n\t\n\tprintf(\"%.2f\", (result*0.65 - 1) * 2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```","source":"_posts/PAT/2017-08-01-pat-advanced-1011.md","raw":"---\n\ntitle: \"PAT甲级1011. World Cup Betting \"\ndescription: \"The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result.\"\ntype: [pat]\ntoc: true\ncover:  /cover/img75.jpg\ncategories: PAT\ndate: 2017/08/01\n---\n\nmodified: 2017-08-01\nWith the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.\n<!--more-->\nChinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results -- namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%.\n\nFor example, 3 games' odds are given as the following:\n\n W    T    L\n\n1.1  2.5  1.7\n\n1.2  3.0  1.6\n\n4.1  1.2  1.1\n\nTo obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1*3.0*2.5*65%-1)*2 = 37.98 yuans (accurate up to 2 decimal places).\n\nInput\n\nEach input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.\n\nOutput\n\nFor each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.\n\nSample Input\n\n1.1 2.5 1.7\n\n1.2 3.0 1.6\n\n4.1 1.2 1.1\n\nSample Output\n\nT T W 37.98\n\n### 题目要求\n\n题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；\n\n### 解题思路\n\n设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];\n\n```c\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n\nint main()\n{\n\tchar line[3] = {'W','T','L'};\n\tchar outChar[3];\n\n\tint index;\n\tfloat in,tmp;\n\tfloat result=1;\n\n\n\tfor (int  i = 0; i < 3; i++)\n\t{\n\t\tindex = 0;\n\t\ttmp = 0;\n\t\tfor (int j = 0; j <3; j++)\n\t\t{\n\t\t\tscanf(\"%f\",&in);\n\t\t\tif (tmp<in)\n\t\t\t{\n\t\t\t\ttmp = in;\n\t\t\t\tindex = j;\n\t\t\t}\n\n\t\t}\n\t\tresult *= tmp;\n\t\toutChar[i]=line[index];\n\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%c \",outChar[i]);\n\t}\n\t\n\tprintf(\"%.2f\", (result*0.65 - 1) * 2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```","slug":"PAT/2017-08-01-pat-advanced-1011","published":1,"updated":"2021-01-05T12:15:47.718Z","_id":"ckjju0m0r002320ua6gopb5fa","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-01<br>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>\n<a id=\"more\"></a>\n<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>\n<p>For example, 3 games’ odds are given as the following:</p>\n<p> W    T    L</p>\n<p>1.1  2.5  1.7</p>\n<p>1.2  3.0  1.6</p>\n<p>4.1  1.2  1.1</p>\n<p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1<em>3.0</em>2.5*65%-1)*2 = 37.98 yuans (accurate up to 2 decimal places).</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p>\n<p>Output</p>\n<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>\n<p>Sample Input</p>\n<p>1.1 2.5 1.7</p>\n<p>1.2 3.0 1.6</p>\n<p>4.1 1.2 1.1</p>\n<p>Sample Output</p>\n<p>T T W 37.98</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> line[<span class=\"number\">3</span>] = &#123;<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;T&#x27;</span>,<span class=\"string\">&#x27;L&#x27;</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outChar[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> in,tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> result=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;<span class=\"number\">3</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%f&quot;</span>,&amp;in);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&lt;in)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttmp = in;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tresult *= tmp;</span><br><span class=\"line\">\t\toutChar[i]=line[index];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>,outChar[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.2f&quot;</span>, (result*<span class=\"number\">0.65</span> - <span class=\"number\">1</span>) * <span class=\"number\">2</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>modified: 2017-08-01<br>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>","more":"<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>\n<p>For example, 3 games’ odds are given as the following:</p>\n<p> W    T    L</p>\n<p>1.1  2.5  1.7</p>\n<p>1.2  3.0  1.6</p>\n<p>4.1  1.2  1.1</p>\n<p>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1<em>3.0</em>2.5*65%-1)*2 = 37.98 yuans (accurate up to 2 decimal places).</p>\n<p>Input</p>\n<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p>\n<p>Output</p>\n<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>\n<p>Sample Input</p>\n<p>1.1 2.5 1.7</p>\n<p>1.2 3.0 1.6</p>\n<p>4.1 1.2 1.1</p>\n<p>Sample Output</p>\n<p>T T W 37.98</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>题目中给了一大堆规则，其实就是查找到每一行的最大值将它们相乘，计算结果=（相乘的结果*65%-1）X2，计算结果保留两位小数；输出最大值所对应的的列，以及将计算结果；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>设置一个结果变量result，找出每一行中的最大的数与结果变量相乘result *= tmp，可以避免每次查找都需要对最大的数进行记录；然后记录位置，将最大的数对应的结果类型赋值给 outChar[3];</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;stdlib.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> line[<span class=\"number\">3</span>] = &#123;<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;T&#x27;</span>,<span class=\"string\">&#x27;L&#x27;</span>&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> outChar[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> in,tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> result=<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>  i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;<span class=\"number\">3</span>; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%f&quot;</span>,&amp;in);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&lt;in)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttmp = in;</span><br><span class=\"line\">\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tresult *= tmp;</span><br><span class=\"line\">\t\toutChar[i]=line[index];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c &quot;</span>,outChar[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.2f&quot;</span>, (result*<span class=\"number\">0.65</span> - <span class=\"number\">1</span>) * <span class=\"number\">2</span>);</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"PAT甲级1060. Are They Equal","description":"Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.","type":["pat"],"toc":true,"cover":"/cover/img76.jpg","date":"2017-07-31T16:00:00.000Z","_content":"\nmodified: 2017-08-01\nIf a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\n<!--more-->\nInput Specification:\n\nEach input file contains one test case which gives three numbers N, A and B, where N (<100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.\n\nOutput Specification:\n\nFor each test case, print in a line \"YES\" if the two numbers are treated equal, and then the number in the standard form \"0.d1...dN*10^k\" (d1>0 unless the number is 0); or \"NO\" if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\n\nNote: Simple chopping is assumed without rounding.\n\nSample Input 1:\n\n3 12300 12358.9\n\nSample Output 1:\n\nYES 0.123*10^5\n\n\nSample Input 2:\n\n3 120 128\n\nSample Output 2:\n\nNO 0.120*10^3 0.128*10^3\n\n### 题目要求\n\n将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；\n\n### 解题思路\n\n题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;\n\nvoid getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；\n\nvoid formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index>=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index<=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；\n\n对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；\n\n数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；\n\n需要注意的要点：结尾需要使用0进行补足\n\n\n### C语言代码\n\n```c\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中\nvoid getRidZero(char  num[10000], int *index, int *decimalPoint, char  pNum[10000])\n{\n\t//做一个循环除去开头的零和小数点\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] != '0'&&num[i] != '.'&&num[i] != '\\0')\n\t\t{\n\t\t\t*index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n    //用于获取小数点的位置\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] == '.')\n\t\t{\n\t\t\t*decimalPoint = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint j = 0;\n\n\tfor (int i = *index; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] < 0)\n\t\t{\n\t\t\tpNum[j] = '0';\n\t\t\tj++;\n\t\t}\n\t\telse if (num[i] == '.')\n\t\t{\n\n\t\t\tcontinue;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tpNum[j] = num[i];\n\t\t\tj++;\n\t\t}\n\n\t}\n\n}\n\n//用于将pNum[]中保存的数按照科学计数法输出\nvoid formatPrint(int accuracy, char  pNum[10000], int decimalPoint, int index)\n{\n\tprintf(\"0.\");\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tprintf(\"%C\", pNum[i]);\n\t}\n\tif (decimalPoint - index >= 0)\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index);\n\t}\n\telse\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index + 1);\n\t}\n}\n\nint main() {\n\n\tint  accuracy;\n\tchar num1[10000];\n\tchar num2[10000];\n\n\tchar pNum1[10000];\n\tchar pNum2[10000];\n\n\t//用于记录小数点的位置\n\tint decimalPoint1 = 0;\n\tint decimalPoint2 = 0;\n\n\t//用于记录数字开始的位置\n\tint index1 = 0;\n\tint index2 = 0;\n\n\tbool equal = true;\n\n\tscanf(\"%d %s %s\", &accuracy, num1, num2);\n\tgetRidZero(num1, &index1, &decimalPoint1, pNum1);\n\tgetRidZero(num2, &index2, &decimalPoint2, pNum2);\n\n\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tif (pNum1[i] != pNum2[i])\n\t\t{\n\t\t\tequal = false;\n\t\t}\n\t}\n\n\tif ((index1 - decimalPoint1) != (index2 - decimalPoint2))\n\t{\n\t\tequal = false;\n\t}\n\n\tbool notZero = false;\n\t//判断00000000 和000000.000000000\n\tfor (int i = 0; i < 5000; i++)\n\t{\n\t\tif (pNum1[i] != '0' || pNum2[i] != '0')\n\t\t{\n\t\t\t//证明不是0\n\t\t\tnotZero = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tif (!notZero)  //证明都是0   然后输出 0.0000*10^0 ，是第六个测试点\n\t{\n\t\tprintf(\"YES 0.\");\n\t\tfor (int i = 0; i < accuracy; i++)\n\t\t{\n\t\t\tprintf(\"%C\", '0');\n\t\t}\n\t\tprintf(\"*10^%d\", 0);\n\n\t}\n\telse if (equal)    //如果两个数相等\n\t{\n\t\tprintf(\"YES \");\n\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t}\n\telse          //如果两个数不想等\n\t{\n\t\tprintf(\"NO \");\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t\t//输出第二个数\n\t\tprintf(\" \");\n\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n\n### 测试用例\n\n* 5　0000.0000123　0.0000123\n* 4　000123　　　　　00123.005\n* 4　00000　　　　　000.000001\n* 4　00.000　　　　　00000\n* 4　0.01　　　　　　0.01000005\n\n","source":"_posts/PAT/2017-08-01-pat-advanced-1060.md","raw":"---\ntitle: \"PAT甲级1060. Are They Equal\"\ndescription: \"Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\"\ntype: [pat]\ntoc: true\ncover:  /cover/img76.jpg\ncategories: PAT\ndate: 2017/08/01\n---\n\nmodified: 2017-08-01\nIf a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\n<!--more-->\nInput Specification:\n\nEach input file contains one test case which gives three numbers N, A and B, where N (<100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.\n\nOutput Specification:\n\nFor each test case, print in a line \"YES\" if the two numbers are treated equal, and then the number in the standard form \"0.d1...dN*10^k\" (d1>0 unless the number is 0); or \"NO\" if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\n\nNote: Simple chopping is assumed without rounding.\n\nSample Input 1:\n\n3 12300 12358.9\n\nSample Output 1:\n\nYES 0.123*10^5\n\n\nSample Input 2:\n\n3 120 128\n\nSample Output 2:\n\nNO 0.120*10^3 0.128*10^3\n\n### 题目要求\n\n将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；\n\n### 解题思路\n\n题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;\n\nvoid getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；\n\nvoid formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index>=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index<=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；\n\n对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；\n\n数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；\n\n需要注意的要点：结尾需要使用0进行补足\n\n\n### C语言代码\n\n```c\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中\nvoid getRidZero(char  num[10000], int *index, int *decimalPoint, char  pNum[10000])\n{\n\t//做一个循环除去开头的零和小数点\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] != '0'&&num[i] != '.'&&num[i] != '\\0')\n\t\t{\n\t\t\t*index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n    //用于获取小数点的位置\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] == '.')\n\t\t{\n\t\t\t*decimalPoint = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint j = 0;\n\n\tfor (int i = *index; i < 10000; i++)\n\t{\n\t\tif (num[i] == '\\0' || num[i] < 0)\n\t\t{\n\t\t\tpNum[j] = '0';\n\t\t\tj++;\n\t\t}\n\t\telse if (num[i] == '.')\n\t\t{\n\n\t\t\tcontinue;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tpNum[j] = num[i];\n\t\t\tj++;\n\t\t}\n\n\t}\n\n}\n\n//用于将pNum[]中保存的数按照科学计数法输出\nvoid formatPrint(int accuracy, char  pNum[10000], int decimalPoint, int index)\n{\n\tprintf(\"0.\");\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tprintf(\"%C\", pNum[i]);\n\t}\n\tif (decimalPoint - index >= 0)\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index);\n\t}\n\telse\n\t{\n\t\tprintf(\"*10^%d\", decimalPoint - index + 1);\n\t}\n}\n\nint main() {\n\n\tint  accuracy;\n\tchar num1[10000];\n\tchar num2[10000];\n\n\tchar pNum1[10000];\n\tchar pNum2[10000];\n\n\t//用于记录小数点的位置\n\tint decimalPoint1 = 0;\n\tint decimalPoint2 = 0;\n\n\t//用于记录数字开始的位置\n\tint index1 = 0;\n\tint index2 = 0;\n\n\tbool equal = true;\n\n\tscanf(\"%d %s %s\", &accuracy, num1, num2);\n\tgetRidZero(num1, &index1, &decimalPoint1, pNum1);\n\tgetRidZero(num2, &index2, &decimalPoint2, pNum2);\n\n\n\tfor (int i = 0; i < accuracy; i++)\n\t{\n\t\tif (pNum1[i] != pNum2[i])\n\t\t{\n\t\t\tequal = false;\n\t\t}\n\t}\n\n\tif ((index1 - decimalPoint1) != (index2 - decimalPoint2))\n\t{\n\t\tequal = false;\n\t}\n\n\tbool notZero = false;\n\t//判断00000000 和000000.000000000\n\tfor (int i = 0; i < 5000; i++)\n\t{\n\t\tif (pNum1[i] != '0' || pNum2[i] != '0')\n\t\t{\n\t\t\t//证明不是0\n\t\t\tnotZero = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tif (!notZero)  //证明都是0   然后输出 0.0000*10^0 ，是第六个测试点\n\t{\n\t\tprintf(\"YES 0.\");\n\t\tfor (int i = 0; i < accuracy; i++)\n\t\t{\n\t\t\tprintf(\"%C\", '0');\n\t\t}\n\t\tprintf(\"*10^%d\", 0);\n\n\t}\n\telse if (equal)    //如果两个数相等\n\t{\n\t\tprintf(\"YES \");\n\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t}\n\telse          //如果两个数不想等\n\t{\n\t\tprintf(\"NO \");\n\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);\n\n\t\t//输出第二个数\n\t\tprintf(\" \");\n\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n\n### 测试用例\n\n* 5　0000.0000123　0.0000123\n* 4　000123　　　　　00123.005\n* 4　00000　　　　　000.000001\n* 4　00.000　　　　　00000\n* 4　0.01　　　　　　0.01000005\n\n","slug":"PAT/2017-08-01-pat-advanced-1060","published":1,"updated":"2021-01-05T12:15:46.701Z","_id":"ckjju0m0s002820ua2hmm21t2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-08-01<br>If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.</p>\n<a id=\"more\"></a>\n<p>Input Specification:</p>\n<p>Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.</p>\n<p>Note: Simple chopping is assumed without rounding.</p>\n<p>Sample Input 1:</p>\n<p>3 12300 12358.9</p>\n<p>Sample Output 1:</p>\n<p>YES 0.123*10^5</p>\n<p>Sample Input 2:</p>\n<p>3 120 128</p>\n<p>Sample Output 2:</p>\n<p>NO 0.120<em>10^3 0.128</em>10^3</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;</p>\n<p>void getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；</p>\n<p>void formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index&gt;=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index&lt;=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；</p>\n<p>对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；</p>\n<p>数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；</p>\n<p>需要注意的要点：结尾需要使用0进行补足</p>\n<h3 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getRidZero</span><span class=\"params\">(<span class=\"keyword\">char</span>  num[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> *index, <span class=\"keyword\">int</span> *decimalPoint, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//做一个循环除去开头的零和小数点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] != <span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;num[i] != <span class=\"string\">&#x27;.&#x27;</span>&amp;&amp;num[i] != <span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*index = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于获取小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">&#x27;\\0&#x27;</span> || num[i] == <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*decimalPoint = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = *index; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">&#x27;\\0&#x27;</span> || num[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num[i] == <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = num[i];</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将pNum[]中保存的数按照科学计数法输出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">formatPrint</span><span class=\"params\">(<span class=\"keyword\">int</span> accuracy, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> decimalPoint, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%C&quot;</span>, pNum[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (decimalPoint - index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*10^%d&quot;</span>, decimalPoint - index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*10^%d&quot;</span>, decimalPoint - index + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>  accuracy;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录数字开始的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> equal = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %s %s&quot;</span>, &amp;accuracy, num1, num2);</span><br><span class=\"line\">\tgetRidZero(num1, &amp;index1, &amp;decimalPoint1, pNum1);</span><br><span class=\"line\">\tgetRidZero(num2, &amp;index2, &amp;decimalPoint2, pNum2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != pNum2[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((index1 - decimalPoint1) != (index2 - decimalPoint2))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> notZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断00000000 和000000.000000000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != <span class=\"string\">&#x27;0&#x27;</span> || pNum2[i] != <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//证明不是0</span></span><br><span class=\"line\">\t\t\tnotZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!notZero)  <span class=\"comment\">//证明都是0   然后输出 0.0000*10^0 ，是第六个测试点</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES 0.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%C&quot;</span>, <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*10^%d&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (equal)    <span class=\"comment\">//如果两个数相等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>          <span class=\"comment\">//如果两个数不想等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO &quot;</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//输出第二个数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><ul>\n<li>5　0000.0000123　0.0000123</li>\n<li>4　000123　　　　　00123.005</li>\n<li>4　00000　　　　　000.000001</li>\n<li>4　00.000　　　　　00000</li>\n<li>4　0.01　　　　　　0.01000005</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-08-01<br>If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.</p>","more":"<p>Input Specification:</p>\n<p>Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.</p>\n<p>Note: Simple chopping is assumed without rounding.</p>\n<p>Sample Input 1:</p>\n<p>3 12300 12358.9</p>\n<p>Sample Output 1:</p>\n<p>YES 0.123*10^5</p>\n<p>Sample Input 2:</p>\n<p>3 120 128</p>\n<p>Sample Output 2:</p>\n<p>NO 0.120<em>10^3 0.128</em>10^3</p>\n<h3 id=\"题目要求\"><a href=\"#题目要求\" class=\"headerlink\" title=\"题目要求\"></a>题目要求</h3><p>将两个不超过10^100的浮点数按照输入输入的精确度表示，然后比较两个浮点数是否相同，如果相同则输出 YES，并将使用科学计数法表示的数字输出；如果不相同，则输出NO，并将两个数字以科学计数法输出；</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>题目要求不超过10^100，那么这个浮点数只能用数组来表示；数字大小的比较可以通过比较其所对应的的ASCII，即不用char来表示每一个数字，通过字符的比较即可得到数字是否相同;</p>\n<p>void getRidZero() 这一个函数用于将num[]数组清除前导零和小数点，然后将剩下的复制到数组pNum()中；同时将小数点的位置以及给予的浮点数第一个非零的数字记录在decimalPoint和index中；</p>\n<p>void formatPrint()这一个函数用于将浮点数格式化输出；其中decimalPoint-index表示的是科学计数法的指数；decimalPoint1-index&gt;=0说明原来的数大于0，如：123.2223；如果decimalPoint1-index&lt;=0则说明是纯小数，如：0.00123，它的index=4,decimalPoint=1,小数点占了一位，因此指数需要将decimalPoint-index的值+1；</p>\n<p>对于两个0比较，如：0000和000.000则先判断是否都为0，然后再输出；</p>\n<p>数组的大小开到10000，是开始时开到100，发现没有AC，是因为题目给出的是数字位数不超过100，但数字的前导零的个数是不确定的；</p>\n<p>需要注意的要点：结尾需要使用0进行补足</p>\n<h3 id=\"C语言代码\"><a href=\"#C语言代码\" class=\"headerlink\" title=\"C语言代码\"></a>C语言代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将数组的前导零和小数点去掉，并将num[]数组的其他字符保存在 pNUm[]中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getRidZero</span><span class=\"params\">(<span class=\"keyword\">char</span>  num[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> *index, <span class=\"keyword\">int</span> *decimalPoint, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//做一个循环除去开头的零和小数点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] != <span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;num[i] != <span class=\"string\">&#x27;.&#x27;</span>&amp;&amp;num[i] != <span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*index = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于获取小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">&#x27;\\0&#x27;</span> || num[i] == <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t*decimalPoint = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = *index; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num[i] == <span class=\"string\">&#x27;\\0&#x27;</span> || num[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num[i] == <span class=\"string\">&#x27;.&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpNum[j] = num[i];</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于将pNum[]中保存的数按照科学计数法输出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">formatPrint</span><span class=\"params\">(<span class=\"keyword\">int</span> accuracy, <span class=\"keyword\">char</span>  pNum[<span class=\"number\">10000</span>], <span class=\"keyword\">int</span> decimalPoint, <span class=\"keyword\">int</span> index)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%C&quot;</span>, pNum[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (decimalPoint - index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*10^%d&quot;</span>, decimalPoint - index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*10^%d&quot;</span>, decimalPoint - index + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>  accuracy;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> num2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum1[<span class=\"number\">10000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> pNum2[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录小数点的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> decimalPoint2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//用于记录数字开始的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> equal = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %s %s&quot;</span>, &amp;accuracy, num1, num2);</span><br><span class=\"line\">\tgetRidZero(num1, &amp;index1, &amp;decimalPoint1, pNum1);</span><br><span class=\"line\">\tgetRidZero(num2, &amp;index2, &amp;decimalPoint2, pNum2);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != pNum2[i])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((index1 - decimalPoint1) != (index2 - decimalPoint2))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tequal = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> notZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断00000000 和000000.000000000</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pNum1[i] != <span class=\"string\">&#x27;0&#x27;</span> || pNum2[i] != <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//证明不是0</span></span><br><span class=\"line\">\t\t\tnotZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!notZero)  <span class=\"comment\">//证明都是0   然后输出 0.0000*10^0 ，是第六个测试点</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES 0.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; accuracy; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%C&quot;</span>, <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*10^%d&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (equal)    <span class=\"comment\">//如果两个数相等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>          <span class=\"comment\">//如果两个数不想等</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO &quot;</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum1, decimalPoint1, index1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//输出第二个数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\tformatPrint(accuracy, pNum2, decimalPoint2, index2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h3><ul>\n<li>5　0000.0000123　0.0000123</li>\n<li>4　000123　　　　　00123.005</li>\n<li>4　00000　　　　　000.000001</li>\n<li>4　00.000　　　　　00000</li>\n<li>4　0.01　　　　　　0.01000005</li>\n</ul>"},{"title":"Android JNI敏感信息保护","cover":"/cover/img2.jpg","toc":true,"description":"Android JNI敏感信息保护","type":["JNI","Android"],"date":"2019-09-20T16:00:00.000Z","_content":"\n\n# Android JNI对敏感信息进行保护\n\n## Android反编译\n\n在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。\n\n<!--more-->\n\n## 将敏感信息保存使用native代码实现\n\n相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。\n\n\n\n\n\n\n\n","source":"_posts/Android/Android JNI/Android JNI敏感信息保护.md","raw":"---\ntitle: Android JNI敏感信息保护\ncover:  /cover/img2.jpg\ntoc: true\ndescription: Android JNI敏感信息保护\ntype: [JNI,Android]\ncategories: Android\ndate: 2019/09/21\n---\n\n\n# Android JNI对敏感信息进行保护\n\n## Android反编译\n\n在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。\n\n<!--more-->\n\n## 将敏感信息保存使用native代码实现\n\n相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。\n\n\n\n\n\n\n\n","slug":"Android/Android JNI/Android JNI敏感信息保护","published":1,"updated":"2021-01-05T12:13:43.215Z","_id":"ckjju0m0t002b20ua92532b0o","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android-JNI对敏感信息进行保护\"><a href=\"#Android-JNI对敏感信息进行保护\" class=\"headerlink\" title=\"Android JNI对敏感信息进行保护\"></a>Android JNI对敏感信息进行保护</h1><h2 id=\"Android反编译\"><a href=\"#Android反编译\" class=\"headerlink\" title=\"Android反编译\"></a>Android反编译</h2><p>在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"将敏感信息保存使用native代码实现\"><a href=\"#将敏感信息保存使用native代码实现\" class=\"headerlink\" title=\"将敏感信息保存使用native代码实现\"></a>将敏感信息保存使用native代码实现</h2><p>相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-JNI对敏感信息进行保护\"><a href=\"#Android-JNI对敏感信息进行保护\" class=\"headerlink\" title=\"Android JNI对敏感信息进行保护\"></a>Android JNI对敏感信息进行保护</h1><h2 id=\"Android反编译\"><a href=\"#Android反编译\" class=\"headerlink\" title=\"Android反编译\"></a>Android反编译</h2><p>在Android开发的过程中我们通常使用混淆、加壳的方式来对apk文件进行加固，但是Java开发中的，一些常量不能被混淆，对于常量我们需要做特殊处理。</p>","more":"<h2 id=\"将敏感信息保存使用native代码实现\"><a href=\"#将敏感信息保存使用native代码实现\" class=\"headerlink\" title=\"将敏感信息保存使用native代码实现\"></a>将敏感信息保存使用native代码实现</h2><p>相对于java代码容易被反编译，使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度；如果将整个so文件拷贝进行调用，那么敏感信息依旧会被提取。</p>"},{"title":"Android中使用JNI","cover":"/cover/img3.jpg","toc":true,"description":"Android中使用JNI","type":["JNI"],"date":"2019-09-20T16:00:00.000Z","_content":"\n## Android 在已有的项目中引入JNI 最简方式\n\n### JNI与NDK\n\nJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；\nNDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；\n<!--more-->\n            \n### 下载NDK和编译工具\n* NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。\n* CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。\n* LLDB：Android Studio 用于调试原生代码的调试程序。 \n\n安装方式：\n\nAndroid Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载\n\n![](/public/img/Android/AndroidJNI.png)\n\n在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置\n![](/public/img/Android/AndroidJNI1.png)\n\n\n\n### 添加CMakeLists.txt和native-lib-cpp文件\n\n现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码\n```xml\n\n     # 设置cmake的最低版本\n     cmake_minimum_required(VERSION 3.4.1)\n\n    # 设置生成的so库的信息\n    add_library( \n        #生成的so库的名字\n        native-lib\n        # 生成的so库的类型，类型分为两种：\n        #  STATIC：静态库，为目标文件的归档文件\n        #  SHARED：动态库，会被动态链接，在运行时被加载\n        SHARED\n        # 设置源文件的位置，可以是很多个源文件，都需要添加进去\n        native-lib.cpp)\n    # 从系统里查找依赖库，可添加多个\n    find_library(\n        log-lib\n        # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest\n        log)\n     # 配置目标库的链接，即相互依赖关系\n  target_link_libraries(\n        # 目标库（最终生成的库）\n        native-lib\n        # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用\n        # 如果是第三方库，可以直接引用\n        # 每行引用一个库\n        ${log-lib})\n\n\n```\n\n在Andorid的Module下，右键选择 **Link C++ Project with Gradle**，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码\n\n```xml\n    android {\n      …\n      externalNativeBuild {\n        cmake {\n            path file('src/main/cpp/CMakeLists.txt')\n        }\n    }\n```\n\n在native-lib.cpp添加如下代码，方法名命名规则`Java_demo_lucius_baselib_MainActivity_stringFromJNI`，以`Java`作为开头,`demo_lucius_baselib_MainActivity`是“包名+调用类名”，`stringFromJNI`方法名。即` Java_{package_and_classname}_{function_name}(JNI_arguments)`，包名的`.`被下划线替代。\n\n```c++\n    #include <jni.h>\n    #include <string>\n    extern \"C\" JNIEXPORT jstring JNICALL\n    Java_demo_lucius_baselib_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n        std::string text = \"String from C++\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n```\n在上述函数`JNI_arguments`有`JNIEnv*`和`jobject`\n* JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。\n* jobject，指向Java对象的`object`。\n\n`extern \"C\"`只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。\n\n\n在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\"\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    static {\n        //用于在运行时加载本地库\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        System.out.println(stringFromJNI());\n        }\n\n    public native String stringFromJNI();\n\n\n```\n\n### 在JNI中使用C语言，新建helloJIN.c文件\n\n```c\n    #include <jni.h>        // JNI header provided by JDK\n    #include <stdio.h>      // C Standard IO Header\n\n    // Implementation of the native method sayHello()\n    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {\n       printf(\"Hello World!\\n\");\n       return;\n    }\n\n```\n\n\n### JNI基础类型介绍\n\n在`jni.h`文件中定义了预编译类型，区分Java、C++以及C\n\n```c\n\n/* Primitive types that match up with Java equivalents. */\ntypedef uint8_t  jboolean; /* unsigned 8 bits */\ntypedef int8_t   jbyte;    /* signed 8 bits */\ntypedef uint16_t jchar;    /* unsigned 16 bits */\ntypedef int16_t  jshort;   /* signed 16 bits */\ntypedef int32_t  jint;     /* signed 32 bits */\ntypedef int64_t  jlong;    /* signed 64 bits */\ntypedef float    jfloat;   /* 32-bit IEEE 754 */\ntypedef double   jdouble;  /* 64-bit IEEE 754 */\n\n/* \"cardinal indices and sizes\" */\ntypedef jint     jsize;\n\n#ifdef __cplusplus\n/*\n * Reference types, in C++\n */\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n\ntypedef _jobject*       jobject;\ntypedef _jclass*        jclass;\ntypedef _jstring*       jstring;\ntypedef _jarray*        jarray;\ntypedef _jobjectArray*  jobjectArray;\ntypedef _jbooleanArray* jbooleanArray;\ntypedef _jbyteArray*    jbyteArray;\ntypedef _jcharArray*    jcharArray;\ntypedef _jshortArray*   jshortArray;\ntypedef _jintArray*     jintArray;\ntypedef _jlongArray*    jlongArray;\ntypedef _jfloatArray*   jfloatArray;\ntypedef _jdoubleArray*  jdoubleArray;\ntypedef _jthrowable*    jthrowable;\ntypedef _jobject*       jweak;\n\n\n#else /* not __cplusplus */\n\n/*\n * Reference types, in C.\n */\ntypedef void*           jobject;\ntypedef jobject         jclass;\ntypedef jobject         jstring;\ntypedef jobject         jarray;\ntypedef jarray          jobjectArray;\ntypedef jarray          jbooleanArray;\ntypedef jarray          jbyteArray;\ntypedef jarray          jcharArray;\ntypedef jarray          jshortArray;\ntypedef jarray          jintArray;\ntypedef jarray          jlongArray;\ntypedef jarray          jfloatArray;\ntypedef jarray          jdoubleArray;\ntypedef jobject         jthrowable;\ntypedef jobject         jweak;\n\n#endif /* not __cplusplus */\n\n```\n\n\n#### Java基本数据类型与Native层中的数据对应关系\n这些基本数据类型可以在Native层直接使用。\n\n![](/public/img/Android/AndroidJNI2.png)\n\n#### Java引用数据类型与Native层中的数据对应关系\nJava引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为`jobjectArray`类型进行使用。    \n\n![](/public/img/Android/AndroidJNI3.png)\n\n在JNI中二维数组的使用\n```java\n     //获取一维数组的引用，即jintArray类型\n     jclass intArrayClass=env->FindClass(\"[I\");  \n     //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize\n     jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null);\n     \n```\n\n#### jfieldID 和jmethodID\n\n当Native层需要调用Java的某个方法时，需用`jmethodID`表示，变量则用`jfieldID`表示。`jni.h`中对jfieldID和jmethodID的定义\n\n```c++\n    struct _jfieldID;                       /* opaque structure */\n    typedef struct _jfieldID* jfieldID;     /* field IDs */\n\n    struct _jmethodID;                      /* opaque structure */\n    typedef struct _jmethodID* jmethodID;   /* method IDs */\n```\n\n在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。\n\n```c++\n    //获取jfieldID\n      jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetFieldID(this, clazz, name, sig); }\n\n    //获取jmethodID\n     jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetMethodID(this, clazz, name, sig); }\n\n```\n以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用\n\n\n\n\n\n\n\n#### JavaVM介绍\n\nJavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。`jni.h`的定义中，在C++模式下，`JavaVM`是一个结构体；在C语言模式下`JavaVM`是是一个指向方法接口指针的指针。\n\n#### JNIEnv介绍\n\nJNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。`jni.h`的定义中，在C++模式下，`JNIEnv`是一个结构体；在C语言模式下`JNIEnv`是是一个指向方法接口指针的指针。\n\n**作用：**\n* 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;\n* 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;\n\n```c++\n\n    #if defined(__cplusplus)\n    typedef _JNIEnv JNIEnv;\n    typedef _JavaVM JavaVM;\n    #else\n    typedef const struct JNINativeInterface* JNIEnv;\n    typedef const struct JNIInvokeInterface* JavaVM;\n    #endif\n\n```\n\n\n\n#### JNIEnv和JavaVM调用方法\n\n* 对于C语言\n\n```\n    (*env)->方法名(env,参数列表)\n    (*vm)->方法名(vm,参数列表)\n\n```\n* 对于C++\n\n```\n    env->方法名(参数列表)\n    vm->方法名(参数列表)\n\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android JNI/Android Studio JNI引入.md","raw":"---\ntitle: Android中使用JNI\ncover:  /cover/img3.jpg\ntoc: true\ndescription: Android中使用JNI\ntype: [JNI]\ncategories: Android\ndate: 2019/09/21\n---\n\n## Android 在已有的项目中引入JNI 最简方式\n\n### JNI与NDK\n\nJNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；\nNDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；\n<!--more-->\n            \n### 下载NDK和编译工具\n* NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。\n* CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。\n* LLDB：Android Studio 用于调试原生代码的调试程序。 \n\n安装方式：\n\nAndroid Studio Tools—>SDK manager—>SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载\n\n![](/public/img/Android/AndroidJNI.png)\n\n在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置\n![](/public/img/Android/AndroidJNI1.png)\n\n\n\n### 添加CMakeLists.txt和native-lib-cpp文件\n\n现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码\n```xml\n\n     # 设置cmake的最低版本\n     cmake_minimum_required(VERSION 3.4.1)\n\n    # 设置生成的so库的信息\n    add_library( \n        #生成的so库的名字\n        native-lib\n        # 生成的so库的类型，类型分为两种：\n        #  STATIC：静态库，为目标文件的归档文件\n        #  SHARED：动态库，会被动态链接，在运行时被加载\n        SHARED\n        # 设置源文件的位置，可以是很多个源文件，都需要添加进去\n        native-lib.cpp)\n    # 从系统里查找依赖库，可添加多个\n    find_library(\n        log-lib\n        # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest\n        log)\n     # 配置目标库的链接，即相互依赖关系\n  target_link_libraries(\n        # 目标库（最终生成的库）\n        native-lib\n        # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加${}进行引用\n        # 如果是第三方库，可以直接引用\n        # 每行引用一个库\n        ${log-lib})\n\n\n```\n\n在Andorid的Module下，右键选择 **Link C++ Project with Gradle**，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码\n\n```xml\n    android {\n      …\n      externalNativeBuild {\n        cmake {\n            path file('src/main/cpp/CMakeLists.txt')\n        }\n    }\n```\n\n在native-lib.cpp添加如下代码，方法名命名规则`Java_demo_lucius_baselib_MainActivity_stringFromJNI`，以`Java`作为开头,`demo_lucius_baselib_MainActivity`是“包名+调用类名”，`stringFromJNI`方法名。即` Java_{package_and_classname}_{function_name}(JNI_arguments)`，包名的`.`被下划线替代。\n\n```c++\n    #include <jni.h>\n    #include <string>\n    extern \"C\" JNIEXPORT jstring JNICALL\n    Java_demo_lucius_baselib_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n        std::string text = \"String from C++\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n```\n在上述函数`JNI_arguments`有`JNIEnv*`和`jobject`\n* JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。\n* jobject，指向Java对象的`object`。\n\n`extern \"C\"`只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。\n\n\n在MainActivity中添加C++代码的调用，启动MainActivity后会输出\"String from C++\"\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    static {\n        //用于在运行时加载本地库\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        System.out.println(stringFromJNI());\n        }\n\n    public native String stringFromJNI();\n\n\n```\n\n### 在JNI中使用C语言，新建helloJIN.c文件\n\n```c\n    #include <jni.h>        // JNI header provided by JDK\n    #include <stdio.h>      // C Standard IO Header\n\n    // Implementation of the native method sayHello()\n    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {\n       printf(\"Hello World!\\n\");\n       return;\n    }\n\n```\n\n\n### JNI基础类型介绍\n\n在`jni.h`文件中定义了预编译类型，区分Java、C++以及C\n\n```c\n\n/* Primitive types that match up with Java equivalents. */\ntypedef uint8_t  jboolean; /* unsigned 8 bits */\ntypedef int8_t   jbyte;    /* signed 8 bits */\ntypedef uint16_t jchar;    /* unsigned 16 bits */\ntypedef int16_t  jshort;   /* signed 16 bits */\ntypedef int32_t  jint;     /* signed 32 bits */\ntypedef int64_t  jlong;    /* signed 64 bits */\ntypedef float    jfloat;   /* 32-bit IEEE 754 */\ntypedef double   jdouble;  /* 64-bit IEEE 754 */\n\n/* \"cardinal indices and sizes\" */\ntypedef jint     jsize;\n\n#ifdef __cplusplus\n/*\n * Reference types, in C++\n */\nclass _jobject {};\nclass _jclass : public _jobject {};\nclass _jstring : public _jobject {};\nclass _jarray : public _jobject {};\nclass _jobjectArray : public _jarray {};\nclass _jbooleanArray : public _jarray {};\nclass _jbyteArray : public _jarray {};\nclass _jcharArray : public _jarray {};\nclass _jshortArray : public _jarray {};\nclass _jintArray : public _jarray {};\nclass _jlongArray : public _jarray {};\nclass _jfloatArray : public _jarray {};\nclass _jdoubleArray : public _jarray {};\nclass _jthrowable : public _jobject {};\n\ntypedef _jobject*       jobject;\ntypedef _jclass*        jclass;\ntypedef _jstring*       jstring;\ntypedef _jarray*        jarray;\ntypedef _jobjectArray*  jobjectArray;\ntypedef _jbooleanArray* jbooleanArray;\ntypedef _jbyteArray*    jbyteArray;\ntypedef _jcharArray*    jcharArray;\ntypedef _jshortArray*   jshortArray;\ntypedef _jintArray*     jintArray;\ntypedef _jlongArray*    jlongArray;\ntypedef _jfloatArray*   jfloatArray;\ntypedef _jdoubleArray*  jdoubleArray;\ntypedef _jthrowable*    jthrowable;\ntypedef _jobject*       jweak;\n\n\n#else /* not __cplusplus */\n\n/*\n * Reference types, in C.\n */\ntypedef void*           jobject;\ntypedef jobject         jclass;\ntypedef jobject         jstring;\ntypedef jobject         jarray;\ntypedef jarray          jobjectArray;\ntypedef jarray          jbooleanArray;\ntypedef jarray          jbyteArray;\ntypedef jarray          jcharArray;\ntypedef jarray          jshortArray;\ntypedef jarray          jintArray;\ntypedef jarray          jlongArray;\ntypedef jarray          jfloatArray;\ntypedef jarray          jdoubleArray;\ntypedef jobject         jthrowable;\ntypedef jobject         jweak;\n\n#endif /* not __cplusplus */\n\n```\n\n\n#### Java基本数据类型与Native层中的数据对应关系\n这些基本数据类型可以在Native层直接使用。\n\n![](/public/img/Android/AndroidJNI2.png)\n\n#### Java引用数据类型与Native层中的数据对应关系\nJava引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为`jobjectArray`类型进行使用。    \n\n![](/public/img/Android/AndroidJNI3.png)\n\n在JNI中二维数组的使用\n```java\n     //获取一维数组的引用，即jintArray类型\n     jclass intArrayClass=env->FindClass(\"[I\");  \n     //构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize\n     jobjectArray objectIntArray=env->NewObjectArray(length,intArrayClass,Null);\n     \n```\n\n#### jfieldID 和jmethodID\n\n当Native层需要调用Java的某个方法时，需用`jmethodID`表示，变量则用`jfieldID`表示。`jni.h`中对jfieldID和jmethodID的定义\n\n```c++\n    struct _jfieldID;                       /* opaque structure */\n    typedef struct _jfieldID* jfieldID;     /* field IDs */\n\n    struct _jmethodID;                      /* opaque structure */\n    typedef struct _jmethodID* jmethodID;   /* method IDs */\n```\n\n在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。\n\n```c++\n    //获取jfieldID\n      jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetFieldID(this, clazz, name, sig); }\n\n    //获取jmethodID\n     jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    { return functions->GetMethodID(this, clazz, name, sig); }\n\n```\n以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用\n\n\n\n\n\n\n\n#### JavaVM介绍\n\nJavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。`jni.h`的定义中，在C++模式下，`JavaVM`是一个结构体；在C语言模式下`JavaVM`是是一个指向方法接口指针的指针。\n\n#### JNIEnv介绍\n\nJNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。`jni.h`的定义中，在C++模式下，`JNIEnv`是一个结构体；在C语言模式下`JNIEnv`是是一个指向方法接口指针的指针。\n\n**作用：**\n* 调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;\n* 操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;\n\n```c++\n\n    #if defined(__cplusplus)\n    typedef _JNIEnv JNIEnv;\n    typedef _JavaVM JavaVM;\n    #else\n    typedef const struct JNINativeInterface* JNIEnv;\n    typedef const struct JNIInvokeInterface* JavaVM;\n    #endif\n\n```\n\n\n\n#### JNIEnv和JavaVM调用方法\n\n* 对于C语言\n\n```\n    (*env)->方法名(env,参数列表)\n    (*vm)->方法名(vm,参数列表)\n\n```\n* 对于C++\n\n```\n    env->方法名(参数列表)\n    vm->方法名(参数列表)\n\n```\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android JNI/Android Studio JNI引入","published":1,"updated":"2021-01-05T12:13:44.520Z","_id":"ckjju0m0u002e20ua0doib7kr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android-在已有的项目中引入JNI-最简方式\"><a href=\"#Android-在已有的项目中引入JNI-最简方式\" class=\"headerlink\" title=\"Android 在已有的项目中引入JNI 最简方式\"></a>Android 在已有的项目中引入JNI 最简方式</h2><h3 id=\"JNI与NDK\"><a href=\"#JNI与NDK\" class=\"headerlink\" title=\"JNI与NDK\"></a>JNI与NDK</h3><p>JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；<br>NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；</p>\n<a id=\"more\"></a>\n\n<h3 id=\"下载NDK和编译工具\"><a href=\"#下载NDK和编译工具\" class=\"headerlink\" title=\"下载NDK和编译工具\"></a>下载NDK和编译工具</h3><ul>\n<li>NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。</li>\n<li>CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。</li>\n<li>LLDB：Android Studio 用于调试原生代码的调试程序。 </li>\n</ul>\n<p>安装方式：</p>\n<p>Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载</p>\n<p><img src=\"/public/img/Android/AndroidJNI.png\"></p>\n<p>在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置<br><img src=\"/public/img/Android/AndroidJNI1.png\"></p>\n<h3 id=\"添加CMakeLists-txt和native-lib-cpp文件\"><a href=\"#添加CMakeLists-txt和native-lib-cpp文件\" class=\"headerlink\" title=\"添加CMakeLists.txt和native-lib-cpp文件\"></a>添加CMakeLists.txt和native-lib-cpp文件</h3><p>现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   # 设置cmake的最低版本</span><br><span class=\"line\">   cmake_minimum_required(VERSION 3.4.1)</span><br><span class=\"line\"></span><br><span class=\"line\">  # 设置生成的so库的信息</span><br><span class=\"line\">  add_library( </span><br><span class=\"line\">      #生成的so库的名字</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 生成的so库的类型，类型分为两种：</span><br><span class=\"line\">      #  STATIC：静态库，为目标文件的归档文件</span><br><span class=\"line\">      #  SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class=\"line\">      SHARED</span><br><span class=\"line\">      # 设置源文件的位置，可以是很多个源文件，都需要添加进去</span><br><span class=\"line\">      native-lib.cpp)</span><br><span class=\"line\">  # 从系统里查找依赖库，可添加多个</span><br><span class=\"line\">  find_library(</span><br><span class=\"line\">      log-lib</span><br><span class=\"line\">      # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest</span><br><span class=\"line\">      log)</span><br><span class=\"line\">   # 配置目标库的链接，即相互依赖关系</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">      # 目标库（最终生成的库）</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加$&#123;&#125;进行引用</span><br><span class=\"line\">      # 如果是第三方库，可以直接引用</span><br><span class=\"line\">      # 每行引用一个库</span><br><span class=\"line\">      $&#123;log-lib&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在Andorid的Module下，右键选择 <strong>Link C++ Project with Gradle</strong>，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  …</span><br><span class=\"line\">  externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path file(&#x27;src/main/cpp/CMakeLists.txt&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在native-lib.cpp添加如下代码，方法名命名规则<code>Java_demo_lucius_baselib_MainActivity_stringFromJNI</code>，以<code>Java</code>作为开头,<code>demo_lucius_baselib_MainActivity</code>是“包名+调用类名”，<code>stringFromJNI</code>方法名。即<code> Java_&#123;package_and_classname&#125;_&#123;function_name&#125;(JNI_arguments)</code>，包名的<code>.</code>被下划线替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_demo_lucius_baselib_MainActivity_stringFromJNI(</span><br><span class=\"line\">    JNIEnv *env,</span><br><span class=\"line\">    jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> text = <span class=\"string\">&quot;String from C++&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上述函数<code>JNI_arguments</code>有<code>JNIEnv*</code>和<code>jobject</code></p>\n<ul>\n<li>JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。</li>\n<li>jobject，指向Java对象的<code>object</code>。</li>\n</ul>\n<p><code>extern &quot;C&quot;</code>只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。</p>\n<p>在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于在运行时加载本地库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;native-lib&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringFromJNI());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"在JNI中使用C语言，新建helloJIN-c文件\"><a href=\"#在JNI中使用C语言，新建helloJIN-c文件\" class=\"headerlink\" title=\"在JNI中使用C语言，新建helloJIN.c文件\"></a>在JNI中使用C语言，新建helloJIN.c文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;        // JNI header provided by JDK</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;      // C Standard IO Header</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation of the native method sayHello()</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_HelloJNI_sayHello</span><span class=\"params\">(JNIEnv *env, jobject thisObj)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World!\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JNI基础类型介绍\"><a href=\"#JNI基础类型介绍\" class=\"headerlink\" title=\"JNI基础类型介绍\"></a>JNI基础类型介绍</h3><p>在<code>jni.h</code>文件中定义了预编译类型，区分Java、C++以及C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Primitive types that match up with Java equivalents. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint8_t</span>  jboolean; <span class=\"comment\">/* unsigned 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int8_t</span>   jbyte;    <span class=\"comment\">/* signed 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint16_t</span> jchar;    <span class=\"comment\">/* unsigned 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int16_t</span>  jshort;   <span class=\"comment\">/* signed 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int32_t</span>  jint;     <span class=\"comment\">/* signed 32 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int64_t</span>  jlong;    <span class=\"comment\">/* signed 64 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">float</span>    jfloat;   <span class=\"comment\">/* 32-bit IEEE 754 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span>   jdouble;  <span class=\"comment\">/* 64-bit IEEE 754 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* &quot;cardinal indices and sizes&quot; */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jint     jsize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C++</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobject</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jclass</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jstring</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jarray</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobjectArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbooleanArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbyteArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jcharArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jshortArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jintArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jlongArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jfloatArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jdoubleArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jthrowable</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass*        jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jstring*       jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jarray*        jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jcharArray*    jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jshortArray*   jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jintArray*     jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jlongArray*    jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jthrowable*    jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>*           jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java基本数据类型与Native层中的数据对应关系\"><a href=\"#Java基本数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java基本数据类型与Native层中的数据对应关系\"></a>Java基本数据类型与Native层中的数据对应关系</h4><p>这些基本数据类型可以在Native层直接使用。</p>\n<p><img src=\"/public/img/Android/AndroidJNI2.png\"></p>\n<h4 id=\"Java引用数据类型与Native层中的数据对应关系\"><a href=\"#Java引用数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java引用数据类型与Native层中的数据对应关系\"></a>Java引用数据类型与Native层中的数据对应关系</h4><p>Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为<code>jobjectArray</code>类型进行使用。    </p>\n<p><img src=\"/public/img/Android/AndroidJNI3.png\"></p>\n<p>在JNI中二维数组的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一维数组的引用，即jintArray类型</span></span><br><span class=\"line\">jclass intArrayClass=env-&gt;FindClass(<span class=\"string\">&quot;[I&quot;</span>);  </span><br><span class=\"line\"><span class=\"comment\">//构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize</span></span><br><span class=\"line\">jobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"jfieldID-和jmethodID\"><a href=\"#jfieldID-和jmethodID\" class=\"headerlink\" title=\"jfieldID 和jmethodID\"></a>jfieldID 和jmethodID</h4><p>当Native层需要调用Java的某个方法时，需用<code>jmethodID</code>表示，变量则用<code>jfieldID</code>表示。<code>jni.h</code>中对jfieldID和jmethodID的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>                       <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>* <span class=\"title\">jfieldID</span>;</span>     <span class=\"comment\">/* field IDs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>                      <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>* <span class=\"title\">jmethodID</span>;</span>   <span class=\"comment\">/* method IDs */</span></span><br></pre></td></tr></table></figure>\n<p>在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取jfieldID</span></span><br><span class=\"line\">  <span class=\"function\">jfieldID <span class=\"title\">GetFieldID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetFieldID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取jmethodID</span></span><br><span class=\"line\"> <span class=\"function\">jmethodID <span class=\"title\">GetMethodID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetMethodID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用</p>\n<h4 id=\"JavaVM介绍\"><a href=\"#JavaVM介绍\" class=\"headerlink\" title=\"JavaVM介绍\"></a>JavaVM介绍</h4><p>JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。<code>jni.h</code>的定义中，在C++模式下，<code>JavaVM</code>是一个结构体；在C语言模式下<code>JavaVM</code>是是一个指向方法接口指针的指针。</p>\n<h4 id=\"JNIEnv介绍\"><a href=\"#JNIEnv介绍\" class=\"headerlink\" title=\"JNIEnv介绍\"></a>JNIEnv介绍</h4><p>JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。<code>jni.h</code>的定义中，在C++模式下，<code>JNIEnv</code>是一个结构体；在C语言模式下<code>JNIEnv</code>是是一个指向方法接口指针的指针。</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;</li>\n<li>操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(__cplusplus)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JNIEnv JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JavaVM JavaVM;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span>* <span class=\"title\">JNIEnv</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"JNIEnv和JavaVM调用方法\"><a href=\"#JNIEnv和JavaVM调用方法\" class=\"headerlink\" title=\"JNIEnv和JavaVM调用方法\"></a>JNIEnv和JavaVM调用方法</h4><ul>\n<li>对于C语言</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;方法名(env,参数列表)</span><br><span class=\"line\">(*vm)-&gt;方法名(vm,参数列表)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于C++</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env-&gt;方法名(参数列表)</span><br><span class=\"line\">vm-&gt;方法名(参数列表)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"Android-在已有的项目中引入JNI-最简方式\"><a href=\"#Android-在已有的项目中引入JNI-最简方式\" class=\"headerlink\" title=\"Android 在已有的项目中引入JNI 最简方式\"></a>Android 在已有的项目中引入JNI 最简方式</h2><h3 id=\"JNI与NDK\"><a href=\"#JNI与NDK\" class=\"headerlink\" title=\"JNI与NDK\"></a>JNI与NDK</h3><p>JNI：JNI是一套编程接口，用来实现Java代码与本地的C/C++代码进行交互；<br>NDK: NDK是Google开发的一套开发和编译工具集，可以生成动态链接库，主要用于Android的JNI开发；</p>","more":"<h3 id=\"下载NDK和编译工具\"><a href=\"#下载NDK和编译工具\" class=\"headerlink\" title=\"下载NDK和编译工具\"></a>下载NDK和编译工具</h3><ul>\n<li>NDK:一个工具集，能够在 Android 应用中使用 C 和 C++ 代码；它提供各种平台库，可以管理原生 Activity 并访问实际设备组件，例如传感器和轻触输入。</li>\n<li>CMake：一款外部编译工具，可与 Gradle 搭配使用来编译原生库。</li>\n<li>LLDB：Android Studio 用于调试原生代码的调试程序。 </li>\n</ul>\n<p>安装方式：</p>\n<p>Android Studio Tools—&gt;SDK manager—&gt;SDK Tools 选择LLDB、CMake、NDK点击Apply进行下载</p>\n<p><img src=\"/public/img/Android/AndroidJNI.png\"></p>\n<p>在cpp文件夹下新建CMakeLists.txt和native-lib.cpp文件，CMakeLists.txt可以建在工程的任意位置<br><img src=\"/public/img/Android/AndroidJNI1.png\"></p>\n<h3 id=\"添加CMakeLists-txt和native-lib-cpp文件\"><a href=\"#添加CMakeLists-txt和native-lib-cpp文件\" class=\"headerlink\" title=\"添加CMakeLists.txt和native-lib-cpp文件\"></a>添加CMakeLists.txt和native-lib-cpp文件</h3><p>现在CMakeLists.txt中添加如下代码，native-lib-cpp可以先不添加代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   # 设置cmake的最低版本</span><br><span class=\"line\">   cmake_minimum_required(VERSION 3.4.1)</span><br><span class=\"line\"></span><br><span class=\"line\">  # 设置生成的so库的信息</span><br><span class=\"line\">  add_library( </span><br><span class=\"line\">      #生成的so库的名字</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 生成的so库的类型，类型分为两种：</span><br><span class=\"line\">      #  STATIC：静态库，为目标文件的归档文件</span><br><span class=\"line\">      #  SHARED：动态库，会被动态链接，在运行时被加载</span><br><span class=\"line\">      SHARED</span><br><span class=\"line\">      # 设置源文件的位置，可以是很多个源文件，都需要添加进去</span><br><span class=\"line\">      native-lib.cpp)</span><br><span class=\"line\">  # 从系统里查找依赖库，可添加多个</span><br><span class=\"line\">  find_library(</span><br><span class=\"line\">      log-lib</span><br><span class=\"line\">      # liblog.so库指定的名称为 log，libjnitest.so的名称为jnitest</span><br><span class=\"line\">      log)</span><br><span class=\"line\">   # 配置目标库的链接，即相互依赖关系</span><br><span class=\"line\">target_link_libraries(</span><br><span class=\"line\">      # 目标库（最终生成的库）</span><br><span class=\"line\">      native-lib</span><br><span class=\"line\">      # 需要依赖的log库，一般情况下，如果依赖的是系统中的库，需要加$&#123;&#125;进行引用</span><br><span class=\"line\">      # 如果是第三方库，可以直接引用</span><br><span class=\"line\">      # 每行引用一个库</span><br><span class=\"line\">      $&#123;log-lib&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在Andorid的Module下，右键选择 <strong>Link C++ Project with Gradle</strong>，选择新建的CMakeLists.txt文件的路径；构建完成后，在moudle的build.gradle会增加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  …</span><br><span class=\"line\">  externalNativeBuild &#123;</span><br><span class=\"line\">    cmake &#123;</span><br><span class=\"line\">        path file(&#x27;src/main/cpp/CMakeLists.txt&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在native-lib.cpp添加如下代码，方法名命名规则<code>Java_demo_lucius_baselib_MainActivity_stringFromJNI</code>，以<code>Java</code>作为开头,<code>demo_lucius_baselib_MainActivity</code>是“包名+调用类名”，<code>stringFromJNI</code>方法名。即<code> Java_&#123;package_and_classname&#125;_&#123;function_name&#125;(JNI_arguments)</code>，包名的<code>.</code>被下划线替代。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class=\"line\">Java_demo_lucius_baselib_MainActivity_stringFromJNI(</span><br><span class=\"line\">    JNIEnv *env,</span><br><span class=\"line\">    jobject <span class=\"comment\">/* this */</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> text = <span class=\"string\">&quot;String from C++&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上述函数<code>JNI_arguments</code>有<code>JNIEnv*</code>和<code>jobject</code></p>\n<ul>\n<li>JNIEnv*，代表JNI的环境，可以获取到所有的JNI方法。</li>\n<li>jobject，指向Java对象的<code>object</code>。</li>\n</ul>\n<p><code>extern &quot;C&quot;</code>只会被C++编译器识别，C++编译器在编译时会按照C语言方法的命名规则，而非C++的命名规则进行编译。C和C++的有不同方法命名规则,C++支持方法的重载，同时C++使用mangling scheme识别方法的重载。</p>\n<p>在MainActivity中添加C++代码的调用，启动MainActivity后会输出”String from C++”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于在运行时加载本地库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;native-lib&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringFromJNI());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> String <span class=\"title\">stringFromJNI</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"在JNI中使用C语言，新建helloJIN-c文件\"><a href=\"#在JNI中使用C语言，新建helloJIN-c文件\" class=\"headerlink\" title=\"在JNI中使用C语言，新建helloJIN.c文件\"></a>在JNI中使用C语言，新建helloJIN.c文件</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;        // JNI header provided by JDK</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;      // C Standard IO Header</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation of the native method sayHello()</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_HelloJNI_sayHello</span><span class=\"params\">(JNIEnv *env, jobject thisObj)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World!\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JNI基础类型介绍\"><a href=\"#JNI基础类型介绍\" class=\"headerlink\" title=\"JNI基础类型介绍\"></a>JNI基础类型介绍</h3><p>在<code>jni.h</code>文件中定义了预编译类型，区分Java、C++以及C</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Primitive types that match up with Java equivalents. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint8_t</span>  jboolean; <span class=\"comment\">/* unsigned 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int8_t</span>   jbyte;    <span class=\"comment\">/* signed 8 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint16_t</span> jchar;    <span class=\"comment\">/* unsigned 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int16_t</span>  jshort;   <span class=\"comment\">/* signed 16 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int32_t</span>  jint;     <span class=\"comment\">/* signed 32 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int64_t</span>  jlong;    <span class=\"comment\">/* signed 64 bits */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">float</span>    jfloat;   <span class=\"comment\">/* 32-bit IEEE 754 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span>   jdouble;  <span class=\"comment\">/* 64-bit IEEE 754 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* &quot;cardinal indices and sizes&quot; */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jint     jsize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C++</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobject</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jclass</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jstring</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jarray</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jobjectArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbooleanArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jbyteArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jcharArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jshortArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jintArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jlongArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jfloatArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jdoubleArray</span> :</span> <span class=\"keyword\">public</span> _jarray &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">jthrowable</span> :</span> <span class=\"keyword\">public</span> _jobject &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass*        jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jstring*       jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jarray*        jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobjectArray*  jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbooleanArray* jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jbyteArray*    jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jcharArray*    jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jshortArray*   jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jintArray*     jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jlongArray*    jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jfloatArray*   jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jdoubleArray*  jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jthrowable*    jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject*       jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference types, in C.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>*           jobject;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jclass;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jstring;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jarray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jobjectArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbooleanArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jbyteArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jcharArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jshortArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jintArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jlongArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jfloatArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jarray          jdoubleArray;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jthrowable;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> jobject         jweak;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">/* not __cplusplus */</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java基本数据类型与Native层中的数据对应关系\"><a href=\"#Java基本数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java基本数据类型与Native层中的数据对应关系\"></a>Java基本数据类型与Native层中的数据对应关系</h4><p>这些基本数据类型可以在Native层直接使用。</p>\n<p><img src=\"/public/img/Android/AndroidJNI2.png\"></p>\n<h4 id=\"Java引用数据类型与Native层中的数据对应关系\"><a href=\"#Java引用数据类型与Native层中的数据对应关系\" class=\"headerlink\" title=\"Java引用数据类型与Native层中的数据对应关系\"></a>Java引用数据类型与Native层中的数据对应关系</h4><p>Java引用数据类型不能直接在Native层使用，需要根据JNI函数进行类型的转换后，才能使用。多维数组（包括二维数组）都是引用类型，需要转化为<code>jobjectArray</code>类型进行使用。    </p>\n<p><img src=\"/public/img/Android/AndroidJNI3.png\"></p>\n<p>在JNI中二维数组的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一维数组的引用，即jintArray类型</span></span><br><span class=\"line\">jclass intArrayClass=env-&gt;FindClass(<span class=\"string\">&quot;[I&quot;</span>);  </span><br><span class=\"line\"><span class=\"comment\">//构造一个指向jintArray类的一维数组对象，该对象数组初始大小为length,类型为jsize</span></span><br><span class=\"line\">jobjectArray objectIntArray=env-&gt;NewObjectArray(length,intArrayClass,Null);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"jfieldID-和jmethodID\"><a href=\"#jfieldID-和jmethodID\" class=\"headerlink\" title=\"jfieldID 和jmethodID\"></a>jfieldID 和jmethodID</h4><p>当Native层需要调用Java的某个方法时，需用<code>jmethodID</code>表示，变量则用<code>jfieldID</code>表示。<code>jni.h</code>中对jfieldID和jmethodID的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>                       <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>* <span class=\"title\">jfieldID</span>;</span>     <span class=\"comment\">/* field IDs */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>                      <span class=\"comment\">/* opaque structure */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>* <span class=\"title\">jmethodID</span>;</span>   <span class=\"comment\">/* method IDs */</span></span><br></pre></td></tr></table></figure>\n<p>在JNI规则中，用jfieldID 和jmethodID 来表示Java类的成员变量和成员函数，它们通过JNIEnv的下面两个函数可以得到，其中jclass代表Java类，name表示成员函数或成员变量的名字，sig为这个函数和变量的签名信息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取jfieldID</span></span><br><span class=\"line\">  <span class=\"function\">jfieldID <span class=\"title\">GetFieldID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetFieldID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取jmethodID</span></span><br><span class=\"line\"> <span class=\"function\">jmethodID <span class=\"title\">GetMethodID</span><span class=\"params\">(jclass clazz, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"keyword\">return</span> functions-&gt;GetMethodID(<span class=\"keyword\">this</span>, clazz, name, sig); &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以Java中的MD5加密在JNI层调用为例，介绍jmethodID的使用</p>\n<h4 id=\"JavaVM介绍\"><a href=\"#JavaVM介绍\" class=\"headerlink\" title=\"JavaVM介绍\"></a>JavaVM介绍</h4><p>JavaVM是虚拟机在JNI层的代表，每一个虚拟机进程只有一个JavaVM，即对JNI来说，JavaVM是一个全局变量。<code>jni.h</code>的定义中，在C++模式下，<code>JavaVM</code>是一个结构体；在C语言模式下<code>JavaVM</code>是是一个指向方法接口指针的指针。</p>\n<h4 id=\"JNIEnv介绍\"><a href=\"#JNIEnv介绍\" class=\"headerlink\" title=\"JNIEnv介绍\"></a>JNIEnv介绍</h4><p>JNIEnv是JavaVM在线程中的代表，是一个与线程相关的，代表JNI环境的结构体，不同线程的JNIEnv彼此独立。<code>jni.h</code>的定义中，在C++模式下，<code>JNIEnv</code>是一个结构体；在C语言模式下<code>JNIEnv</code>是是一个指向方法接口指针的指针。</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>调用Java函数 ：JNIEnv 代表 Java 运行环境, 可以使用 JNIEnv 调用Java中的代码;</li>\n<li>操作Java对象 : Java对象传入JNI层就是Jobject对象, 需要使用 JNIEnv来操作这个 Java 对象;</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(__cplusplus)</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JNIEnv JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _JavaVM JavaVM;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span>* <span class=\"title\">JNIEnv</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNIInvokeInterface</span>* <span class=\"title\">JavaVM</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"JNIEnv和JavaVM调用方法\"><a href=\"#JNIEnv和JavaVM调用方法\" class=\"headerlink\" title=\"JNIEnv和JavaVM调用方法\"></a>JNIEnv和JavaVM调用方法</h4><ul>\n<li>对于C语言</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*env)-&gt;方法名(env,参数列表)</span><br><span class=\"line\">(*vm)-&gt;方法名(vm,参数列表)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于C++</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env-&gt;方法名(参数列表)</span><br><span class=\"line\">vm-&gt;方法名(参数列表)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Android防止二次打包","cover":"/cover/img4.jpg","toc":true,"description":"Android防止二次打包","type":["Android"],"date":"2019-09-29T16:00:00.000Z","_content":"Android防止二次打包主要通过对签名文件的验证来进行\n\n### 应用签名文件介绍\n\n在Android Studio2.2之后多了对签名版本的选择`V1(Jar Signature)`和`V2(Full APK Signature)`V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。\n<!--more-->\n#### 签名文件在gradle中配置\n\n    signingConfigs {      \n      debug {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"         \n        keyAlias \"**\"          \n        keyPassword \"******\"          \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }      \n      release {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"          \n        keyAlias \"**\"          \n        keyPassword \"******\"         \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }\n    }\n\n### 应用签名文件查看\n\n* 已有.jks文件\n\n在cmd中输入\n```xml\n\nkeytool -list -v -keystore path/android.jks -storepass password\n\n```\n![](/public/img/Android/Android safe.png)\n\n\n* 只有.apk文件\n\n使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入\n```xml\nkeytool -printcert -file path/android.jks\n```\n![](/public/img/Android/Android safe1.png)\n\n**两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码**\n\n### 在Java代码中进行验证，通过PackageManager获取签名信息。\n\n使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解\n\n\n### 在native层进行签名验证\n使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。\n\n因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。\n\n### 在服务端对签名文件进行验证\n服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）\n\n\n","source":"_posts/Android/Android反编译/Android应用防止二次打包.md","raw":"---\ntitle: Android防止二次打包\ncover: /cover/img4.jpg\ntoc: true\ndescription: Android防止二次打包\ntype: [Android]\ncategories: Android\ndate: 2019/09/30\n---\nAndroid防止二次打包主要通过对签名文件的验证来进行\n\n### 应用签名文件介绍\n\n在Android Studio2.2之后多了对签名版本的选择`V1(Jar Signature)`和`V2(Full APK Signature)`V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。\n<!--more-->\n#### 签名文件在gradle中配置\n\n    signingConfigs {      \n      debug {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"         \n        keyAlias \"**\"          \n        keyPassword \"******\"          \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }      \n      release {          \n        storeFile file(\"./hyydev.jks\")          \n        storePassword \"******\"          \n        keyAlias \"**\"          \n        keyPassword \"******\"         \n        v1SigningEnabled true          \n        v2SigningEnabled true      \n      }\n    }\n\n### 应用签名文件查看\n\n* 已有.jks文件\n\n在cmd中输入\n```xml\n\nkeytool -list -v -keystore path/android.jks -storepass password\n\n```\n![](/public/img/Android/Android safe.png)\n\n\n* 只有.apk文件\n\n使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入\n```xml\nkeytool -printcert -file path/android.jks\n```\n![](/public/img/Android/Android safe1.png)\n\n**两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码**\n\n### 在Java代码中进行验证，通过PackageManager获取签名信息。\n\n使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解\n\n\n### 在native层进行签名验证\n使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。\n\n因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。\n\n### 在服务端对签名文件进行验证\n服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）\n\n\n","slug":"Android/Android反编译/Android应用防止二次打包","published":1,"updated":"2021-01-05T12:13:47.709Z","_id":"ckjju0m0v002j20uah2rodt0k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Android防止二次打包主要通过对签名文件的验证来进行</p>\n<h3 id=\"应用签名文件介绍\"><a href=\"#应用签名文件介绍\" class=\"headerlink\" title=\"应用签名文件介绍\"></a>应用签名文件介绍</h3><p>在Android Studio2.2之后多了对签名版本的选择<code>V1(Jar Signature)</code>和<code>V2(Full APK Signature)</code>V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。</p>\n<a id=\"more\"></a>\n<h4 id=\"签名文件在gradle中配置\"><a href=\"#签名文件在gradle中配置\" class=\"headerlink\" title=\"签名文件在gradle中配置\"></a>签名文件在gradle中配置</h4><pre><code>signingConfigs &#123;      \n  debug &#123;          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;         \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;          \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  &#125;      \n  release &#123;          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;          \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;         \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  &#125;\n&#125;</code></pre>\n<h3 id=\"应用签名文件查看\"><a href=\"#应用签名文件查看\" class=\"headerlink\" title=\"应用签名文件查看\"></a>应用签名文件查看</h3><ul>\n<li>已有.jks文件</li>\n</ul>\n<p>在cmd中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">keytool -list -v -keystore path/android.jks -storepass password</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>![](/public/img/Android/Android safe.png)</p>\n<ul>\n<li>只有.apk文件</li>\n</ul>\n<p>使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file path/android.jks</span><br></pre></td></tr></table></figure>\n<p>![](/public/img/Android/Android safe1.png)</p>\n<p><strong>两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码</strong></p>\n<h3 id=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"><a href=\"#在Java代码中进行验证，通过PackageManager获取签名信息。\" class=\"headerlink\" title=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"></a>在Java代码中进行验证，通过PackageManager获取签名信息。</h3><p>使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解</p>\n<h3 id=\"在native层进行签名验证\"><a href=\"#在native层进行签名验证\" class=\"headerlink\" title=\"在native层进行签名验证\"></a>在native层进行签名验证</h3><p>使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。</p>\n<p>因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。</p>\n<h3 id=\"在服务端对签名文件进行验证\"><a href=\"#在服务端对签名文件进行验证\" class=\"headerlink\" title=\"在服务端对签名文件进行验证\"></a>在服务端对签名文件进行验证</h3><p>服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）</p>\n","site":{"data":{}},"excerpt":"<p>Android防止二次打包主要通过对签名文件的验证来进行</p>\n<h3 id=\"应用签名文件介绍\"><a href=\"#应用签名文件介绍\" class=\"headerlink\" title=\"应用签名文件介绍\"></a>应用签名文件介绍</h3><p>在Android Studio2.2之后多了对签名版本的选择<code>V1(Jar Signature)</code>和<code>V2(Full APK Signature)</code>V1就是传统的签名方式，V2则是Android7.0之后引入的。其区别是，V1是通过ZIP条目进行验证，这样APK 签署后可进行许多修改；而V2验证压缩文件的所有字节，而不是单个 ZIP 条目，这样在签名后无法再更改。V2的好处很明显，更安全且验证更迅速。所以，推荐在生成apk时，签名方式选择V1+V2。当然，仅仅选择V1也是可以的。如果仅选择V2呢，这样生成的apk在Android7.0及之后的版本上没有问题，不过会导致7.0以下的版本无法安装，所以要避免这种方式。</p>","more":"<h4 id=\"签名文件在gradle中配置\"><a href=\"#签名文件在gradle中配置\" class=\"headerlink\" title=\"签名文件在gradle中配置\"></a>签名文件在gradle中配置</h4><pre><code>signingConfigs &#123;      \n  debug &#123;          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;         \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;          \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  &#125;      \n  release &#123;          \n    storeFile file(&quot;./hyydev.jks&quot;)          \n    storePassword &quot;******&quot;          \n    keyAlias &quot;**&quot;          \n    keyPassword &quot;******&quot;         \n    v1SigningEnabled true          \n    v2SigningEnabled true      \n  &#125;\n&#125;</code></pre>\n<h3 id=\"应用签名文件查看\"><a href=\"#应用签名文件查看\" class=\"headerlink\" title=\"应用签名文件查看\"></a>应用签名文件查看</h3><ul>\n<li>已有.jks文件</li>\n</ul>\n<p>在cmd中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">keytool -list -v -keystore path/android.jks -storepass password</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>![](/public/img/Android/Android safe.png)</p>\n<ul>\n<li>只有.apk文件</li>\n</ul>\n<p>使用解压工具解压APK文件，在META-INF文件夹拿到CERT.RSA文件,在CMD中输入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -printcert -file path/android.jks</span><br></pre></td></tr></table></figure>\n<p>![](/public/img/Android/Android safe1.png)</p>\n<p><strong>两种方式获取到的签名文件是一致的，使用.jks文件需要密码，而使用.apk文件无需密码</strong></p>\n<h3 id=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"><a href=\"#在Java代码中进行验证，通过PackageManager获取签名信息。\" class=\"headerlink\" title=\"在Java代码中进行验证，通过PackageManager获取签名信息。\"></a>在Java代码中进行验证，通过PackageManager获取签名信息。</h3><p>使用Java代码进行签名信息验证，通过修改smali文件可以绕过，容易破解</p>\n<h3 id=\"在native层进行签名验证\"><a href=\"#在native层进行签名验证\" class=\"headerlink\" title=\"在native层进行签名验证\"></a>在native层进行签名验证</h3><p>使用NDK开发出来的原生C++代码编译后生成的so库是一个二进制文件，可以增加了破解的难度，但在实现中将用于对比的签名HASH串明文存放在代码中，可能会被取出。</p>\n<p>因此在编写时需要对签名内容进行加密，使用自定义加密算法，在使用时进行解密。</p>\n<h3 id=\"在服务端对签名文件进行验证\"><a href=\"#在服务端对签名文件进行验证\" class=\"headerlink\" title=\"在服务端对签名文件进行验证\"></a>在服务端对签名文件进行验证</h3><p>服务器校验即将本地的程序信息，传输到服务器进行校验，然后返回一段核心代码进行执行（非校验结果，防本地修改；同时也不建议服务器下发校验信息，本地校验，原理同）</p>"},{"title":"Hello World","cover":"/cover/img16.jpg","toc":true,"description":"测试摘要","date":"2019-08-04T16:00:00.000Z","_content":"","source":"_posts/Android/Other/Groovy介绍.md","raw":"---\ntitle: Hello World\ncover: /cover/img16.jpg\ntoc: true\ndescription: 测试摘要\ndate: 2019/08/05\n---","slug":"Android/Other/Groovy介绍","published":1,"updated":"2021-01-05T11:57:11.260Z","_id":"ckjju0m0w002m20uagiry92uv","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"gradle介绍","cover":"/cover/img17.jpg","toc":true,"description":"gradle介绍","type":["Android"],"date":"2019-08-09T16:00:00.000Z","_content":"\n### gradle介绍\n\ngradle和make以及ant不同，它基于Groovy语言，而非一种配置；\n\nGradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，\n\n<!--more-->\n\n#### 在Moudle的build.gradle中添加依赖包\n\n```java\n    android { ... }\n\n    dependencies {\n        // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`\n        implementation project(\":mylibrary\")\n\n        // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 \n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n        // 依赖于远程库\n        implementation 'com.example.android:app-magic:12.3'\n    }\n\n```\n\n依赖包的配置有以下类型：`implementation`、`api`、`compileOnly`、`runtimeOnly`、`annotationProcessor`、`lintChecks`、`lintPublish`\n在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。\n\n```java\n    dependencies {\n        freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n    }\n\n```\n如果需要将依赖作为变量，与flavor和build type进行结合，要在`configurations`代码块中进行初始化。\n```java\n    configurations {\n        //初始化只与freeDebugRuntimeOnly相关的依赖\n        freeDebugRuntimeOnly {}\n    }\n\n    dependencies {\n        freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n```\n\n\n### 在Debug模式下使用正式签名\n\n在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错`ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.`\n\n```java\n\n    android{\n           ...\n        signingConfigs {\n            release {\n                //.jks文件放在项目目录（app目录）\n                storeFile file(\"app.jks\")//签名文件名\n                storePassword \"password\"//密码\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"//密码\n                }\n\n            debug {\n                storeFile file(\"app.jks\")\n                storePassword\"password\"\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"\n            }\n        }   \n           \n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n                signingConfig signingConfigs.release\n            }\n            debug {\n            signingConfig signingConfigs.release\n            }\n        }\n\n       ....\n    }\n```\n\n### 加速项目的构建速度\n\n#### 优化项目配置\n有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个`dev`flavor和`prod`flavor(发布版本)。\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n  productFlavors {\n    //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；\n    dev {\n      \n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n    }\n\n    prod {\n      // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。\n      \n    }\n  }\n}\n\n```\n\n可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出`devDemo`和`prodFull`\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n\n  // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度\n  flavorDimensions \"stage\", \"mode\"\n\n  productFlavors {\n    dev {\n      dimension \"stage\"\n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n      \n      //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片\n      resConfigs \"en\", \"xxhdpi\"\n      ...\n    }\n\n    prod {\n      dimension \"stage\"\n      ...\n    }\n\n    demo {\n      dimension \"mode\"\n      ...\n    }\n\n    full {\n      dimension \"mode\"\n      ...\n    }\n  }\n}\n\n```\n#### 编译类型配置\n\n```java\n    android {\n      ...\n      buildTypes {\n        debug {\n          //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`\n          ext.enableCrashlytics = false\n          //防止Crashlytics 每次更新编译的id\n          ext.alwaysUpdateBuildId = false\n        }\n}\n\n```\n#### 在Debug版本构建的过程中使用静态常量\n在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。\n\n```java\n\nint MILLIS_IN_MINUTE = 1000 * 60\nint minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE\n\nandroid {\n    ...\n    defaultConfig {\n  \n        //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk\n        versionCode 1\n        versionName \"1.0\"\n        ...\n    }\n\n    //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。\n    //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理\n    applicationVariants.all { variant ->\n        if (variant.buildType.name == \"release\") {\n            variant.mergedFlavor.versionCode = minutesSinceEpoch;\n            variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName;\n        }\n    }\n}\n\n```\n\n#### 使用增量注解处理（incremental annotation processors）\nAndroid Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。\n\n```xml\n     android.enableSeparateAnnotationProcessing = true\n```\n\n\n#### 其他方式\n\n* 使用确定的依赖，避免使用`+`，如：'com.android.tools.build:gradle:2.+'\n* 使用离线模式进行编译\n* 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。\n* 创建自定义编译任务\n* 将图片转换为WebP\n   \n   WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。\n* 禁用PNG压缩\n\n  ```java\n  \n  android {\n    buildTypes {\n        release {\n            //禁用PNG压缩\n            crunchPngs false\n        }\n    }\n\n    // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩\n    //  aaptOptions {\n    //      cruncherEnabled false\n    //  }\n}\n  ```\n  \n* 使用编译缓存\n在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，`clean build`会变得更快，因为其会调用缓存中的文件，而非重新生成。\n在gradle.gradle.properties 中指定编译缓存的路径，默认路径为`<user-home>/.android/build-cache/`\n\n```xml\n    // 执行绝对路径或者相对路径\n    android.buildCacheDir=<path-to-directory>\n    android.enableBuildCache=true\n```\n\n#### 打包编译多个版本的apk\n\n1、packageName和applicationId\n\n* build.gradle可以通过applicationId修改应用的包名，但是BuildConfig的类名不会发生变化；\n* build.gradle可以通过buildConfigField给BuildConfig添加属性，用于用于代码配置，每个module的BuildConfig只能获取自己的module的配置\n* buildConfig的包名由manifest.xml中的包名决定，而非applicationId决定\n* manifest.xml中的package名称和applicationId不一致出现问题：某些框架在初始化通过反射获取BuildConfig配置信息，如果没有传入包名，其会根据context.getPackageName()拼接BuildConfig字段反射获取，这个时候获取到的packageName是applicationId的值，会抛出异常。\n\n\n\n\n","source":"_posts/Android/Other/Module的.gradle配置.md","raw":"---\ntitle: gradle介绍\ncover: /cover/img17.jpg\ntoc: true\ndescription: gradle介绍\ntype: [Android]\ncategories: Android\ndate: 2019/08/10\n---\n\n### gradle介绍\n\ngradle和make以及ant不同，它基于Groovy语言，而非一种配置；\n\nGradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，\n\n<!--more-->\n\n#### 在Moudle的build.gradle中添加依赖包\n\n```java\n    android { ... }\n\n    dependencies {\n        // 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`\n        implementation project(\":mylibrary\")\n\n        // 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 \n        implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n        // 依赖于远程库\n        implementation 'com.example.android:app-magic:12.3'\n    }\n\n```\n\n依赖包的配置有以下类型：`implementation`、`api`、`compileOnly`、`runtimeOnly`、`annotationProcessor`、`lintChecks`、`lintPublish`\n在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。\n\n```java\n    dependencies {\n        freeImplementation 'com.google.firebase:firebase-ads:9.8.0'\n    }\n\n```\n如果需要将依赖作为变量，与flavor和build type进行结合，要在`configurations`代码块中进行初始化。\n```java\n    configurations {\n        //初始化只与freeDebugRuntimeOnly相关的依赖\n        freeDebugRuntimeOnly {}\n    }\n\n    dependencies {\n        freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n```\n\n\n### 在Debug模式下使用正式签名\n\n在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错`ERROR: Could not get unknown property 'release' for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.`\n\n```java\n\n    android{\n           ...\n        signingConfigs {\n            release {\n                //.jks文件放在项目目录（app目录）\n                storeFile file(\"app.jks\")//签名文件名\n                storePassword \"password\"//密码\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"//密码\n                }\n\n            debug {\n                storeFile file(\"app.jks\")\n                storePassword\"password\"\n                keyAlias\"key0\"//别名\n                keyPassword\"password\"\n            }\n        }   \n           \n        buildTypes {\n            release {\n                minifyEnabled false\n                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n                signingConfig signingConfigs.release\n            }\n            debug {\n            signingConfig signingConfigs.release\n            }\n        }\n\n       ....\n    }\n```\n\n### 加速项目的构建速度\n\n#### 优化项目配置\n有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个`dev`flavor和`prod`flavor(发布版本)。\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n  productFlavors {\n    //当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；\n    dev {\n      \n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n    }\n\n    prod {\n      // 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。\n      \n    }\n  }\n}\n\n```\n\n可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出`devDemo`和`prodFull`\n\n```java\n\nandroid {\n  ...\n  defaultConfig {...}\n  buildTypes {...}\n\n  // 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度\n  flavorDimensions \"stage\", \"mode\"\n\n  productFlavors {\n    dev {\n      dimension \"stage\"\n      minSdkVersion 21\n      versionNameSuffix \"-dev\"\n      applicationIdSuffix '.dev'\n      \n      //可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片\n      resConfigs \"en\", \"xxhdpi\"\n      ...\n    }\n\n    prod {\n      dimension \"stage\"\n      ...\n    }\n\n    demo {\n      dimension \"mode\"\n      ...\n    }\n\n    full {\n      dimension \"mode\"\n      ...\n    }\n  }\n}\n\n```\n#### 编译类型配置\n\n```java\n    android {\n      ...\n      buildTypes {\n        debug {\n          //如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`\n          ext.enableCrashlytics = false\n          //防止Crashlytics 每次更新编译的id\n          ext.alwaysUpdateBuildId = false\n        }\n}\n\n```\n#### 在Debug版本构建的过程中使用静态常量\n在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。\n\n```java\n\nint MILLIS_IN_MINUTE = 1000 * 60\nint minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE\n\nandroid {\n    ...\n    defaultConfig {\n  \n        //如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk\n        versionCode 1\n        versionName \"1.0\"\n        ...\n    }\n\n    //进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。\n    //下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理\n    applicationVariants.all { variant ->\n        if (variant.buildType.name == \"release\") {\n            variant.mergedFlavor.versionCode = minutesSinceEpoch;\n            variant.mergedFlavor.versionName = minutesSinceEpoch + \"-\" + variant.flavorName;\n        }\n    }\n}\n\n```\n\n#### 使用增量注解处理（incremental annotation processors）\nAndroid Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。\n\n```xml\n     android.enableSeparateAnnotationProcessing = true\n```\n\n\n#### 其他方式\n\n* 使用确定的依赖，避免使用`+`，如：'com.android.tools.build:gradle:2.+'\n* 使用离线模式进行编译\n* 创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。\n* 创建自定义编译任务\n* 将图片转换为WebP\n   \n   WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。\n* 禁用PNG压缩\n\n  ```java\n  \n  android {\n    buildTypes {\n        release {\n            //禁用PNG压缩\n            crunchPngs false\n        }\n    }\n\n    // 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩\n    //  aaptOptions {\n    //      cruncherEnabled false\n    //  }\n}\n  ```\n  \n* 使用编译缓存\n在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，`clean build`会变得更快，因为其会调用缓存中的文件，而非重新生成。\n在gradle.gradle.properties 中指定编译缓存的路径，默认路径为`<user-home>/.android/build-cache/`\n\n```xml\n    // 执行绝对路径或者相对路径\n    android.buildCacheDir=<path-to-directory>\n    android.enableBuildCache=true\n```\n\n#### 打包编译多个版本的apk\n\n1、packageName和applicationId\n\n* build.gradle可以通过applicationId修改应用的包名，但是BuildConfig的类名不会发生变化；\n* build.gradle可以通过buildConfigField给BuildConfig添加属性，用于用于代码配置，每个module的BuildConfig只能获取自己的module的配置\n* buildConfig的包名由manifest.xml中的包名决定，而非applicationId决定\n* manifest.xml中的package名称和applicationId不一致出现问题：某些框架在初始化通过反射获取BuildConfig配置信息，如果没有传入包名，其会根据context.getPackageName()拼接BuildConfig字段反射获取，这个时候获取到的packageName是applicationId的值，会抛出异常。\n\n\n\n\n","slug":"Android/Other/Module的.gradle配置","published":1,"updated":"2021-01-05T12:14:03.966Z","_id":"ckjju0m0x002p20ua0ffd009r","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h3><p>gradle和make以及ant不同，它基于Groovy语言，而非一种配置；</p>\n<p>Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，</p>\n<a id=\"more\"></a>\n\n<h4 id=\"在Moudle的build-gradle中添加依赖包\"><a href=\"#在Moudle的build-gradle中添加依赖包\" class=\"headerlink\" title=\"在Moudle的build.gradle中添加依赖包\"></a>在Moudle的build.gradle中添加依赖包</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`</span></span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&quot;:mylibrary&quot;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 </span></span></span><br><span class=\"line\"><span class=\"function\">    implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于远程库</span></span></span><br><span class=\"line\"><span class=\"function\">    implementation &#x27;com.example.android:app-magic:12.3&#x27;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br></pre></td></tr></table></figure>\n<p>依赖包的配置有以下类型：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code>、<code>annotationProcessor</code>、<code>lintChecks</code>、<code>lintPublish</code><br>在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    freeImplementation <span class=\"string\">&#x27;com.google.firebase:firebase-ads:9.8.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果需要将依赖作为变量，与flavor和build type进行结合，要在<code>configurations</code>代码块中进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化只与freeDebugRuntimeOnly相关的依赖</span></span><br><span class=\"line\">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">freeDebugRuntimeOnly <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在Debug模式下使用正式签名\"><a href=\"#在Debug模式下使用正式签名\" class=\"headerlink\" title=\"在Debug模式下使用正式签名\"></a>在Debug模式下使用正式签名</h3><p>在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错<code>ERROR: Could not get unknown property &#39;release&#39; for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//.jks文件放在项目目录（app目录）</span></span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">&quot;app.jks&quot;</span>)</span><span class=\"comment\">//签名文件名</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword &quot;password&quot;<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            keyAlias&quot;key0&quot;<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword&quot;password&quot;<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">&quot;app.jks&quot;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword&quot;password&quot;</span></span><br><span class=\"line\"><span class=\"function\">            keyAlias&quot;key0&quot;<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword&quot;password&quot;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;   </span></span><br><span class=\"line\"><span class=\"function\">       </span></span><br><span class=\"line\"><span class=\"function\">    buildTypes </span>&#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">&#x27;proguard-android.txt&#x27;</span>)</span>, &#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\"><span class=\"function\">            signingConfig signingConfigs.release</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">        signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"加速项目的构建速度\"><a href=\"#加速项目的构建速度\" class=\"headerlink\" title=\"加速项目的构建速度\"></a>加速项目的构建速度</h3><h4 id=\"优化项目配置\"><a href=\"#优化项目配置\" class=\"headerlink\" title=\"优化项目配置\"></a>优化项目配置</h4><p>有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个<code>dev</code>flavor和<code>prod</code>flavor(发布版本)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；</span></span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">&quot;-dev&quot;</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">&#x27;.dev&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出<code>devDemo</code>和<code>prodFull</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度</span></span><br><span class=\"line\">  flavorDimensions <span class=\"string\">&quot;stage&quot;</span>, <span class=\"string\">&quot;mode&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;stage&quot;</span></span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">&quot;-dev&quot;</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">&#x27;.dev&#x27;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片</span></span><br><span class=\"line\">      resConfigs <span class=\"string\">&quot;en&quot;</span>, <span class=\"string\">&quot;xxhdpi&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;stage&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    demo &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;mode&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    full &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;mode&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"编译类型配置\"><a href=\"#编译类型配置\" class=\"headerlink\" title=\"编译类型配置\"></a>编译类型配置</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    android &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      buildTypes &#123;</span><br><span class=\"line\">        debug &#123;</span><br><span class=\"line\">          <span class=\"comment\">//如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`</span></span><br><span class=\"line\">          ext.enableCrashlytics = <span class=\"keyword\">false</span></span><br><span class=\"line\">          <span class=\"comment\">//防止Crashlytics 每次更新编译的id</span></span><br><span class=\"line\">          ext.alwaysUpdateBuildId = <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在Debug版本构建的过程中使用静态常量\"><a href=\"#在Debug版本构建的过程中使用静态常量\" class=\"headerlink\" title=\"在Debug版本构建的过程中使用静态常量\"></a>在Debug版本构建的过程中使用静态常量</h4><p>在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MILLIS_IN_MINUTE = <span class=\"number\">1000</span> * <span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理</span></span><br><span class=\"line\">    applicationVariants.all &#123; variant -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variant.buildType.name == <span class=\"string\">&quot;release&quot;</span>) &#123;</span><br><span class=\"line\">            variant.mergedFlavor.versionCode = minutesSinceEpoch;</span><br><span class=\"line\">            variant.mergedFlavor.versionName = minutesSinceEpoch + <span class=\"string\">&quot;-&quot;</span> + variant.flavorName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用增量注解处理（incremental-annotation-processors）\"><a href=\"#使用增量注解处理（incremental-annotation-processors）\" class=\"headerlink\" title=\"使用增量注解处理（incremental annotation processors）\"></a>使用增量注解处理（incremental annotation processors）</h4><p>Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.enableSeparateAnnotationProcessing = true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h4><ul>\n<li><p>使用确定的依赖，避免使用<code>+</code>，如：’com.android.tools.build:gradle:2.+’</p>\n</li>\n<li><p>使用离线模式进行编译</p>\n</li>\n<li><p>创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。</p>\n</li>\n<li><p>创建自定义编译任务</p>\n</li>\n<li><p>将图片转换为WebP</p>\n<p> WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。</p>\n</li>\n<li><p>禁用PNG压缩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//禁用PNG压缩</span></span><br><span class=\"line\">            crunchPngs <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩</span></span><br><span class=\"line\">    <span class=\"comment\">//  aaptOptions &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      cruncherEnabled false</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用编译缓存<br>在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，<code>clean build</code>会变得更快，因为其会调用缓存中的文件，而非重新生成。<br>在gradle.gradle.properties 中指定编译缓存的路径，默认路径为<code>&lt;user-home&gt;/.android/build-cache/</code></p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 执行绝对路径或者相对路径</span><br><span class=\"line\">android.buildCacheDir=<span class=\"tag\">&lt;<span class=\"name\">path-to-directory</span>&gt;</span></span><br><span class=\"line\">android.enableBuildCache=true</span><br></pre></td></tr></table></figure>\n<h4 id=\"打包编译多个版本的apk\"><a href=\"#打包编译多个版本的apk\" class=\"headerlink\" title=\"打包编译多个版本的apk\"></a>打包编译多个版本的apk</h4><p>1、packageName和applicationId</p>\n<ul>\n<li>build.gradle可以通过applicationId修改应用的包名，但是BuildConfig的类名不会发生变化；</li>\n<li>build.gradle可以通过buildConfigField给BuildConfig添加属性，用于用于代码配置，每个module的BuildConfig只能获取自己的module的配置</li>\n<li>buildConfig的包名由manifest.xml中的包名决定，而非applicationId决定</li>\n<li>manifest.xml中的package名称和applicationId不一致出现问题：某些框架在初始化通过反射获取BuildConfig配置信息，如果没有传入包名，其会根据context.getPackageName()拼接BuildConfig字段反射获取，这个时候获取到的packageName是applicationId的值，会抛出异常。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h3><p>gradle和make以及ant不同，它基于Groovy语言，而非一种配置；</p>\n<p>Gradle是一个自动化构建的开源工具，使用基于Groovy的领域专用语言(domain specific language (DSL))，来替代使用xml文件对工程的配置。其支持增量编译，可以使用cache，</p>","more":"<h4 id=\"在Moudle的build-gradle中添加依赖包\"><a href=\"#在Moudle的build-gradle中添加依赖包\" class=\"headerlink\" title=\"在Moudle的build.gradle中添加依赖包\"></a>在Moudle的build.gradle中添加依赖包</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖于本地模块，在添加本地模块依赖时，需要在`settings.gradle`文件中添加`include:mylibrary`</span></span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&quot;:mylibrary&quot;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于本地库,需要将jar文件添加至 `module_name/libs/`文件夹中 </span></span></span><br><span class=\"line\"><span class=\"function\">    implementation <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 依赖于远程库</span></span></span><br><span class=\"line\"><span class=\"function\">    implementation &#x27;com.example.android:app-magic:12.3&#x27;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br></pre></td></tr></table></figure>\n<p>依赖包的配置有以下类型：<code>implementation</code>、<code>api</code>、<code>compileOnly</code>、<code>runtimeOnly</code>、<code>annotationProcessor</code>、<code>lintChecks</code>、<code>lintPublish</code><br>在上述配置中，会将所有的依赖在构建的时候进行打包；如果需要将特定的依赖打包到特定的版本中，需要在依赖配置前添加响应的前缀,下述依赖只会打包到falvor为free的生成包中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    freeImplementation <span class=\"string\">&#x27;com.google.firebase:firebase-ads:9.8.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果需要将依赖作为变量，与flavor和build type进行结合，要在<code>configurations</code>代码块中进行初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations &#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化只与freeDebugRuntimeOnly相关的依赖</span></span><br><span class=\"line\">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">freeDebugRuntimeOnly <span class=\"title\">fileTree</span><span class=\"params\">(dir: <span class=\"string\">&#x27;libs&#x27;</span>, include: [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在Debug模式下使用正式签名\"><a href=\"#在Debug模式下使用正式签名\" class=\"headerlink\" title=\"在Debug模式下使用正式签名\"></a>在Debug模式下使用正式签名</h3><p>在moudle.gradle进行配置,signingConfigs配置需要在buildTypes配置之后,否则会报错<code>ERROR: Could not get unknown property &#39;release&#39; for SigningConfig container of type org.gradle.api.internal.FactoryNamedDomainObjectContainer.</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    signingConfigs &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//.jks文件放在项目目录（app目录）</span></span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">&quot;app.jks&quot;</span>)</span><span class=\"comment\">//签名文件名</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword &quot;password&quot;<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            keyAlias&quot;key0&quot;<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword&quot;password&quot;<span class=\"comment\">//密码</span></span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">            <span class=\"function\">storeFile <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">&quot;app.jks&quot;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">            storePassword&quot;password&quot;</span></span><br><span class=\"line\"><span class=\"function\">            keyAlias&quot;key0&quot;<span class=\"comment\">//别名</span></span></span><br><span class=\"line\"><span class=\"function\">            keyPassword&quot;password&quot;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;   </span></span><br><span class=\"line\"><span class=\"function\">       </span></span><br><span class=\"line\"><span class=\"function\">    buildTypes </span>&#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">&#x27;proguard-android.txt&#x27;</span>)</span>, &#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\"><span class=\"function\">            signingConfig signingConfigs.release</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        debug </span>&#123;</span><br><span class=\"line\">        signingConfig signingConfigs.release</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"加速项目的构建速度\"><a href=\"#加速项目的构建速度\" class=\"headerlink\" title=\"加速项目的构建速度\"></a>加速项目的构建速度</h3><h4 id=\"优化项目配置\"><a href=\"#优化项目配置\" class=\"headerlink\" title=\"优化项目配置\"></a>优化项目配置</h4><p>有一些打包的配置，在进行开发的过程中不需要，这些不需要的配置会拖慢增量编译，以及clean up的速度；我们可以配置仅在打包的时候进行使用的编译变量，下述示例是创建一个<code>dev</code>flavor和<code>prod</code>flavor(发布版本)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当在构件时使用下述flavor，则会覆盖`defaultConfig`代码块；</span></span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">&quot;-dev&quot;</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">&#x27;.dev&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果使用默认配置发布版本，则这一代码块可以设置为空，但不能省略`prob`，否则所有的编译版本都会使用`dev`中的配置。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以使用flavor维度设置，可以创建出组合的flavor；如下述示例中创建出<code>devDemo</code>和<code>prodFull</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  defaultConfig &#123;...&#125;</span><br><span class=\"line\">  buildTypes &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要使用的flavor dimensions，定义的顺序就是它们从高到底的优先级；使用flavor维度后，需要在每一项flavor配置中定义指定维度</span></span><br><span class=\"line\">  flavorDimensions <span class=\"string\">&quot;stage&quot;</span>, <span class=\"string\">&quot;mode&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  productFlavors &#123;</span><br><span class=\"line\">    dev &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;stage&quot;</span></span><br><span class=\"line\">      minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">      versionNameSuffix <span class=\"string\">&quot;-dev&quot;</span></span><br><span class=\"line\">      applicationIdSuffix <span class=\"string\">&#x27;.dev&#x27;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//可以通过配置`resConfigs`仅配置英文，以及`xxhdpi`尺寸的图片</span></span><br><span class=\"line\">      resConfigs <span class=\"string\">&quot;en&quot;</span>, <span class=\"string\">&quot;xxhdpi&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prod &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;stage&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    demo &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;mode&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    full &#123;</span><br><span class=\"line\">      dimension <span class=\"string\">&quot;mode&quot;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"编译类型配置\"><a href=\"#编译类型配置\" class=\"headerlink\" title=\"编译类型配置\"></a>编译类型配置</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    android &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      buildTypes &#123;</span><br><span class=\"line\">        debug &#123;</span><br><span class=\"line\">          <span class=\"comment\">//如果不需要Crashlytics 报告可以设置为`diable`加快编译速度`</span></span><br><span class=\"line\">          ext.enableCrashlytics = <span class=\"keyword\">false</span></span><br><span class=\"line\">          <span class=\"comment\">//防止Crashlytics 每次更新编译的id</span></span><br><span class=\"line\">          ext.alwaysUpdateBuildId = <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在Debug版本构建的过程中使用静态常量\"><a href=\"#在Debug版本构建的过程中使用静态常量\" class=\"headerlink\" title=\"在Debug版本构建的过程中使用静态常量\"></a>在Debug版本构建的过程中使用静态常量</h4><p>在Debug版本中总是使用静态常量，或者硬编码的方式进行编译。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MILLIS_IN_MINUTE = <span class=\"number\">1000</span> * <span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minutesSinceEpoch = System.currentTimeMillis() / MILLIS_IN_MINUTE</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//如果将下述两个值设置为动态的，会在`AndroidManifest.xml`的影响下进行更新，编译出完整版本apk</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//进行上述默认配置后，在进行增量变异的时候不需要重新构建`manifest`，重新构建会导致构建完整apk，拖慢构建速度。</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的语句会在构建的时候遍历`buildType.name`并进行相应的处理</span></span><br><span class=\"line\">    applicationVariants.all &#123; variant -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (variant.buildType.name == <span class=\"string\">&quot;release&quot;</span>) &#123;</span><br><span class=\"line\">            variant.mergedFlavor.versionCode = minutesSinceEpoch;</span><br><span class=\"line\">            variant.mergedFlavor.versionName = minutesSinceEpoch + <span class=\"string\">&quot;-&quot;</span> + variant.flavorName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用增量注解处理（incremental-annotation-processors）\"><a href=\"#使用增量注解处理（incremental-annotation-processors）\" class=\"headerlink\" title=\"使用增量注解处理（incremental annotation processors）\"></a>使用增量注解处理（incremental annotation processors）</h4><p>Android Studio的Gradle插件版本高于3.3.0支持增量注解处理，如果您使用一个或多个不支持增量编译的注解处理器，则增量 Java 编译不会启用。如果需要使用不支持此优化的注解处理器，可以再 gradle.properties 文件中添加以下标记。添加后，Android Gradle 插件会在一个单独的任务中执行所有注解处理器，并允许 Java 编译任务以增量方式运行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android.enableSeparateAnnotationProcessing = true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h4><ul>\n<li><p>使用确定的依赖，避免使用<code>+</code>，如：’com.android.tools.build:gradle:2.+’</p>\n</li>\n<li><p>使用离线模式进行编译</p>\n</li>\n<li><p>创建library modules，使用这种方式，该模块可以编译输出至缓存中，仅在模块编辑后才会重新编译。</p>\n</li>\n<li><p>创建自定义编译任务</p>\n</li>\n<li><p>将图片转换为WebP</p>\n<p> WebP可以像PNG一样透明，使用与JPEG一样是有损压缩，但比JPG和JPEG压缩更优秀。重新更改图片的尺寸，而非在编译时压缩可以加快编译速度。可以使用Android Studio进行图片的转换。</p>\n</li>\n<li><p>禁用PNG压缩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">  android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            <span class=\"comment\">//禁用PNG压缩</span></span><br><span class=\"line\">            crunchPngs <span class=\"keyword\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果使用的gradle插件版本小于3.0.0，使用下述方式禁用PNG压缩</span></span><br><span class=\"line\">    <span class=\"comment\">//  aaptOptions &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      cruncherEnabled false</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用编译缓存<br>在编译缓存中会保存Gradle插件在编译过程中的输出（如：未打包的AAR文件，提前下载的远程库），当使用编译缓存，<code>clean build</code>会变得更快，因为其会调用缓存中的文件，而非重新生成。<br>在gradle.gradle.properties 中指定编译缓存的路径，默认路径为<code>&lt;user-home&gt;/.android/build-cache/</code></p>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 执行绝对路径或者相对路径</span><br><span class=\"line\">android.buildCacheDir=<span class=\"tag\">&lt;<span class=\"name\">path-to-directory</span>&gt;</span></span><br><span class=\"line\">android.enableBuildCache=true</span><br></pre></td></tr></table></figure>\n<h4 id=\"打包编译多个版本的apk\"><a href=\"#打包编译多个版本的apk\" class=\"headerlink\" title=\"打包编译多个版本的apk\"></a>打包编译多个版本的apk</h4><p>1、packageName和applicationId</p>\n<ul>\n<li>build.gradle可以通过applicationId修改应用的包名，但是BuildConfig的类名不会发生变化；</li>\n<li>build.gradle可以通过buildConfigField给BuildConfig添加属性，用于用于代码配置，每个module的BuildConfig只能获取自己的module的配置</li>\n<li>buildConfig的包名由manifest.xml中的包名决定，而非applicationId决定</li>\n<li>manifest.xml中的package名称和applicationId不一致出现问题：某些框架在初始化通过反射获取BuildConfig配置信息，如果没有传入包名，其会根据context.getPackageName()拼接BuildConfig字段反射获取，这个时候获取到的packageName是applicationId的值，会抛出异常。</li>\n</ul>"},{"title":"Android开发常用操作","cover":"/cover/img18.jpg","toc":true,"description":"Android开发常用操作","type":["Android"],"date":"2019-08-14T16:00:00.000Z","_content":"\n### 查看签名文件信息\n\n密码是password\n\n```\n    keytool -list -v -keystore application.jks -storepass password\n```\n<!--more-->","source":"_posts/Android/Other/常用操作.md","raw":"---\ntitle: Android开发常用操作\ncover: /cover/img18.jpg\ntoc: true\ndescription: Android开发常用操作\ntype: [Android]\ncategories: Android\ndate: 2019/08/15\n---\n\n### 查看签名文件信息\n\n密码是password\n\n```\n    keytool -list -v -keystore application.jks -storepass password\n```\n<!--more-->","slug":"Android/Other/常用操作","published":1,"updated":"2021-01-05T12:14:06.410Z","_id":"ckjju0m0y002t20ua3wbf3es3","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"查看签名文件信息\"><a href=\"#查看签名文件信息\" class=\"headerlink\" title=\"查看签名文件信息\"></a>查看签名文件信息</h3><p>密码是password</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -v -keystore application.jks -storepass password</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<h3 id=\"查看签名文件信息\"><a href=\"#查看签名文件信息\" class=\"headerlink\" title=\"查看签名文件信息\"></a>查看签名文件信息</h3><p>密码是password</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keytool -list -v -keystore application.jks -storepass password</span><br></pre></td></tr></table></figure>","more":""},{"title":"Android 6.0及以上手机权限进行动态获取","cover":"/cover/img8.jpg","toc":true,"type":["Android"],"date":"2019-09-18T16:00:00.000Z","_content":"\n\n## 在Android 6.0及以上需要对手机权限进行动态获取\n\n如果手机版本为Android 6.0(API 23)或更高版本，以及app的`targetSdkVersion`为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。\n\n<!--more-->\n\n**同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。** *同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如`Manifest.permission.BLUETOOTH`在动态申请时同样不会出现权限申请对话框，但会回调*\n< !--more-->\nAndroid动态权限的申请仅对下图中的9大权限组进行申请\n![](/public/img/Android/android_basis_permission.png)\n\n### 一、对于可选硬件功能权限的获取\n\n使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加`<uses-feature> `\n```html\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n```\n当声明为`android:required=\"false\"`时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要`PackageManager.hasSystemFeature()`来确定该设备是否存在；当声明为`android:required=\"true\"`时，需要手机上具有该设备，否则不能进行安装操作。\n\n### 二、代码实现\n\n```java\n\n    String[] permissions = {Manifest.permission.BLUETOOTH};\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //只有系统API大于23时，才需要判断权限是否需要获取\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            //用于判断权限是否已经获取\n            int i = ContextCompat.checkSelfPermission(this, permissions[0]);\n            //权限是否已经获取 GRANTED--授权 DINED--拒绝\n            if (i != PackageManager.PERMISSION_GRANTED) {\n                //如果没有被授予该权限，提示用户请求该权限\n                ActivityCompat.requestPermissions(this, permissions, 1);\n            }else {\n                Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                           @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode==1){\n            //未获取到权限\n            if (grantResults[0] != PackageManager.PERMISSION_GRANTED) {\n                //判断用户是否点击了不再提醒；检测该权限是否还可以再申请\n                boolean result = this.shouldShowRequestPermissionRationale(permissions[0]);\n                //如果不可以再申请\n                if (!result) {\n                    //用户需要继续使用App\n                    //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示\n                    LogUtils.printInfo(\"请到设置界面开启相应权限\");\n                }else {\n                    //如果可以再申请\n                    Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show();\n                }\n            }\n        }\n    }\n```\n\n### 三、连续多次申请权限出现问题\n在进行连续多次申请时，在回调函数`onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)`的`permissions`数组会返回长度为零的数组，因为在Activity的`requestPermissions()`方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行`onRequestPermissionsResult`方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；\n\n```java\n    //Activity源码\n    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {\n        //省略部分代码\n        if (mHasCurrentPermissionsRequest) {\n            Log.w(TAG, \"Can request only one set of permissions at a time\");\n            // Dispatch the callback with empty arrays which means a cancellation.\n            onRequestPermissionsResult(requestCode, new String[0], new int[0]);\n            return;\n        }\n        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);\n        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);\n        mHasCurrentPermissionsRequest = true;\n    }\n```\n\n\n### 四、其他\n\n有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。\n```xml\n\n```\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Android 6.0动态权限获取.md","raw":"---\ntitle: Android 6.0及以上手机权限进行动态获取\ncover: /cover/img8.jpg\ntoc: true\ncategories: Android\ntype: [Android]\ndate: 2019/09/19\n---\n\n\n## 在Android 6.0及以上需要对手机权限进行动态获取\n\n如果手机版本为Android 6.0(API 23)或更高版本，以及app的`targetSdkVersion`为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。\n\n<!--more-->\n\n**同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。** *同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如`Manifest.permission.BLUETOOTH`在动态申请时同样不会出现权限申请对话框，但会回调*\n< !--more-->\nAndroid动态权限的申请仅对下图中的9大权限组进行申请\n![](/public/img/Android/android_basis_permission.png)\n\n### 一、对于可选硬件功能权限的获取\n\n使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加`<uses-feature> `\n```html\n<uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n```\n当声明为`android:required=\"false\"`时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要`PackageManager.hasSystemFeature()`来确定该设备是否存在；当声明为`android:required=\"true\"`时，需要手机上具有该设备，否则不能进行安装操作。\n\n### 二、代码实现\n\n```java\n\n    String[] permissions = {Manifest.permission.BLUETOOTH};\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //只有系统API大于23时，才需要判断权限是否需要获取\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            //用于判断权限是否已经获取\n            int i = ContextCompat.checkSelfPermission(this, permissions[0]);\n            //权限是否已经获取 GRANTED--授权 DINED--拒绝\n            if (i != PackageManager.PERMISSION_GRANTED) {\n                //如果没有被授予该权限，提示用户请求该权限\n                ActivityCompat.requestPermissions(this, permissions, 1);\n            }else {\n                Toast.makeText(this,\"权限已获取\",Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                           @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode==1){\n            //未获取到权限\n            if (grantResults[0] != PackageManager.PERMISSION_GRANTED) {\n                //判断用户是否点击了不再提醒；检测该权限是否还可以再申请\n                boolean result = this.shouldShowRequestPermissionRationale(permissions[0]);\n                //如果不可以再申请\n                if (!result) {\n                    //用户需要继续使用App\n                    //提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示\n                    LogUtils.printInfo(\"请到设置界面开启相应权限\");\n                }else {\n                    //如果可以再申请\n                    Toast.makeText(this,\"请开启权限权限\",Toast.LENGTH_LONG).show();\n                }\n            }\n        }\n    }\n```\n\n### 三、连续多次申请权限出现问题\n在进行连续多次申请时，在回调函数`onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)`的`permissions`数组会返回长度为零的数组，因为在Activity的`requestPermissions()`方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行`onRequestPermissionsResult`方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；\n\n```java\n    //Activity源码\n    public final void requestPermissions(@NonNull String[] permissions, int requestCode) {\n        //省略部分代码\n        if (mHasCurrentPermissionsRequest) {\n            Log.w(TAG, \"Can request only one set of permissions at a time\");\n            // Dispatch the callback with empty arrays which means a cancellation.\n            onRequestPermissionsResult(requestCode, new String[0], new int[0]);\n            return;\n        }\n        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);\n        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);\n        mHasCurrentPermissionsRequest = true;\n    }\n```\n\n\n### 四、其他\n\n有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。\n```xml\n\n```\n\n\n\n\n\n\n\n\n","slug":"Android/Android基础/Android 6.0动态权限获取","published":1,"updated":"2021-01-05T12:13:48.423Z","_id":"ckjju0m0y002v20ua1pglgl0t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"在Android-6-0及以上需要对手机权限进行动态获取\"><a href=\"#在Android-6-0及以上需要对手机权限进行动态获取\" class=\"headerlink\" title=\"在Android 6.0及以上需要对手机权限进行动态获取\"></a>在Android 6.0及以上需要对手机权限进行动态获取</h2><p>如果手机版本为Android 6.0(API 23)或更高版本，以及app的<code>targetSdkVersion</code>为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。</p>\n<a id=\"more\"></a>\n\n<p><strong>同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。</strong> <em>同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如<code>Manifest.permission.BLUETOOTH</code>在动态申请时同样不会出现权限申请对话框，但会回调</em><br>&lt; !–more–&gt;<br>Android动态权限的申请仅对下图中的9大权限组进行申请<br><img src=\"/public/img/Android/android_basis_permission.png\"></p>\n<h3 id=\"一、对于可选硬件功能权限的获取\"><a href=\"#一、对于可选硬件功能权限的获取\" class=\"headerlink\" title=\"一、对于可选硬件功能权限的获取\"></a>一、对于可选硬件功能权限的获取</h3><p>使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加<code>&lt;uses-feature&gt; </code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-feature</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.hardware.camera&quot;</span> <span class=\"attr\">android:required</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当声明为<code>android:required=&quot;false&quot;</code>时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要<code>PackageManager.hasSystemFeature()</code>来确定该设备是否存在；当声明为<code>android:required=&quot;true&quot;</code>时，需要手机上具有该设备，否则不能进行安装操作。</p>\n<h3 id=\"二、代码实现\"><a href=\"#二、代码实现\" class=\"headerlink\" title=\"二、代码实现\"></a>二、代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String[] permissions = &#123;Manifest.permission.BLUETOOTH&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    <span class=\"comment\">//只有系统API大于23时，才需要判断权限是否需要获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断权限是否已经获取</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = ContextCompat.checkSelfPermission(<span class=\"keyword\">this</span>, permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//权限是否已经获取 GRANTED--授权 DINED--拒绝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有被授予该权限，提示用户请求该权限</span></span><br><span class=\"line\">            ActivityCompat.requestPermissions(<span class=\"keyword\">this</span>, permissions, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">&quot;权限已获取&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"meta\">@NonNull</span> String[] permissions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@NonNull</span> <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//未获取到权限</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grantResults[<span class=\"number\">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断用户是否点击了不再提醒；检测该权限是否还可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.shouldShowRequestPermissionRationale(permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//如果不可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用户需要继续使用App</span></span><br><span class=\"line\">                <span class=\"comment\">//提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示</span></span><br><span class=\"line\">                LogUtils.printInfo(<span class=\"string\">&quot;请到设置界面开启相应权限&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果可以再申请</span></span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">&quot;请开启权限权限&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、连续多次申请权限出现问题\"><a href=\"#三、连续多次申请权限出现问题\" class=\"headerlink\" title=\"三、连续多次申请权限出现问题\"></a>三、连续多次申请权限出现问题</h3><p>在进行连续多次申请时，在回调函数<code>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)</code>的<code>permissions</code>数组会返回长度为零的数组，因为在Activity的<code>requestPermissions()</code>方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行<code>onRequestPermissionsResult</code>方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">requestPermissions</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String[] permissions, <span class=\"keyword\">int</span> requestCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Can request only one set of permissions at a time&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class=\"line\">        onRequestPermissionsResult(requestCode, <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class=\"line\">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mHasCurrentPermissionsRequest = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、其他\"><a href=\"#四、其他\" class=\"headerlink\" title=\"四、其他\"></a>四、其他</h3><p>有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"在Android-6-0及以上需要对手机权限进行动态获取\"><a href=\"#在Android-6-0及以上需要对手机权限进行动态获取\" class=\"headerlink\" title=\"在Android 6.0及以上需要对手机权限进行动态获取\"></a>在Android 6.0及以上需要对手机权限进行动态获取</h2><p>如果手机版本为Android 6.0(API 23)或更高版本，以及app的<code>targetSdkVersion</code>为23或者更高，用户在安装的时候未被提示权限获取，则用户在使用应用的时候需要动态获取权限。如果在获取用户权限时，用户选择“不再提醒”，则app再次获取权限时，系统将不再对用户进行提示。</p>","more":"<p><strong>同一组权限不用重复授权，即：同一组的权限只要有一个授权了，那么同一组的其他权限也就授权了，前提是在Manifest.xml中有声明。</strong> <em>同一组权限在使用某一个权限申请，而该权限未在Manifest.xml声明，则该权限组不能申请成功，不显示权限申请对话框，但会回调；同时非危险权限如<code>Manifest.permission.BLUETOOTH</code>在动态申请时同样不会出现权限申请对话框，但会回调</em><br>&lt; !–more–&gt;<br>Android动态权限的申请仅对下图中的9大权限组进行申请<br><img src=\"/public/img/Android/android_basis_permission.png\"></p>\n<h3 id=\"一、对于可选硬件功能权限的获取\"><a href=\"#一、对于可选硬件功能权限的获取\" class=\"headerlink\" title=\"一、对于可选硬件功能权限的获取\"></a>一、对于可选硬件功能权限的获取</h3><p>使用蓝牙以及相机等硬件权限时，手机上可以没有蓝牙或者相机设备，因此在获取相机设备权限时，需要添加<code>&lt;uses-feature&gt; </code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-feature</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.hardware.camera&quot;</span> <span class=\"attr\">android:required</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当声明为<code>android:required=&quot;false&quot;</code>时，用户即使没有该设备也可以进行安装，在进行权限申请时则需要<code>PackageManager.hasSystemFeature()</code>来确定该设备是否存在；当声明为<code>android:required=&quot;true&quot;</code>时，需要手机上具有该设备，否则不能进行安装操作。</p>\n<h3 id=\"二、代码实现\"><a href=\"#二、代码实现\" class=\"headerlink\" title=\"二、代码实现\"></a>二、代码实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String[] permissions = &#123;Manifest.permission.BLUETOOTH&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    <span class=\"comment\">//只有系统API大于23时，才需要判断权限是否需要获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于判断权限是否已经获取</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = ContextCompat.checkSelfPermission(<span class=\"keyword\">this</span>, permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//权限是否已经获取 GRANTED--授权 DINED--拒绝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有被授予该权限，提示用户请求该权限</span></span><br><span class=\"line\">            ActivityCompat.requestPermissions(<span class=\"keyword\">this</span>, permissions, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">&quot;权限已获取&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"meta\">@NonNull</span> String[] permissions,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"meta\">@NonNull</span> <span class=\"keyword\">int</span>[] grantResults)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestCode==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//未获取到权限</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grantResults[<span class=\"number\">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断用户是否点击了不再提醒；检测该权限是否还可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.shouldShowRequestPermissionRationale(permissions[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//如果不可以再申请</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//用户需要继续使用App</span></span><br><span class=\"line\">                <span class=\"comment\">//提示用户去应用设置界面手动开启权限，各大厂商权限开启的方法各不相同，需要进行不同厂商适配，因此只给予提示</span></span><br><span class=\"line\">                LogUtils.printInfo(<span class=\"string\">&quot;请到设置界面开启相应权限&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果可以再申请</span></span><br><span class=\"line\">                Toast.makeText(<span class=\"keyword\">this</span>,<span class=\"string\">&quot;请开启权限权限&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、连续多次申请权限出现问题\"><a href=\"#三、连续多次申请权限出现问题\" class=\"headerlink\" title=\"三、连续多次申请权限出现问题\"></a>三、连续多次申请权限出现问题</h3><p>在进行连续多次申请时，在回调函数<code>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,@NonNull int[] grantResults)</code>的<code>permissions</code>数组会返回长度为零的数组，因为在Activity的<code>requestPermissions()</code>方法源码中，mHasCurrentPermissionsRequest标记当前是否有正在请求的权限，方法是异步执行的，如果你在申请权限的时候连续多次执行此方法，会直接执行<code>onRequestPermissionsResult</code>方法，返回的permissions和grantResults都是长度为0的空数组。在返回结果处理时需要对数组长度进行判断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">requestPermissions</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String[] permissions, <span class=\"keyword\">int</span> requestCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class=\"line\">        Log.w(TAG, <span class=\"string\">&quot;Can request only one set of permissions at a time&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class=\"line\">        onRequestPermissionsResult(requestCode, <span class=\"keyword\">new</span> String[<span class=\"number\">0</span>], <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class=\"line\">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    mHasCurrentPermissionsRequest = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、其他\"><a href=\"#四、其他\" class=\"headerlink\" title=\"四、其他\"></a>四、其他</h3><p>有些apk需要系统权限，比如实现关机指令，需要在AndroidMainfest.xml进行声明；用到系统权限的apk，签名必须使用系统签名，否则安装不上。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Android Binder机制介绍","description":"Android Binder机制介绍","type":["Android"],"toc":true,"cover":"/cover/img84.jpg","date":"2017-07-31T16:00:00.000Z","_content":"\n# Andorid Binder机制\n\n## Android Binder介绍\n\nBinder可以实现进程间通信，采用类似于C/S架构的设计模式，性能仅次于共享内存\n<!--more-->\n![](/public/img/Android/android_base_binder2.png)\n\nBinder机制的优点：\n\n1、高效：Binder机制的数据只拷贝一次，而管道、消息队列、Socket都需要两次；通过驱动在内核拷贝数据，不需要额外的同步处理。\n2、安全性高：Binder机制为每个进程分配了UID/PID来作为鉴别身份的标示；在Binder通信时会根据UID/PID进行有效性额检测（传统方式下，对于通信双方的身份没有做出验证）\n3、简单易用：采用C/S架构，以及面向对象的方式进行实现。\n\n\n### Android Binder 组成\n\n![](/public/img/Android/android_base_binder1.png)\n\n1、Server：位于用户空间； 提供服务方，当Server进程向Binder驱动进行注册后，其Binder引用会自动加入到ServiceManager中；\n2、Client：位于用户空间； 需求方\n3、ServiceManager:位于用户空间；作为Servier和Client之间的桥梁，Client可以通过ServiceManager拿到Server中Binder实体的引用；\n4、Binder驱动：位于内核空间；用于进程之间Binder通信实现；连接Service进程、Client进程和Service Manager的桥梁；在实现时采用内存映射的方式进行；\n\n注：\n \n * 用户空间不能进行进程间通信，而内核空间可以进行进程间通信\n * 在Andorid开发中系统服务很多通过Binder进行交互 `context.getSustemService(Context.AUDIO_SERVICE);`\n\n \n### Android Binder机制执行流程\n\n![](/public/img/Android/android_base_binder3.png)\n\n![](/public/img/Android/android_base_binder4.png)\n\n### Linux内核中提供的通信方式\n1、管道通信，性能耗费严重；半双工的方式，数据需要复制两次\n2、共享内存，多个进程可以访问同一块内存空间，内存管理混乱\n3、Socket通信，其主要适合于网络通信\n\n\n### AIDL介绍\n\n1、IBinder： 代表跨进程通信能力的接口，对象只需要实现IBinder就可以跨进程传输\n2、IInterface：代表Server进程提供的功能； 对应AIDL定义的接口；\n3、Binder：代表Binder的本地对象BinderProxy\n4、Stub：继承Binder，实现IInterface\n\n### Android 9.0 中的Binder\n\n","source":"_posts/Android/Android基础/Android Binder机制.md","raw":"---\ntitle: \"Android Binder机制介绍\"\ndescription: \"Android Binder机制介绍\"\ntype: [Android]\ntoc: true\ncover: /cover/img84.jpg\ncategories: Android\ndate: 2017/08/01\n---\n\n# Andorid Binder机制\n\n## Android Binder介绍\n\nBinder可以实现进程间通信，采用类似于C/S架构的设计模式，性能仅次于共享内存\n<!--more-->\n![](/public/img/Android/android_base_binder2.png)\n\nBinder机制的优点：\n\n1、高效：Binder机制的数据只拷贝一次，而管道、消息队列、Socket都需要两次；通过驱动在内核拷贝数据，不需要额外的同步处理。\n2、安全性高：Binder机制为每个进程分配了UID/PID来作为鉴别身份的标示；在Binder通信时会根据UID/PID进行有效性额检测（传统方式下，对于通信双方的身份没有做出验证）\n3、简单易用：采用C/S架构，以及面向对象的方式进行实现。\n\n\n### Android Binder 组成\n\n![](/public/img/Android/android_base_binder1.png)\n\n1、Server：位于用户空间； 提供服务方，当Server进程向Binder驱动进行注册后，其Binder引用会自动加入到ServiceManager中；\n2、Client：位于用户空间； 需求方\n3、ServiceManager:位于用户空间；作为Servier和Client之间的桥梁，Client可以通过ServiceManager拿到Server中Binder实体的引用；\n4、Binder驱动：位于内核空间；用于进程之间Binder通信实现；连接Service进程、Client进程和Service Manager的桥梁；在实现时采用内存映射的方式进行；\n\n注：\n \n * 用户空间不能进行进程间通信，而内核空间可以进行进程间通信\n * 在Andorid开发中系统服务很多通过Binder进行交互 `context.getSustemService(Context.AUDIO_SERVICE);`\n\n \n### Android Binder机制执行流程\n\n![](/public/img/Android/android_base_binder3.png)\n\n![](/public/img/Android/android_base_binder4.png)\n\n### Linux内核中提供的通信方式\n1、管道通信，性能耗费严重；半双工的方式，数据需要复制两次\n2、共享内存，多个进程可以访问同一块内存空间，内存管理混乱\n3、Socket通信，其主要适合于网络通信\n\n\n### AIDL介绍\n\n1、IBinder： 代表跨进程通信能力的接口，对象只需要实现IBinder就可以跨进程传输\n2、IInterface：代表Server进程提供的功能； 对应AIDL定义的接口；\n3、Binder：代表Binder的本地对象BinderProxy\n4、Stub：继承Binder，实现IInterface\n\n### Android 9.0 中的Binder\n\n","slug":"Android/Android基础/Android Binder机制","published":1,"updated":"2021-01-05T12:13:49.002Z","_id":"ckjju0m11003020ua9zzj00wb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Andorid-Binder机制\"><a href=\"#Andorid-Binder机制\" class=\"headerlink\" title=\"Andorid Binder机制\"></a>Andorid Binder机制</h1><h2 id=\"Android-Binder介绍\"><a href=\"#Android-Binder介绍\" class=\"headerlink\" title=\"Android Binder介绍\"></a>Android Binder介绍</h2><p>Binder可以实现进程间通信，采用类似于C/S架构的设计模式，性能仅次于共享内存</p>\n<a id=\"more\"></a>\n<p><img src=\"/public/img/Android/android_base_binder2.png\"></p>\n<p>Binder机制的优点：</p>\n<p>1、高效：Binder机制的数据只拷贝一次，而管道、消息队列、Socket都需要两次；通过驱动在内核拷贝数据，不需要额外的同步处理。<br>2、安全性高：Binder机制为每个进程分配了UID/PID来作为鉴别身份的标示；在Binder通信时会根据UID/PID进行有效性额检测（传统方式下，对于通信双方的身份没有做出验证）<br>3、简单易用：采用C/S架构，以及面向对象的方式进行实现。</p>\n<h3 id=\"Android-Binder-组成\"><a href=\"#Android-Binder-组成\" class=\"headerlink\" title=\"Android Binder 组成\"></a>Android Binder 组成</h3><p><img src=\"/public/img/Android/android_base_binder1.png\"></p>\n<p>1、Server：位于用户空间； 提供服务方，当Server进程向Binder驱动进行注册后，其Binder引用会自动加入到ServiceManager中；<br>2、Client：位于用户空间； 需求方<br>3、ServiceManager:位于用户空间；作为Servier和Client之间的桥梁，Client可以通过ServiceManager拿到Server中Binder实体的引用；<br>4、Binder驱动：位于内核空间；用于进程之间Binder通信实现；连接Service进程、Client进程和Service Manager的桥梁；在实现时采用内存映射的方式进行；</p>\n<p>注：</p>\n<ul>\n<li>用户空间不能进行进程间通信，而内核空间可以进行进程间通信</li>\n<li>在Andorid开发中系统服务很多通过Binder进行交互 <code>context.getSustemService(Context.AUDIO_SERVICE);</code></li>\n</ul>\n<h3 id=\"Android-Binder机制执行流程\"><a href=\"#Android-Binder机制执行流程\" class=\"headerlink\" title=\"Android Binder机制执行流程\"></a>Android Binder机制执行流程</h3><p><img src=\"/public/img/Android/android_base_binder3.png\"></p>\n<p><img src=\"/public/img/Android/android_base_binder4.png\"></p>\n<h3 id=\"Linux内核中提供的通信方式\"><a href=\"#Linux内核中提供的通信方式\" class=\"headerlink\" title=\"Linux内核中提供的通信方式\"></a>Linux内核中提供的通信方式</h3><p>1、管道通信，性能耗费严重；半双工的方式，数据需要复制两次<br>2、共享内存，多个进程可以访问同一块内存空间，内存管理混乱<br>3、Socket通信，其主要适合于网络通信</p>\n<h3 id=\"AIDL介绍\"><a href=\"#AIDL介绍\" class=\"headerlink\" title=\"AIDL介绍\"></a>AIDL介绍</h3><p>1、IBinder： 代表跨进程通信能力的接口，对象只需要实现IBinder就可以跨进程传输<br>2、IInterface：代表Server进程提供的功能； 对应AIDL定义的接口；<br>3、Binder：代表Binder的本地对象BinderProxy<br>4、Stub：继承Binder，实现IInterface</p>\n<h3 id=\"Android-9-0-中的Binder\"><a href=\"#Android-9-0-中的Binder\" class=\"headerlink\" title=\"Android 9.0 中的Binder\"></a>Android 9.0 中的Binder</h3>","site":{"data":{}},"excerpt":"<h1 id=\"Andorid-Binder机制\"><a href=\"#Andorid-Binder机制\" class=\"headerlink\" title=\"Andorid Binder机制\"></a>Andorid Binder机制</h1><h2 id=\"Android-Binder介绍\"><a href=\"#Android-Binder介绍\" class=\"headerlink\" title=\"Android Binder介绍\"></a>Android Binder介绍</h2><p>Binder可以实现进程间通信，采用类似于C/S架构的设计模式，性能仅次于共享内存</p>","more":"<p><img src=\"/public/img/Android/android_base_binder2.png\"></p>\n<p>Binder机制的优点：</p>\n<p>1、高效：Binder机制的数据只拷贝一次，而管道、消息队列、Socket都需要两次；通过驱动在内核拷贝数据，不需要额外的同步处理。<br>2、安全性高：Binder机制为每个进程分配了UID/PID来作为鉴别身份的标示；在Binder通信时会根据UID/PID进行有效性额检测（传统方式下，对于通信双方的身份没有做出验证）<br>3、简单易用：采用C/S架构，以及面向对象的方式进行实现。</p>\n<h3 id=\"Android-Binder-组成\"><a href=\"#Android-Binder-组成\" class=\"headerlink\" title=\"Android Binder 组成\"></a>Android Binder 组成</h3><p><img src=\"/public/img/Android/android_base_binder1.png\"></p>\n<p>1、Server：位于用户空间； 提供服务方，当Server进程向Binder驱动进行注册后，其Binder引用会自动加入到ServiceManager中；<br>2、Client：位于用户空间； 需求方<br>3、ServiceManager:位于用户空间；作为Servier和Client之间的桥梁，Client可以通过ServiceManager拿到Server中Binder实体的引用；<br>4、Binder驱动：位于内核空间；用于进程之间Binder通信实现；连接Service进程、Client进程和Service Manager的桥梁；在实现时采用内存映射的方式进行；</p>\n<p>注：</p>\n<ul>\n<li>用户空间不能进行进程间通信，而内核空间可以进行进程间通信</li>\n<li>在Andorid开发中系统服务很多通过Binder进行交互 <code>context.getSustemService(Context.AUDIO_SERVICE);</code></li>\n</ul>\n<h3 id=\"Android-Binder机制执行流程\"><a href=\"#Android-Binder机制执行流程\" class=\"headerlink\" title=\"Android Binder机制执行流程\"></a>Android Binder机制执行流程</h3><p><img src=\"/public/img/Android/android_base_binder3.png\"></p>\n<p><img src=\"/public/img/Android/android_base_binder4.png\"></p>\n<h3 id=\"Linux内核中提供的通信方式\"><a href=\"#Linux内核中提供的通信方式\" class=\"headerlink\" title=\"Linux内核中提供的通信方式\"></a>Linux内核中提供的通信方式</h3><p>1、管道通信，性能耗费严重；半双工的方式，数据需要复制两次<br>2、共享内存，多个进程可以访问同一块内存空间，内存管理混乱<br>3、Socket通信，其主要适合于网络通信</p>\n<h3 id=\"AIDL介绍\"><a href=\"#AIDL介绍\" class=\"headerlink\" title=\"AIDL介绍\"></a>AIDL介绍</h3><p>1、IBinder： 代表跨进程通信能力的接口，对象只需要实现IBinder就可以跨进程传输<br>2、IInterface：代表Server进程提供的功能； 对应AIDL定义的接口；<br>3、Binder：代表Binder的本地对象BinderProxy<br>4、Stub：继承Binder，实现IInterface</p>\n<h3 id=\"Android-9-0-中的Binder\"><a href=\"#Android-9-0-中的Binder\" class=\"headerlink\" title=\"Android 9.0 中的Binder\"></a>Android 9.0 中的Binder</h3>"},{"title":"Handler介绍","cover":"/cover/img13.jpg","toc":true,"description":"Android Handler介绍与使用","type":["Android"],"date":"2019-09-29T16:00:00.000Z","_content":"# Handler介绍\n\nHandler直接继承于Object类\n\nHandler与一个线程的`MessageQueue`进行绑定，可以用于`Message`的发送与处理以及`Runnable`对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的`Message Queue`相绑定，它可以将messages以及runnables对象传递到`Message Queue`，并对`Message Queue`中的messages以及runnables对象进行处理。\n<!--more-->\nHandler使用的两个主要方面：\n1、对messages以及runnables在将来某一个节点执行进行调度；\n2、在非当前线程执行其他操作\n\nHandler对Message的调度通过`post(Runnable)`, `postAtTime(Runnable, long)`, `postDelayed(Runnable, Object, long)`, `sendEmptyMessage(int)`, `sendMessage(Message)`, `sendMessageAtTime(Message, long)`, 以及·、`sendMessageDelayed(Message, long) `等方法进行，`post`方法可以将`Runnable`对象插入到队列中，当消息队列收到`Runnable`对象时，可以执行。`sendMessage`方法可以将`Message`对象（其中包含大量数据）插入到队列中，通过`HandlerMessage`方法进行处理。\n\n当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。\n\n当应用程序创建一个进程之后，它的主线程用于持有的`Message Queue`用于管理“顶级”的应用对象(`Activity` `Broadcast Receiver`等)和他们创建的窗口。当创建自己的线程时，可以通过`Handler`与应用的主线程进行信息交换。\n\n# Looper介绍\n\nLooper直接继承于Object\n\nLooper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的`prepare()`方法来运行一个loop，`loop()`方法用来处理message。\n\n与message loop进行大部分交互都是通过`Handler`类来进行。\n\n下列代码是实现一个`Looper`线程的方式，通过分离开的`prepare()`以及`loop()`方法初始化一个Handler与Looper进行交互。\n\n\n```java\n\n class LooperThread extends Thread {\n  \n      public Handler mHandler;\n\n      public void run() {\n          Looper.prepare();\n\n          mHandler = new Handler() {\n              public void handleMessage(Message msg) {\n                  // process incoming messages here\n              }\n          };\n\n          Looper.loop();\n      }\n  }\n\n```\n\n# MessageQueue介绍\n\nMessageQueue直接继承于Object\n\nMessage不能直接添加至`Message Queue`中，需要通过与`Looper`相关联的`Handler`对象来实现。通过`Looper.myQueue`方法可以从当前线程中获取`MessageQueue`\n\n\n### 从源码角度分析Handler、Looper、MessageQueue三者之间的关系\n\n`Handler`默认构造函数`Handler()`，将自己与当前线程的`Looper`进行绑定，如果当前线程中没有`Looper`对象，会报出异常。\n\n```\n  \n    //Handler源码117行\n    public Handler() {\n        this(null, false);\n    }\n    \n    //Handler源码131行\n      public Handler(Callback callback) {\n        this(callback, false);\n    }\n    \n    \n```\n\n通过`Looper.prepare();`为当前线程设置一个`Looper`\n具体流程：\n其中`prepare()`方法是`Looper`类中的静态方法；在`prepare(boolean quitAllowed)`方法中调用`sThreadLocal.set(new Looper(quitAllowed));`当前线程设置一个新的`Looper`在构造函数`Looper(boolean quitAllowed)`中，该`Looper`创建了一个新的`MessageQueue`(mQueue = new MessageQueue(quitAllowed););\n\n```\n\n    //Looper源码97行\n       public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n    \n    \n    //Looper源码267行\n        private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n```\n\n\n在Handler源码的192行中，通过`mLooper = Looper.myLooper();`来获取当前线程中的`Looper`\n\n```\n\n     //Handler源码192行\n  public Handler(Callback callback, boolean async) {\n      \n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n\n   //Looper71行\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n\n   //Looper97行\n\n   //Looper源码254行\n     public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n\n## Handler发送消息机制\n\nHandler调用` sendMessage(Message msg)`方法最终会一步一步调用`sendMessageAtTime(Message msg, long uptimeMillis)`在该方法中通过`MessageQueue queue = mQueue;`获取到MessageQueue，调用  用`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`方法将`Message`加入到消息队列中\n\n```\n   //Handler源码中的689行\n       public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n## Handler消息处理机制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Android Handler机制.md","raw":"---\ntitle:  Handler介绍\ncover: /cover/img13.jpg\ntoc: true\ndescription: Android Handler介绍与使用\ntype: [Android]\ncategories: Android\ndate: 2019/09/30\n---\n# Handler介绍\n\nHandler直接继承于Object类\n\nHandler与一个线程的`MessageQueue`进行绑定，可以用于`Message`的发送与处理以及`Runnable`对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的`Message Queue`相绑定，它可以将messages以及runnables对象传递到`Message Queue`，并对`Message Queue`中的messages以及runnables对象进行处理。\n<!--more-->\nHandler使用的两个主要方面：\n1、对messages以及runnables在将来某一个节点执行进行调度；\n2、在非当前线程执行其他操作\n\nHandler对Message的调度通过`post(Runnable)`, `postAtTime(Runnable, long)`, `postDelayed(Runnable, Object, long)`, `sendEmptyMessage(int)`, `sendMessage(Message)`, `sendMessageAtTime(Message, long)`, 以及·、`sendMessageDelayed(Message, long) `等方法进行，`post`方法可以将`Runnable`对象插入到队列中，当消息队列收到`Runnable`对象时，可以执行。`sendMessage`方法可以将`Message`对象（其中包含大量数据）插入到队列中，通过`HandlerMessage`方法进行处理。\n\n当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。\n\n当应用程序创建一个进程之后，它的主线程用于持有的`Message Queue`用于管理“顶级”的应用对象(`Activity` `Broadcast Receiver`等)和他们创建的窗口。当创建自己的线程时，可以通过`Handler`与应用的主线程进行信息交换。\n\n# Looper介绍\n\nLooper直接继承于Object\n\nLooper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的`prepare()`方法来运行一个loop，`loop()`方法用来处理message。\n\n与message loop进行大部分交互都是通过`Handler`类来进行。\n\n下列代码是实现一个`Looper`线程的方式，通过分离开的`prepare()`以及`loop()`方法初始化一个Handler与Looper进行交互。\n\n\n```java\n\n class LooperThread extends Thread {\n  \n      public Handler mHandler;\n\n      public void run() {\n          Looper.prepare();\n\n          mHandler = new Handler() {\n              public void handleMessage(Message msg) {\n                  // process incoming messages here\n              }\n          };\n\n          Looper.loop();\n      }\n  }\n\n```\n\n# MessageQueue介绍\n\nMessageQueue直接继承于Object\n\nMessage不能直接添加至`Message Queue`中，需要通过与`Looper`相关联的`Handler`对象来实现。通过`Looper.myQueue`方法可以从当前线程中获取`MessageQueue`\n\n\n### 从源码角度分析Handler、Looper、MessageQueue三者之间的关系\n\n`Handler`默认构造函数`Handler()`，将自己与当前线程的`Looper`进行绑定，如果当前线程中没有`Looper`对象，会报出异常。\n\n```\n  \n    //Handler源码117行\n    public Handler() {\n        this(null, false);\n    }\n    \n    //Handler源码131行\n      public Handler(Callback callback) {\n        this(callback, false);\n    }\n    \n    \n```\n\n通过`Looper.prepare();`为当前线程设置一个`Looper`\n具体流程：\n其中`prepare()`方法是`Looper`类中的静态方法；在`prepare(boolean quitAllowed)`方法中调用`sThreadLocal.set(new Looper(quitAllowed));`当前线程设置一个新的`Looper`在构造函数`Looper(boolean quitAllowed)`中，该`Looper`创建了一个新的`MessageQueue`(mQueue = new MessageQueue(quitAllowed););\n\n```\n\n    //Looper源码97行\n       public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n    \n    \n    //Looper源码267行\n        private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n```\n\n\n在Handler源码的192行中，通过`mLooper = Looper.myLooper();`来获取当前线程中的`Looper`\n\n```\n\n     //Handler源码192行\n  public Handler(Callback callback, boolean async) {\n      \n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n\n   //Looper71行\n    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n\n   //Looper97行\n\n   //Looper源码254行\n     public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n\n## Handler发送消息机制\n\nHandler调用` sendMessage(Message msg)`方法最终会一步一步调用`sendMessageAtTime(Message msg, long uptimeMillis)`在该方法中通过`MessageQueue queue = mQueue;`获取到MessageQueue，调用  用`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`方法将`Message`加入到消息队列中\n\n```\n   //Handler源码中的689行\n       public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n## Handler消息处理机制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android基础/Android Handler机制","published":1,"updated":"2021-01-05T12:13:49.269Z","_id":"ckjju0m12003320uaehwqdao5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Handler介绍\"><a href=\"#Handler介绍\" class=\"headerlink\" title=\"Handler介绍\"></a>Handler介绍</h1><p>Handler直接继承于Object类</p>\n<p>Handler与一个线程的<code>MessageQueue</code>进行绑定，可以用于<code>Message</code>的发送与处理以及<code>Runnable</code>对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的<code>Message Queue</code>相绑定，它可以将messages以及runnables对象传递到<code>Message Queue</code>，并对<code>Message Queue</code>中的messages以及runnables对象进行处理。</p>\n<a id=\"more\"></a>\n<p>Handler使用的两个主要方面：<br>1、对messages以及runnables在将来某一个节点执行进行调度；<br>2、在非当前线程执行其他操作</p>\n<p>Handler对Message的调度通过<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, 以及·、<code>sendMessageDelayed(Message, long) </code>等方法进行，<code>post</code>方法可以将<code>Runnable</code>对象插入到队列中，当消息队列收到<code>Runnable</code>对象时，可以执行。<code>sendMessage</code>方法可以将<code>Message</code>对象（其中包含大量数据）插入到队列中，通过<code>HandlerMessage</code>方法进行处理。</p>\n<p>当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。</p>\n<p>当应用程序创建一个进程之后，它的主线程用于持有的<code>Message Queue</code>用于管理“顶级”的应用对象(<code>Activity</code> <code>Broadcast Receiver</code>等)和他们创建的窗口。当创建自己的线程时，可以通过<code>Handler</code>与应用的主线程进行信息交换。</p>\n<h1 id=\"Looper介绍\"><a href=\"#Looper介绍\" class=\"headerlink\" title=\"Looper介绍\"></a>Looper介绍</h1><p>Looper直接继承于Object</p>\n<p>Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的<code>prepare()</code>方法来运行一个loop，<code>loop()</code>方法用来处理message。</p>\n<p>与message loop进行大部分交互都是通过<code>Handler</code>类来进行。</p>\n<p>下列代码是实现一个<code>Looper</code>线程的方式，通过分离开的<code>prepare()</code>以及<code>loop()</code>方法初始化一个Handler与Looper进行交互。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         Looper.prepare();</span><br><span class=\"line\"></span><br><span class=\"line\">         mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         Looper.loop();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"MessageQueue介绍\"><a href=\"#MessageQueue介绍\" class=\"headerlink\" title=\"MessageQueue介绍\"></a>MessageQueue介绍</h1><p>MessageQueue直接继承于Object</p>\n<p>Message不能直接添加至<code>Message Queue</code>中，需要通过与<code>Looper</code>相关联的<code>Handler</code>对象来实现。通过<code>Looper.myQueue</code>方法可以从当前线程中获取<code>MessageQueue</code></p>\n<h3 id=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"><a href=\"#从源码角度分析Handler、Looper、MessageQueue三者之间的关系\" class=\"headerlink\" title=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"></a>从源码角度分析Handler、Looper、MessageQueue三者之间的关系</h3><p><code>Handler</code>默认构造函数<code>Handler()</code>，将自己与当前线程的<code>Looper</code>进行绑定，如果当前线程中没有<code>Looper</code>对象，会报出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">&#x2F;&#x2F;Handler源码117行</span><br><span class=\"line\">public Handler() &#123;</span><br><span class=\"line\">    this(null, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Handler源码131行</span><br><span class=\"line\">  public Handler(Callback callback) &#123;</span><br><span class=\"line\">    this(callback, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过<code>Looper.prepare();</code>为当前线程设置一个<code>Looper</code><br>具体流程：<br>其中<code>prepare()</code>方法是<code>Looper</code>类中的静态方法；在<code>prepare(boolean quitAllowed)</code>方法中调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>当前线程设置一个新的<code>Looper</code>在构造函数<code>Looper(boolean quitAllowed)</code>中，该<code>Looper</code>创建了一个新的<code>MessageQueue</code>(mQueue = new MessageQueue(quitAllowed););</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码97行</span><br><span class=\"line\">   public static void prepare() &#123;</span><br><span class=\"line\">    prepare(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void prepare(boolean quitAllowed) &#123;</span><br><span class=\"line\">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class=\"line\">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码267行</span><br><span class=\"line\">    private Looper(boolean quitAllowed) &#123;</span><br><span class=\"line\">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread &#x3D; Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在Handler源码的192行中，通过<code>mLooper = Looper.myLooper();</code>来获取当前线程中的<code>Looper</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;Handler源码192行</span><br><span class=\"line\">public Handler(Callback callback, boolean async) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      mLooper &#x3D; Looper.myLooper();</span><br><span class=\"line\">      if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(</span><br><span class=\"line\">              &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class=\"line\">                      + &quot; that has not called Looper.prepare()&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mQueue &#x3D; mLooper.mQueue;</span><br><span class=\"line\">      mCallback &#x3D; callback;</span><br><span class=\"line\">      mAsynchronous &#x3D; async;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper71行</span><br><span class=\"line\">  static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper97行</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper源码254行</span><br><span class=\"line\">   public static @Nullable Looper myLooper() &#123;</span><br><span class=\"line\">      return sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Handler发送消息机制\"><a href=\"#Handler发送消息机制\" class=\"headerlink\" title=\"Handler发送消息机制\"></a>Handler发送消息机制</h2><p>Handler调用<code> sendMessage(Message msg)</code>方法最终会一步一步调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>在该方法中通过<code>MessageQueue queue = mQueue;</code>获取到MessageQueue，调用  用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>方法将<code>Message</code>加入到消息队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Handler源码中的689行</span><br><span class=\"line\">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">     MessageQueue queue &#x3D; mQueue;</span><br><span class=\"line\">     if (queue &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">         RuntimeException e &#x3D; new RuntimeException(</span><br><span class=\"line\">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Handler消息处理机制\"><a href=\"#Handler消息处理机制\" class=\"headerlink\" title=\"Handler消息处理机制\"></a>Handler消息处理机制</h2>","site":{"data":{}},"excerpt":"<h1 id=\"Handler介绍\"><a href=\"#Handler介绍\" class=\"headerlink\" title=\"Handler介绍\"></a>Handler介绍</h1><p>Handler直接继承于Object类</p>\n<p>Handler与一个线程的<code>MessageQueue</code>进行绑定，可以用于<code>Message</code>的发送与处理以及<code>Runnable</code>对象的处理。Handler对象被创建时，就与创建自己的线程以及该线程的<code>Message Queue</code>相绑定，它可以将messages以及runnables对象传递到<code>Message Queue</code>，并对<code>Message Queue</code>中的messages以及runnables对象进行处理。</p>","more":"<p>Handler使用的两个主要方面：<br>1、对messages以及runnables在将来某一个节点执行进行调度；<br>2、在非当前线程执行其他操作</p>\n<p>Handler对Message的调度通过<code>post(Runnable)</code>, <code>postAtTime(Runnable, long)</code>, <code>postDelayed(Runnable, Object, long)</code>, <code>sendEmptyMessage(int)</code>, <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, long)</code>, 以及·、<code>sendMessageDelayed(Message, long) </code>等方法进行，<code>post</code>方法可以将<code>Runnable</code>对象插入到队列中，当消息队列收到<code>Runnable</code>对象时，可以执行。<code>sendMessage</code>方法可以将<code>Message</code>对象（其中包含大量数据）插入到队列中，通过<code>HandlerMessage</code>方法进行处理。</p>\n<p>当向Handler发送消息时，既可以立刻处理消息，也可以指定延时处理。</p>\n<p>当应用程序创建一个进程之后，它的主线程用于持有的<code>Message Queue</code>用于管理“顶级”的应用对象(<code>Activity</code> <code>Broadcast Receiver</code>等)和他们创建的窗口。当创建自己的线程时，可以通过<code>Handler</code>与应用的主线程进行信息交换。</p>\n<h1 id=\"Looper介绍\"><a href=\"#Looper介绍\" class=\"headerlink\" title=\"Looper介绍\"></a>Looper介绍</h1><p>Looper直接继承于Object</p>\n<p>Looper类用于运行一个线程中的message loop，线程在默认状态下没有message loop与之相关联；需要通过调用thread类中的<code>prepare()</code>方法来运行一个loop，<code>loop()</code>方法用来处理message。</p>\n<p>与message loop进行大部分交互都是通过<code>Handler</code>类来进行。</p>\n<p>下列代码是实现一个<code>Looper</code>线程的方式，通过分离开的<code>prepare()</code>以及<code>loop()</code>方法初始化一个Handler与Looper进行交互。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         Looper.prepare();</span><br><span class=\"line\"></span><br><span class=\"line\">         mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         Looper.loop();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"MessageQueue介绍\"><a href=\"#MessageQueue介绍\" class=\"headerlink\" title=\"MessageQueue介绍\"></a>MessageQueue介绍</h1><p>MessageQueue直接继承于Object</p>\n<p>Message不能直接添加至<code>Message Queue</code>中，需要通过与<code>Looper</code>相关联的<code>Handler</code>对象来实现。通过<code>Looper.myQueue</code>方法可以从当前线程中获取<code>MessageQueue</code></p>\n<h3 id=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"><a href=\"#从源码角度分析Handler、Looper、MessageQueue三者之间的关系\" class=\"headerlink\" title=\"从源码角度分析Handler、Looper、MessageQueue三者之间的关系\"></a>从源码角度分析Handler、Looper、MessageQueue三者之间的关系</h3><p><code>Handler</code>默认构造函数<code>Handler()</code>，将自己与当前线程的<code>Looper</code>进行绑定，如果当前线程中没有<code>Looper</code>对象，会报出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">&#x2F;&#x2F;Handler源码117行</span><br><span class=\"line\">public Handler() &#123;</span><br><span class=\"line\">    this(null, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Handler源码131行</span><br><span class=\"line\">  public Handler(Callback callback) &#123;</span><br><span class=\"line\">    this(callback, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过<code>Looper.prepare();</code>为当前线程设置一个<code>Looper</code><br>具体流程：<br>其中<code>prepare()</code>方法是<code>Looper</code>类中的静态方法；在<code>prepare(boolean quitAllowed)</code>方法中调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>当前线程设置一个新的<code>Looper</code>在构造函数<code>Looper(boolean quitAllowed)</code>中，该<code>Looper</code>创建了一个新的<code>MessageQueue</code>(mQueue = new MessageQueue(quitAllowed););</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码97行</span><br><span class=\"line\">   public static void prepare() &#123;</span><br><span class=\"line\">    prepare(true);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void prepare(boolean quitAllowed) &#123;</span><br><span class=\"line\">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class=\"line\">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Looper源码267行</span><br><span class=\"line\">    private Looper(boolean quitAllowed) &#123;</span><br><span class=\"line\">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread &#x3D; Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在Handler源码的192行中，通过<code>mLooper = Looper.myLooper();</code>来获取当前线程中的<code>Looper</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;Handler源码192行</span><br><span class=\"line\">public Handler(Callback callback, boolean async) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">      mLooper &#x3D; Looper.myLooper();</span><br><span class=\"line\">      if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">          throw new RuntimeException(</span><br><span class=\"line\">              &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class=\"line\">                      + &quot; that has not called Looper.prepare()&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mQueue &#x3D; mLooper.mQueue;</span><br><span class=\"line\">      mCallback &#x3D; callback;</span><br><span class=\"line\">      mAsynchronous &#x3D; async;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper71行</span><br><span class=\"line\">  static final ThreadLocal&lt;Looper&gt; sThreadLocal &#x3D; new ThreadLocal&lt;Looper&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper97行</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F;Looper源码254行</span><br><span class=\"line\">   public static @Nullable Looper myLooper() &#123;</span><br><span class=\"line\">      return sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Handler发送消息机制\"><a href=\"#Handler发送消息机制\" class=\"headerlink\" title=\"Handler发送消息机制\"></a>Handler发送消息机制</h2><p>Handler调用<code> sendMessage(Message msg)</code>方法最终会一步一步调用<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>在该方法中通过<code>MessageQueue queue = mQueue;</code>获取到MessageQueue，调用  用<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>方法将<code>Message</code>加入到消息队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Handler源码中的689行</span><br><span class=\"line\">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class=\"line\">     MessageQueue queue &#x3D; mQueue;</span><br><span class=\"line\">     if (queue &#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">         RuntimeException e &#x3D; new RuntimeException(</span><br><span class=\"line\">                 this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class=\"line\">         Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class=\"line\">         return false;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Handler消息处理机制\"><a href=\"#Handler消息处理机制\" class=\"headerlink\" title=\"Handler消息处理机制\"></a>Handler消息处理机制</h2>"},{"title":"Android常用网站","type":["Android"],"description":"Android常用网站","cover":"/cover/img86.jpg","toc":true,"date":"2019-08-08T16:00:00.000Z","_content":"\n1、Android UI 源码\n\nhttp://androidblog.cn/index.php/Source/index/p/1\n\n2、","source":"_posts/Android/Android基础/Android 常用网站.md","raw":"---\ntitle: Android常用网站\ntype: [Android]\ndescription: Android常用网站\ncover: /cover/img86.jpg\ntoc: true\ncategories: Android\ndate: 2019/08/09\n---\n\n1、Android UI 源码\n\nhttp://androidblog.cn/index.php/Source/index/p/1\n\n2、","slug":"Android/Android基础/Android 常用网站","published":1,"updated":"2021-01-05T12:13:49.484Z","_id":"ckjju0m13003720ua2mxz58w0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1、Android UI 源码</p>\n<p><a href=\"http://androidblog.cn/index.php/Source/index/p/1\">http://androidblog.cn/index.php/Source/index/p/1</a></p>\n<p>2、</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、Android UI 源码</p>\n<p><a href=\"http://androidblog.cn/index.php/Source/index/p/1\">http://androidblog.cn/index.php/Source/index/p/1</a></p>\n<p>2、</p>\n"},{"title":"Android生命周期感知组件","description":"Android生命周期感知组件介绍","type":["Android"],"cover":"/cover/img7.jpg","toc":true,"date":"2018-08-08T16:00:00.000Z","_content":"\nmodified: 2018-08-09\n# Android生命周期感知组件介绍(Android lifecycle-aware components)\n\n## lifecycle-aware组件介绍\n<!--more-->\n* **ViewModel：**为绑定在特定生命周期的对象提供创建以及恢复的方法，`ViewModel`通常保存`View`的数据或者用于与其他组件进行通信，例如data repository\n* **LifecycleOwner/LifecycleRegisterOwner：**`LifecycleOwner`以及`LifecycleRegisterOwner`都是需要在`AppCompatActivity`或者`Support Fragment`类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。\n* **LiveData:**通过`LiveData`可以通过多个组件来观察到数据的变化。`LiveData`不会影响应用中的组件如：Activity、Service、Fragment或者其他`LifecycleOwner`的生命周期。`LiveData`可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。\n\n## 布局文件中添加计时器\n\n```xml\n    <Chronometer\n        android:id=\"@+id/chronometer\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n```\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);\n        chronometer.start();\n    }\n}\n\n\n```\n\n**当旋转屏幕时，由于Activity重建，使得计时器被重置**\n\n## 添加ViewMedel\n\n添加`ViewModel`来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用`ViewModel`也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。\n\n### 使用ViewModel来留存计时器（`Chronometer`）的状态\n\nChronometerViewModel中的代码\n\n```java\npublic class ChronometerViewModel extends ViewModel {\n    \n    private MutableLiveData<Long>mElapsedTime=new MutableLiveData<>();\n\n    private long mInitialTime;\n\n    public ChronometerViewModel(){\n        mInitialTime= SystemClock.elapsedRealtime();\n\n        Timer timer=new Timer();\n\n        timer.scheduleAtFixedRate(new TimerTask() {\n            @Override\n            public void run() {\n                 final long newValue=(SystemClock.elapsedRealtime()-mInitialTime)/1000;\n                 mElapsedTime.postValue(newValue);\n            }\n        },1000,1000);\n    }\n\n    public LiveData<Long>getElapsedTime(){\n\n        return mElapsedTime;\n    }\n}\n\n\n```\n\n在MainActivity中添加代码\n```java\n     chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n\n```\n\n`this`指代的是`LifecycleOwner`的一个实例，`ViewModel`与`LifecycleOwner`保活时间一样长，当`ViewModel`的所有者的配置信息（如：屏幕旋转）发生变化时，`ViewModel`不会被销毁，当其所有者重新被实例化时，会与已经存在的`ViewModel`重新建立联系。其生命周期如图所示：\n\n![](public/img/Android/view_model.png)\n\n\n## 将Activity中使用的数据使用LiveData进行封装\n\n将计时控件`chronometer`使用`Timer`来设置，每隔一秒钟更新一次UI，将相应的代码放在`ChronometerViewModel`中，而让Activity只保持用户与UI之间的交流操作。\n\n\nMainActivity中的完整代码\n```java\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ChronometerViewModel chronometerViewModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n         chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n         subscribe();\n\n    }\n    \n    private void subscribe(){\n        final Observer<Long>elapseTimeObserver=new Observer<Long>() {\n            @Override\n            public void onChanged(@Nullable Long aLong) {\n\n                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+\"秒\");\n            }\n        };\n        chronometerViewModel.getElapsedTime().observe(this,elapseTimeObserver);\n    }\n}\n\n\n```\n\n当`timer`每隔一秒***通知***`MainActivity`时，`MainActivity`将会更新一下UI，为避免内存泄漏，`ViewModel`中没有指向Activity的引用。\n\n`ViewModel`并不直接改变View，在使用`ViewModel`中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。\n\n**注：为了将数据暴露给观察者，需要使用`LiveData`对数据进行封装**\n\n`LiveData`是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。\n\n**运行结果：**\n\n![](/public/img/Android/view_model1.png)\n![](/public/img/Android/view_model2.png)\n\n\n在旋转屏幕后计时器继续未重置。\n\n\n\n\n\n\n","source":"_posts/Android/Android基础/Android-ViewModel介绍.md","raw":"---\n\ntitle: \"Android生命周期感知组件\"\ndescription: \"Android生命周期感知组件介绍\"\ntype: [Android]\ncover: /cover/img7.jpg\ntoc: true\ncategories: Android\ndate: 2018/08/09\n---\n\nmodified: 2018-08-09\n# Android生命周期感知组件介绍(Android lifecycle-aware components)\n\n## lifecycle-aware组件介绍\n<!--more-->\n* **ViewModel：**为绑定在特定生命周期的对象提供创建以及恢复的方法，`ViewModel`通常保存`View`的数据或者用于与其他组件进行通信，例如data repository\n* **LifecycleOwner/LifecycleRegisterOwner：**`LifecycleOwner`以及`LifecycleRegisterOwner`都是需要在`AppCompatActivity`或者`Support Fragment`类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。\n* **LiveData:**通过`LiveData`可以通过多个组件来观察到数据的变化。`LiveData`不会影响应用中的组件如：Activity、Service、Fragment或者其他`LifecycleOwner`的生命周期。`LiveData`可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。\n\n## 布局文件中添加计时器\n\n```xml\n    <Chronometer\n        android:id=\"@+id/chronometer\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n```\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);\n        chronometer.start();\n    }\n}\n\n\n```\n\n**当旋转屏幕时，由于Activity重建，使得计时器被重置**\n\n## 添加ViewMedel\n\n添加`ViewModel`来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用`ViewModel`也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。\n\n### 使用ViewModel来留存计时器（`Chronometer`）的状态\n\nChronometerViewModel中的代码\n\n```java\npublic class ChronometerViewModel extends ViewModel {\n    \n    private MutableLiveData<Long>mElapsedTime=new MutableLiveData<>();\n\n    private long mInitialTime;\n\n    public ChronometerViewModel(){\n        mInitialTime= SystemClock.elapsedRealtime();\n\n        Timer timer=new Timer();\n\n        timer.scheduleAtFixedRate(new TimerTask() {\n            @Override\n            public void run() {\n                 final long newValue=(SystemClock.elapsedRealtime()-mInitialTime)/1000;\n                 mElapsedTime.postValue(newValue);\n            }\n        },1000,1000);\n    }\n\n    public LiveData<Long>getElapsedTime(){\n\n        return mElapsedTime;\n    }\n}\n\n\n```\n\n在MainActivity中添加代码\n```java\n     chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n\n```\n\n`this`指代的是`LifecycleOwner`的一个实例，`ViewModel`与`LifecycleOwner`保活时间一样长，当`ViewModel`的所有者的配置信息（如：屏幕旋转）发生变化时，`ViewModel`不会被销毁，当其所有者重新被实例化时，会与已经存在的`ViewModel`重新建立联系。其生命周期如图所示：\n\n![](public/img/Android/view_model.png)\n\n\n## 将Activity中使用的数据使用LiveData进行封装\n\n将计时控件`chronometer`使用`Timer`来设置，每隔一秒钟更新一次UI，将相应的代码放在`ChronometerViewModel`中，而让Activity只保持用户与UI之间的交流操作。\n\n\nMainActivity中的完整代码\n```java\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ChronometerViewModel chronometerViewModel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n         chronometerViewModel= ViewModelProviders.of(this).get(ChronometerViewModel.class);\n         subscribe();\n\n    }\n    \n    private void subscribe(){\n        final Observer<Long>elapseTimeObserver=new Observer<Long>() {\n            @Override\n            public void onChanged(@Nullable Long aLong) {\n\n                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+\"秒\");\n            }\n        };\n        chronometerViewModel.getElapsedTime().observe(this,elapseTimeObserver);\n    }\n}\n\n\n```\n\n当`timer`每隔一秒***通知***`MainActivity`时，`MainActivity`将会更新一下UI，为避免内存泄漏，`ViewModel`中没有指向Activity的引用。\n\n`ViewModel`并不直接改变View，在使用`ViewModel`中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。\n\n**注：为了将数据暴露给观察者，需要使用`LiveData`对数据进行封装**\n\n`LiveData`是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。\n\n**运行结果：**\n\n![](/public/img/Android/view_model1.png)\n![](/public/img/Android/view_model2.png)\n\n\n在旋转屏幕后计时器继续未重置。\n\n\n\n\n\n\n","slug":"Android/Android基础/Android-ViewModel介绍","published":1,"updated":"2021-01-05T12:13:50.642Z","_id":"ckjju0m14003a20uac1nz7cb7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2018-08-09</p>\n<h1 id=\"Android生命周期感知组件介绍-Android-lifecycle-aware-components\"><a href=\"#Android生命周期感知组件介绍-Android-lifecycle-aware-components\" class=\"headerlink\" title=\"Android生命周期感知组件介绍(Android lifecycle-aware components)\"></a>Android生命周期感知组件介绍(Android lifecycle-aware components)</h1><h2 id=\"lifecycle-aware组件介绍\"><a href=\"#lifecycle-aware组件介绍\" class=\"headerlink\" title=\"lifecycle-aware组件介绍\"></a>lifecycle-aware组件介绍</h2><a id=\"more\"></a>\n<ul>\n<li><strong>ViewModel：</strong>为绑定在特定生命周期的对象提供创建以及恢复的方法，<code>ViewModel</code>通常保存<code>View</code>的数据或者用于与其他组件进行通信，例如data repository</li>\n<li><strong>LifecycleOwner/LifecycleRegisterOwner：</strong><code>LifecycleOwner</code>以及<code>LifecycleRegisterOwner</code>都是需要在<code>AppCompatActivity</code>或者<code>Support Fragment</code>类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。</li>\n<li>**LiveData:**通过<code>LiveData</code>可以通过多个组件来观察到数据的变化。<code>LiveData</code>不会影响应用中的组件如：Activity、Service、Fragment或者其他<code>LifecycleOwner</code>的生命周期。<code>LiveData</code>可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。</li>\n</ul>\n<h2 id=\"布局文件中添加计时器\"><a href=\"#布局文件中添加计时器\" class=\"headerlink\" title=\"布局文件中添加计时器\"></a>布局文件中添加计时器</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Chronometer</span><br><span class=\"line\">    android:id=&quot;@+id/chronometer&quot;</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text=&quot;Hello World!&quot;</span><br><span class=\"line\">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);</span><br><span class=\"line\">        chronometer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>当旋转屏幕时，由于Activity重建，使得计时器被重置</strong></p>\n<h2 id=\"添加ViewMedel\"><a href=\"#添加ViewMedel\" class=\"headerlink\" title=\"添加ViewMedel\"></a>添加ViewMedel</h2><p>添加<code>ViewModel</code>来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用<code>ViewModel</code>也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。</p>\n<h3 id=\"使用ViewModel来留存计时器（Chronometer）的状态\"><a href=\"#使用ViewModel来留存计时器（Chronometer）的状态\" class=\"headerlink\" title=\"使用ViewModel来留存计时器（Chronometer）的状态\"></a>使用ViewModel来留存计时器（<code>Chronometer</code>）的状态</h3><p>ChronometerViewModel中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChronometerViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Long&gt;mElapsedTime=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mInitialTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChronometerViewModel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        mInitialTime= SystemClock.elapsedRealtime();</span><br><span class=\"line\"></span><br><span class=\"line\">        Timer timer=<span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">        timer.scheduleAtFixedRate(<span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newValue=(SystemClock.elapsedRealtime()-mInitialTime)/<span class=\"number\">1000</span>;</span><br><span class=\"line\">                 mElapsedTime.postValue(newValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;Long&gt;getElapsedTime()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mElapsedTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在MainActivity中添加代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>this</code>指代的是<code>LifecycleOwner</code>的一个实例，<code>ViewModel</code>与<code>LifecycleOwner</code>保活时间一样长，当<code>ViewModel</code>的所有者的配置信息（如：屏幕旋转）发生变化时，<code>ViewModel</code>不会被销毁，当其所有者重新被实例化时，会与已经存在的<code>ViewModel</code>重新建立联系。其生命周期如图所示：</p>\n<p><img src=\"public/img/Android/view_model.png\"></p>\n<h2 id=\"将Activity中使用的数据使用LiveData进行封装\"><a href=\"#将Activity中使用的数据使用LiveData进行封装\" class=\"headerlink\" title=\"将Activity中使用的数据使用LiveData进行封装\"></a>将Activity中使用的数据使用LiveData进行封装</h2><p>将计时控件<code>chronometer</code>使用<code>Timer</code>来设置，每隔一秒钟更新一次UI，将相应的代码放在<code>ChronometerViewModel</code>中，而让Activity只保持用户与UI之间的交流操作。</p>\n<p>MainActivity中的完整代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ChronometerViewModel chronometerViewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">         chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel.class);</span><br><span class=\"line\">         subscribe();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;Long&gt;elapseTimeObserver=<span class=\"keyword\">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Long aLong)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+<span class=\"string\">&quot;秒&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        chronometerViewModel.getElapsedTime().observe(<span class=\"keyword\">this</span>,elapseTimeObserver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当<code>timer</code>每隔一秒**<em>通知**</em><code>MainActivity</code>时，<code>MainActivity</code>将会更新一下UI，为避免内存泄漏，<code>ViewModel</code>中没有指向Activity的引用。</p>\n<p><code>ViewModel</code>并不直接改变View，在使用<code>ViewModel</code>中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。</p>\n<p><strong>注：为了将数据暴露给观察者，需要使用<code>LiveData</code>对数据进行封装</strong></p>\n<p><code>LiveData</code>是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。</p>\n<p><strong>运行结果：</strong></p>\n<p><img src=\"/public/img/Android/view_model1.png\"><br><img src=\"/public/img/Android/view_model2.png\"></p>\n<p>在旋转屏幕后计时器继续未重置。</p>\n","site":{"data":{}},"excerpt":"<p>modified: 2018-08-09</p>\n<h1 id=\"Android生命周期感知组件介绍-Android-lifecycle-aware-components\"><a href=\"#Android生命周期感知组件介绍-Android-lifecycle-aware-components\" class=\"headerlink\" title=\"Android生命周期感知组件介绍(Android lifecycle-aware components)\"></a>Android生命周期感知组件介绍(Android lifecycle-aware components)</h1><h2 id=\"lifecycle-aware组件介绍\"><a href=\"#lifecycle-aware组件介绍\" class=\"headerlink\" title=\"lifecycle-aware组件介绍\"></a>lifecycle-aware组件介绍</h2>","more":"<ul>\n<li><strong>ViewModel：</strong>为绑定在特定生命周期的对象提供创建以及恢复的方法，<code>ViewModel</code>通常保存<code>View</code>的数据或者用于与其他组件进行通信，例如data repository</li>\n<li><strong>LifecycleOwner/LifecycleRegisterOwner：</strong><code>LifecycleOwner</code>以及<code>LifecycleRegisterOwner</code>都是需要在<code>AppCompatActivity</code>或者<code>Support Fragment</code>类中实现的接口。可以订阅实现这些接口的其他组件的对象，来观察这些对象的生命周期。</li>\n<li>**LiveData:**通过<code>LiveData</code>可以通过多个组件来观察到数据的变化。<code>LiveData</code>不会影响应用中的组件如：Activity、Service、Fragment或者其他<code>LifecycleOwner</code>的生命周期。<code>LiveData</code>可以对观察者订阅的内容进行管理，主要的方式有：停止或者取消订阅。</li>\n</ul>\n<h2 id=\"布局文件中添加计时器\"><a href=\"#布局文件中添加计时器\" class=\"headerlink\" title=\"布局文件中添加计时器\"></a>布局文件中添加计时器</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Chronometer</span><br><span class=\"line\">    android:id=&quot;@+id/chronometer&quot;</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text=&quot;Hello World!&quot;</span><br><span class=\"line\">    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class=\"line\">    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        Chronometer chronometer=(Chronometer)findViewById(R.id.chronometer);</span><br><span class=\"line\">        chronometer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>当旋转屏幕时，由于Activity重建，使得计时器被重置</strong></p>\n<h2 id=\"添加ViewMedel\"><a href=\"#添加ViewMedel\" class=\"headerlink\" title=\"添加ViewMedel\"></a>添加ViewMedel</h2><p>添加<code>ViewModel</code>来保持Activity或者Fragment整个生命周期中的数据.Activity以及Fragment是short-lived类型的对象，它们在用户操作App的过程中会被频繁地创建以及销毁。使用<code>ViewModel</code>也可以很好地处理与网络请求相关的数据，以及数据的操作和持久化。</p>\n<h3 id=\"使用ViewModel来留存计时器（Chronometer）的状态\"><a href=\"#使用ViewModel来留存计时器（Chronometer）的状态\" class=\"headerlink\" title=\"使用ViewModel来留存计时器（Chronometer）的状态\"></a>使用ViewModel来留存计时器（<code>Chronometer</code>）的状态</h3><p>ChronometerViewModel中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChronometerViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Long&gt;mElapsedTime=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mInitialTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChronometerViewModel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        mInitialTime= SystemClock.elapsedRealtime();</span><br><span class=\"line\"></span><br><span class=\"line\">        Timer timer=<span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">        timer.scheduleAtFixedRate(<span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newValue=(SystemClock.elapsedRealtime()-mInitialTime)/<span class=\"number\">1000</span>;</span><br><span class=\"line\">                 mElapsedTime.postValue(newValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LiveData&lt;Long&gt;getElapsedTime()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mElapsedTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在MainActivity中添加代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>this</code>指代的是<code>LifecycleOwner</code>的一个实例，<code>ViewModel</code>与<code>LifecycleOwner</code>保活时间一样长，当<code>ViewModel</code>的所有者的配置信息（如：屏幕旋转）发生变化时，<code>ViewModel</code>不会被销毁，当其所有者重新被实例化时，会与已经存在的<code>ViewModel</code>重新建立联系。其生命周期如图所示：</p>\n<p><img src=\"public/img/Android/view_model.png\"></p>\n<h2 id=\"将Activity中使用的数据使用LiveData进行封装\"><a href=\"#将Activity中使用的数据使用LiveData进行封装\" class=\"headerlink\" title=\"将Activity中使用的数据使用LiveData进行封装\"></a>将Activity中使用的数据使用LiveData进行封装</h2><p>将计时控件<code>chronometer</code>使用<code>Timer</code>来设置，每隔一秒钟更新一次UI，将相应的代码放在<code>ChronometerViewModel</code>中，而让Activity只保持用户与UI之间的交流操作。</p>\n<p>MainActivity中的完整代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ChronometerViewModel chronometerViewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">         chronometerViewModel= ViewModelProviders.of(<span class=\"keyword\">this</span>).get(ChronometerViewModel.class);</span><br><span class=\"line\">         subscribe();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;Long&gt;elapseTimeObserver=<span class=\"keyword\">new</span> Observer&lt;Long&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Long aLong)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                ((TextView)findViewById(R.id.chronometer_text)).setText(aLong+<span class=\"string\">&quot;秒&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        chronometerViewModel.getElapsedTime().observe(<span class=\"keyword\">this</span>,elapseTimeObserver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>当<code>timer</code>每隔一秒**<em>通知**</em><code>MainActivity</code>时，<code>MainActivity</code>将会更新一下UI，为避免内存泄漏，<code>ViewModel</code>中没有指向Activity的引用。</p>\n<p><code>ViewModel</code>并不直接改变View，在使用<code>ViewModel</code>中需要配置Activity以及Fragment去观察数据源的变化，当观察到数据源发生变换时UI发生相应的改变，这被称为观察者模式。</p>\n<p><strong>注：为了将数据暴露给观察者，需要使用<code>LiveData</code>对数据进行封装</strong></p>\n<p><code>LiveData</code>是一个特殊的可观察类，是lifecycle-aware类型的，只会通知处于活跃状态的观察者。</p>\n<p><strong>运行结果：</strong></p>\n<p><img src=\"/public/img/Android/view_model1.png\"><br><img src=\"/public/img/Android/view_model2.png\"></p>\n<p>在旋转屏幕后计时器继续未重置。</p>"},{"title":"Android Broadcast介绍","description":"Android Broadcast介绍","type":["Android"],"cover":"/cover/img6.jpg","toc":true,"date":"2018-07-31T16:00:00.000Z","_content":"\n# Android Broadcast介绍\n\nmodified: 2018-08-01\nAndroid应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。\n<!--more-->\n手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。\n\n广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。\n\n### 广播中的一些变化\n\n* 在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO\n* 在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效\n* 从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。\n\n## 接收广播\n\n手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。**在Android 8.0(API 26)之后建议使用第二种方式**\n\n### 在menifest文件中声明receiver\n\n通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。\n\n#### 1、menifest文件配置\n\n```xml\n<receiver\n       android:name=\".receiver.BroadcastReceiverTest\"\n       android:exported=\"true\">\n       <intent-filter>\n            <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n             <action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/>\n        </intent-filter>\n</receiver>\n\n```\n### 2、继承BroadcastReceiver类\n\n当用户手机充电时，将会弹出充电的提示。\n\n```java\n\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n    }\n}\n```\n## 通过Context-register的方式注册Receiver\n###1、创建一个BroadcastReceiverTest实例\n```\nBroadcastReceiverTest br=new BroadcastReceiverTest()\n```\n\n###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播\n\n```java\n//用于监控网络的状态变化\nIntentFilter intentFilter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\nintentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nthis.registerReceiver(br,intentFilter);\n```\n\n* 注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。\n\n###3、停止接收广播\n\n停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。\n\n**一定要记得unregister receiver**，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(***防止广播被重复多次注册***)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。\n\n## Broadcast对进程的影响\n\nBroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。\n\n当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。\n\n因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。\n\n```java\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n        final PendingResult pendingResult=goAsync();\n\n        AsyncTask<String,Integer,String>asyncTask=new AsyncTask<String, Integer, String>() {\n            @Override\n            protected String doInBackground(String... strings) {\n                Log.i(\"+++++++++\",\"++++\");\n                pendingResult.finish();\n                return \"测试\";\n            }\n        };\n\n        asyncTask.execute();\n\n    }\n}\n\n```\n\n## 发送广播\n\n### Android提供三种方式发送广播\n\n* 通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。\n* 通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。\n* 通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。\n\n**发送广播的例子**\n\n```java\nIntent intent = new Intent();\nintent.setAction(\"com.example.broadcast.MY_NOTIFICATION\");\nintent.putExtra(\"data\",\"Notice me senpai!\");\nsendBroadcast(intent);\n```\n\n广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。\n\n* 注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。\n\n## 通过permissions限制广播的发送\n\n广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。\n\n### 带有权限的广播发送\n\n当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。\n例如：\n```\nsendBroadcast(new Intent(\"com.example.NOTIFY\"), Manifest.permission.SEND_SMS);\n```\n\n这一条广播的接收者，只能是已经在manifest文件中申请了权限的App\n\n```\n<uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\n```\n\n### 带有权限的广播接收\n无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。**发送广播的App一定要取得相应的权限**\n\n例如：在manifest文件中添加权限限制。\n\n```xml\n<receiver android:name=\".MyBroadcastReceiver\"\n          android:permission=\"android.permission.SEND_SMS\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.AIRPLANE_MODE\"/>\n    </intent-filter>\n</receiver>\n\n``` \n\n使用context-register方式注册广播权限限制\n\n```java\nIntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nregisterReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );\n```\n\n\n\n","source":"_posts/Android/Android基础/Android-broadcast介绍.md","raw":"---\ntitle: \"Android Broadcast介绍\"\ndescription: \"Android Broadcast介绍\"\ntype: [Android]\ncover: /cover/img6.jpg\ntoc: true\ncategories: Android\n\ndate: 2018/08/01\n---\n\n# Android Broadcast介绍\n\nmodified: 2018-08-01\nAndroid应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。\n<!--more-->\n手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。\n\n广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。\n\n### 广播中的一些变化\n\n* 在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO\n* 在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效\n* 从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。\n\n## 接收广播\n\n手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。**在Android 8.0(API 26)之后建议使用第二种方式**\n\n### 在menifest文件中声明receiver\n\n通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。\n\n#### 1、menifest文件配置\n\n```xml\n<receiver\n       android:name=\".receiver.BroadcastReceiverTest\"\n       android:exported=\"true\">\n       <intent-filter>\n            <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n             <action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/>\n        </intent-filter>\n</receiver>\n\n```\n### 2、继承BroadcastReceiver类\n\n当用户手机充电时，将会弹出充电的提示。\n\n```java\n\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n    }\n}\n```\n## 通过Context-register的方式注册Receiver\n###1、创建一个BroadcastReceiverTest实例\n```\nBroadcastReceiverTest br=new BroadcastReceiverTest()\n```\n\n###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播\n\n```java\n//用于监控网络的状态变化\nIntentFilter intentFilter=new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);\nintentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nthis.registerReceiver(br,intentFilter);\n```\n\n* 注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。\n\n###3、停止接收广播\n\n停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。\n\n**一定要记得unregister receiver**，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(***防止广播被重复多次注册***)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。\n\n## Broadcast对进程的影响\n\nBroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。\n\n当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。\n\n因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。\n\n```java\npublic class BroadcastReceiverTest extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();\n        final PendingResult pendingResult=goAsync();\n\n        AsyncTask<String,Integer,String>asyncTask=new AsyncTask<String, Integer, String>() {\n            @Override\n            protected String doInBackground(String... strings) {\n                Log.i(\"+++++++++\",\"++++\");\n                pendingResult.finish();\n                return \"测试\";\n            }\n        };\n\n        asyncTask.execute();\n\n    }\n}\n\n```\n\n## 发送广播\n\n### Android提供三种方式发送广播\n\n* 通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。\n* 通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。\n* 通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。\n\n**发送广播的例子**\n\n```java\nIntent intent = new Intent();\nintent.setAction(\"com.example.broadcast.MY_NOTIFICATION\");\nintent.putExtra(\"data\",\"Notice me senpai!\");\nsendBroadcast(intent);\n```\n\n广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。\n\n* 注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。\n\n## 通过permissions限制广播的发送\n\n广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。\n\n### 带有权限的广播发送\n\n当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。\n例如：\n```\nsendBroadcast(new Intent(\"com.example.NOTIFY\"), Manifest.permission.SEND_SMS);\n```\n\n这一条广播的接收者，只能是已经在manifest文件中申请了权限的App\n\n```\n<uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\n```\n\n### 带有权限的广播接收\n无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。**发送广播的App一定要取得相应的权限**\n\n例如：在manifest文件中添加权限限制。\n\n```xml\n<receiver android:name=\".MyBroadcastReceiver\"\n          android:permission=\"android.permission.SEND_SMS\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.AIRPLANE_MODE\"/>\n    </intent-filter>\n</receiver>\n\n``` \n\n使用context-register方式注册广播权限限制\n\n```java\nIntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);\nregisterReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );\n```\n\n\n\n","slug":"Android/Android基础/Android-broadcast介绍","published":1,"updated":"2021-01-05T12:13:49.721Z","_id":"ckjju0m15003e20uaddpr356c","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android-Broadcast介绍\"><a href=\"#Android-Broadcast介绍\" class=\"headerlink\" title=\"Android Broadcast介绍\"></a>Android Broadcast介绍</h1><p>modified: 2018-08-01<br>Android应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。</p>\n<a id=\"more\"></a>\n<p>手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。</p>\n<p>广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。</p>\n<h3 id=\"广播中的一些变化\"><a href=\"#广播中的一些变化\" class=\"headerlink\" title=\"广播中的一些变化\"></a>广播中的一些变化</h3><ul>\n<li>在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO</li>\n<li>在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效</li>\n<li>从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。</li>\n</ul>\n<h2 id=\"接收广播\"><a href=\"#接收广播\" class=\"headerlink\" title=\"接收广播\"></a>接收广播</h2><p>手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。<strong>在Android 8.0(API 26)之后建议使用第二种方式</strong></p>\n<h3 id=\"在menifest文件中声明receiver\"><a href=\"#在menifest文件中声明receiver\" class=\"headerlink\" title=\"在menifest文件中声明receiver\"></a>在menifest文件中声明receiver</h3><p>通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。</p>\n<h4 id=\"1、menifest文件配置\"><a href=\"#1、menifest文件配置\" class=\"headerlink\" title=\"1、menifest文件配置\"></a>1、menifest文件配置</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">       android:name=&quot;.receiver.BroadcastReceiverTest&quot;</span><br><span class=\"line\">       android:exported=&quot;true&quot;&gt;</span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、继承BroadcastReceiver类\"><a href=\"#2、继承BroadcastReceiver类\" class=\"headerlink\" title=\"2、继承BroadcastReceiver类\"></a>2、继承BroadcastReceiver类</h3><p>当用户手机充电时，将会弹出充电的提示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过Context-register的方式注册Receiver\"><a href=\"#通过Context-register的方式注册Receiver\" class=\"headerlink\" title=\"通过Context-register的方式注册Receiver\"></a>通过Context-register的方式注册Receiver</h2><p>###1、创建一个BroadcastReceiverTest实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BroadcastReceiverTest br&#x3D;new BroadcastReceiverTest()</span><br></pre></td></tr></table></figure>\n<p>###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于监控网络的状态变化</span></span><br><span class=\"line\">IntentFilter intentFilter=<span class=\"keyword\">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class=\"line\">intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.registerReceiver(br,intentFilter);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。</li>\n</ul>\n<p>###3、停止接收广播</p>\n<p>停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。</p>\n<p><strong>一定要记得unregister receiver</strong>，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(<strong><em>防止广播被重复多次注册</em></strong>)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。</p>\n<h2 id=\"Broadcast对进程的影响\"><a href=\"#Broadcast对进程的影响\" class=\"headerlink\" title=\"Broadcast对进程的影响\"></a>Broadcast对进程的影响</h2><p>BroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。</p>\n<p>当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。</p>\n<p>因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PendingResult pendingResult=goAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        AsyncTask&lt;String,Integer,String&gt;asyncTask=<span class=\"keyword\">new</span> AsyncTask&lt;String, Integer, String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... strings)</span> </span>&#123;</span><br><span class=\"line\">                Log.i(<span class=\"string\">&quot;+++++++++&quot;</span>,<span class=\"string\">&quot;++++&quot;</span>);</span><br><span class=\"line\">                pendingResult.finish();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;测试&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        asyncTask.execute();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"发送广播\"><a href=\"#发送广播\" class=\"headerlink\" title=\"发送广播\"></a>发送广播</h2><h3 id=\"Android提供三种方式发送广播\"><a href=\"#Android提供三种方式发送广播\" class=\"headerlink\" title=\"Android提供三种方式发送广播\"></a>Android提供三种方式发送广播</h3><ul>\n<li>通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。</li>\n<li>通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。</li>\n<li>通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。</li>\n</ul>\n<p><strong>发送广播的例子</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;com.example.broadcast.MY_NOTIFICATION&quot;</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;data&quot;</span>,<span class=\"string\">&quot;Notice me senpai!&quot;</span>);</span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n<p>广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。</p>\n<ul>\n<li>注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。</li>\n</ul>\n<h2 id=\"通过permissions限制广播的发送\"><a href=\"#通过permissions限制广播的发送\" class=\"headerlink\" title=\"通过permissions限制广播的发送\"></a>通过permissions限制广播的发送</h2><p>广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。</p>\n<h3 id=\"带有权限的广播发送\"><a href=\"#带有权限的广播发送\" class=\"headerlink\" title=\"带有权限的广播发送\"></a>带有权限的广播发送</h3><p>当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS);</span><br></pre></td></tr></table></figure>\n<p>这一条广播的接收者，只能是已经在manifest文件中申请了权限的App</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name&#x3D;&quot;android.permission.SEND_SMS&quot;&#x2F;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"带有权限的广播接收\"><a href=\"#带有权限的广播接收\" class=\"headerlink\" title=\"带有权限的广播接收\"></a>带有权限的广播接收</h3><p>无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。<strong>发送广播的App一定要取得相应的权限</strong></p>\n<p>例如：在manifest文件中添加权限限制。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:permission</span>=<span class=\"string\">&quot;android.permission.SEND_SMS&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.AIRPLANE_MODE&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用context-register方式注册广播权限限制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\">registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, <span class=\"keyword\">null</span> );</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-Broadcast介绍\"><a href=\"#Android-Broadcast介绍\" class=\"headerlink\" title=\"Android Broadcast介绍\"></a>Android Broadcast介绍</h1><p>modified: 2018-08-01<br>Android应用可以向系统和其他应用发送或者接收广播信息，手机系统在启动或者电量低的时候会发送不同的广播，也允许手机应用发送广播，来通知用户某些事件。</p>","more":"<p>手机应用可以注册或者接受特定的广播，当一个广播被发出，系统会自动会自动将广播发送给注册并接收特定广播的手机应用。</p>\n<p>广播中的信息被包裹在Intent对象中，Intent中的action会判断出发生的是哪一个事件，如：android.intent.action.AIRPLANE_MODE。在Intent中同时可以携带其他的信息。</p>\n<h3 id=\"广播中的一些变化\"><a href=\"#广播中的一些变化\" class=\"headerlink\" title=\"广播中的一些变化\"></a>广播中的一些变化</h3><ul>\n<li>在Android 7.0(API 24)及以上的版本，将不再使用系统广播中的 ACTION_NEW_PICTURE和ACTION_NEW_VIDEO</li>\n<li>在Android 7.0(API 24)及以上的版本，监听CONNECTIVITY_ACTION广播时，需要使用registerReceiver(BroadcastReceiver, IntentFilter)方法，只在manifest文件中声明receiver将失效</li>\n<li>从Android 8.0(API 26)开始，对于大部分隐式广播（广播的对象不是针对你开发的APP），不能在menifest中声明receiver，如果需要使用隐式广播，需要使用context-registered reciever 的方法。</li>\n</ul>\n<h2 id=\"接收广播\"><a href=\"#接收广播\" class=\"headerlink\" title=\"接收广播\"></a>接收广播</h2><p>手机应用可以通过两种方式接收广播：通过在menifest文件中声明receiver；使用context-registered的方式。<strong>在Android 8.0(API 26)之后建议使用第二种方式</strong></p>\n<h3 id=\"在menifest文件中声明receiver\"><a href=\"#在menifest文件中声明receiver\" class=\"headerlink\" title=\"在menifest文件中声明receiver\"></a>在menifest文件中声明receiver</h3><p>通过在menifest文件中声明receiver的方式，但广播被发送的时候，系统会唤醒手机应用。</p>\n<h4 id=\"1、menifest文件配置\"><a href=\"#1、menifest文件配置\" class=\"headerlink\" title=\"1、menifest文件配置\"></a>1、menifest文件配置</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">       android:name=&quot;.receiver.BroadcastReceiverTest&quot;</span><br><span class=\"line\">       android:exported=&quot;true&quot;&gt;</span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、继承BroadcastReceiver类\"><a href=\"#2、继承BroadcastReceiver类\" class=\"headerlink\" title=\"2、继承BroadcastReceiver类\"></a>2、继承BroadcastReceiver类</h3><p>当用户手机充电时，将会弹出充电的提示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过Context-register的方式注册Receiver\"><a href=\"#通过Context-register的方式注册Receiver\" class=\"headerlink\" title=\"通过Context-register的方式注册Receiver\"></a>通过Context-register的方式注册Receiver</h2><p>###1、创建一个BroadcastReceiverTest实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BroadcastReceiverTest br&#x3D;new BroadcastReceiverTest()</span><br></pre></td></tr></table></figure>\n<p>###2、创建IntentFilter,通过调用registerReceiver(BroadcastReceiver, IntentFilter)方法注册广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于监控网络的状态变化</span></span><br><span class=\"line\">IntentFilter intentFilter=<span class=\"keyword\">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class=\"line\">intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.registerReceiver(br,intentFilter);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注：通过Context-register的方式注册广播，只要注册位置的Context没有被注销，那么它就可以收到广播。如果在Application的位置注册广播，那么只要App在运行，就可以收到广播信息。</li>\n</ul>\n<p>###3、停止接收广播</p>\n<p>停止接收广播需要调用 unregisterReceiver(android.content.BroadcastReceiver)，在此之前需要保证此广播不再被使用。</p>\n<p><strong>一定要记得unregister receiver</strong>，防止造成内存泄漏，如果在onCreate(Bundle)中注册receiver则需要在onDestroy()中unregister；如果在onResume()进行注册，则需要在onPause()中unregister(<strong><em>防止广播被重复多次注册</em></strong>)。但不能在onSaveInstanceState(Bundle)中进行unregister，因为当用户回到历史栈中时，这一个方法将不会被调用。</p>\n<h2 id=\"Broadcast对进程的影响\"><a href=\"#Broadcast对进程的影响\" class=\"headerlink\" title=\"Broadcast对进程的影响\"></a>Broadcast对进程的影响</h2><p>BroadcastReceiver无论是否是运行状态，都会影响到它所在的进程的状态。例如，当一个进程在正在执行receiver(当前运行onReceive()方法中的代码)，会被认为是一个前台进程，只有当内存极其缺乏的时候，该进程才会去杀死。</p>\n<p>当执行代码一旦从onReceive()方法中返回后，BroadcastReceiver就不再处于活跃状态，它所在的进程与应用的其他组件有着相同的优先级。如果进程中只有一个在menifest中声明的receiver，执行完onReceiver()方法返回后，系统将会将将该进程设置为低优先级，有时会被杀死。</p>\n<p>因此在broadcast的receiver中不能启动长时间运行的后台进程，在执行完onReceiver()方法之后，系统在任何时间都可以杀死进程。为了避免进程被杀死，可以调用goAsync()方法(当需要在后台执行一些耗时操作)，或者使用JobService，通过receiver使用JobScheduler，这样系统就会知道进程正在执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BroadcastReceiverTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context,intent.getAction().toString(),Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PendingResult pendingResult=goAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        AsyncTask&lt;String,Integer,String&gt;asyncTask=<span class=\"keyword\">new</span> AsyncTask&lt;String, Integer, String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doInBackground</span><span class=\"params\">(String... strings)</span> </span>&#123;</span><br><span class=\"line\">                Log.i(<span class=\"string\">&quot;+++++++++&quot;</span>,<span class=\"string\">&quot;++++&quot;</span>);</span><br><span class=\"line\">                pendingResult.finish();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;测试&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        asyncTask.execute();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"发送广播\"><a href=\"#发送广播\" class=\"headerlink\" title=\"发送广播\"></a>发送广播</h2><h3 id=\"Android提供三种方式发送广播\"><a href=\"#Android提供三种方式发送广播\" class=\"headerlink\" title=\"Android提供三种方式发送广播\"></a>Android提供三种方式发送广播</h3><ul>\n<li>通过 sendOrderedBroadcast(Intent, String) 的方式一次向一个receiver发送一个广播,接收到广播的receiver,可以将运行结果传递到下一个receiver或者直接将广播丢弃。</li>\n<li>通过 sendBroadcast(Intent) 的方式向所有的receiver发送广播，具有更高的效率，但是其他广播不能获取某些广播的执行的结果，也不能发散广播或者将广播取消。</li>\n<li>通过 LocalBroadcastManager.sendBroadcast 的方式发送广播，这种方式只能讲广播发送给本App，这种实现方式会更高效，而且不用担心其他App接收到广播引起的安全问题。</li>\n</ul>\n<p><strong>发送广播的例子</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;com.example.broadcast.MY_NOTIFICATION&quot;</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;data&quot;</span>,<span class=\"string\">&quot;Notice me senpai!&quot;</span>);</span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n<p>广播发送的内容被包裹在Intent对象中，intent的action字符串需要唯一确定广播事件，可以在intent中通过putExtra(String, Bundle) 方法携带更多的信息。也可以限制广播发送到组织中的一系列应用，通过intent调用setPackage(String)方法。</p>\n<ul>\n<li>注：尽管intent被用作发送广播以及启动Activity，但这些活动都是不想关的。Broadcast不能看到或者捕获用于启动activity的intent。</li>\n</ul>\n<h2 id=\"通过permissions限制广播的发送\"><a href=\"#通过permissions限制广播的发送\" class=\"headerlink\" title=\"通过permissions限制广播的发送\"></a>通过permissions限制广播的发送</h2><p>广播可以发送到具有某一权限的一些列的应用中，不仅可以在sender中设置限制，也可以在receiver中进行权限设置。</p>\n<h3 id=\"带有权限的广播发送\"><a href=\"#带有权限的广播发送\" class=\"headerlink\" title=\"带有权限的广播发送\"></a>带有权限的广播发送</h3><p>当调用sendBroadcast(Intent, String) 或者 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)方法时可以指定一个权限参数，只有已经在manifest文件中声明了权限的App才会接收到这一个广播。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS);</span><br></pre></td></tr></table></figure>\n<p>这一条广播的接收者，只能是已经在manifest文件中申请了权限的App</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name&#x3D;&quot;android.permission.SEND_SMS&quot;&#x2F;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"带有权限的广播接收\"><a href=\"#带有权限的广播接收\" class=\"headerlink\" title=\"带有权限的广播接收\"></a>带有权限的广播接收</h3><p>无论是使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler) 还是在manifest中使用标签 <receiver>来注册广播，当对receiver进行权限限制时，只能接收到已经获取到已经取得权限的App的广播。<strong>发送广播的App一定要取得相应的权限</strong></p>\n<p>例如：在manifest文件中添加权限限制。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">          <span class=\"attr\">android:permission</span>=<span class=\"string\">&quot;android.permission.SEND_SMS&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.AIRPLANE_MODE&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用context-register方式注册广播权限限制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\">registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, <span class=\"keyword\">null</span> );</span><br></pre></td></tr></table></figure>"},{"title":"Android Service介绍","description":"Android Service介绍","cover":"/cover/img4.jpg","type":["Android"],"toc":true,"date":"2018-07-30T16:00:00.000Z","_content":"\n\n# Android开发Service介绍\n\nService是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。\n<!--more-->\n## 不同类型的Service介绍\n\n### Foreground service\n\nForeground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)\n\n### Background service\n\nBackground service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。\n\n* 注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。\n\n### Bound\n\n当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。\n\n\n不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。\n\n\n## Service的使用\n\n创建一个Service,需要创建Service的子类，并在其中重写回调函数。\n\n### 函数的介绍\n\n#### onStartCommend()\n\n其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。\n\n#### onBind()\n\n其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。**在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null**\n\n#### onCreate()\n\n在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。\n\n#### onDestory()\n\n当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。\n\n### 在menifest中声明一个service\n\n```xml\n<manifest ... >\n  ...\n  <application ... >\n      <service android:name=\".ExampleService\" />\n      ...\n  </application>\n</manifest>\n\n```\n\n* 注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service\n\n## 创建一个Started service\n\n当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。\n\n应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。\n\n例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。\n\n* 注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。\n\n### 两个可以继承启动的service类\n\n#### Service类\n\nService类是所有service的基类，当在继承这一个类的时候，**需要创建一个新的线程，使得service可以再其中完成它的工作** ***（很重要）***，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。\n\n#### IntentService类\n\nIntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。\n\n### 继承IntentService类\n\n在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类\n\n**IntentService类所做的工作**\n\n* 创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。\n* 创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。\n* 当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。\n* 提供onBind()的默认实现方法，并返回null。\n* 提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。\n\n为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。\n\n\n\n\n## 创建一个Bound Service\n\nBound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。\n\n\n## 给用户发送notifications\n\n当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity\n\n\n## 运行foreground service\n\nforeground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。\n\n**谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。**\n\n让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。\n\n\n\n```\n\n//代码\n\n```\n\n注意：\n1、在启动Service时，需要使用显示Intent，且不能为Service声明Intent过滤器，在API21开始，如果使用隐式Intent调用bindService(), 系统会抛出异常。\n2、不应在Activity的onCreate()和onDestory()方法中，绑定启动service,在Activity生命周期改变时，这两个方法会发生回调。\n\n## service的生命周期\n\n通过startService() 启动服务，会调用Service的 `onStartService`方法，\n\nservice的生命周期从创建至销毁有两种情况；\n\n\n### 通过调用startService()创建service\n\n其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service\n\n### 通过调用bindService()创建service\n\n其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。\n\n如果组件通过调用bindServer来创建服务，且未调用onStartCommand，则服务只会在该组件与其绑定时运行，当该服务与其所有组件取消绑定后，系统会将其销毁。\n\n\n\n![](/source/img/201807/service_lifecycle.png)\n\n\n\n## 绑定服务\n\n在对服务进行绑定时，需要实现`onBind()`方法，该方法返回 `IBinder`对象。\n\n\n\n\n\n## 不同版本启动Service\n\n### Android 8.0 之前版本启动Service\n\n\n","source":"_posts/Android/Android基础/Android-service介绍.md","raw":"---\ntitle: \"Android Service介绍\"\ndescription: \"Android Service介绍\"\ncover: /cover/img4.jpg\ntype: [Android]\ntoc: true\ncategories: Android\ndate: 2018/07/31\n---\n\n\n# Android开发Service介绍\n\nService是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。\n<!--more-->\n## 不同类型的Service介绍\n\n### Foreground service\n\nForeground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)\n\n### Background service\n\nBackground service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。\n\n* 注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。\n\n### Bound\n\n当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。\n\n\n不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。\n\n\n## Service的使用\n\n创建一个Service,需要创建Service的子类，并在其中重写回调函数。\n\n### 函数的介绍\n\n#### onStartCommend()\n\n其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。\n\n#### onBind()\n\n其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。**在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null**\n\n#### onCreate()\n\n在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。\n\n#### onDestory()\n\n当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。\n\n### 在menifest中声明一个service\n\n```xml\n<manifest ... >\n  ...\n  <application ... >\n      <service android:name=\".ExampleService\" />\n      ...\n  </application>\n</manifest>\n\n```\n\n* 注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service\n\n## 创建一个Started service\n\n当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。\n\n应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。\n\n例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。\n\n* 注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。\n\n### 两个可以继承启动的service类\n\n#### Service类\n\nService类是所有service的基类，当在继承这一个类的时候，**需要创建一个新的线程，使得service可以再其中完成它的工作** ***（很重要）***，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。\n\n#### IntentService类\n\nIntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。\n\n### 继承IntentService类\n\n在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类\n\n**IntentService类所做的工作**\n\n* 创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。\n* 创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。\n* 当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。\n* 提供onBind()的默认实现方法，并返回null。\n* 提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。\n\n为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。\n\n\n\n\n## 创建一个Bound Service\n\nBound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。\n\n\n## 给用户发送notifications\n\n当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity\n\n\n## 运行foreground service\n\nforeground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。\n\n**谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。**\n\n让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。\n\n\n\n```\n\n//代码\n\n```\n\n注意：\n1、在启动Service时，需要使用显示Intent，且不能为Service声明Intent过滤器，在API21开始，如果使用隐式Intent调用bindService(), 系统会抛出异常。\n2、不应在Activity的onCreate()和onDestory()方法中，绑定启动service,在Activity生命周期改变时，这两个方法会发生回调。\n\n## service的生命周期\n\n通过startService() 启动服务，会调用Service的 `onStartService`方法，\n\nservice的生命周期从创建至销毁有两种情况；\n\n\n### 通过调用startService()创建service\n\n其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service\n\n### 通过调用bindService()创建service\n\n其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。\n\n如果组件通过调用bindServer来创建服务，且未调用onStartCommand，则服务只会在该组件与其绑定时运行，当该服务与其所有组件取消绑定后，系统会将其销毁。\n\n\n\n![](/source/img/201807/service_lifecycle.png)\n\n\n\n## 绑定服务\n\n在对服务进行绑定时，需要实现`onBind()`方法，该方法返回 `IBinder`对象。\n\n\n\n\n\n## 不同版本启动Service\n\n### Android 8.0 之前版本启动Service\n\n\n","slug":"Android/Android基础/Android-service介绍","published":1,"updated":"2021-01-05T12:13:50.183Z","_id":"ckjju0m15003h20uagush5jwe","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android开发Service介绍\"><a href=\"#Android开发Service介绍\" class=\"headerlink\" title=\"Android开发Service介绍\"></a>Android开发Service介绍</h1><p>Service是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。</p>\n<a id=\"more\"></a>\n<h2 id=\"不同类型的Service介绍\"><a href=\"#不同类型的Service介绍\" class=\"headerlink\" title=\"不同类型的Service介绍\"></a>不同类型的Service介绍</h2><h3 id=\"Foreground-service\"><a href=\"#Foreground-service\" class=\"headerlink\" title=\"Foreground service\"></a>Foreground service</h3><p>Foreground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)</p>\n<h3 id=\"Background-service\"><a href=\"#Background-service\" class=\"headerlink\" title=\"Background service\"></a>Background service</h3><p>Background service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。</p>\n<ul>\n<li>注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。</li>\n</ul>\n<h3 id=\"Bound\"><a href=\"#Bound\" class=\"headerlink\" title=\"Bound\"></a>Bound</h3><p>当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。</p>\n<p>不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。</p>\n<h2 id=\"Service的使用\"><a href=\"#Service的使用\" class=\"headerlink\" title=\"Service的使用\"></a>Service的使用</h2><p>创建一个Service,需要创建Service的子类，并在其中重写回调函数。</p>\n<h3 id=\"函数的介绍\"><a href=\"#函数的介绍\" class=\"headerlink\" title=\"函数的介绍\"></a>函数的介绍</h3><h4 id=\"onStartCommend\"><a href=\"#onStartCommend\" class=\"headerlink\" title=\"onStartCommend()\"></a>onStartCommend()</h4><p>其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。</p>\n<h4 id=\"onBind\"><a href=\"#onBind\" class=\"headerlink\" title=\"onBind()\"></a>onBind()</h4><p>其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。<strong>在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null</strong></p>\n<h4 id=\"onCreate\"><a href=\"#onCreate\" class=\"headerlink\" title=\"onCreate()\"></a>onCreate()</h4><p>在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。</p>\n<h4 id=\"onDestory\"><a href=\"#onDestory\" class=\"headerlink\" title=\"onDestory()\"></a>onDestory()</h4><p>当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。</p>\n<h3 id=\"在menifest中声明一个service\"><a href=\"#在menifest中声明一个service\" class=\"headerlink\" title=\"在menifest中声明一个service\"></a>在menifest中声明一个service</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.ExampleService&quot;</span> /&gt;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service</li>\n</ul>\n<h2 id=\"创建一个Started-service\"><a href=\"#创建一个Started-service\" class=\"headerlink\" title=\"创建一个Started service\"></a>创建一个Started service</h2><p>当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。</p>\n<p>应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。</p>\n<p>例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。</p>\n<ul>\n<li>注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。</li>\n</ul>\n<h3 id=\"两个可以继承启动的service类\"><a href=\"#两个可以继承启动的service类\" class=\"headerlink\" title=\"两个可以继承启动的service类\"></a>两个可以继承启动的service类</h3><h4 id=\"Service类\"><a href=\"#Service类\" class=\"headerlink\" title=\"Service类\"></a>Service类</h4><p>Service类是所有service的基类，当在继承这一个类的时候，<strong>需要创建一个新的线程，使得service可以再其中完成它的工作</strong> <strong><em>（很重要）</em></strong>，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。</p>\n<h4 id=\"IntentService类\"><a href=\"#IntentService类\" class=\"headerlink\" title=\"IntentService类\"></a>IntentService类</h4><p>IntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。</p>\n<h3 id=\"继承IntentService类\"><a href=\"#继承IntentService类\" class=\"headerlink\" title=\"继承IntentService类\"></a>继承IntentService类</h3><p>在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类</p>\n<p><strong>IntentService类所做的工作</strong></p>\n<ul>\n<li>创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。</li>\n<li>创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。</li>\n<li>当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。</li>\n<li>提供onBind()的默认实现方法，并返回null。</li>\n<li>提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。</li>\n</ul>\n<p>为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。</p>\n<h2 id=\"创建一个Bound-Service\"><a href=\"#创建一个Bound-Service\" class=\"headerlink\" title=\"创建一个Bound Service\"></a>创建一个Bound Service</h2><p>Bound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。</p>\n<h2 id=\"给用户发送notifications\"><a href=\"#给用户发送notifications\" class=\"headerlink\" title=\"给用户发送notifications\"></a>给用户发送notifications</h2><p>当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity</p>\n<h2 id=\"运行foreground-service\"><a href=\"#运行foreground-service\" class=\"headerlink\" title=\"运行foreground service\"></a>运行foreground service</h2><p>foreground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。</p>\n<p><strong>谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。</strong></p>\n<p>让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注意：<br>1、在启动Service时，需要使用显示Intent，且不能为Service声明Intent过滤器，在API21开始，如果使用隐式Intent调用bindService(), 系统会抛出异常。<br>2、不应在Activity的onCreate()和onDestory()方法中，绑定启动service,在Activity生命周期改变时，这两个方法会发生回调。</p>\n<h2 id=\"service的生命周期\"><a href=\"#service的生命周期\" class=\"headerlink\" title=\"service的生命周期\"></a>service的生命周期</h2><p>通过startService() 启动服务，会调用Service的 <code>onStartService</code>方法，</p>\n<p>service的生命周期从创建至销毁有两种情况；</p>\n<h3 id=\"通过调用startService-创建service\"><a href=\"#通过调用startService-创建service\" class=\"headerlink\" title=\"通过调用startService()创建service\"></a>通过调用startService()创建service</h3><p>其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service</p>\n<h3 id=\"通过调用bindService-创建service\"><a href=\"#通过调用bindService-创建service\" class=\"headerlink\" title=\"通过调用bindService()创建service\"></a>通过调用bindService()创建service</h3><p>其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。</p>\n<p>如果组件通过调用bindServer来创建服务，且未调用onStartCommand，则服务只会在该组件与其绑定时运行，当该服务与其所有组件取消绑定后，系统会将其销毁。</p>\n<p><img src=\"/source/img/201807/service_lifecycle.png\"></p>\n<h2 id=\"绑定服务\"><a href=\"#绑定服务\" class=\"headerlink\" title=\"绑定服务\"></a>绑定服务</h2><p>在对服务进行绑定时，需要实现<code>onBind()</code>方法，该方法返回 <code>IBinder</code>对象。</p>\n<h2 id=\"不同版本启动Service\"><a href=\"#不同版本启动Service\" class=\"headerlink\" title=\"不同版本启动Service\"></a>不同版本启动Service</h2><h3 id=\"Android-8-0-之前版本启动Service\"><a href=\"#Android-8-0-之前版本启动Service\" class=\"headerlink\" title=\"Android 8.0 之前版本启动Service\"></a>Android 8.0 之前版本启动Service</h3>","site":{"data":{}},"excerpt":"<h1 id=\"Android开发Service介绍\"><a href=\"#Android开发Service介绍\" class=\"headerlink\" title=\"Android开发Service介绍\"></a>Android开发Service介绍</h1><p>Service是应用的一个组件，可以在后台处理耗时操作，但没有用户界面，其他的组件可以启动Service,即使用户切换到其他的应用，Service依旧可以在后台运行。另外，一个组件可以绑定一个Service并与其进行通信（IPC机制）。例如：Service可以控制网络传输、播放音乐、对文件进行I/O操作，都可以在后台进行。</p>","more":"<h2 id=\"不同类型的Service介绍\"><a href=\"#不同类型的Service介绍\" class=\"headerlink\" title=\"不同类型的Service介绍\"></a>不同类型的Service介绍</h2><h3 id=\"Foreground-service\"><a href=\"#Foreground-service\" class=\"headerlink\" title=\"Foreground service\"></a>Foreground service</h3><p>Foreground service进行一些可以被用户看到的一些操作，例如：一个audio app会使用foreground service播放audio track,foreground service需要显示一个Notification,当用户切换到其他的应用时Foreground service依旧在后台运行。(音乐播放器类在后台播放，并在通知栏系显示的Service)</p>\n<h3 id=\"Background-service\"><a href=\"#Background-service\" class=\"headerlink\" title=\"Background service\"></a>Background service</h3><p>Background service进行的操作不会被用户感知，如：如果一个App使用Service对手机的存储空间进行进行压缩，会使用一个Background service。</p>\n<ul>\n<li>注：当App targets Api大于26时，如果App没有在前台运行，那么background service将会受到限制，应该使用schedule job进行替换。</li>\n</ul>\n<h3 id=\"Bound\"><a href=\"#Bound\" class=\"headerlink\" title=\"Bound\"></a>Bound</h3><p>当应用功能组件使用bindService时，这个Service就是Bound类型的。Bound service提供client-server接口使得组件和service可以进行通信，通过IPC机制发出请求，获取结果，Bound service存在运行的时间与绑定的它组件相同，多个组件可以绑定同一个service,当所有的组件解绑service时，service将被销毁。</p>\n<p>不管你的service是否启动、被绑定或者既启动也被绑定，所有的应用组件都可以使用Intent来启动，可以再manifest文件中将service设置为private,防止被其他的应用调用。</p>\n<h2 id=\"Service的使用\"><a href=\"#Service的使用\" class=\"headerlink\" title=\"Service的使用\"></a>Service的使用</h2><p>创建一个Service,需要创建Service的子类，并在其中重写回调函数。</p>\n<h3 id=\"函数的介绍\"><a href=\"#函数的介绍\" class=\"headerlink\" title=\"函数的介绍\"></a>函数的介绍</h3><h4 id=\"onStartCommend\"><a href=\"#onStartCommend\" class=\"headerlink\" title=\"onStartCommend()\"></a>onStartCommend()</h4><p>其他组件调用startService()方法启动Service时，会调用Service中onStartCommend()方法，当着一个方法执行时，service就启动了并在后台运行。如果自己实现了这一个方法，当任务结束时就需要自己调用stopSelf()或者stopService()方法，如果仅仅是要绑定服务，那么就不需要自己实现这一个方法。</p>\n<h4 id=\"onBind\"><a href=\"#onBind\" class=\"headerlink\" title=\"onBind()\"></a>onBind()</h4><p>其他组件调用bindService()来绑定服务时，会调用Service中的OnBind()方法。在实现这一个方法时，需要提供一个接口使得组件可以通过返回的IBinder与之进行通讯。<strong>在使用service时这一个方法都需要实现，如果service没有被绑定到其他组件上，返回值为null</strong></p>\n<h4 id=\"onCreate\"><a href=\"#onCreate\" class=\"headerlink\" title=\"onCreate()\"></a>onCreate()</h4><p>在service进行初始化的时候会调用这一个方法（在Service调用onStartCommand()或者onBinde()之前），如果service已经运行了，那么将不会调用这一个方法。</p>\n<h4 id=\"onDestory\"><a href=\"#onDestory\" class=\"headerlink\" title=\"onDestory()\"></a>onDestory()</h4><p>当服务不再使用或者将要销毁时，service需要实现这一个方法去清理资源，如：线程、注册的监听以及接收器等。</p>\n<h3 id=\"在menifest中声明一个service\"><a href=\"#在menifest中声明一个service\" class=\"headerlink\" title=\"在menifest中声明一个service\"></a>在menifest中声明一个service</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span> &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.ExampleService&quot;</span> /&gt;</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>注：为了保证App是安全的，需要使用显示调用的方法，启动一个service,而不是使用intent filter来启动。可以使用android:exported=false属性来防止外部应用启动此service</li>\n</ul>\n<h2 id=\"创建一个Started-service\"><a href=\"#创建一个Started-service\" class=\"headerlink\" title=\"创建一个Started service\"></a>创建一个Started service</h2><p>当一个服务被启动后，它与启动它的组件有着不同的生命周期，即使当启动service的组件被销毁了它依然可以在后台运行。因此，servive需要通过调用自身的stopSelf()来停止，或者通过其他组件调用stopService()。</p>\n<p>应用组件通过使用startService()启动service，通过Intent来启动特定的service并传递数据，servive可以在onStartCommand()方法中获取到intent中的数据。</p>\n<p>例如Actvivity需要将数据传递到线上数据库，这一个activity可以启动service组件，将数据通过Intent传递给startService (Intent service)，这一个service在onStartCommand()方法中获取到Intent中携带的数据，连接到网络并将数据传递到线上数据库，在数据传输完成后将会停止并销毁。</p>\n<ul>\n<li>注：service与应用运行在相同的进程中，当用户在与Activity进行交互的时候，service需要避免影响到Activity，需要在service中启动一个新的Thread。</li>\n</ul>\n<h3 id=\"两个可以继承启动的service类\"><a href=\"#两个可以继承启动的service类\" class=\"headerlink\" title=\"两个可以继承启动的service类\"></a>两个可以继承启动的service类</h3><h4 id=\"Service类\"><a href=\"#Service类\" class=\"headerlink\" title=\"Service类\"></a>Service类</h4><p>Service类是所有service的基类，当在继承这一个类的时候，<strong>需要创建一个新的线程，使得service可以再其中完成它的工作</strong> <strong><em>（很重要）</em></strong>，service会默认在应用的主线程中使用，这样会使得应用中的activity变得缓慢。</p>\n<h4 id=\"IntentService类\"><a href=\"#IntentService类\" class=\"headerlink\" title=\"IntentService类\"></a>IntentService类</h4><p>IntentService是Service的一个子类，其调用工作进程来处理在service启动时的请求操作，当不需要service同时处理多个请求时可以使用IntentService。实现onHandlerIntent()方法，接收到请求的intent，在后台完成任务。</p>\n<h3 id=\"继承IntentService类\"><a href=\"#继承IntentService类\" class=\"headerlink\" title=\"继承IntentService类\"></a>继承IntentService类</h3><p>在大多数情况下启动一个service不需要同时处理复杂的工作，所以推荐使用IntentService类</p>\n<p><strong>IntentService类所做的工作</strong></p>\n<ul>\n<li>创建一个默认的工作线程处理所有传递到onStartCommand()方法中的intent，从应用主线程中分离。</li>\n<li>创建一个工作队列，每一次传递一个intent到onHandleIntent方法中，所以无需担心多线程的问题。</li>\n<li>当所有的请求都被处理后，停止service，不需要调用stopSelf()方法来停止service。</li>\n<li>提供onBind()的默认实现方法，并返回null。</li>\n<li>提供onStartCommand()的默认实现方法，并将intent传递到工作队列，然后传递到onHandleIntent()的实现方法中。</li>\n</ul>\n<p>为了完成client传递的任务，需要实现onHandleIntent()方法，同时需要为定义的service添加一个构造方法。</p>\n<h2 id=\"创建一个Bound-Service\"><a href=\"#创建一个Bound-Service\" class=\"headerlink\" title=\"创建一个Bound Service\"></a>创建一个Bound Service</h2><p>Bound Service允许应用组件调用bindService()绑定到service上，它通常不允许使用startService()来创建Service。当需要service与其他应用组件进行信息交换或者将自己的应用的function，通过IPC暴露给其他应用调用时，使用Bound Service。</p>\n<h2 id=\"给用户发送notifications\"><a href=\"#给用户发送notifications\" class=\"headerlink\" title=\"给用户发送notifications\"></a>给用户发送notifications</h2><p>当一个服务在运行时，可以通过Toast Notifications或者Status Bar Notification向用户发通知。Toast Notification就是在Activity中使用的普通Toast,Status Bar可以有一个图标以及信息，用户可以点击启动相应的activity</p>\n<h2 id=\"运行foreground-service\"><a href=\"#运行foreground-service\" class=\"headerlink\" title=\"运行foreground service\"></a>运行foreground service</h2><p>foreground service可以被用户感知，即使在系统内存偏低的状态下也不会被杀死。foreground service需要在Status Bar中提供一个notification,除非这一个service被杀死，否则这个notification不会消失。</p>\n<p><strong>谨慎使用foreground service 当需要执行一项需要被用户感知的任务时，使用foreground service，它需要在Status Bar中显示一条notification，优先级设置为PRIORITY_LOW或者高一点的优先级。</strong></p>\n<p>让service运行在foreground，需要调用startForeground (int id, Notification notification)，第一个参数是Notification的唯一标识符ID。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;代码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注意：<br>1、在启动Service时，需要使用显示Intent，且不能为Service声明Intent过滤器，在API21开始，如果使用隐式Intent调用bindService(), 系统会抛出异常。<br>2、不应在Activity的onCreate()和onDestory()方法中，绑定启动service,在Activity生命周期改变时，这两个方法会发生回调。</p>\n<h2 id=\"service的生命周期\"><a href=\"#service的生命周期\" class=\"headerlink\" title=\"service的生命周期\"></a>service的生命周期</h2><p>通过startService() 启动服务，会调用Service的 <code>onStartService</code>方法，</p>\n<p>service的生命周期从创建至销毁有两种情况；</p>\n<h3 id=\"通过调用startService-创建service\"><a href=\"#通过调用startService-创建service\" class=\"headerlink\" title=\"通过调用startService()创建service\"></a>通过调用startService()创建service</h3><p>其他组件调用startService()会创建一个service，以这种方式启动的service需要主动停止，否则将会一直存在，service自身可以调用stopSelf()，其他组件可以调用stopService()方式来实现，当service停止后，系统将会销毁这一个service</p>\n<h3 id=\"通过调用bindService-创建service\"><a href=\"#通过调用bindService-创建service\" class=\"headerlink\" title=\"通过调用bindService()创建service\"></a>通过调用bindService()创建service</h3><p>其他组件调用bindService()方法创建一个service,启动service的客户端（组件）通过IBinder接口与service进行信息的交互，客户端可以通过调用unbindService()方法来取消与service之间的联系。多个客户端通过调用bindService()绑定同一个service,只有所有的客户端调用unBindService()方法后，service才会被系统销毁，而不能通过调用stopSelf()或者stopService()方法。</p>\n<p>如果组件通过调用bindServer来创建服务，且未调用onStartCommand，则服务只会在该组件与其绑定时运行，当该服务与其所有组件取消绑定后，系统会将其销毁。</p>\n<p><img src=\"/source/img/201807/service_lifecycle.png\"></p>\n<h2 id=\"绑定服务\"><a href=\"#绑定服务\" class=\"headerlink\" title=\"绑定服务\"></a>绑定服务</h2><p>在对服务进行绑定时，需要实现<code>onBind()</code>方法，该方法返回 <code>IBinder</code>对象。</p>\n<h2 id=\"不同版本启动Service\"><a href=\"#不同版本启动Service\" class=\"headerlink\" title=\"不同版本启动Service\"></a>不同版本启动Service</h2><h3 id=\"Android-8-0-之前版本启动Service\"><a href=\"#Android-8-0-之前版本启动Service\" class=\"headerlink\" title=\"Android 8.0 之前版本启动Service\"></a>Android 8.0 之前版本启动Service</h3>"},{"title":"Android后台处理","cover":"/cover/img9.jpg","toc":true,"description":"Android后台处理介绍","type":["Android"],"date":"2019-09-29T16:00:00.000Z","_content":"# Android后台处理介绍\n\nAndroid手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。\n<!--more-->\n## 推荐在后台进行处理的三种情况\n\n### App处理操作是否可以滞后进行，或者需要实时处理\n\n例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行\n\n### App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\n\n例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。\n\n### App操作处理是否是由系统进行触发\n\n系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。\n\n#### 加一个选择策略图片\n\n## 线程池\n\n对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。\n\n* 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁\n\n## Foreground Service操作\n\n对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。\n\n## Workmanager\n\n对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0\\(API 23\\)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。\n\n## 后台进程操作的限制\n\n为了最大化利用电池以及更好的App使用体验，Android会限制App\\(或者一个forceground service notification\\)，当其对用户不可见时。\n\n* Android 6.0\\(Api 23\\)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。\n* Android 7.0\\(Api 24\\)限制隐式广播。\n* Android 8.0\\(Api 26\\)限制更多的后台操作，包括后台获取地址信息以及释放缓存。\n\n","source":"_posts/Android/Android基础/Android后台任务.md","raw":"---\ntitle: Android后台处理\ncover: /cover/img9.jpg\ntoc: true\ndescription: Android后台处理介绍\ntype: [Android]\ncategories: Android\ndate: 2019/09/30\n---\n# Android后台处理介绍\n\nAndroid手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。\n<!--more-->\n## 推荐在后台进行处理的三种情况\n\n### App处理操作是否可以滞后进行，或者需要实时处理\n\n例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行\n\n### App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\n\n例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。\n\n### App操作处理是否是由系统进行触发\n\n系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。\n\n#### 加一个选择策略图片\n\n## 线程池\n\n对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。\n\n* 注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁\n\n## Foreground Service操作\n\n对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。\n\n## Workmanager\n\n对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0\\(API 23\\)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。\n\n## 后台进程操作的限制\n\n为了最大化利用电池以及更好的App使用体验，Android会限制App\\(或者一个forceground service notification\\)，当其对用户不可见时。\n\n* Android 6.0\\(Api 23\\)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。\n* Android 7.0\\(Api 24\\)限制隐式广播。\n* Android 8.0\\(Api 26\\)限制更多的后台操作，包括后台获取地址信息以及释放缓存。\n\n","slug":"Android/Android基础/Android后台任务","published":1,"updated":"2021-01-05T12:13:50.856Z","_id":"ckjju0m16003k20uacxpzawrj","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android后台处理介绍\"><a href=\"#Android后台处理介绍\" class=\"headerlink\" title=\"Android后台处理介绍\"></a>Android后台处理介绍</h1><p>Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。</p>\n<a id=\"more\"></a>\n<h2 id=\"推荐在后台进行处理的三种情况\"><a href=\"#推荐在后台进行处理的三种情况\" class=\"headerlink\" title=\"推荐在后台进行处理的三种情况\"></a>推荐在后台进行处理的三种情况</h2><h3 id=\"App处理操作是否可以滞后进行，或者需要实时处理\"><a href=\"#App处理操作是否可以滞后进行，或者需要实时处理\" class=\"headerlink\" title=\"App处理操作是否可以滞后进行，或者需要实时处理\"></a>App处理操作是否可以滞后进行，或者需要实时处理</h3><p>例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行</p>\n<h3 id=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\"><a href=\"#App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\" class=\"headerlink\" title=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\"></a>App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理</h3><p>例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。</p>\n<h3 id=\"App操作处理是否是由系统进行触发\"><a href=\"#App操作处理是否是由系统进行触发\" class=\"headerlink\" title=\"App操作处理是否是由系统进行触发\"></a>App操作处理是否是由系统进行触发</h3><p>系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。</p>\n<h4 id=\"加一个选择策略图片\"><a href=\"#加一个选择策略图片\" class=\"headerlink\" title=\"加一个选择策略图片\"></a>加一个选择策略图片</h4><h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。</p>\n<ul>\n<li>注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁</li>\n</ul>\n<h2 id=\"Foreground-Service操作\"><a href=\"#Foreground-Service操作\" class=\"headerlink\" title=\"Foreground Service操作\"></a>Foreground Service操作</h2><p>对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。</p>\n<h2 id=\"Workmanager\"><a href=\"#Workmanager\" class=\"headerlink\" title=\"Workmanager\"></a>Workmanager</h2><p>对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。</p>\n<h2 id=\"后台进程操作的限制\"><a href=\"#后台进程操作的限制\" class=\"headerlink\" title=\"后台进程操作的限制\"></a>后台进程操作的限制</h2><p>为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。</p>\n<ul>\n<li>Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。</li>\n<li>Android 7.0(Api 24)限制隐式广播。</li>\n<li>Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android后台处理介绍\"><a href=\"#Android后台处理介绍\" class=\"headerlink\" title=\"Android后台处理介绍\"></a>Android后台处理介绍</h1><p>Android手机应用通过主线程来控制UI，包括计算以及View绘制；当有太多的工作在主线程中进行，会造成App假死或者运行缓慢，会给用户较差的体验。很多耗时操作包括编码与解码Bitmap、读取存储器内容或者网络处理工作可以在一个独立的后台进程中进行。</p>","more":"<h2 id=\"推荐在后台进行处理的三种情况\"><a href=\"#推荐在后台进行处理的三种情况\" class=\"headerlink\" title=\"推荐在后台进行处理的三种情况\"></a>推荐在后台进行处理的三种情况</h2><h3 id=\"App处理操作是否可以滞后进行，或者需要实时处理\"><a href=\"#App处理操作是否可以滞后进行，或者需要实时处理\" class=\"headerlink\" title=\"App处理操作是否可以滞后进行，或者需要实时处理\"></a>App处理操作是否可以滞后进行，或者需要实时处理</h3><p>例如：当用户需要获取数据并显示时，不能将此数据获取放在后台；如果需要将App输出的log日志传递到服务器中，则需要将传输工作放置在后台中进行</p>\n<h3 id=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\"><a href=\"#App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep-Alive）处理\" class=\"headerlink\" title=\"App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理\"></a>App的处理操作开始的时候，Android操作系统是否需要将App进行“保活”（Keep Alive）处理</h3><p>例如：当对Bitmap进行解码显示处理的时候，通常需要App保持运行；当使用手机播放器进行音乐播放的时候,手机播放器需要可以再后台运行。</p>\n<h3 id=\"App操作处理是否是由系统进行触发\"><a href=\"#App操作处理是否是由系统进行触发\" class=\"headerlink\" title=\"App操作处理是否是由系统进行触发\"></a>App操作处理是否是由系统进行触发</h3><p>系统触发的内容包括：手机网络状态、电量状态、存储器容量以及其他的触发。例如：当你需要在手机处于网络可应用的状态下与服务器进行通信，如果此时App进程已经死掉，你需要重新启动一个。</p>\n<h4 id=\"加一个选择策略图片\"><a href=\"#加一个选择策略图片\" class=\"headerlink\" title=\"加一个选择策略图片\"></a>加一个选择策略图片</h4><h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>对于处理工作只能在App前台工作的情况使用线程池，线程池提供了一组后台线程，接收任务提交队列。如果需要监控操作系统的触发机制，需要使用动态注册Broadcast receivers,去监控操作系统的状态以及触发任务。</p>\n<ul>\n<li>注：在需要线程池进行网络、存储器以及计算操作时，这些任务通常需要是独立的避免引发死锁</li>\n</ul>\n<h2 id=\"Foreground-Service操作\"><a href=\"#Foreground-Service操作\" class=\"headerlink\" title=\"Foreground Service操作\"></a>Foreground Service操作</h2><p>对于需要尽快完成的工作，使用Foreground Servie通知操作系统App正在进行一些重要的工作，不可以被杀死。Foreground Service对于用户是可见的，它显示在通知栏中。</p>\n<h2 id=\"Workmanager\"><a href=\"#Workmanager\" class=\"headerlink\" title=\"Workmanager\"></a>Workmanager</h2><p>对于那些可以进行演示进行但必须要完成的任务，可以使用WorkManager。WorkManager是Android的一个库，用以运行可以延时触发后台任务（如：网络状态触发，或者电池状态触发）。WorkManager使用的是framework层的JobScheduler,当设备的版本低于Android 6.0(API 23)，如果已经在App中添加依赖，WorkManager就会使用Workbase JobDispatcher,否则将会使用AlarmManager来对后台任务进行处理。</p>\n<h2 id=\"后台进程操作的限制\"><a href=\"#后台进程操作的限制\" class=\"headerlink\" title=\"后台进程操作的限制\"></a>后台进程操作的限制</h2><p>为了最大化利用电池以及更好的App使用体验，Android会限制App(或者一个forceground service notification)，当其对用户不可见时。</p>\n<ul>\n<li>Android 6.0(Api 23)使用休眠状态或者standby状态，当屏幕关闭或者未操作状态时，App处于standby状态时，是未使用的应用进入到网络、任务以及同步都被限制的状态。</li>\n<li>Android 7.0(Api 24)限制隐式广播。</li>\n<li>Android 8.0(Api 26)限制更多的后台操作，包括后台获取地址信息以及释放缓存。</li>\n</ul>"},{"title":"Android 常用开源库","description":"Android 常用开源库","type":["Android"],"toc":true,"cover":"/cover/img100.jpg","date":"2019-06-14T16:00:00.000Z","_content":"\n### 一、网络请求\n\nRetrofit\n\n## 二、图片处理\n\n1、图片压缩\n\nLuban\n\n2、图片选择器\n\nmatisse\n\n3、图片加载\n\nglide\n\n### 三、动态权限请求\n\nrxpermissions\n \n\n### 四、下拉刷新，上拉加载\n\nswiperefreshlayout\n\n### 五、时间日期选择器\n\nAndroid-PickerView\n\n### 六、消息推送\n\n友盟推送","source":"_posts/Android/Android基础/Android常用的库.md","raw":"---\ntitle: \"Android 常用开源库\"\ndescription: \"Android 常用开源库\"\ntype: [Android]\ntoc: true\ncover:  /cover/img100.jpg\ncategories: Android\ndate: 2019/6/15\n---\n\n### 一、网络请求\n\nRetrofit\n\n## 二、图片处理\n\n1、图片压缩\n\nLuban\n\n2、图片选择器\n\nmatisse\n\n3、图片加载\n\nglide\n\n### 三、动态权限请求\n\nrxpermissions\n \n\n### 四、下拉刷新，上拉加载\n\nswiperefreshlayout\n\n### 五、时间日期选择器\n\nAndroid-PickerView\n\n### 六、消息推送\n\n友盟推送","slug":"Android/Android基础/Android常用的库","published":1,"updated":"2021-01-06T00:56:45.014Z","_id":"ckjju0m18003n20ua7hkmgcwf","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一、网络请求\"><a href=\"#一、网络请求\" class=\"headerlink\" title=\"一、网络请求\"></a>一、网络请求</h3><p>Retrofit</p>\n<h2 id=\"二、图片处理\"><a href=\"#二、图片处理\" class=\"headerlink\" title=\"二、图片处理\"></a>二、图片处理</h2><p>1、图片压缩</p>\n<p>Luban</p>\n<p>2、图片选择器</p>\n<p>matisse</p>\n<p>3、图片加载</p>\n<p>glide</p>\n<h3 id=\"三、动态权限请求\"><a href=\"#三、动态权限请求\" class=\"headerlink\" title=\"三、动态权限请求\"></a>三、动态权限请求</h3><p>rxpermissions</p>\n<h3 id=\"四、下拉刷新，上拉加载\"><a href=\"#四、下拉刷新，上拉加载\" class=\"headerlink\" title=\"四、下拉刷新，上拉加载\"></a>四、下拉刷新，上拉加载</h3><p>swiperefreshlayout</p>\n<h3 id=\"五、时间日期选择器\"><a href=\"#五、时间日期选择器\" class=\"headerlink\" title=\"五、时间日期选择器\"></a>五、时间日期选择器</h3><p>Android-PickerView</p>\n<h3 id=\"六、消息推送\"><a href=\"#六、消息推送\" class=\"headerlink\" title=\"六、消息推送\"></a>六、消息推送</h3><p>友盟推送</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、网络请求\"><a href=\"#一、网络请求\" class=\"headerlink\" title=\"一、网络请求\"></a>一、网络请求</h3><p>Retrofit</p>\n<h2 id=\"二、图片处理\"><a href=\"#二、图片处理\" class=\"headerlink\" title=\"二、图片处理\"></a>二、图片处理</h2><p>1、图片压缩</p>\n<p>Luban</p>\n<p>2、图片选择器</p>\n<p>matisse</p>\n<p>3、图片加载</p>\n<p>glide</p>\n<h3 id=\"三、动态权限请求\"><a href=\"#三、动态权限请求\" class=\"headerlink\" title=\"三、动态权限请求\"></a>三、动态权限请求</h3><p>rxpermissions</p>\n<h3 id=\"四、下拉刷新，上拉加载\"><a href=\"#四、下拉刷新，上拉加载\" class=\"headerlink\" title=\"四、下拉刷新，上拉加载\"></a>四、下拉刷新，上拉加载</h3><p>swiperefreshlayout</p>\n<h3 id=\"五、时间日期选择器\"><a href=\"#五、时间日期选择器\" class=\"headerlink\" title=\"五、时间日期选择器\"></a>五、时间日期选择器</h3><p>Android-PickerView</p>\n<h3 id=\"六、消息推送\"><a href=\"#六、消息推送\" class=\"headerlink\" title=\"六、消息推送\"></a>六、消息推送</h3><p>友盟推送</p>\n"},{"title":"Android序列化","cover":"/cover/img10.jpg","toc":true,"description":"Android序列化","type":["Android"],"date":"2018-09-09T16:00:00.000Z","_content":"## Android序列化\n\nAndroid序列化对象的方法有两种：\n\n* 实现Serializable接口，Java自带\n* 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）\n<!--more-->","source":"_posts/Android/Android基础/Android序列化.md","raw":"---\ntitle: Android序列化\ncover: /cover/img10.jpg\ntoc: true\ndescription: Android序列化\ntype: [Android]\ncategories: Android\ndate: 2018/09/10\n---\n## Android序列化\n\nAndroid序列化对象的方法有两种：\n\n* 实现Serializable接口，Java自带\n* 实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）\n<!--more-->","slug":"Android/Android基础/Android序列化","published":1,"updated":"2021-01-05T12:13:51.952Z","_id":"ckjju0m19003q20ua74lg4efo","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android序列化\"><a href=\"#Android序列化\" class=\"headerlink\" title=\"Android序列化\"></a>Android序列化</h2><p>Android序列化对象的方法有两种：</p>\n<ul>\n<li>实现Serializable接口，Java自带</li>\n<li>实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）<a id=\"more\"></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Android序列化\"><a href=\"#Android序列化\" class=\"headerlink\" title=\"Android序列化\"></a>Android序列化</h2><p>Android序列化对象的方法有两种：</p>\n<ul>\n<li>实现Serializable接口，Java自带</li>\n<li>实现Parcelable接口，android特有接口，效率高于Serializable接口，支持Intent数据传递，也可用于跨进程通讯（IPC）","more":"</li>\n</ul>"},{"title":"Android文件操作","cover":"/cover/img11.jpg","toc":true,"description":"Android文件操作","type":["Android"],"date":"2019-09-18T16:00:00.000Z","_content":"\n## Android文件的读和写\n\n1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；\n2、SD卡中的文件；\n3、数据区(/data/data/..)的文件；\n<!--more-->\n### 资源文件的读写\n\nraw使用InputStream in = getResources().openRawResource(R.raw.test);\nasset使用InputStream in = getResources().getAssets().open(fileName);\n\n### Android应用数据私有目录存储（位于应用功能安装目录下）\n\n该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。\n\n文件类型：\n/data/data/包名/cache ：存放的是APP的缓存信息\n/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码\n/data/data/包名/files ： 存放APP的文件信息\n\n还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。\n\n私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录\n\n`context.getCacheDir()`用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间\n\n\n### 从assets目录下读取文件\n\n```java\n    StringBuilder stringBuilder=new StringBuilder();\n\n    try{\n        //获取assets资源管理器\n        AssetManager assetManager=this.getAssets();\n        //通过资源管理器打开文件并进行读取\n        BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(\n            assetManager.open(\"test.txt\")\n        ));\n\n        String line;\n        while(((line =bufferedReader.readLine())!=null)){\n            stringBuilder.append(line);\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n\n\n```\n\n\n### 文件写操作\n\n//将数据保存至文件\n\n```java\n     String info=\"example\";\n     try{\n         FileWriter fileWriter =new FileWriter(\"/data/data/com.example\"+\".txt\",false);\n         fileWriter.write(info);\n         fileWriter.close();\n     }catch(Exception e){\n        e.printStackTrace();\n     }\n\n\n```\n\n#### 文件保存完成后，直接对文件进行读取会抛出异常\n\n解决该异常需要提醒媒体库刷新文件\n\n```java\n\n    Uri localUri=Uri.fromFile(new File(filepath));\n    \n    Intent localIntent=new Intent(  Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,localUri);\n\n    context.sendBroadcast(localIntent);\n\n\n```\n\n### Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\n\n该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。\n\n\n\n* 首先需要获取权限\n\n```xml\n\n     <!--用于获取文件操作的权限-->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n* 需要确定写入文件目录是否存在，如果不存在，则需要新建目录\n\n\n\n### Android存储公有目录\nAndorid开发公有目录与Context无关，使用Environment进行获取\n\n* Environment.DIRECTORY_PICTURES 图片目录\n* Environment.DIRECTORY_DCIM 相册目录\n* Environment.DIRECTORY_DOCUMENTS 文档目录\n* Environment.DIRECTORY_DOWNLOADS 下载目录\n* Environment.DIRECTORY_MOVIES 视频\n\n```java\n    //有参\n    Environment.getExternalStoragePublicDirectory(String type) ;\n    //无参\n    Environment.getExternalStoragePublicDirectory();\n\n```\n\n\n### Android本地文件选择\n\n### Android配置文件的读写\n\n```java\n    try{\n        Properties props=new Properties();\n\n        //如果配置文件位于 app/src/main/assets 文件夹下\n        InputStream inputStream=context.getAssets().open(\"config.properties\");\n        //如果配置文件位于 app/src/main/res/raw 文件夹下\n        InputStream inputStream=context.getResources().openRawResources(\"config.properties\");\n        //Java的写法\n        InputStream inputStream=PropertiesFactory.class.getResourceAsStream(\"assets/config.properties\");\n\n        props.load(inputStream);\n        props.getProperty(\"key\");\n\n    }catch(Exception e){\n\n    }\n\n\n```","source":"_posts/Android/Android基础/Android文件操作.md","raw":"---\ntitle: Android文件操作\ncover: /cover/img11.jpg\ntoc: true\ndescription: Android文件操作\ntype: [Android]\ncategories: Android\ndate: 2019/09/19\n---\n\n## Android文件的读和写\n\n1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；\n2、SD卡中的文件；\n3、数据区(/data/data/..)的文件；\n<!--more-->\n### 资源文件的读写\n\nraw使用InputStream in = getResources().openRawResource(R.raw.test);\nasset使用InputStream in = getResources().getAssets().open(fileName);\n\n### Android应用数据私有目录存储（位于应用功能安装目录下）\n\n该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。\n\n文件类型：\n/data/data/包名/cache ：存放的是APP的缓存信息\n/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码\n/data/data/包名/files ： 存放APP的文件信息\n\n还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。\n\n私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录\n\n`context.getCacheDir()`用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间\n\n\n### 从assets目录下读取文件\n\n```java\n    StringBuilder stringBuilder=new StringBuilder();\n\n    try{\n        //获取assets资源管理器\n        AssetManager assetManager=this.getAssets();\n        //通过资源管理器打开文件并进行读取\n        BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(\n            assetManager.open(\"test.txt\")\n        ));\n\n        String line;\n        while(((line =bufferedReader.readLine())!=null)){\n            stringBuilder.append(line);\n        }\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n\n\n```\n\n\n### 文件写操作\n\n//将数据保存至文件\n\n```java\n     String info=\"example\";\n     try{\n         FileWriter fileWriter =new FileWriter(\"/data/data/com.example\"+\".txt\",false);\n         fileWriter.write(info);\n         fileWriter.close();\n     }catch(Exception e){\n        e.printStackTrace();\n     }\n\n\n```\n\n#### 文件保存完成后，直接对文件进行读取会抛出异常\n\n解决该异常需要提醒媒体库刷新文件\n\n```java\n\n    Uri localUri=Uri.fromFile(new File(filepath));\n    \n    Intent localIntent=new Intent(  Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,localUri);\n\n    context.sendBroadcast(localIntent);\n\n\n```\n\n### Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\n\n该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。\n\n\n\n* 首先需要获取权限\n\n```xml\n\n     <!--用于获取文件操作的权限-->\n     <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n     <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n* 需要确定写入文件目录是否存在，如果不存在，则需要新建目录\n\n\n\n### Android存储公有目录\nAndorid开发公有目录与Context无关，使用Environment进行获取\n\n* Environment.DIRECTORY_PICTURES 图片目录\n* Environment.DIRECTORY_DCIM 相册目录\n* Environment.DIRECTORY_DOCUMENTS 文档目录\n* Environment.DIRECTORY_DOWNLOADS 下载目录\n* Environment.DIRECTORY_MOVIES 视频\n\n```java\n    //有参\n    Environment.getExternalStoragePublicDirectory(String type) ;\n    //无参\n    Environment.getExternalStoragePublicDirectory();\n\n```\n\n\n### Android本地文件选择\n\n### Android配置文件的读写\n\n```java\n    try{\n        Properties props=new Properties();\n\n        //如果配置文件位于 app/src/main/assets 文件夹下\n        InputStream inputStream=context.getAssets().open(\"config.properties\");\n        //如果配置文件位于 app/src/main/res/raw 文件夹下\n        InputStream inputStream=context.getResources().openRawResources(\"config.properties\");\n        //Java的写法\n        InputStream inputStream=PropertiesFactory.class.getResourceAsStream(\"assets/config.properties\");\n\n        props.load(inputStream);\n        props.getProperty(\"key\");\n\n    }catch(Exception e){\n\n    }\n\n\n```","slug":"Android/Android基础/Android文件操作","published":1,"updated":"2021-01-05T12:13:54.706Z","_id":"ckjju0m19003t20ua4a044hzb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android文件的读和写\"><a href=\"#Android文件的读和写\" class=\"headerlink\" title=\"Android文件的读和写\"></a>Android文件的读和写</h2><p>1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；<br>2、SD卡中的文件；<br>3、数据区(/data/data/..)的文件；</p>\n<a id=\"more\"></a>\n<h3 id=\"资源文件的读写\"><a href=\"#资源文件的读写\" class=\"headerlink\" title=\"资源文件的读写\"></a>资源文件的读写</h3><p>raw使用InputStream in = getResources().openRawResource(R.raw.test);<br>asset使用InputStream in = getResources().getAssets().open(fileName);</p>\n<h3 id=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"><a href=\"#Android应用数据私有目录存储（位于应用功能安装目录下）\" class=\"headerlink\" title=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"></a>Android应用数据私有目录存储（位于应用功能安装目录下）</h3><p>该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。</p>\n<p>文件类型：<br>/data/data/包名/cache ：存放的是APP的缓存信息<br>/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码<br>/data/data/包名/files ： 存放APP的文件信息</p>\n<p>还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。</p>\n<p>私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录</p>\n<p><code>context.getCacheDir()</code>用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间</p>\n<h3 id=\"从assets目录下读取文件\"><a href=\"#从assets目录下读取文件\" class=\"headerlink\" title=\"从assets目录下读取文件\"></a>从assets目录下读取文件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder stringBuilder=<span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取assets资源管理器</span></span><br><span class=\"line\">    AssetManager assetManager=<span class=\"keyword\">this</span>.getAssets();</span><br><span class=\"line\">    <span class=\"comment\">//通过资源管理器打开文件并进行读取</span></span><br><span class=\"line\">    BufferedReader bufferedReader=<span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(</span><br><span class=\"line\">        assetManager.open(<span class=\"string\">&quot;test.txt&quot;</span>)</span><br><span class=\"line\">    ));</span><br><span class=\"line\"></span><br><span class=\"line\">    String line;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(((line =bufferedReader.readLine())!=<span class=\"keyword\">null</span>))&#123;</span><br><span class=\"line\">        stringBuilder.append(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件写操作\"><a href=\"#文件写操作\" class=\"headerlink\" title=\"文件写操作\"></a>文件写操作</h3><p>//将数据保存至文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String info=<span class=\"string\">&quot;example&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    FileWriter fileWriter =<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">&quot;/data/data/com.example&quot;</span>+<span class=\"string\">&quot;.txt&quot;</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    fileWriter.write(info);</span><br><span class=\"line\">    fileWriter.close();</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">   e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"文件保存完成后，直接对文件进行读取会抛出异常\"><a href=\"#文件保存完成后，直接对文件进行读取会抛出异常\" class=\"headerlink\" title=\"文件保存完成后，直接对文件进行读取会抛出异常\"></a>文件保存完成后，直接对文件进行读取会抛出异常</h4><p>解决该异常需要提醒媒体库刷新文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Uri localUri=Uri.fromFile(<span class=\"keyword\">new</span> File(filepath));</span><br><span class=\"line\"></span><br><span class=\"line\">Intent localIntent=<span class=\"keyword\">new</span> Intent(  Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,localUri);</span><br><span class=\"line\"></span><br><span class=\"line\">context.sendBroadcast(localIntent);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"><a href=\"#Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\" class=\"headerlink\" title=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"></a>Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）</h3><p>该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。</p>\n<ul>\n<li>首先需要获取权限</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--用于获取文件操作的权限--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要确定写入文件目录是否存在，如果不存在，则需要新建目录</li>\n</ul>\n<h3 id=\"Android存储公有目录\"><a href=\"#Android存储公有目录\" class=\"headerlink\" title=\"Android存储公有目录\"></a>Android存储公有目录</h3><p>Andorid开发公有目录与Context无关，使用Environment进行获取</p>\n<ul>\n<li>Environment.DIRECTORY_PICTURES 图片目录</li>\n<li>Environment.DIRECTORY_DCIM 相册目录</li>\n<li>Environment.DIRECTORY_DOCUMENTS 文档目录</li>\n<li>Environment.DIRECTORY_DOWNLOADS 下载目录</li>\n<li>Environment.DIRECTORY_MOVIES 视频</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory(String type) ;</span><br><span class=\"line\"><span class=\"comment\">//无参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Android本地文件选择\"><a href=\"#Android本地文件选择\" class=\"headerlink\" title=\"Android本地文件选择\"></a>Android本地文件选择</h3><h3 id=\"Android配置文件的读写\"><a href=\"#Android配置文件的读写\" class=\"headerlink\" title=\"Android配置文件的读写\"></a>Android配置文件的读写</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Properties props=<span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果配置文件位于 app/src/main/assets 文件夹下</span></span><br><span class=\"line\">    InputStream inputStream=context.getAssets().open(<span class=\"string\">&quot;config.properties&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//如果配置文件位于 app/src/main/res/raw 文件夹下</span></span><br><span class=\"line\">    InputStream inputStream=context.getResources().openRawResources(<span class=\"string\">&quot;config.properties&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//Java的写法</span></span><br><span class=\"line\">    InputStream inputStream=PropertiesFactory.class.getResourceAsStream(<span class=\"string\">&quot;assets/config.properties&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    props.load(inputStream);</span><br><span class=\"line\">    props.getProperty(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Android文件的读和写\"><a href=\"#Android文件的读和写\" class=\"headerlink\" title=\"Android文件的读和写\"></a>Android文件的读和写</h2><p>1、apk资源文件在raw和assert文件夹下，只能进行读取不能进行写入，文件大小不能超过1M；<br>2、SD卡中的文件；<br>3、数据区(/data/data/..)的文件；</p>","more":"<h3 id=\"资源文件的读写\"><a href=\"#资源文件的读写\" class=\"headerlink\" title=\"资源文件的读写\"></a>资源文件的读写</h3><p>raw使用InputStream in = getResources().openRawResource(R.raw.test);<br>asset使用InputStream in = getResources().getAssets().open(fileName);</p>\n<h3 id=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"><a href=\"#Android应用数据私有目录存储（位于应用功能安装目录下）\" class=\"headerlink\" title=\"Android应用数据私有目录存储（位于应用功能安装目录下）\"></a>Android应用数据私有目录存储（位于应用功能安装目录下）</h3><p>该目录使用不需要获取用户权限，不能被其他应用访问，当应用被卸载时，该目录会被删除。在在使用该目录时，需要使用完整的包名进行访问。</p>\n<p>文件类型：<br>/data/data/包名/cache ：存放的是APP的缓存信息<br>/data/data/包名/code_cache ：在运行时存放应用产生的编译或者优化的代码<br>/data/data/包名/files ： 存放APP的文件信息</p>\n<p>还有其他一些文件，该内部存储文件在Debug模式下，使用Android Studio的Device File Explore工具可以进行访问；以release模式进行安装，则不能进行访问；对App进行反编译，以Debug模式运行则可以进入到该文件下访问；手机在Root模式下也可访问该文件（未进行测试）。</p>\n<p>私有目录和 Context 相关，所以使用 context.getExternalXXX获取目录</p>\n<p><code>context.getCacheDir()</code>用于获取缓存目录，当Android内存不足时，可以删除该目录进行空间</p>\n<h3 id=\"从assets目录下读取文件\"><a href=\"#从assets目录下读取文件\" class=\"headerlink\" title=\"从assets目录下读取文件\"></a>从assets目录下读取文件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder stringBuilder=<span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取assets资源管理器</span></span><br><span class=\"line\">    AssetManager assetManager=<span class=\"keyword\">this</span>.getAssets();</span><br><span class=\"line\">    <span class=\"comment\">//通过资源管理器打开文件并进行读取</span></span><br><span class=\"line\">    BufferedReader bufferedReader=<span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(</span><br><span class=\"line\">        assetManager.open(<span class=\"string\">&quot;test.txt&quot;</span>)</span><br><span class=\"line\">    ));</span><br><span class=\"line\"></span><br><span class=\"line\">    String line;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(((line =bufferedReader.readLine())!=<span class=\"keyword\">null</span>))&#123;</span><br><span class=\"line\">        stringBuilder.append(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件写操作\"><a href=\"#文件写操作\" class=\"headerlink\" title=\"文件写操作\"></a>文件写操作</h3><p>//将数据保存至文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String info=<span class=\"string\">&quot;example&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    FileWriter fileWriter =<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">&quot;/data/data/com.example&quot;</span>+<span class=\"string\">&quot;.txt&quot;</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    fileWriter.write(info);</span><br><span class=\"line\">    fileWriter.close();</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">   e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"文件保存完成后，直接对文件进行读取会抛出异常\"><a href=\"#文件保存完成后，直接对文件进行读取会抛出异常\" class=\"headerlink\" title=\"文件保存完成后，直接对文件进行读取会抛出异常\"></a>文件保存完成后，直接对文件进行读取会抛出异常</h4><p>解决该异常需要提醒媒体库刷新文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Uri localUri=Uri.fromFile(<span class=\"keyword\">new</span> File(filepath));</span><br><span class=\"line\"></span><br><span class=\"line\">Intent localIntent=<span class=\"keyword\">new</span> Intent(  Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,localUri);</span><br><span class=\"line\"></span><br><span class=\"line\">context.sendBroadcast(localIntent);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"><a href=\"#Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\" class=\"headerlink\" title=\"Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）\"></a>Android应用数据外部存储（保存至SD卡，也可以认为非应用安装目录）</h3><p>该目录使用需要获取用户权限，能被其他应用访问，当应用被卸载时，该目录不会被删除。</p>\n<ul>\n<li>首先需要获取权限</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--用于获取文件操作的权限--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要确定写入文件目录是否存在，如果不存在，则需要新建目录</li>\n</ul>\n<h3 id=\"Android存储公有目录\"><a href=\"#Android存储公有目录\" class=\"headerlink\" title=\"Android存储公有目录\"></a>Android存储公有目录</h3><p>Andorid开发公有目录与Context无关，使用Environment进行获取</p>\n<ul>\n<li>Environment.DIRECTORY_PICTURES 图片目录</li>\n<li>Environment.DIRECTORY_DCIM 相册目录</li>\n<li>Environment.DIRECTORY_DOCUMENTS 文档目录</li>\n<li>Environment.DIRECTORY_DOWNLOADS 下载目录</li>\n<li>Environment.DIRECTORY_MOVIES 视频</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory(String type) ;</span><br><span class=\"line\"><span class=\"comment\">//无参</span></span><br><span class=\"line\">Environment.getExternalStoragePublicDirectory();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Android本地文件选择\"><a href=\"#Android本地文件选择\" class=\"headerlink\" title=\"Android本地文件选择\"></a>Android本地文件选择</h3><h3 id=\"Android配置文件的读写\"><a href=\"#Android配置文件的读写\" class=\"headerlink\" title=\"Android配置文件的读写\"></a>Android配置文件的读写</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Properties props=<span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果配置文件位于 app/src/main/assets 文件夹下</span></span><br><span class=\"line\">    InputStream inputStream=context.getAssets().open(<span class=\"string\">&quot;config.properties&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//如果配置文件位于 app/src/main/res/raw 文件夹下</span></span><br><span class=\"line\">    InputStream inputStream=context.getResources().openRawResources(<span class=\"string\">&quot;config.properties&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//Java的写法</span></span><br><span class=\"line\">    InputStream inputStream=PropertiesFactory.class.getResourceAsStream(<span class=\"string\">&quot;assets/config.properties&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    props.load(inputStream);</span><br><span class=\"line\">    props.getProperty(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Android中使用的集合","description":"Android中使用的集合介绍","type":["Android"],"toc":true,"cover":"/cover/img101.jpg","date":"2019-05-15T16:00:00.000Z","_content":"## Android中使用的集合介绍\n\n### HashMap、ArrayMap和SparseArray\n\n1、HashMap本质上是一个基于HashMapEntry的数组，每个Entry的实体都包括:\n\n*  一个非基本类型的key\n*  一个非基本类型的value\n*  一个key的Hashcode\n*  指向下一个Entry的指针\n\n\n```java\n  final K key;\n  V value;\n  HashMapEntry<K,V> next;\n  int hash;\n\n```\n\n因为使用泛型，所以不能使用基本类型作为key和value，当插入基本类型时，会产生自动装箱操作\n查找的时间复杂度为O(1)\n\n\n\nHashMap的缺点\n\n* 自动装箱意味着需要产生额外的对象，这对于内存的使用和垃圾回收产生影响。\n* HashMapEntity自己本身也会产生额外的对象，这同样会影响内存的使用和垃圾回收产生。\n* 每次HashMap的存储对象减少或都增加的时候，这个开销会随着Hashmap的size增加而增加。\n* 需要存储它的key和对应的hash值。这种冗余有助于解决冲突。 \n*\n\n2、android.util.ArrayMap\n\nArrayMap用了两个数组，在其内部使用`Object[] mArray`来存储object,使用`int[] mHashes`来存储hashCode，相对于HashMap来说，每一次put会少创建一个对象 HashMapEntry\n\n* Key/Value可以被自动装箱\n* Key和Value在mArray中交叉存储，key在 2 index位置，value在 2 index+1的位置；\n* Key的哈希值会被计算出来并存储在mHashed[]中\n* 在查找时，计算key的hashcode并在，mHashes[]中对hashcode进行二分法查找，时间复杂度为O(logN)\n\n\n\n\n3、android.support.v4.util.ArrayMap\n\nandroid.util.ArrayMap只能在api不小于19（Kitkat）的平台才能使用。而Support library则支持在旧平台上提供相同的功能。\n4、android.support.v4.util.SimpleArrayMap\n\n这个类没有entrySet()这个支持迭代的方法,java标准集合中方法大部分也没有，有助于减少大部分没有使用的Collection api代码，内部工作和android.util.ArrayMap是一样的\n \n5、android.util.SparseArray\n\n其与ArrayMap一样，里面也是两个数组，一个int[] mKeys和Object[] mValues\n\nSparseArray只接受 int 类型作为key，\n\n注：\n\n* key(不是hashcode)保存在 mKeys[]的下一个可用位置上，所以不会对key进行自动装箱\n* value保存在  mValues[] 的下一个可用的位置上，如果其是基本类型，需要进行自动装箱\n* 查找key采用二分法查找，时间复杂度为O(logN)\n* 相较于HashMap，放弃了HashCode并依赖于二分查找，在添加和删除操作时会有更好的性能\n\n6、android.util.LongSparseArray\n\n实现原理与android.util.SparseArray一致，其key为long类型\n\n7、android.util.SparseBooleanArray\n\n实现原理与android.util.SparseArray一致，其key为boolean类型\n\n\n\n\n注：\n\n* ArrayMap和SparseArray不能保证保留它们的插入顺序，在迭代的时候应该注意。\n\n\nMap在put时创建对象的个数 HashMap>ArrayMap>SparseArray\n\n||HashMap|ArrayMap|SparseArray|\n| ------ | ------ | ------ | ------ |\n|put创建对象个数|3|2|0|\n|是否装箱|是|是|否|\n|查找时间复杂度|O(1)|O(logN)|O(logN)|\n\n","source":"_posts/Android/Android基础/Android集合.md","raw":"---\ntitle: \"Android中使用的集合\"\ndescription: \"Android中使用的集合介绍\"\ntype: [Android]\ntoc: true\ncover:  /cover/img101.jpg\ncategories: Android\ndate: 2019/5/16\n---\n## Android中使用的集合介绍\n\n### HashMap、ArrayMap和SparseArray\n\n1、HashMap本质上是一个基于HashMapEntry的数组，每个Entry的实体都包括:\n\n*  一个非基本类型的key\n*  一个非基本类型的value\n*  一个key的Hashcode\n*  指向下一个Entry的指针\n\n\n```java\n  final K key;\n  V value;\n  HashMapEntry<K,V> next;\n  int hash;\n\n```\n\n因为使用泛型，所以不能使用基本类型作为key和value，当插入基本类型时，会产生自动装箱操作\n查找的时间复杂度为O(1)\n\n\n\nHashMap的缺点\n\n* 自动装箱意味着需要产生额外的对象，这对于内存的使用和垃圾回收产生影响。\n* HashMapEntity自己本身也会产生额外的对象，这同样会影响内存的使用和垃圾回收产生。\n* 每次HashMap的存储对象减少或都增加的时候，这个开销会随着Hashmap的size增加而增加。\n* 需要存储它的key和对应的hash值。这种冗余有助于解决冲突。 \n*\n\n2、android.util.ArrayMap\n\nArrayMap用了两个数组，在其内部使用`Object[] mArray`来存储object,使用`int[] mHashes`来存储hashCode，相对于HashMap来说，每一次put会少创建一个对象 HashMapEntry\n\n* Key/Value可以被自动装箱\n* Key和Value在mArray中交叉存储，key在 2 index位置，value在 2 index+1的位置；\n* Key的哈希值会被计算出来并存储在mHashed[]中\n* 在查找时，计算key的hashcode并在，mHashes[]中对hashcode进行二分法查找，时间复杂度为O(logN)\n\n\n\n\n3、android.support.v4.util.ArrayMap\n\nandroid.util.ArrayMap只能在api不小于19（Kitkat）的平台才能使用。而Support library则支持在旧平台上提供相同的功能。\n4、android.support.v4.util.SimpleArrayMap\n\n这个类没有entrySet()这个支持迭代的方法,java标准集合中方法大部分也没有，有助于减少大部分没有使用的Collection api代码，内部工作和android.util.ArrayMap是一样的\n \n5、android.util.SparseArray\n\n其与ArrayMap一样，里面也是两个数组，一个int[] mKeys和Object[] mValues\n\nSparseArray只接受 int 类型作为key，\n\n注：\n\n* key(不是hashcode)保存在 mKeys[]的下一个可用位置上，所以不会对key进行自动装箱\n* value保存在  mValues[] 的下一个可用的位置上，如果其是基本类型，需要进行自动装箱\n* 查找key采用二分法查找，时间复杂度为O(logN)\n* 相较于HashMap，放弃了HashCode并依赖于二分查找，在添加和删除操作时会有更好的性能\n\n6、android.util.LongSparseArray\n\n实现原理与android.util.SparseArray一致，其key为long类型\n\n7、android.util.SparseBooleanArray\n\n实现原理与android.util.SparseArray一致，其key为boolean类型\n\n\n\n\n注：\n\n* ArrayMap和SparseArray不能保证保留它们的插入顺序，在迭代的时候应该注意。\n\n\nMap在put时创建对象的个数 HashMap>ArrayMap>SparseArray\n\n||HashMap|ArrayMap|SparseArray|\n| ------ | ------ | ------ | ------ |\n|put创建对象个数|3|2|0|\n|是否装箱|是|是|否|\n|查找时间复杂度|O(1)|O(logN)|O(logN)|\n\n","slug":"Android/Android基础/Android集合","published":1,"updated":"2021-01-06T00:57:12.822Z","_id":"ckjju0m1a003w20uacdl80df8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android中使用的集合介绍\"><a href=\"#Android中使用的集合介绍\" class=\"headerlink\" title=\"Android中使用的集合介绍\"></a>Android中使用的集合介绍</h2><h3 id=\"HashMap、ArrayMap和SparseArray\"><a href=\"#HashMap、ArrayMap和SparseArray\" class=\"headerlink\" title=\"HashMap、ArrayMap和SparseArray\"></a>HashMap、ArrayMap和SparseArray</h3><p>1、HashMap本质上是一个基于HashMapEntry的数组，每个Entry的实体都包括:</p>\n<ul>\n<li> 一个非基本类型的key</li>\n<li> 一个非基本类型的value</li>\n<li> 一个key的Hashcode</li>\n<li> 指向下一个Entry的指针</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">V value;</span><br><span class=\"line\">HashMapEntry&lt;K,V&gt; next;</span><br><span class=\"line\"><span class=\"keyword\">int</span> hash;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为使用泛型，所以不能使用基本类型作为key和value，当插入基本类型时，会产生自动装箱操作<br>查找的时间复杂度为O(1)</p>\n<p>HashMap的缺点</p>\n<ul>\n<li>自动装箱意味着需要产生额外的对象，这对于内存的使用和垃圾回收产生影响。</li>\n<li>HashMapEntity自己本身也会产生额外的对象，这同样会影响内存的使用和垃圾回收产生。</li>\n<li>每次HashMap的存储对象减少或都增加的时候，这个开销会随着Hashmap的size增加而增加。</li>\n<li>需要存储它的key和对应的hash值。这种冗余有助于解决冲突。 </li>\n<li></li>\n</ul>\n<p>2、android.util.ArrayMap</p>\n<p>ArrayMap用了两个数组，在其内部使用<code>Object[] mArray</code>来存储object,使用<code>int[] mHashes</code>来存储hashCode，相对于HashMap来说，每一次put会少创建一个对象 HashMapEntry</p>\n<ul>\n<li>Key/Value可以被自动装箱</li>\n<li>Key和Value在mArray中交叉存储，key在 2 index位置，value在 2 index+1的位置；</li>\n<li>Key的哈希值会被计算出来并存储在mHashed[]中</li>\n<li>在查找时，计算key的hashcode并在，mHashes[]中对hashcode进行二分法查找，时间复杂度为O(logN)</li>\n</ul>\n<p>3、android.support.v4.util.ArrayMap</p>\n<p>android.util.ArrayMap只能在api不小于19（Kitkat）的平台才能使用。而Support library则支持在旧平台上提供相同的功能。<br>4、android.support.v4.util.SimpleArrayMap</p>\n<p>这个类没有entrySet()这个支持迭代的方法,java标准集合中方法大部分也没有，有助于减少大部分没有使用的Collection api代码，内部工作和android.util.ArrayMap是一样的</p>\n<p>5、android.util.SparseArray</p>\n<p>其与ArrayMap一样，里面也是两个数组，一个int[] mKeys和Object[] mValues</p>\n<p>SparseArray只接受 int 类型作为key，</p>\n<p>注：</p>\n<ul>\n<li>key(不是hashcode)保存在 mKeys[]的下一个可用位置上，所以不会对key进行自动装箱</li>\n<li>value保存在  mValues[] 的下一个可用的位置上，如果其是基本类型，需要进行自动装箱</li>\n<li>查找key采用二分法查找，时间复杂度为O(logN)</li>\n<li>相较于HashMap，放弃了HashCode并依赖于二分查找，在添加和删除操作时会有更好的性能</li>\n</ul>\n<p>6、android.util.LongSparseArray</p>\n<p>实现原理与android.util.SparseArray一致，其key为long类型</p>\n<p>7、android.util.SparseBooleanArray</p>\n<p>实现原理与android.util.SparseArray一致，其key为boolean类型</p>\n<p>注：</p>\n<ul>\n<li>ArrayMap和SparseArray不能保证保留它们的插入顺序，在迭代的时候应该注意。</li>\n</ul>\n<p>Map在put时创建对象的个数 HashMap&gt;ArrayMap&gt;SparseArray</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>HashMap</th>\n<th>ArrayMap</th>\n<th>SparseArray</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>put创建对象个数</td>\n<td>3</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>是否装箱</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>查找时间复杂度</td>\n<td>O(1)</td>\n<td>O(logN)</td>\n<td>O(logN)</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android中使用的集合介绍\"><a href=\"#Android中使用的集合介绍\" class=\"headerlink\" title=\"Android中使用的集合介绍\"></a>Android中使用的集合介绍</h2><h3 id=\"HashMap、ArrayMap和SparseArray\"><a href=\"#HashMap、ArrayMap和SparseArray\" class=\"headerlink\" title=\"HashMap、ArrayMap和SparseArray\"></a>HashMap、ArrayMap和SparseArray</h3><p>1、HashMap本质上是一个基于HashMapEntry的数组，每个Entry的实体都包括:</p>\n<ul>\n<li> 一个非基本类型的key</li>\n<li> 一个非基本类型的value</li>\n<li> 一个key的Hashcode</li>\n<li> 指向下一个Entry的指针</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">V value;</span><br><span class=\"line\">HashMapEntry&lt;K,V&gt; next;</span><br><span class=\"line\"><span class=\"keyword\">int</span> hash;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为使用泛型，所以不能使用基本类型作为key和value，当插入基本类型时，会产生自动装箱操作<br>查找的时间复杂度为O(1)</p>\n<p>HashMap的缺点</p>\n<ul>\n<li>自动装箱意味着需要产生额外的对象，这对于内存的使用和垃圾回收产生影响。</li>\n<li>HashMapEntity自己本身也会产生额外的对象，这同样会影响内存的使用和垃圾回收产生。</li>\n<li>每次HashMap的存储对象减少或都增加的时候，这个开销会随着Hashmap的size增加而增加。</li>\n<li>需要存储它的key和对应的hash值。这种冗余有助于解决冲突。 </li>\n<li></li>\n</ul>\n<p>2、android.util.ArrayMap</p>\n<p>ArrayMap用了两个数组，在其内部使用<code>Object[] mArray</code>来存储object,使用<code>int[] mHashes</code>来存储hashCode，相对于HashMap来说，每一次put会少创建一个对象 HashMapEntry</p>\n<ul>\n<li>Key/Value可以被自动装箱</li>\n<li>Key和Value在mArray中交叉存储，key在 2 index位置，value在 2 index+1的位置；</li>\n<li>Key的哈希值会被计算出来并存储在mHashed[]中</li>\n<li>在查找时，计算key的hashcode并在，mHashes[]中对hashcode进行二分法查找，时间复杂度为O(logN)</li>\n</ul>\n<p>3、android.support.v4.util.ArrayMap</p>\n<p>android.util.ArrayMap只能在api不小于19（Kitkat）的平台才能使用。而Support library则支持在旧平台上提供相同的功能。<br>4、android.support.v4.util.SimpleArrayMap</p>\n<p>这个类没有entrySet()这个支持迭代的方法,java标准集合中方法大部分也没有，有助于减少大部分没有使用的Collection api代码，内部工作和android.util.ArrayMap是一样的</p>\n<p>5、android.util.SparseArray</p>\n<p>其与ArrayMap一样，里面也是两个数组，一个int[] mKeys和Object[] mValues</p>\n<p>SparseArray只接受 int 类型作为key，</p>\n<p>注：</p>\n<ul>\n<li>key(不是hashcode)保存在 mKeys[]的下一个可用位置上，所以不会对key进行自动装箱</li>\n<li>value保存在  mValues[] 的下一个可用的位置上，如果其是基本类型，需要进行自动装箱</li>\n<li>查找key采用二分法查找，时间复杂度为O(logN)</li>\n<li>相较于HashMap，放弃了HashCode并依赖于二分查找，在添加和删除操作时会有更好的性能</li>\n</ul>\n<p>6、android.util.LongSparseArray</p>\n<p>实现原理与android.util.SparseArray一致，其key为long类型</p>\n<p>7、android.util.SparseBooleanArray</p>\n<p>实现原理与android.util.SparseArray一致，其key为boolean类型</p>\n<p>注：</p>\n<ul>\n<li>ArrayMap和SparseArray不能保证保留它们的插入顺序，在迭代的时候应该注意。</li>\n</ul>\n<p>Map在put时创建对象的个数 HashMap&gt;ArrayMap&gt;SparseArray</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>HashMap</th>\n<th>ArrayMap</th>\n<th>SparseArray</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>put创建对象个数</td>\n<td>3</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>是否装箱</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>查找时间复杂度</td>\n<td>O(1)</td>\n<td>O(logN)</td>\n<td>O(logN)</td>\n</tr>\n</tbody></table>\n"},{"title":"getSystemService的使用","cover":"/cover/img12.jpg","toc":true,"description":"getSystemService的使用","type":["Android"],"date":"2019-09-29T16:00:00.000Z","_content":"\ngetSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；\n<!--more-->\n|传入的Name|返回的对象|说明|\n|------|------|------|\n|WINDOW_SERVICE|WindowManager|管理打开的窗口程序|\n|LAYOUT_INFLATER_SERVICE|\tLayoutInflater\t|取得xml里定义的view\n|ACTIVITY_SERVICE\t|ActivityManager\t|管理应用程序的系统状态\n|POWER_SERVICE\t|PowerManger\t|电源的服务\n|ALARM_SERVICE\t|AlarmManager|\t闹钟的服务\n|NOTIFICATION_SERVICE\t|NotificationManager\t|状态栏的服务\n|KEYGUARD_SERVICE\t|KeyguardManager\t|键盘锁的服务\n|LOCATION_SERVICE\t|LocationManager\t|位置的服务，如GPS\n|SEARCH_SERVICE\t|SearchManager\t|搜索的服务\n|VEBRATOR_SERVICE|\tVebrator|\t手机震动的服务\n|CONNECTIVITY_SERVICE\t|Connectivity\t|网络连接的服务\n|WIFI_SERVICE\t|WifiManager\t|Wi-Fi服务\n|TELEPHONY_SERVICE\t|TeleponyManager\t|电话服务","source":"_posts/Android/Android基础/getSystemService的使用.md","raw":"---\ntitle: getSystemService的使用\ncover: /cover/img12.jpg\ntoc: true\ndescription: getSystemService的使用\ntype: [Android]\ncategories: Android\ndate: 2019/09/30\n---\n\ngetSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；\n<!--more-->\n|传入的Name|返回的对象|说明|\n|------|------|------|\n|WINDOW_SERVICE|WindowManager|管理打开的窗口程序|\n|LAYOUT_INFLATER_SERVICE|\tLayoutInflater\t|取得xml里定义的view\n|ACTIVITY_SERVICE\t|ActivityManager\t|管理应用程序的系统状态\n|POWER_SERVICE\t|PowerManger\t|电源的服务\n|ALARM_SERVICE\t|AlarmManager|\t闹钟的服务\n|NOTIFICATION_SERVICE\t|NotificationManager\t|状态栏的服务\n|KEYGUARD_SERVICE\t|KeyguardManager\t|键盘锁的服务\n|LOCATION_SERVICE\t|LocationManager\t|位置的服务，如GPS\n|SEARCH_SERVICE\t|SearchManager\t|搜索的服务\n|VEBRATOR_SERVICE|\tVebrator|\t手机震动的服务\n|CONNECTIVITY_SERVICE\t|Connectivity\t|网络连接的服务\n|WIFI_SERVICE\t|WifiManager\t|Wi-Fi服务\n|TELEPHONY_SERVICE\t|TeleponyManager\t|电话服务","slug":"Android/Android基础/getSystemService的使用","published":1,"updated":"2021-01-05T12:13:58.053Z","_id":"ckjju0m1b003z20ua5ati36g6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；</p>\n<a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th>传入的Name</th>\n<th>返回的对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WINDOW_SERVICE</td>\n<td>WindowManager</td>\n<td>管理打开的窗口程序</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td>LayoutInflater</td>\n<td>取得xml里定义的view</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td>ActivityManager</td>\n<td>管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td>PowerManger</td>\n<td>电源的服务</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td>AlarmManager</td>\n<td>闹钟的服务</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td>NotificationManager</td>\n<td>状态栏的服务</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td>KeyguardManager</td>\n<td>键盘锁的服务</td>\n</tr>\n<tr>\n<td>LOCATION_SERVICE</td>\n<td>LocationManager</td>\n<td>位置的服务，如GPS</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td>SearchManager</td>\n<td>搜索的服务</td>\n</tr>\n<tr>\n<td>VEBRATOR_SERVICE</td>\n<td>Vebrator</td>\n<td>手机震动的服务</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td>Connectivity</td>\n<td>网络连接的服务</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td>WifiManager</td>\n<td>Wi-Fi服务</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td>TeleponyManager</td>\n<td>电话服务</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>getSystemService是Activity的一个方法，根据传入的name得到对应的Object,然后转换成相应的服务对象；</p>","more":"<table>\n<thead>\n<tr>\n<th>传入的Name</th>\n<th>返回的对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WINDOW_SERVICE</td>\n<td>WindowManager</td>\n<td>管理打开的窗口程序</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td>LayoutInflater</td>\n<td>取得xml里定义的view</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td>ActivityManager</td>\n<td>管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td>PowerManger</td>\n<td>电源的服务</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td>AlarmManager</td>\n<td>闹钟的服务</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td>NotificationManager</td>\n<td>状态栏的服务</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td>KeyguardManager</td>\n<td>键盘锁的服务</td>\n</tr>\n<tr>\n<td>LOCATION_SERVICE</td>\n<td>LocationManager</td>\n<td>位置的服务，如GPS</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td>SearchManager</td>\n<td>搜索的服务</td>\n</tr>\n<tr>\n<td>VEBRATOR_SERVICE</td>\n<td>Vebrator</td>\n<td>手机震动的服务</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td>Connectivity</td>\n<td>网络连接的服务</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td>WifiManager</td>\n<td>Wi-Fi服务</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td>TeleponyManager</td>\n<td>电话服务</td>\n</tr>\n</tbody></table>"},{"title":"Android 定位","description":"Android 定位实现","type":["Android"],"toc":true,"cover":"/cover/img85.jpg","date":"2019-04-04T16:00:00.000Z","_content":"\n## Android 原生定位\n\nAndroid 的原生定位主要有以下几种\n\n### network: LocationManager.NETWORK_PROVIDER\n\n通过网络来进行定位，低精度、低耗电模式的定位，可通过Wifi或4g进行适配定位。使用网络定位，在国内不可行，通常使用第三方定位服务；原因如下：\n<!--more-->\n* network 需要连接谷歌服务器，且定位不准确。\n\n### gps: LocationManager.GPS_PROVIDER \n\n通过GPS定位，高精度、高耗电定位模式，只能用于室外,可在无网络的状态下使用。\n\n### passive: LocationManager.PASSIVE_PROVIDER\n\n被动定位模式，依赖其他APP的定位信息，需要获取`android.Manifest.permission.ACCESS_FINE_LOCATION`权限\n\n## 在Android P上利用802.11 mc协议以及RTT实现Wifi室内定位\n\nAndroid 9 需要具有硬件支持\n\n\n## Android原生定位实现\n\n\n\n## 地图使用过程中遇到的问题\n\n### 百度地图在连续定位的过程中只定位一次\n\n```xml\n  <service android:name=\"com.baidu.location.f\" android:enabled=\"true\" android:process=\":remote\">\n   </service>\n```","source":"_posts/Android/Android基础/定位.md","raw":"---\ntitle: \"Android 定位\"\ndescription: \"Android 定位实现\"\ntype: [Android]\ntoc: true\ncover: /cover/img85.jpg\ncategories: Android\ndate: 2019/04/05\n---\n\n## Android 原生定位\n\nAndroid 的原生定位主要有以下几种\n\n### network: LocationManager.NETWORK_PROVIDER\n\n通过网络来进行定位，低精度、低耗电模式的定位，可通过Wifi或4g进行适配定位。使用网络定位，在国内不可行，通常使用第三方定位服务；原因如下：\n<!--more-->\n* network 需要连接谷歌服务器，且定位不准确。\n\n### gps: LocationManager.GPS_PROVIDER \n\n通过GPS定位，高精度、高耗电定位模式，只能用于室外,可在无网络的状态下使用。\n\n### passive: LocationManager.PASSIVE_PROVIDER\n\n被动定位模式，依赖其他APP的定位信息，需要获取`android.Manifest.permission.ACCESS_FINE_LOCATION`权限\n\n## 在Android P上利用802.11 mc协议以及RTT实现Wifi室内定位\n\nAndroid 9 需要具有硬件支持\n\n\n## Android原生定位实现\n\n\n\n## 地图使用过程中遇到的问题\n\n### 百度地图在连续定位的过程中只定位一次\n\n```xml\n  <service android:name=\"com.baidu.location.f\" android:enabled=\"true\" android:process=\":remote\">\n   </service>\n```","slug":"Android/Android基础/定位","published":1,"updated":"2021-01-05T12:13:58.656Z","_id":"ckjju0m1b004220ua7x3ea7r5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android-原生定位\"><a href=\"#Android-原生定位\" class=\"headerlink\" title=\"Android 原生定位\"></a>Android 原生定位</h2><p>Android 的原生定位主要有以下几种</p>\n<h3 id=\"network-LocationManager-NETWORK-PROVIDER\"><a href=\"#network-LocationManager-NETWORK-PROVIDER\" class=\"headerlink\" title=\"network: LocationManager.NETWORK_PROVIDER\"></a>network: LocationManager.NETWORK_PROVIDER</h3><p>通过网络来进行定位，低精度、低耗电模式的定位，可通过Wifi或4g进行适配定位。使用网络定位，在国内不可行，通常使用第三方定位服务；原因如下：</p>\n<a id=\"more\"></a>\n<ul>\n<li>network 需要连接谷歌服务器，且定位不准确。</li>\n</ul>\n<h3 id=\"gps-LocationManager-GPS-PROVIDER\"><a href=\"#gps-LocationManager-GPS-PROVIDER\" class=\"headerlink\" title=\"gps: LocationManager.GPS_PROVIDER\"></a>gps: LocationManager.GPS_PROVIDER</h3><p>通过GPS定位，高精度、高耗电定位模式，只能用于室外,可在无网络的状态下使用。</p>\n<h3 id=\"passive-LocationManager-PASSIVE-PROVIDER\"><a href=\"#passive-LocationManager-PASSIVE-PROVIDER\" class=\"headerlink\" title=\"passive: LocationManager.PASSIVE_PROVIDER\"></a>passive: LocationManager.PASSIVE_PROVIDER</h3><p>被动定位模式，依赖其他APP的定位信息，需要获取<code>android.Manifest.permission.ACCESS_FINE_LOCATION</code>权限</p>\n<h2 id=\"在Android-P上利用802-11-mc协议以及RTT实现Wifi室内定位\"><a href=\"#在Android-P上利用802-11-mc协议以及RTT实现Wifi室内定位\" class=\"headerlink\" title=\"在Android P上利用802.11 mc协议以及RTT实现Wifi室内定位\"></a>在Android P上利用802.11 mc协议以及RTT实现Wifi室内定位</h2><p>Android 9 需要具有硬件支持</p>\n<h2 id=\"Android原生定位实现\"><a href=\"#Android原生定位实现\" class=\"headerlink\" title=\"Android原生定位实现\"></a>Android原生定位实现</h2><h2 id=\"地图使用过程中遇到的问题\"><a href=\"#地图使用过程中遇到的问题\" class=\"headerlink\" title=\"地图使用过程中遇到的问题\"></a>地图使用过程中遇到的问题</h2><h3 id=\"百度地图在连续定位的过程中只定位一次\"><a href=\"#百度地图在连续定位的过程中只定位一次\" class=\"headerlink\" title=\"百度地图在连续定位的过程中只定位一次\"></a>百度地图在连续定位的过程中只定位一次</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.baidu.location.f&quot;</span> <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:remote&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">service</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Android-原生定位\"><a href=\"#Android-原生定位\" class=\"headerlink\" title=\"Android 原生定位\"></a>Android 原生定位</h2><p>Android 的原生定位主要有以下几种</p>\n<h3 id=\"network-LocationManager-NETWORK-PROVIDER\"><a href=\"#network-LocationManager-NETWORK-PROVIDER\" class=\"headerlink\" title=\"network: LocationManager.NETWORK_PROVIDER\"></a>network: LocationManager.NETWORK_PROVIDER</h3><p>通过网络来进行定位，低精度、低耗电模式的定位，可通过Wifi或4g进行适配定位。使用网络定位，在国内不可行，通常使用第三方定位服务；原因如下：</p>","more":"<ul>\n<li>network 需要连接谷歌服务器，且定位不准确。</li>\n</ul>\n<h3 id=\"gps-LocationManager-GPS-PROVIDER\"><a href=\"#gps-LocationManager-GPS-PROVIDER\" class=\"headerlink\" title=\"gps: LocationManager.GPS_PROVIDER\"></a>gps: LocationManager.GPS_PROVIDER</h3><p>通过GPS定位，高精度、高耗电定位模式，只能用于室外,可在无网络的状态下使用。</p>\n<h3 id=\"passive-LocationManager-PASSIVE-PROVIDER\"><a href=\"#passive-LocationManager-PASSIVE-PROVIDER\" class=\"headerlink\" title=\"passive: LocationManager.PASSIVE_PROVIDER\"></a>passive: LocationManager.PASSIVE_PROVIDER</h3><p>被动定位模式，依赖其他APP的定位信息，需要获取<code>android.Manifest.permission.ACCESS_FINE_LOCATION</code>权限</p>\n<h2 id=\"在Android-P上利用802-11-mc协议以及RTT实现Wifi室内定位\"><a href=\"#在Android-P上利用802-11-mc协议以及RTT实现Wifi室内定位\" class=\"headerlink\" title=\"在Android P上利用802.11 mc协议以及RTT实现Wifi室内定位\"></a>在Android P上利用802.11 mc协议以及RTT实现Wifi室内定位</h2><p>Android 9 需要具有硬件支持</p>\n<h2 id=\"Android原生定位实现\"><a href=\"#Android原生定位实现\" class=\"headerlink\" title=\"Android原生定位实现\"></a>Android原生定位实现</h2><h2 id=\"地图使用过程中遇到的问题\"><a href=\"#地图使用过程中遇到的问题\" class=\"headerlink\" title=\"地图使用过程中遇到的问题\"></a>地图使用过程中遇到的问题</h2><h3 id=\"百度地图在连续定位的过程中只定位一次\"><a href=\"#百度地图在连续定位的过程中只定位一次\" class=\"headerlink\" title=\"百度地图在连续定位的过程中只定位一次\"></a>百度地图在连续定位的过程中只定位一次</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.baidu.location.f&quot;</span> <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:remote&quot;</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">service</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"Android开发过程中注意问题","description":"Android开发过程中注意问题","type":["Android"],"toc":true,"cover":"/cover/img102.jpg","date":"2019-05-15T16:00:00.000Z","_content":"","source":"_posts/Android/Android基础/开发过程中注意问题.md","raw":"---\ntitle: \"Android开发过程中注意问题\"\ndescription: \"Android开发过程中注意问题\"\ntype: [Android]\ntoc: true\ncover:  /cover/img102.jpg\ncategories: Android\ndate: 2019/5/16\n---\n","slug":"Android/Android基础/开发过程中注意问题","published":1,"updated":"2021-01-06T00:58:02.557Z","_id":"ckjju0m1c004520ua6egy1e7s","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"AsyncTask异步操作","cover":"/cover/img14.jpg","toc":true,"description":"AsyncTask异步操作","type":["Android"],"date":"2019-08-19T16:00:00.000Z","_content":"\n**知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor**\n\n一个AsyncTask对象被创建出来后,就只能执行一个异步任务。\n<!--more-->\n\nAsyncTask<Params,Progress,Result>是一个抽象类，继承AsyncTask需要指定三个泛型参数\n* Params：启动任务时输入的参数类型\n* Progress：后台任务执行中返回进度值的类型\n* Result：后台任务执行完成后返回结果类型\n\nAsyncTask中三个重要函数\n\n* doInBackground：异步执行后台线程要完成的任务在此方法中进行\n* onPreExecute：执行后台耗时操作前调用，通常用于初始化操作\n* onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI\n* onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。\n","source":"_posts/Android/Android基础/异步操作Asynctask.md","raw":"---\ntitle: AsyncTask异步操作\ncover: /cover/img14.jpg\ntoc: true\ndescription: AsyncTask异步操作\ntype: [Android]\ncategories: Android\ndate: 2019/08/20\n---\n\n**知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor**\n\n一个AsyncTask对象被创建出来后,就只能执行一个异步任务。\n<!--more-->\n\nAsyncTask<Params,Progress,Result>是一个抽象类，继承AsyncTask需要指定三个泛型参数\n* Params：启动任务时输入的参数类型\n* Progress：后台任务执行中返回进度值的类型\n* Result：后台任务执行完成后返回结果类型\n\nAsyncTask中三个重要函数\n\n* doInBackground：异步执行后台线程要完成的任务在此方法中进行\n* onPreExecute：执行后台耗时操作前调用，通常用于初始化操作\n* onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI\n* onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。\n","slug":"Android/Android基础/异步操作Asynctask","published":1,"updated":"2021-01-05T12:13:59.686Z","_id":"ckjju0m1d004820uac2n46364","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor</strong></p>\n<p>一个AsyncTask对象被创建出来后,就只能执行一个异步任务。</p>\n<a id=\"more\"></a>\n\n<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数</p>\n<ul>\n<li>Params：启动任务时输入的参数类型</li>\n<li>Progress：后台任务执行中返回进度值的类型</li>\n<li>Result：后台任务执行完成后返回结果类型</li>\n</ul>\n<p>AsyncTask中三个重要函数</p>\n<ul>\n<li>doInBackground：异步执行后台线程要完成的任务在此方法中进行</li>\n<li>onPreExecute：执行后台耗时操作前调用，通常用于初始化操作</li>\n<li>onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI</li>\n<li>onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>知识点：AsyncTask适合短时间的异步操作，如果需要长时间操作，最好使用线程池Executor</strong></p>\n<p>一个AsyncTask对象被创建出来后,就只能执行一个异步任务。</p>","more":"<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类，继承AsyncTask需要指定三个泛型参数</p>\n<ul>\n<li>Params：启动任务时输入的参数类型</li>\n<li>Progress：后台任务执行中返回进度值的类型</li>\n<li>Result：后台任务执行完成后返回结果类型</li>\n</ul>\n<p>AsyncTask中三个重要函数</p>\n<ul>\n<li>doInBackground：异步执行后台线程要完成的任务在此方法中进行</li>\n<li>onPreExecute：执行后台耗时操作前调用，通常用于初始化操作</li>\n<li>onPostExecute：当doInbackground方法完成后，系统自动调用此方法，并将doInBackground方法的返回值传入此方法中，通过此方法更新UI</li>\n<li>onProgressUpdate：当在doInBackground方法中调用publishProgress方法更新任务进度后，可以在此方法中更细UI进度。</li>\n</ul>"},{"title":"Android 蓝牙4.0开发","cover":"/cover/img15.jpg","toc":true,"description":"Android 蓝牙4.0开发","type":["Android"],"date":"2019-09-18T16:00:00.000Z","_content":"# Android 蓝牙4.0开发\n\n这是一条优雅的分割线\n\n### 写在前面：\n\n本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0\n<!--more-->\n尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。\n\n\n### 首先对蓝牙进行非专业的介绍，\n\n蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！\n\n### 对GATT的介绍\n\n\n\n\n\n按照惯例先上代码\n\n优雅的代码\n\n##3 权限的获取\n\n蓝牙4.0有一个坑爹的权限是位置信息的获取\n\n\n### 蓝牙搜索\n蓝牙的搜索有三种方式\n* 方法一：`BluetoothAdapter.startDiscovery()`是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；\n蓝牙扫描广播接收器\n\n```java\n\n//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果\nprivate class DeviceReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if(BluetoothDevice.ACTION_FOUND.equals(action)){\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  \n        }\n    }\n}\n```\n\n* 方法二：`BluetoothAdapter.startScan(ScanCallback callback)`在`ScanCallback`的`onScanResult(int callbacktype, ScanResult result)`方法中，通过`result.getDevice()`可获取扫描到的Ble设备\n* 方法三：`BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)`\n  该方法已经被舍弃\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Ble/Android ble 4.0.md","raw":"---\ntitle: Android 蓝牙4.0开发\ncover: /cover/img15.jpg\ntoc: true\ndescription: Android 蓝牙4.0开发\ntype: [Android]\ncategories: Android\ndate: 2019/09/19\n---\n# Android 蓝牙4.0开发\n\n这是一条优雅的分割线\n\n### 写在前面：\n\n本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0\n<!--more-->\n尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。\n\n\n### 首先对蓝牙进行非专业的介绍，\n\n蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！\n\n### 对GATT的介绍\n\n\n\n\n\n按照惯例先上代码\n\n优雅的代码\n\n##3 权限的获取\n\n蓝牙4.0有一个坑爹的权限是位置信息的获取\n\n\n### 蓝牙搜索\n蓝牙的搜索有三种方式\n* 方法一：`BluetoothAdapter.startDiscovery()`是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；\n蓝牙扫描广播接收器\n\n```java\n\n//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果\nprivate class DeviceReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        if(BluetoothDevice.ACTION_FOUND.equals(action)){\n            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  \n        }\n    }\n}\n```\n\n* 方法二：`BluetoothAdapter.startScan(ScanCallback callback)`在`ScanCallback`的`onScanResult(int callbacktype, ScanResult result)`方法中，通过`result.getDevice()`可获取扫描到的Ble设备\n* 方法三：`BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)`\n  该方法已经被舍弃\n\n\n\n\n\n\n\n\n\n","slug":"Android/Ble/Android ble 4.0","published":1,"updated":"2021-01-05T12:14:00.044Z","_id":"ckjju0m1d004b20uab0dug3c8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android-蓝牙4-0开发\"><a href=\"#Android-蓝牙4-0开发\" class=\"headerlink\" title=\"Android 蓝牙4.0开发\"></a>Android 蓝牙4.0开发</h1><p>这是一条优雅的分割线</p>\n<h3 id=\"写在前面：\"><a href=\"#写在前面：\" class=\"headerlink\" title=\"写在前面：\"></a>写在前面：</h3><p>本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0</p>\n<a id=\"more\"></a>\n<p>尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。</p>\n<h3 id=\"首先对蓝牙进行非专业的介绍，\"><a href=\"#首先对蓝牙进行非专业的介绍，\" class=\"headerlink\" title=\"首先对蓝牙进行非专业的介绍，\"></a>首先对蓝牙进行非专业的介绍，</h3><p>蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！</p>\n<h3 id=\"对GATT的介绍\"><a href=\"#对GATT的介绍\" class=\"headerlink\" title=\"对GATT的介绍\"></a>对GATT的介绍</h3><p>按照惯例先上代码</p>\n<p>优雅的代码</p>\n<p>##3 权限的获取</p>\n<p>蓝牙4.0有一个坑爹的权限是位置信息的获取</p>\n<h3 id=\"蓝牙搜索\"><a href=\"#蓝牙搜索\" class=\"headerlink\" title=\"蓝牙搜索\"></a>蓝牙搜索</h3><p>蓝牙的搜索有三种方式</p>\n<ul>\n<li>方法一：<code>BluetoothAdapter.startDiscovery()</code>是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；<br>蓝牙扫描广播接收器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeviceReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BluetoothDevice.ACTION_FOUND.equals(action))&#123;</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法二：<code>BluetoothAdapter.startScan(ScanCallback callback)</code>在<code>ScanCallback</code>的<code>onScanResult(int callbacktype, ScanResult result)</code>方法中，通过<code>result.getDevice()</code>可获取扫描到的Ble设备</li>\n<li>方法三：<code>BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)</code><br>该方法已经被舍弃</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-蓝牙4-0开发\"><a href=\"#Android-蓝牙4-0开发\" class=\"headerlink\" title=\"Android 蓝牙4.0开发\"></a>Android 蓝牙4.0开发</h1><p>这是一条优雅的分割线</p>\n<h3 id=\"写在前面：\"><a href=\"#写在前面：\" class=\"headerlink\" title=\"写在前面：\"></a>写在前面：</h3><p>本篇教程使用的蓝牙版本为4.0，测试系统版本为Android 7.0</p>","more":"<p>尽管蓝牙已经推出5.0版本了，不过目前手机上大部分适配的还是4.0 4.2，但蓝牙的教程以及Demo还是较少，尤其是可以运行的Demo,现有的Demo中以及教程中没有注明可以使用的版本以及运行的环境。</p>\n<h3 id=\"首先对蓝牙进行非专业的介绍，\"><a href=\"#首先对蓝牙进行非专业的介绍，\" class=\"headerlink\" title=\"首先对蓝牙进行非专业的介绍，\"></a>首先对蓝牙进行非专业的介绍，</h3><p>蓝牙4.0又被称为低功耗蓝牙，即BLE，是基于GATT协议实现，而蓝牙4.0以下是传统蓝牙，基于socket的方式实现。所以蓝牙4.0以上没有使用官方文档介绍的 BluetoothSocket，敲重点！！！！</p>\n<h3 id=\"对GATT的介绍\"><a href=\"#对GATT的介绍\" class=\"headerlink\" title=\"对GATT的介绍\"></a>对GATT的介绍</h3><p>按照惯例先上代码</p>\n<p>优雅的代码</p>\n<p>##3 权限的获取</p>\n<p>蓝牙4.0有一个坑爹的权限是位置信息的获取</p>\n<h3 id=\"蓝牙搜索\"><a href=\"#蓝牙搜索\" class=\"headerlink\" title=\"蓝牙搜索\"></a>蓝牙搜索</h3><p>蓝牙的搜索有三种方式</p>\n<ul>\n<li>方法一：<code>BluetoothAdapter.startDiscovery()</code>是通用的扫描方法，扫描时间持续10秒后会自动停止；当扫描到蓝牙设备后，会发出广播通知；<br>蓝牙扫描广播接收器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册此广播，监听BluetoothDevice.ACTION_FOUND，以接收系统消息取得扫描结果</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeviceReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        String action = intent.getAction();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BluetoothDevice.ACTION_FOUND.equals(action))&#123;</span><br><span class=\"line\">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法二：<code>BluetoothAdapter.startScan(ScanCallback callback)</code>在<code>ScanCallback</code>的<code>onScanResult(int callbacktype, ScanResult result)</code>方法中，通过<code>result.getDevice()</code>可获取扫描到的Ble设备</li>\n<li>方法三：<code>BluetoothAdapter.startLeScan(BluetoothAdapter.LeScanCallback callback)</code><br>该方法已经被舍弃</li>\n</ul>"},{"title":"Android架构设计","type":["Android"],"description":"Android架构设计","cover":"/cover/img87.jpg","toc":true,"date":"2018-08-24T16:00:00.000Z","_content":"\n### MVC模式\n\n用户操作交给Controler（Activity） —— 》 \n\nView : 视图层，面向用户渲染画面UI —— 》 Layout自定义View\nModel: 模型层，面向需求模型，数据模型 —— 》Beans实体类SqliteDatabase\nController: 控制层，面向业务逻辑具体操作  —— 》Activity Network网络具体业务逻辑 \n\n1、View接收到用户的操作\n2、View将用户的操作，交给Controller 即Activity\n        Model和View之间的联系紧密，耦合性太强，Activity负责的内容太多\n3、Controller完成具体业务逻辑\n4、得到封装Model,再进行View更新 \n\nMVC模式容易发生内存泄露：\n    在Control层使员工耗时操作，Activity退出后，线程依然存在\n\n### MVP模式\n\nView —— 》 Acivity\n\n\n1、View收到用户操作\n2、View把用户的操作交给Presenter\n3、Presenter控制Model进行业务逻辑处理\n4、Presenter处理完毕后，数据封装到Model\n5、Presenter收到通知后，再更新View\n\n方式：双向通信的方式\n\n优点：\n* View与Model层完全分离\n* 所有的逻辑交互都在Presenter\n* MVP分层严谨\n* View层只需面向Presenter层，不需要知道Model层\n* Model层只需面向Presenter层，不需要知道View层\n* View层和Model层逻辑交互都在Presenter\n\nMVP发生内存泄露：\n    在P层使用线程耗时操作，使用弱引用可以避免","source":"_posts/Android/Structure/架构设计.md","raw":"---\ntitle: Android架构设计\ntype: [Android]\ndescription: Android架构设计\ncover: /cover/img87.jpg\ntoc: true\ncategories: Android\ndate: 2018/08/25\n---\n\n### MVC模式\n\n用户操作交给Controler（Activity） —— 》 \n\nView : 视图层，面向用户渲染画面UI —— 》 Layout自定义View\nModel: 模型层，面向需求模型，数据模型 —— 》Beans实体类SqliteDatabase\nController: 控制层，面向业务逻辑具体操作  —— 》Activity Network网络具体业务逻辑 \n\n1、View接收到用户的操作\n2、View将用户的操作，交给Controller 即Activity\n        Model和View之间的联系紧密，耦合性太强，Activity负责的内容太多\n3、Controller完成具体业务逻辑\n4、得到封装Model,再进行View更新 \n\nMVC模式容易发生内存泄露：\n    在Control层使员工耗时操作，Activity退出后，线程依然存在\n\n### MVP模式\n\nView —— 》 Acivity\n\n\n1、View收到用户操作\n2、View把用户的操作交给Presenter\n3、Presenter控制Model进行业务逻辑处理\n4、Presenter处理完毕后，数据封装到Model\n5、Presenter收到通知后，再更新View\n\n方式：双向通信的方式\n\n优点：\n* View与Model层完全分离\n* 所有的逻辑交互都在Presenter\n* MVP分层严谨\n* View层只需面向Presenter层，不需要知道Model层\n* Model层只需面向Presenter层，不需要知道View层\n* View层和Model层逻辑交互都在Presenter\n\nMVP发生内存泄露：\n    在P层使用线程耗时操作，使用弱引用可以避免","slug":"Android/Structure/架构设计","published":1,"updated":"2021-01-06T00:59:20.686Z","_id":"ckjju0m1e004e20ua9k4g51ks","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h3><p>用户操作交给Controler（Activity） —— 》 </p>\n<p>View : 视图层，面向用户渲染画面UI —— 》 Layout自定义View<br>Model: 模型层，面向需求模型，数据模型 —— 》Beans实体类SqliteDatabase<br>Controller: 控制层，面向业务逻辑具体操作  —— 》Activity Network网络具体业务逻辑 </p>\n<p>1、View接收到用户的操作<br>2、View将用户的操作，交给Controller 即Activity<br>        Model和View之间的联系紧密，耦合性太强，Activity负责的内容太多<br>3、Controller完成具体业务逻辑<br>4、得到封装Model,再进行View更新 </p>\n<p>MVC模式容易发生内存泄露：<br>    在Control层使员工耗时操作，Activity退出后，线程依然存在</p>\n<h3 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h3><p>View —— 》 Acivity</p>\n<p>1、View收到用户操作<br>2、View把用户的操作交给Presenter<br>3、Presenter控制Model进行业务逻辑处理<br>4、Presenter处理完毕后，数据封装到Model<br>5、Presenter收到通知后，再更新View</p>\n<p>方式：双向通信的方式</p>\n<p>优点：</p>\n<ul>\n<li>View与Model层完全分离</li>\n<li>所有的逻辑交互都在Presenter</li>\n<li>MVP分层严谨</li>\n<li>View层只需面向Presenter层，不需要知道Model层</li>\n<li>Model层只需面向Presenter层，不需要知道View层</li>\n<li>View层和Model层逻辑交互都在Presenter</li>\n</ul>\n<p>MVP发生内存泄露：<br>    在P层使用线程耗时操作，使用弱引用可以避免</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"MVC模式\"><a href=\"#MVC模式\" class=\"headerlink\" title=\"MVC模式\"></a>MVC模式</h3><p>用户操作交给Controler（Activity） —— 》 </p>\n<p>View : 视图层，面向用户渲染画面UI —— 》 Layout自定义View<br>Model: 模型层，面向需求模型，数据模型 —— 》Beans实体类SqliteDatabase<br>Controller: 控制层，面向业务逻辑具体操作  —— 》Activity Network网络具体业务逻辑 </p>\n<p>1、View接收到用户的操作<br>2、View将用户的操作，交给Controller 即Activity<br>        Model和View之间的联系紧密，耦合性太强，Activity负责的内容太多<br>3、Controller完成具体业务逻辑<br>4、得到封装Model,再进行View更新 </p>\n<p>MVC模式容易发生内存泄露：<br>    在Control层使员工耗时操作，Activity退出后，线程依然存在</p>\n<h3 id=\"MVP模式\"><a href=\"#MVP模式\" class=\"headerlink\" title=\"MVP模式\"></a>MVP模式</h3><p>View —— 》 Acivity</p>\n<p>1、View收到用户操作<br>2、View把用户的操作交给Presenter<br>3、Presenter控制Model进行业务逻辑处理<br>4、Presenter处理完毕后，数据封装到Model<br>5、Presenter收到通知后，再更新View</p>\n<p>方式：双向通信的方式</p>\n<p>优点：</p>\n<ul>\n<li>View与Model层完全分离</li>\n<li>所有的逻辑交互都在Presenter</li>\n<li>MVP分层严谨</li>\n<li>View层只需面向Presenter层，不需要知道Model层</li>\n<li>Model层只需面向Presenter层，不需要知道View层</li>\n<li>View层和Model层逻辑交互都在Presenter</li>\n</ul>\n<p>MVP发生内存泄露：<br>    在P层使用线程耗时操作，使用弱引用可以避免</p>\n"},{"title":"ActionBar和ToolBar的使用","cover":"/cover/img19.jpg","toc":true,"description":"ActionBar和ToolBar的使用","type":["Android"],"date":"2019-09-29T16:00:00.000Z","_content":"","source":"_posts/Android/View/ActionBar和ToolBar的使用.md","raw":"---\ntitle: ActionBar和ToolBar的使用\ncover: /cover/img19.jpg\ntoc: true\ndescription: ActionBar和ToolBar的使用\ncategories: Android\ntype: [Android]\ndate: 2019/09/30\n---\n","slug":"Android/View/ActionBar和ToolBar的使用","published":1,"updated":"2021-01-05T12:14:11.364Z","_id":"ckjju0m1f004g20uafjdf7skb","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Android多语言设置","type":["Android"],"description":"Android多语言设置","cover":"/cover/img88.jpg","toc":true,"date":"2020-01-05T16:00:00.000Z","_content":"\n## Android多语言适配\n\n\n\n\n### 遇到的问题\n\n部分Fragment页面失效，如嵌套的Fragment,使用Navigation进行导航的Fagment\n\n解决方式：在所在的Activity的`onCreate()`方法中进行设置，需要在`setContextView()`之前","source":"_posts/Android/View/Android多语言设置.md","raw":"---\ntitle: Android多语言设置\ntype: [Android]\ndescription:  Android多语言设置\ncover: /cover/img88.jpg\ntoc: true\ncategories: Android\ndate: 2020/01/06\n---\n\n## Android多语言适配\n\n\n\n\n### 遇到的问题\n\n部分Fragment页面失效，如嵌套的Fragment,使用Navigation进行导航的Fagment\n\n解决方式：在所在的Activity的`onCreate()`方法中进行设置，需要在`setContextView()`之前","slug":"Android/View/Android多语言设置","published":1,"updated":"2021-01-05T12:14:11.518Z","_id":"ckjju0m1f004j20uaa3kq05t3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android多语言适配\"><a href=\"#Android多语言适配\" class=\"headerlink\" title=\"Android多语言适配\"></a>Android多语言适配</h2><h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>部分Fragment页面失效，如嵌套的Fragment,使用Navigation进行导航的Fagment</p>\n<p>解决方式：在所在的Activity的<code>onCreate()</code>方法中进行设置，需要在<code>setContextView()</code>之前</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android多语言适配\"><a href=\"#Android多语言适配\" class=\"headerlink\" title=\"Android多语言适配\"></a>Android多语言适配</h2><h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>部分Fragment页面失效，如嵌套的Fragment,使用Navigation进行导航的Fagment</p>\n<p>解决方式：在所在的Activity的<code>onCreate()</code>方法中进行设置，需要在<code>setContextView()</code>之前</p>\n"},{"title":"自定义View实现倒计时功能","cover":"/cover/img20.jpg","toc":true,"description":"自定义View实现倒计时功能","type":["Android"],"date":"2018-06-19T16:00:00.000Z","_content":"\n\n# 使用自定义View实现倒计时功能\n\n当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。\n<!--more-->\n## 倒计时控件实现的功能\n\n* 显示时间进度\n* 计时结束后将会自动跳转到下一个Activity中\n\n实现效果如图所示\n\n在本篇博客中的代码会有部分缺省，源码链接\n\n## 对自定义View的尺寸进行测量并绘制中间的大圆\n\nView在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。\n\n```text\npublic class CountDownView extends android.support.v7.widget.AppCompatTextView {\n\n    private int circleRadius;\n\n    private int circleColor=0xff33b5e5;\n\n    private Paint circlePaint;\n    private Rect bounds;\n\n    private int centerX;\n    private int centerY;\n\n    public CountDownView(Context context) {\n        super(context);\n        init();\n    }\n\n    public void init(){\n        circlePaint=new Paint();\n        bounds=new Rect();\n\n    }\n\n    public CountDownView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n\n        circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;\n        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        getDrawingRect(bounds);      //获取控件的边界\n\n        centerX=bounds.centerX();\n        centerY=bounds.centerY();\n\n        //绘制中间的大圆的背景\n        circlePaint.setAntiAlias(true);\n        circlePaint.setStyle(Paint.Style.FILL);\n        circlePaint.setColor(circleColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);\n\n    }\n}\n```\n\n在activity\\_main.xml中添加自定义控件\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    tools:context=\".MainActivity\">\n\n    <com.example.wyw.countdowndemo.CountDownView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        />\n\n</LinearLayout>\n```\n\n运行结果\n\n## 绘制进度边框\n\n```text\n    private int cirlceBoundColor=0xff00ddff;\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setStyle(Paint.Style.STROKE);\n        circlePaint.setStrokeWidth(5);\n        circlePaint.setColor(cirlceBoundColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);\n\n    }\n```\n\n## 绘制进度条的一条弧线\n\n进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线\n\n```text\n    private RectF arcRectF;\n    private int processColor=0xff99cc00;\n\n    public void init(){\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setColor(processColor);\n        //设置线冒样式\n        circlePaint.setStrokeCap(Paint.Cap.ROUND);\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,40,false,circlePaint);\n\n    }\n```\n\n## 进度条按照通过Timer不断控制绘制角度的增加\n\n```text\n    private int currentDrawTime;    //已经绘制的次数\n    private Timer timer;\n\n    public void init(){\n        timer=new Timer();\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);\n\n    }\n\n    public void drawProcess(){\n\n        currentDrawTime=0;\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n               postInvalidate();\n               currentDrawTime++;\n               if (currentDrawTime==8)\n                   timer.cancel();\n            }\n        },500,500);\n\n    }\n```\n\n## 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\n\n```text\n    @Override\n    protected void onDraw(Canvas canvas) {\n     Paint paint = getPaint();\n        float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;\n        paint.setAntiAlias(true);  //防锯齿\n        paint.setColor(Color.WHITE);\n        paint.setTextAlign(Paint.Align.CENTER);\n        canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint);\n\n    }\n```\n\n","source":"_posts/Android/View/CountDownView.md","raw":"---\ntitle: 自定义View实现倒计时功能\ncover: /cover/img20.jpg\ntoc: true\ndescription: 自定义View实现倒计时功能\ncategories: Android\ntype: [Android]\ndate: 2018/06/20\n---\n\n\n# 使用自定义View实现倒计时功能\n\n当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。\n<!--more-->\n## 倒计时控件实现的功能\n\n* 显示时间进度\n* 计时结束后将会自动跳转到下一个Activity中\n\n实现效果如图所示\n\n在本篇博客中的代码会有部分缺省，源码链接\n\n## 对自定义View的尺寸进行测量并绘制中间的大圆\n\nView在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。\n\n```text\npublic class CountDownView extends android.support.v7.widget.AppCompatTextView {\n\n    private int circleRadius;\n\n    private int circleColor=0xff33b5e5;\n\n    private Paint circlePaint;\n    private Rect bounds;\n\n    private int centerX;\n    private int centerY;\n\n    public CountDownView(Context context) {\n        super(context);\n        init();\n    }\n\n    public void init(){\n        circlePaint=new Paint();\n        bounds=new Rect();\n\n    }\n\n    public CountDownView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec,heightMeasureSpec);\n\n        circleRadius=getMeasuredWidth()>getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;\n        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        getDrawingRect(bounds);      //获取控件的边界\n\n        centerX=bounds.centerX();\n        centerY=bounds.centerY();\n\n        //绘制中间的大圆的背景\n        circlePaint.setAntiAlias(true);\n        circlePaint.setStyle(Paint.Style.FILL);\n        circlePaint.setColor(circleColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);\n\n    }\n}\n```\n\n在activity\\_main.xml中添加自定义控件\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    tools:context=\".MainActivity\">\n\n    <com.example.wyw.countdowndemo.CountDownView\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        />\n\n</LinearLayout>\n```\n\n运行结果\n\n## 绘制进度边框\n\n```text\n    private int cirlceBoundColor=0xff00ddff;\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setStyle(Paint.Style.STROKE);\n        circlePaint.setStrokeWidth(5);\n        circlePaint.setColor(cirlceBoundColor);\n        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);\n\n    }\n```\n\n## 绘制进度条的一条弧线\n\n进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线\n\n```text\n    private RectF arcRectF;\n    private int processColor=0xff99cc00;\n\n    public void init(){\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        circlePaint.setColor(processColor);\n        //设置线冒样式\n        circlePaint.setStrokeCap(Paint.Cap.ROUND);\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,40,false,circlePaint);\n\n    }\n```\n\n## 进度条按照通过Timer不断控制绘制角度的增加\n\n```text\n    private int currentDrawTime;    //已经绘制的次数\n    private Timer timer;\n\n    public void init(){\n        timer=new Timer();\n        arcRectF=new RectF();\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n\n        arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);\n        canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);\n\n    }\n\n    public void drawProcess(){\n\n        currentDrawTime=0;\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n               postInvalidate();\n               currentDrawTime++;\n               if (currentDrawTime==8)\n                   timer.cancel();\n            }\n        },500,500);\n\n    }\n```\n\n## 倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\n\n```text\n    @Override\n    protected void onDraw(Canvas canvas) {\n     Paint paint = getPaint();\n        float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;\n        paint.setAntiAlias(true);  //防锯齿\n        paint.setColor(Color.WHITE);\n        paint.setTextAlign(Paint.Align.CENTER);\n        canvas.drawText((4000-500*currentDrawTime)/500+\"s\",centerY,textY,paint);\n\n    }\n```\n\n","slug":"Android/View/CountDownView","published":1,"updated":"2021-01-05T12:14:12.476Z","_id":"ckjju0m1h004m20uadaachyyt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用自定义View实现倒计时功能\"><a href=\"#使用自定义View实现倒计时功能\" class=\"headerlink\" title=\"使用自定义View实现倒计时功能\"></a>使用自定义View实现倒计时功能</h1><p>当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。</p>\n<a id=\"more\"></a>\n<h2 id=\"倒计时控件实现的功能\"><a href=\"#倒计时控件实现的功能\" class=\"headerlink\" title=\"倒计时控件实现的功能\"></a>倒计时控件实现的功能</h2><ul>\n<li>显示时间进度</li>\n<li>计时结束后将会自动跳转到下一个Activity中</li>\n</ul>\n<p>实现效果如图所示</p>\n<p>在本篇博客中的代码会有部分缺省，源码链接</p>\n<h2 id=\"对自定义View的尺寸进行测量并绘制中间的大圆\"><a href=\"#对自定义View的尺寸进行测量并绘制中间的大圆\" class=\"headerlink\" title=\"对自定义View的尺寸进行测量并绘制中间的大圆\"></a>对自定义View的尺寸进行测量并绘制中间的大圆</h2><p>View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CountDownView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleColor=0xff33b5e5;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Paint circlePaint;</span><br><span class=\"line\">    private Rect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int centerX;</span><br><span class=\"line\">    private int centerY;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        circlePaint=new Paint();</span><br><span class=\"line\">        bounds=new Rect();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        super.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        circleRadius=getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\">        getDrawingRect(bounds);      //获取控件的边界</span><br><span class=\"line\"></span><br><span class=\"line\">        centerX=bounds.centerX();</span><br><span class=\"line\">        centerY=bounds.centerY();</span><br><span class=\"line\"></span><br><span class=\"line\">        //绘制中间的大圆的背景</span><br><span class=\"line\">        circlePaint.setAntiAlias(true);</span><br><span class=\"line\">        circlePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        circlePaint.setColor(circleColor);</span><br><span class=\"line\">        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在activity_main.xml中添加自定义控件</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.example.wyw.countdowndemo.CountDownView</span><br><span class=\"line\">        android:layout_width=&quot;100dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;100dp&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<h2 id=\"绘制进度边框\"><a href=\"#绘制进度边框\" class=\"headerlink\" title=\"绘制进度边框\"></a>绘制进度边框</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int cirlceBoundColor=0xff00ddff;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">    circlePaint.setStrokeWidth(5);</span><br><span class=\"line\">    circlePaint.setColor(cirlceBoundColor);</span><br><span class=\"line\">    canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"绘制进度条的一条弧线\"><a href=\"#绘制进度条的一条弧线\" class=\"headerlink\" title=\"绘制进度条的一条弧线\"></a>绘制进度条的一条弧线</h2><p>进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private RectF arcRectF;</span><br><span class=\"line\">private int processColor=0xff99cc00;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    arcRectF=new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setColor(processColor);</span><br><span class=\"line\">    //设置线冒样式</span><br><span class=\"line\">    circlePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,40,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"进度条按照通过Timer不断控制绘制角度的增加\"><a href=\"#进度条按照通过Timer不断控制绘制角度的增加\" class=\"headerlink\" title=\"进度条按照通过Timer不断控制绘制角度的增加\"></a>进度条按照通过Timer不断控制绘制角度的增加</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int currentDrawTime;    //已经绘制的次数</span><br><span class=\"line\">private Timer timer;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    timer=new Timer();</span><br><span class=\"line\">    arcRectF=new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void drawProcess()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentDrawTime=0;</span><br><span class=\"line\">    timer.schedule(new TimerTask() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">           currentDrawTime++;</span><br><span class=\"line\">           if (currentDrawTime==8)</span><br><span class=\"line\">               timer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,500,500);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"><a href=\"#倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\" class=\"headerlink\" title=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"></a>倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"> Paint paint = getPaint();</span><br><span class=\"line\">    float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;</span><br><span class=\"line\">    paint.setAntiAlias(true);  //防锯齿</span><br><span class=\"line\">    paint.setColor(Color.WHITE);</span><br><span class=\"line\">    paint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\">    canvas.drawText((4000-500*currentDrawTime)/500+&quot;s&quot;,centerY,textY,paint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用自定义View实现倒计时功能\"><a href=\"#使用自定义View实现倒计时功能\" class=\"headerlink\" title=\"使用自定义View实现倒计时功能\"></a>使用自定义View实现倒计时功能</h1><p>当手机应用在安装后进行资源加载初始化的时候，为提高用户的使用体验，通常会以倒计时的形式给予用户一一定的提示。</p>","more":"<h2 id=\"倒计时控件实现的功能\"><a href=\"#倒计时控件实现的功能\" class=\"headerlink\" title=\"倒计时控件实现的功能\"></a>倒计时控件实现的功能</h2><ul>\n<li>显示时间进度</li>\n<li>计时结束后将会自动跳转到下一个Activity中</li>\n</ul>\n<p>实现效果如图所示</p>\n<p>在本篇博客中的代码会有部分缺省，源码链接</p>\n<h2 id=\"对自定义View的尺寸进行测量并绘制中间的大圆\"><a href=\"#对自定义View的尺寸进行测量并绘制中间的大圆\" class=\"headerlink\" title=\"对自定义View的尺寸进行测量并绘制中间的大圆\"></a>对自定义View的尺寸进行测量并绘制中间的大圆</h2><p>View在绘制的过程中对于尺寸的测量主要在OnMeasure中进行，绘制中间的大圆需要指定圆心、半径、画笔样式、背景样式等信息。倒计时功能控件显示的为圆，因此以View中的长和宽的最小值作为直径。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CountDownView extends android.support.v7.widget.AppCompatTextView &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int circleColor=0xff33b5e5;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Paint circlePaint;</span><br><span class=\"line\">    private Rect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int centerX;</span><br><span class=\"line\">    private int centerY;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context) &#123;</span><br><span class=\"line\">        super(context);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        circlePaint=new Paint();</span><br><span class=\"line\">        bounds=new Rect();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">        super(context, attrs);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public CountDownView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class=\"line\">        super(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        super.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        circleRadius=getMeasuredWidth()&gt;getMeasuredHeight()?getMeasuredHeight()/2:getMeasuredWidth()/2;</span><br><span class=\"line\">        setMeasuredDimension(getMeasuredWidth(),getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">        super.onDraw(canvas);</span><br><span class=\"line\">        getDrawingRect(bounds);      //获取控件的边界</span><br><span class=\"line\"></span><br><span class=\"line\">        centerX=bounds.centerX();</span><br><span class=\"line\">        centerY=bounds.centerY();</span><br><span class=\"line\"></span><br><span class=\"line\">        //绘制中间的大圆的背景</span><br><span class=\"line\">        circlePaint.setAntiAlias(true);</span><br><span class=\"line\">        circlePaint.setStyle(Paint.Style.FILL);</span><br><span class=\"line\">        circlePaint.setColor(circleColor);</span><br><span class=\"line\">        canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在activity_main.xml中添加自定义控件</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;com.example.wyw.countdowndemo.CountDownView</span><br><span class=\"line\">        android:layout_width=&quot;100dp&quot;</span><br><span class=\"line\">        android:layout_height=&quot;100dp&quot;</span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<h2 id=\"绘制进度边框\"><a href=\"#绘制进度边框\" class=\"headerlink\" title=\"绘制进度边框\"></a>绘制进度边框</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int cirlceBoundColor=0xff00ddff;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">    circlePaint.setStrokeWidth(5);</span><br><span class=\"line\">    circlePaint.setColor(cirlceBoundColor);</span><br><span class=\"line\">    canvas.drawCircle(bounds.centerX(),bounds.centerY(),circleRadius-8,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"绘制进度条的一条弧线\"><a href=\"#绘制进度条的一条弧线\" class=\"headerlink\" title=\"绘制进度条的一条弧线\"></a>绘制进度条的一条弧线</h2><p>进度条的绘制过程弧线不断增加绘制角度，然后更新视图显示的，先绘制一条角度为45度的弧线</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private RectF arcRectF;</span><br><span class=\"line\">private int processColor=0xff99cc00;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    arcRectF=new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    circlePaint.setColor(processColor);</span><br><span class=\"line\">    //设置线冒样式</span><br><span class=\"line\">    circlePaint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,40,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"进度条按照通过Timer不断控制绘制角度的增加\"><a href=\"#进度条按照通过Timer不断控制绘制角度的增加\" class=\"headerlink\" title=\"进度条按照通过Timer不断控制绘制角度的增加\"></a>进度条按照通过Timer不断控制绘制角度的增加</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int currentDrawTime;    //已经绘制的次数</span><br><span class=\"line\">private Timer timer;</span><br><span class=\"line\"></span><br><span class=\"line\">public void init()&#123;</span><br><span class=\"line\">    timer=new Timer();</span><br><span class=\"line\">    arcRectF=new RectF();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    arcRectF.set(bounds.left+8,bounds.top+8,bounds.right-8,bounds.bottom-8);</span><br><span class=\"line\">    canvas.drawArc(arcRectF,-90,currentDrawTime*45,false,circlePaint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void drawProcess()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentDrawTime=0;</span><br><span class=\"line\">    timer.schedule(new TimerTask() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">           postInvalidate();</span><br><span class=\"line\">           currentDrawTime++;</span><br><span class=\"line\">           if (currentDrawTime==8)</span><br><span class=\"line\">               timer.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,500,500);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"><a href=\"#倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\" class=\"headerlink\" title=\"倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时\"></a>倒计时时间绘制，倒计时的绘制，需要根据timer来进行倒计时</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\"> Paint paint = getPaint();</span><br><span class=\"line\">    float textY = centerY - (circlePaint.descent() + circlePaint.ascent()) / 2;</span><br><span class=\"line\">    paint.setAntiAlias(true);  //防锯齿</span><br><span class=\"line\">    paint.setColor(Color.WHITE);</span><br><span class=\"line\">    paint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\">    canvas.drawText((4000-500*currentDrawTime)/500+&quot;s&quot;,centerY,textY,paint);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LayoutInflater介绍与使用","cover":"/cover/img21.jpg","toc":true,"description":"LayoutInflater介绍与使用","type":["Android"],"date":"2018-10-21T16:00:00.000Z","_content":"\nLayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。\n<!--more-->\n* LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。\n\n* findViewById用于已载入的界面，使用findViewById来获取其中的界面元素\n\n\n## 获取LayoutInflater实例的方法\n\n* 1、通过系统服务获取布局加载器\n```\n    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n```\n* 2、通过activity中的getLayoutInflater()方法\n```\n    LayoutInflater inflater = getLayoutInflater();\n```\n\n* 3、通过LayoutInflater的from静态方法\n\n```\n    LayoutInflater inflater = LayoutInflater.from(this)\n```\n\n**这三种方式本质都是调用Context.getSystemService()**\n\n## 使用inflate方法加载布局\n\nLayoutInflater提供四种加载布局的方法\n\n* public View inflate (int resource, ViewGroup root)\n* public View inflate (int resource, ViewGroup root, boolean attachToRoot)\n* public View inflate (XmlPullParser parser, ViewGroup root)\n* public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)\n\n\n**ViewGroup root：指实例的布局所要放入的根视图**\n**boolean attachToToot：指是否附加到传入的根视图**\n\n\n1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。\n2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。\n3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。\n\n**即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View**\n\n### 示例：将button布局添加到LinearLayout上\n\n```\n    <Button xmlns:android=”http://schemas.android.com/apk/res/android\"\n     android:layout_width=”match_parent”\n     android:layout_height=”wrap_content”\n     android:text=”@string/action_attach_to_root_true”\n     android:id=”@+id/button_ok”>\n    </Button>\n```\nButton的layout params类型是LinearLayout.LayoutParams\n\n**将attachRoot设置为true**\n\n```\n    inflater.inflate(R.layout.view_button, mLinearLayout, true);\n```\n**将attachRoot设置为false**\n当attachRoot设置为false后，\n\n```\n    Button btn = (Button)inflater.inflate\n                    (R.layout.view_button,parent,false);\n    parent.addView(btn);\n```\n\n同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    \n\n**在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可**\n\n\n\n\n\n","source":"_posts/Android/View/LayoutInflater使用.md","raw":"---\ntitle: LayoutInflater介绍与使用\ncover: /cover/img21.jpg\ntoc: true\ndescription: LayoutInflater介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2018/10/22\n---\n\nLayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。\n<!--more-->\n* LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。\n\n* findViewById用于已载入的界面，使用findViewById来获取其中的界面元素\n\n\n## 获取LayoutInflater实例的方法\n\n* 1、通过系统服务获取布局加载器\n```\n    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n```\n* 2、通过activity中的getLayoutInflater()方法\n```\n    LayoutInflater inflater = getLayoutInflater();\n```\n\n* 3、通过LayoutInflater的from静态方法\n\n```\n    LayoutInflater inflater = LayoutInflater.from(this)\n```\n\n**这三种方式本质都是调用Context.getSystemService()**\n\n## 使用inflate方法加载布局\n\nLayoutInflater提供四种加载布局的方法\n\n* public View inflate (int resource, ViewGroup root)\n* public View inflate (int resource, ViewGroup root, boolean attachToRoot)\n* public View inflate (XmlPullParser parser, ViewGroup root)\n* public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)\n\n\n**ViewGroup root：指实例的布局所要放入的根视图**\n**boolean attachToToot：指是否附加到传入的根视图**\n\n\n1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。\n2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。\n3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。\n\n**即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View**\n\n### 示例：将button布局添加到LinearLayout上\n\n```\n    <Button xmlns:android=”http://schemas.android.com/apk/res/android\"\n     android:layout_width=”match_parent”\n     android:layout_height=”wrap_content”\n     android:text=”@string/action_attach_to_root_true”\n     android:id=”@+id/button_ok”>\n    </Button>\n```\nButton的layout params类型是LinearLayout.LayoutParams\n\n**将attachRoot设置为true**\n\n```\n    inflater.inflate(R.layout.view_button, mLinearLayout, true);\n```\n**将attachRoot设置为false**\n当attachRoot设置为false后，\n\n```\n    Button btn = (Button)inflater.inflate\n                    (R.layout.view_button,parent,false);\n    parent.addView(btn);\n```\n\n同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    \n\n**在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可**\n\n\n\n\n\n","slug":"Android/View/LayoutInflater使用","published":1,"updated":"2021-01-05T12:14:12.672Z","_id":"ckjju0m1h004p20ua26v30fp9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。</p>\n</li>\n<li><p>findViewById用于已载入的界面，使用findViewById来获取其中的界面元素</p>\n</li>\n</ul>\n<h2 id=\"获取LayoutInflater实例的方法\"><a href=\"#获取LayoutInflater实例的方法\" class=\"headerlink\" title=\"获取LayoutInflater实例的方法\"></a>获取LayoutInflater实例的方法</h2><ul>\n<li>1、通过系统服务获取布局加载器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li>\n<li>2、通过activity中的getLayoutInflater()方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; getLayoutInflater();</span><br></pre></td></tr></table></figure></li>\n<li>3、通过LayoutInflater的from静态方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; LayoutInflater.from(this)</span><br></pre></td></tr></table></figure>\n<p><strong>这三种方式本质都是调用Context.getSystemService()</strong></p>\n<h2 id=\"使用inflate方法加载布局\"><a href=\"#使用inflate方法加载布局\" class=\"headerlink\" title=\"使用inflate方法加载布局\"></a>使用inflate方法加载布局</h2><p>LayoutInflater提供四种加载布局的方法</p>\n<ul>\n<li>public View inflate (int resource, ViewGroup root)</li>\n<li>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)</li>\n</ul>\n<p><strong>ViewGroup root：指实例的布局所要放入的根视图</strong><br><strong>boolean attachToToot：指是否附加到传入的根视图</strong></p>\n<p>1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。<br>2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。<br>3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。</p>\n<p><strong>即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View</strong></p>\n<h3 id=\"示例：将button布局添加到LinearLayout上\"><a href=\"#示例：将button布局添加到LinearLayout上\" class=\"headerlink\" title=\"示例：将button布局添加到LinearLayout上\"></a>示例：将button布局添加到LinearLayout上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button xmlns:android&#x3D;”http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\"> android:layout_width&#x3D;”match_parent”</span><br><span class=\"line\"> android:layout_height&#x3D;”wrap_content”</span><br><span class=\"line\"> android:text&#x3D;”@string&#x2F;action_attach_to_root_true”</span><br><span class=\"line\"> android:id&#x3D;”@+id&#x2F;button_ok”&gt;</span><br><span class=\"line\">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>\n<p>Button的layout params类型是LinearLayout.LayoutParams</p>\n<p><strong>将attachRoot设置为true</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.view_button, mLinearLayout, true);</span><br></pre></td></tr></table></figure>\n<p><strong>将attachRoot设置为false</strong><br>当attachRoot设置为false后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button btn &#x3D; (Button)inflater.inflate</span><br><span class=\"line\">                (R.layout.view_button,parent,false);</span><br><span class=\"line\">parent.addView(btn);</span><br></pre></td></tr></table></figure>\n<p>同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    </p>\n<p><strong>在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可</strong></p>\n","site":{"data":{}},"excerpt":"<p>LayoutInflater用于给相应的View对象实例化一个layout(即：将一个xml文件转化为一个View对象),在开发过程中不会直接使用，而是通过Activity.getLayoutInflater()或者Context.getSystemService(Class)方法，获取一个标准的实例，该实例已经与当前Context相关联。</p>","more":"<ul>\n<li><p>LayoutInflater通常用于动态载入的页面，使用LayoutInflater的inflate方法动态接入layout文件。</p>\n</li>\n<li><p>findViewById用于已载入的界面，使用findViewById来获取其中的界面元素</p>\n</li>\n</ul>\n<h2 id=\"获取LayoutInflater实例的方法\"><a href=\"#获取LayoutInflater实例的方法\" class=\"headerlink\" title=\"获取LayoutInflater实例的方法\"></a>获取LayoutInflater实例的方法</h2><ul>\n<li>1、通过系统服务获取布局加载器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li>\n<li>2、通过activity中的getLayoutInflater()方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; getLayoutInflater();</span><br></pre></td></tr></table></figure></li>\n<li>3、通过LayoutInflater的from静态方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater inflater &#x3D; LayoutInflater.from(this)</span><br></pre></td></tr></table></figure>\n<p><strong>这三种方式本质都是调用Context.getSystemService()</strong></p>\n<h2 id=\"使用inflate方法加载布局\"><a href=\"#使用inflate方法加载布局\" class=\"headerlink\" title=\"使用inflate方法加载布局\"></a>使用inflate方法加载布局</h2><p>LayoutInflater提供四种加载布局的方法</p>\n<ul>\n<li>public View inflate (int resource, ViewGroup root)</li>\n<li>public View inflate (int resource, ViewGroup root, boolean attachToRoot)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root)</li>\n<li>public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)</li>\n</ul>\n<p><strong>ViewGroup root：指实例的布局所要放入的根视图</strong><br><strong>boolean attachToToot：指是否附加到传入的根视图</strong></p>\n<p>1、当root为null，attachToRoot为任何值都毫无意义，只会单纯加载布局文件。<br>2、当root不为null，attachToRoot设为true,第一个参数指定的layout文件将会inflate并且绑定到root上。<br>3、当root不为null，attachToRoot为false，此时View并没有添加到root,但view的layout属性被保留下来，如果调用addView(View child)，layout属性会自动生效。</p>\n<p><strong>即attachToRoot为true,布局文件的View将会与root绑定，如果为false View将会通过其他方式添加到ViewGroup中，为false时返回View</strong></p>\n<h3 id=\"示例：将button布局添加到LinearLayout上\"><a href=\"#示例：将button布局添加到LinearLayout上\" class=\"headerlink\" title=\"示例：将button布局添加到LinearLayout上\"></a>示例：将button布局添加到LinearLayout上</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Button xmlns:android&#x3D;”http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\"> android:layout_width&#x3D;”match_parent”</span><br><span class=\"line\"> android:layout_height&#x3D;”wrap_content”</span><br><span class=\"line\"> android:text&#x3D;”@string&#x2F;action_attach_to_root_true”</span><br><span class=\"line\"> android:id&#x3D;”@+id&#x2F;button_ok”&gt;</span><br><span class=\"line\">&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>\n<p>Button的layout params类型是LinearLayout.LayoutParams</p>\n<p><strong>将attachRoot设置为true</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inflater.inflate(R.layout.view_button, mLinearLayout, true);</span><br></pre></td></tr></table></figure>\n<p><strong>将attachRoot设置为false</strong><br>当attachRoot设置为false后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Button btn &#x3D; (Button)inflater.inflate</span><br><span class=\"line\">                (R.layout.view_button,parent,false);</span><br><span class=\"line\">parent.addView(btn);</span><br></pre></td></tr></table></figure>\n<p>同样的在RecyclerView中需要将attachRoot设置为false，因为在RecyclerView中时由RecyclerView来决定什么时候将childView inflate而不是开发人员。    </p>\n<p><strong>在AlertDialog使用功时，无需传递ViewGroup参数，指定为null即可</strong></p>"},{"title":"Materials Design 介绍与使用","cover":"/cover/img22.jpg","toc":true,"description":"Materials Design 介绍与使用","type":["Android"],"date":"2018-08-31T16:00:00.000Z","_content":"\n # Materials Design 介绍与使用\n\n ## CoordinatorLayout\n CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。\n <!--more-->\n CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar\n \n **CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用**\n \n ## AppBarLayout\n \n AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。\n \n AppBarLayout有五种滚动标识：\n * scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部\n * enterAlways：让任意向下的滚动都会导致该view变为可见\n * enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。\n * exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠\n * snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开\n \n ## CollapsingToolbarLayout\n CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，\n \n ## Behavior\n \n Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。\n \n \n# SnackBar\nSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。\n\n如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；\n\n###SnackBar的使用方式\n```\n\n```\n\n\n# Toast\nToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，\n\n\n### SnackBar和Toast之间的对比\n\n|不同|Toast|SnackBar|\n|---|-----|-----|\n|1|Toast从API1就存在|SnackBar在API23添加|\n|2|不需要Activity，可以显示在Android Home或者其他应用才|只能显示在某一个Activity中|\n|3|不能根据用户的操作执行Action|可以根据用户的操作执行Action|\n|4|在用户滑动时不能消失|在用户滑动时可以消失| \n\n\n### Material Design主题\nMaterial Design主题有三个，API必须在21以上\n* android:style/Theme.Material\n* android:style/Theme.Material.Light\n* android:style/Theme.Material.Light.DarkActionBar\n\nMaterial Design适配API 21以下，要使用兼容包\n兼容包的主题：\n *   Theme.AppCompat.Light\n *   Theme.AppCompat.Light.DarkActionBar\n\n\n #### 主题常用属性\n  已经截图\n * colorPrimary  标题栏   \n * colorPrimaryDark 状态栏\n * colorAccent 强调色\n * textColorPrimary 标题栏上字体和图标的颜色\n * windowBackground 窗口的背景色\n * navigationBarColor 虚拟导航栏\n\n #### 常用控件\n\n * Toolbar 用来替代ActionBar，更灵活\n * DrawerLayout 实现左拉和右拉，类似于抽屉功能\n * NavigationView 与DrawerLayout同时使用\n * BottomNavigationView  实现底部导航\n * FloationgActionButton 用于浮动\n * Snackbar 用于提示功能\n * CardView 圆角和阴影,\n * CoordinatorLayout 继承自 ViewGroup\n * AppBarLayout 垂直线性布局\n * CollapsingToolbarLayout 继承自FragmeLayout\n * NestedScrollView 支持嵌套滑动的ScrollView\n\n\n #### 常用动画\n\n * Fade 淡入\n * Slide 滑动\n * Explode 分解\n * 共享元素","source":"_posts/Android/View/Materials Design.md","raw":"---\ntitle: Materials Design 介绍与使用\ncover: /cover/img22.jpg\ntoc: true\ndescription: Materials Design 介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2018/09/01\n---\n\n # Materials Design 介绍与使用\n\n ## CoordinatorLayout\n CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。\n <!--more-->\n CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar\n \n **CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用**\n \n ## AppBarLayout\n \n AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。\n \n AppBarLayout有五种滚动标识：\n * scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部\n * enterAlways：让任意向下的滚动都会导致该view变为可见\n * enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。\n * exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠\n * snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开\n \n ## CollapsingToolbarLayout\n CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，\n \n ## Behavior\n \n Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。\n \n \n# SnackBar\nSnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。\n\n如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；\n\n###SnackBar的使用方式\n```\n\n```\n\n\n# Toast\nToast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，\n\n\n### SnackBar和Toast之间的对比\n\n|不同|Toast|SnackBar|\n|---|-----|-----|\n|1|Toast从API1就存在|SnackBar在API23添加|\n|2|不需要Activity，可以显示在Android Home或者其他应用才|只能显示在某一个Activity中|\n|3|不能根据用户的操作执行Action|可以根据用户的操作执行Action|\n|4|在用户滑动时不能消失|在用户滑动时可以消失| \n\n\n### Material Design主题\nMaterial Design主题有三个，API必须在21以上\n* android:style/Theme.Material\n* android:style/Theme.Material.Light\n* android:style/Theme.Material.Light.DarkActionBar\n\nMaterial Design适配API 21以下，要使用兼容包\n兼容包的主题：\n *   Theme.AppCompat.Light\n *   Theme.AppCompat.Light.DarkActionBar\n\n\n #### 主题常用属性\n  已经截图\n * colorPrimary  标题栏   \n * colorPrimaryDark 状态栏\n * colorAccent 强调色\n * textColorPrimary 标题栏上字体和图标的颜色\n * windowBackground 窗口的背景色\n * navigationBarColor 虚拟导航栏\n\n #### 常用控件\n\n * Toolbar 用来替代ActionBar，更灵活\n * DrawerLayout 实现左拉和右拉，类似于抽屉功能\n * NavigationView 与DrawerLayout同时使用\n * BottomNavigationView  实现底部导航\n * FloationgActionButton 用于浮动\n * Snackbar 用于提示功能\n * CardView 圆角和阴影,\n * CoordinatorLayout 继承自 ViewGroup\n * AppBarLayout 垂直线性布局\n * CollapsingToolbarLayout 继承自FragmeLayout\n * NestedScrollView 支持嵌套滑动的ScrollView\n\n\n #### 常用动画\n\n * Fade 淡入\n * Slide 滑动\n * Explode 分解\n * 共享元素","slug":"Android/View/Materials Design","published":1,"updated":"2021-01-05T12:14:13.740Z","_id":"ckjju0m1i004s20ua7i7parld","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Materials-Design-介绍与使用\"><a href=\"#Materials-Design-介绍与使用\" class=\"headerlink\" title=\"Materials Design 介绍与使用\"></a>Materials Design 介绍与使用</h1><h2 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h2><p> CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。<br> <a id=\"more\"></a><br> CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar</p>\n<p> <strong>CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用</strong></p>\n<h2 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h2><p> AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。</p>\n<p> AppBarLayout有五种滚动标识：</p>\n<ul>\n<li><p>scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部</p>\n</li>\n<li><p>enterAlways：让任意向下的滚动都会导致该view变为可见</p>\n</li>\n<li><p>enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。</p>\n</li>\n<li><p>exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠</p>\n</li>\n<li><p>snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开</p>\n<h2 id=\"CollapsingToolbarLayout\"><a href=\"#CollapsingToolbarLayout\" class=\"headerlink\" title=\"CollapsingToolbarLayout\"></a>CollapsingToolbarLayout</h2><p>CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，</p>\n<h2 id=\"Behavior\"><a href=\"#Behavior\" class=\"headerlink\" title=\"Behavior\"></a>Behavior</h2><p>Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。</p>\n</li>\n</ul>\n<h1 id=\"SnackBar\"><a href=\"#SnackBar\" class=\"headerlink\" title=\"SnackBar\"></a>SnackBar</h1><p>SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。</p>\n<p>如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；</p>\n<p>###SnackBar的使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Toast\"><a href=\"#Toast\" class=\"headerlink\" title=\"Toast\"></a>Toast</h1><p>Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，</p>\n<h3 id=\"SnackBar和Toast之间的对比\"><a href=\"#SnackBar和Toast之间的对比\" class=\"headerlink\" title=\"SnackBar和Toast之间的对比\"></a>SnackBar和Toast之间的对比</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>Toast</th>\n<th>SnackBar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Toast从API1就存在</td>\n<td>SnackBar在API23添加</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不需要Activity，可以显示在Android Home或者其他应用才</td>\n<td>只能显示在某一个Activity中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不能根据用户的操作执行Action</td>\n<td>可以根据用户的操作执行Action</td>\n</tr>\n<tr>\n<td>4</td>\n<td>在用户滑动时不能消失</td>\n<td>在用户滑动时可以消失</td>\n</tr>\n</tbody></table>\n<h3 id=\"Material-Design主题\"><a href=\"#Material-Design主题\" class=\"headerlink\" title=\"Material Design主题\"></a>Material Design主题</h3><p>Material Design主题有三个，API必须在21以上</p>\n<ul>\n<li>android:style/Theme.Material</li>\n<li>android:style/Theme.Material.Light</li>\n<li>android:style/Theme.Material.Light.DarkActionBar</li>\n</ul>\n<p>Material Design适配API 21以下，要使用兼容包<br>兼容包的主题：</p>\n<ul>\n<li>  Theme.AppCompat.Light</li>\n<li>  Theme.AppCompat.Light.DarkActionBar</li>\n</ul>\n<h4 id=\"主题常用属性\"><a href=\"#主题常用属性\" class=\"headerlink\" title=\"主题常用属性\"></a>主题常用属性</h4><p>  已经截图</p>\n<ul>\n<li><p>colorPrimary  标题栏   </p>\n</li>\n<li><p>colorPrimaryDark 状态栏</p>\n</li>\n<li><p>colorAccent 强调色</p>\n</li>\n<li><p>textColorPrimary 标题栏上字体和图标的颜色</p>\n</li>\n<li><p>windowBackground 窗口的背景色</p>\n</li>\n<li><p>navigationBarColor 虚拟导航栏</p>\n<h4 id=\"常用控件\"><a href=\"#常用控件\" class=\"headerlink\" title=\"常用控件\"></a>常用控件</h4></li>\n<li><p>Toolbar 用来替代ActionBar，更灵活</p>\n</li>\n<li><p>DrawerLayout 实现左拉和右拉，类似于抽屉功能</p>\n</li>\n<li><p>NavigationView 与DrawerLayout同时使用</p>\n</li>\n<li><p>BottomNavigationView  实现底部导航</p>\n</li>\n<li><p>FloationgActionButton 用于浮动</p>\n</li>\n<li><p>Snackbar 用于提示功能</p>\n</li>\n<li><p>CardView 圆角和阴影,</p>\n</li>\n<li><p>CoordinatorLayout 继承自 ViewGroup</p>\n</li>\n<li><p>AppBarLayout 垂直线性布局</p>\n</li>\n<li><p>CollapsingToolbarLayout 继承自FragmeLayout</p>\n</li>\n<li><p>NestedScrollView 支持嵌套滑动的ScrollView</p>\n</li>\n</ul>\n<h4 id=\"常用动画\"><a href=\"#常用动画\" class=\"headerlink\" title=\"常用动画\"></a>常用动画</h4><ul>\n<li>Fade 淡入</li>\n<li>Slide 滑动</li>\n<li>Explode 分解</li>\n<li>共享元素</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Materials-Design-介绍与使用\"><a href=\"#Materials-Design-介绍与使用\" class=\"headerlink\" title=\"Materials Design 介绍与使用\"></a>Materials Design 介绍与使用</h1><h2 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h2><p> CoordinatorLayout布局遵循Materials Design风格，可以实现各种控件之间的联动效果，在联动控件实现的过程中需要Behavior来协助。<br>","more":"<br> CoordinatorLayout是一个顶级父View，其子View包括FloatingActionButton、SnackBar</p>\n<p> <strong>CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout 需要结合起来使用</strong></p>\n<h2 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h2><p> AppBarLayout是LinearLayout的子类，必须在它的子View上设置app:layout_scrollFlags属性，或者在代码中调用setScrollFlags()设置这个属性。</p>\n<p> AppBarLayout有五种滚动标识：</p>\n<ul>\n<li><p>scroll：所有想滚动出屏幕的view都要设置这个flag，否则view将会被固定在屏幕顶部</p>\n</li>\n<li><p>enterAlways：让任意向下的滚动都会导致该view变为可见</p>\n</li>\n<li><p>enterAlwaysCollapsed：假设定义minHeight同时定义enterAlways，view将会在达到最小高度时显示，直至展开玩。</p>\n</li>\n<li><p>exitUntilCollapsed：当定义minHeight，view在滚到最小布局时折叠</p>\n</li>\n<li><p>snap：当一个滚动事件结束，如果视图部分是可见的，那么它将滚动到收缩或展开</p>\n<h2 id=\"CollapsingToolbarLayout\"><a href=\"#CollapsingToolbarLayout\" class=\"headerlink\" title=\"CollapsingToolbarLayout\"></a>CollapsingToolbarLayout</h2><p>CollapsingToolbarLayout作用是提供一个可以折叠的ToolBar，它继承自FrameLayout，</p>\n<h2 id=\"Behavior\"><a href=\"#Behavior\" class=\"headerlink\" title=\"Behavior\"></a>Behavior</h2><p>Behavior只有是CoordinatorLayout的直接View才有意义，只要将Behavior绑定到CoordinatorLayout的直接子元素上，就能对触摸事件（touch event）、window inserts、layout以及嵌套滑动(nested scrolling)等动作进行拦截。Behavior不能直接发挥作用，必须绑定到CoordinatorLayout的子元素上。</p>\n</li>\n</ul>\n<h1 id=\"SnackBar\"><a href=\"#SnackBar\" class=\"headerlink\" title=\"SnackBar\"></a>SnackBar</h1><p>SnackBar是Material Design的一个组件，可以对用户的操作在屏幕低端提供一个轻量的操作提示。在SnackBar中可以添加Action,如：取消；SnackBar主要用于给用户相应提示，同时需要用户进行可选择的操作。</p>\n<p>如：用户删除订单时，在屏幕下方显示“删除”、“取消”Action Button；</p>\n<p>###SnackBar的使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Toast\"><a href=\"#Toast\" class=\"headerlink\" title=\"Toast\"></a>Toast</h1><p>Toast是在SnackBar之前就存在的操作提示，可以显示在APP的任意位置，</p>\n<h3 id=\"SnackBar和Toast之间的对比\"><a href=\"#SnackBar和Toast之间的对比\" class=\"headerlink\" title=\"SnackBar和Toast之间的对比\"></a>SnackBar和Toast之间的对比</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>Toast</th>\n<th>SnackBar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Toast从API1就存在</td>\n<td>SnackBar在API23添加</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不需要Activity，可以显示在Android Home或者其他应用才</td>\n<td>只能显示在某一个Activity中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不能根据用户的操作执行Action</td>\n<td>可以根据用户的操作执行Action</td>\n</tr>\n<tr>\n<td>4</td>\n<td>在用户滑动时不能消失</td>\n<td>在用户滑动时可以消失</td>\n</tr>\n</tbody></table>\n<h3 id=\"Material-Design主题\"><a href=\"#Material-Design主题\" class=\"headerlink\" title=\"Material Design主题\"></a>Material Design主题</h3><p>Material Design主题有三个，API必须在21以上</p>\n<ul>\n<li>android:style/Theme.Material</li>\n<li>android:style/Theme.Material.Light</li>\n<li>android:style/Theme.Material.Light.DarkActionBar</li>\n</ul>\n<p>Material Design适配API 21以下，要使用兼容包<br>兼容包的主题：</p>\n<ul>\n<li>  Theme.AppCompat.Light</li>\n<li>  Theme.AppCompat.Light.DarkActionBar</li>\n</ul>\n<h4 id=\"主题常用属性\"><a href=\"#主题常用属性\" class=\"headerlink\" title=\"主题常用属性\"></a>主题常用属性</h4><p>  已经截图</p>\n<ul>\n<li><p>colorPrimary  标题栏   </p>\n</li>\n<li><p>colorPrimaryDark 状态栏</p>\n</li>\n<li><p>colorAccent 强调色</p>\n</li>\n<li><p>textColorPrimary 标题栏上字体和图标的颜色</p>\n</li>\n<li><p>windowBackground 窗口的背景色</p>\n</li>\n<li><p>navigationBarColor 虚拟导航栏</p>\n<h4 id=\"常用控件\"><a href=\"#常用控件\" class=\"headerlink\" title=\"常用控件\"></a>常用控件</h4></li>\n<li><p>Toolbar 用来替代ActionBar，更灵活</p>\n</li>\n<li><p>DrawerLayout 实现左拉和右拉，类似于抽屉功能</p>\n</li>\n<li><p>NavigationView 与DrawerLayout同时使用</p>\n</li>\n<li><p>BottomNavigationView  实现底部导航</p>\n</li>\n<li><p>FloationgActionButton 用于浮动</p>\n</li>\n<li><p>Snackbar 用于提示功能</p>\n</li>\n<li><p>CardView 圆角和阴影,</p>\n</li>\n<li><p>CoordinatorLayout 继承自 ViewGroup</p>\n</li>\n<li><p>AppBarLayout 垂直线性布局</p>\n</li>\n<li><p>CollapsingToolbarLayout 继承自FragmeLayout</p>\n</li>\n<li><p>NestedScrollView 支持嵌套滑动的ScrollView</p>\n</li>\n</ul>\n<h4 id=\"常用动画\"><a href=\"#常用动画\" class=\"headerlink\" title=\"常用动画\"></a>常用动画</h4><ul>\n<li>Fade 淡入</li>\n<li>Slide 滑动</li>\n<li>Explode 分解</li>\n<li>共享元素</li>\n</ul>"},{"title":"Android UI 绘制流程","type":["Android"],"description":"Android UI 绘制流程","cover":"/cover/img90.jpg","toc":true,"date":"2018-06-14T16:00:00.000Z","_content":"\n\n\n##  UI绘制流程\n\n### View被添加到屏幕窗口的过程\n1、创建顶层布局容器DecroView，DecroView是一个ViewGroup容器，继承FrameLayout，是PhoneWindow类中持有的实例，所有应用程序的顶层View，在系统内部进行初始化，当DecroView初始化完成后，系统会根据应用的主题特性，加载一个基础容器，如NoActionBar或DarkActionBar，不同主题加载的基础容器不同，基础容器中一定有OnDraw.R.id.content的容器，该容器是一个FrameLayout，通过setCOntentView的xml文件被解析后添加到FrameLayout中\n2、在顶层布局中加载基础布局ViewGroup\n3、将ContentView添加到基础布局中的FrameLayout中\n\n\nView的绘制流程\n1、绘制入口\n    Actvityhread.handleResumeActivity\n    ——>WindowManagerImpl.addView(decorView,layoutParams) \n    ——>WindowManagerGlobal.addView()\n2、绘制类及方法\n    ViewRootImpl.setView(decorView,layoutParama,parentView)\n    ——>ViewRootImpl.requestLayout()——>scheduleTraversals()——> doTraversal()\n    ——> perfoemTraversals()\n3、绘制三大步骤\n    测量：ViewRootImpl.performMeasure\n    布局：ViewRootImpl.performLayout\n    绘制：ViewRootImpl.performDraw       \n\n\n\n### 在Android 7.0 下的绘制流程\n1、从setContentView()开始\n在Activity源码中\n\n```java\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n        initWindowDecorActionBar();\n    }\n```\n`Window`是一个抽象类，其只有一个实现类是`android.view.PhoneWindow`\n```java\n    //...\n    public Window getWindow() {\n        return mWindow;\n    }\n```\n`PhoneWindow`中`setContentView()`方法\n```java\n\n @Override\n    public void setContentView(int layoutResID) {\n        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n        // decor, when theme attributes and the like are crystalized. Do not check the feature\n        // before this happens.\n        if (mContentParent == null) {\n            installDecor();\n        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            mContentParent.removeAllViews();\n        }\n\n        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                    getContext());\n            transitionTo(newScene);\n        } else {\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n        }\n        mContentParent.requestApplyInsets();\n        final Callback cb = getCallback();\n        if (cb != null && !isDestroyed()) {\n            cb.onContentChanged();\n        }\n        mContentParentExplicitlySet = true;\n    }\n\n\n```\n\n```java\n private void installDecor() {\n        mForceDecorInstall = false;\n        if (mDecor == null) {\n            mDecor = generateDecor(-1);\n            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n            mDecor.setIsRootNamespace(true);\n            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n            }\n        } else {\n            mDecor.setWindow(this);\n        }\n        if (mContentParent == null) {\n            mContentParent = generateLayout(mDecor);\n\n            // Set up decor part of UI to ignore fitsSystemWindows if appropriate.\n            mDecor.makeOptionalFitsSystemWindows();\n\n            final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(\n                    R.id.decor_content_parent);\n\n            if (decorContentParent != null) {\n                mDecorContentParent = decorContentParent;\n                mDecorContentParent.setWindowCallback(getCallback());\n                if (mDecorContentParent.getTitle() == null) {\n                    mDecorContentParent.setWindowTitle(mTitle);\n                }\n\n                final int localFeatures = getLocalFeatures();\n                for (int i = 0; i < FEATURE_MAX; i++) {\n                    if ((localFeatures & (1 << i)) != 0) {\n                        mDecorContentParent.initFeature(i);\n                    }\n                }\n\n                mDecorContentParent.setUiOptions(mUiOptions);\n\n                if ((mResourcesSetFlags & FLAG_RESOURCE_SET_ICON) != 0 ||\n                        (mIconRes != 0 && !mDecorContentParent.hasIcon())) {\n                    mDecorContentParent.setIcon(mIconRes);\n                } else if ((mResourcesSetFlags & FLAG_RESOURCE_SET_ICON) == 0 &&\n                        mIconRes == 0 && !mDecorContentParent.hasIcon()) {\n                    mDecorContentParent.setIcon(\n                            getContext().getPackageManager().getDefaultActivityIcon());\n                    mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;\n                }\n                if ((mResourcesSetFlags & FLAG_RESOURCE_SET_LOGO) != 0 ||\n                        (mLogoRes != 0 && !mDecorContentParent.hasLogo())) {\n                    mDecorContentParent.setLogo(mLogoRes);\n                }\n\n                // Invalidate if the panel menu hasn't been created before this.\n                // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu\n                // being called in the middle of onCreate or similar.\n                // A pending invalidation will typically be resolved before the posted message\n                // would run normally in order to satisfy instance state restoration.\n                PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);\n                if (!isDestroyed() && (st == null || st.menu == null) && !mIsStartingWindow) {\n                    invalidatePanelMenu(FEATURE_ACTION_BAR);\n                }\n            } else {\n                mTitleView = (TextView) findViewById(R.id.title);\n                if (mTitleView != null) {\n                    if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {\n                        final View titleContainer = findViewById(R.id.title_container);\n                        if (titleContainer != null) {\n                            titleContainer.setVisibility(View.GONE);\n                        } else {\n                            mTitleView.setVisibility(View.GONE);\n                        }\n                        mContentParent.setForeground(null);\n                    } else {\n                        mTitleView.setText(mTitle);\n                    }\n                }\n            }\n\n            if (mDecor.getBackground() == null && mBackgroundFallbackResource != 0) {\n                mDecor.setBackgroundFallback(mBackgroundFallbackResource);\n            }\n\n            // Only inflate or create a new TransitionManager if the caller hasn't\n            // already set a custom one.\n            if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) {\n                if (mTransitionManager == null) {\n                    final int transitionRes = getWindowStyle().getResourceId(\n                            R.styleable.Window_windowContentTransitionManager,\n                            0);\n                    if (transitionRes != 0) {\n                        final TransitionInflater inflater = TransitionInflater.from(getContext());\n                        mTransitionManager = inflater.inflateTransitionManager(transitionRes,\n                                mContentParent);\n                    } else {\n                        mTransitionManager = new TransitionManager();\n                    }\n                }\n                 //.... \n                 //用于对主题进行处理\n                mEnterTransition = getTransition(mEnterTransition, null,\n                        R.styleable.Window_windowEnterTransition);\n                 //....\n            }\n        }\n    }\n\n\n```\n\n在布局资源加载的过程中，创建出一个`DecrorView`\n```java\n    protected DecorView generateDecor(int featureId) {\n        // System process doesn't have application context and in that case we need to directly use\n        // the context we have. Otherwise we want the application context, so we don't cling to the\n        // activity.\n        /....\n        return new DecorView(context, featureId, this, getAttributes());\n    }\n\n\n```\n\n\n`DecrorView`继承自`FramLayout`，其是一个容器;\n\n```java\n    public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks {\n\n    }\n\n```\n\n```java\n  protected ViewGroup generateLayout(DecorView decor) {\n        // Apply data from current theme.\n\n        TypedArray a = getWindowStyle();\n\n        //根据 `R.styleable`设置窗口的主题\n        // .....\n        // Inflate the window decor.，解析窗口的View\n\n        int layoutResource;\n        int features = getLocalFeatures();\n        // System.out.println(\"Features: 0x\" + Integer.toHexString(features));\n        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n            layoutResource = R.layout.screen_swipe_dismiss;\n        } \n\n        //根据features的不同，加载不同的layoutResources\n\n        mDecor.startChanging();\n        //对layoutResource对应的不同布局进行解析，解析完成后加载到DecorView上\n        mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n\n        //ID_ANDROID_CONTENT主容器ID具有的值，而且一定存在\n        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n        if (contentParent == null) {\n            throw new RuntimeException(\"Window couldn't find content container view\");\n        }\n\n        return contentParent;\n    }\n\n\n```\n\n`onResourcesLoaded()`永不解析布局文件，并将解析出的布局文件,通过`addView`添加到`DecorView`中\n\n```java\n    void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n        mStackId = getStackId();\n\n       // .....\n        final View root = inflater.inflate(layoutResource, null);\n        if (mDecorCaptionView != null) {\n            if (mDecorCaptionView.getParent() == null) {\n                addView(mDecorCaptionView,\n                        new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n            }\n            mDecorCaptionView.addView(root,\n                    new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));\n        } \n          // .....\n      \n    }\n\n```\n\n### 在Android 9.0 下的绘制流程\n\n<center/>\n```flow\nst=>start: Start\nop=>operation: Your\ncond=>condition: Yes or No?\ne=>end: End\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n</center>\n\n### \n","source":"_posts/Android/View/UI绘制流程.md","raw":"---\ntitle: Android UI 绘制流程\ntype: [Android]\ndescription:  Android UI 绘制流程\ncover: /cover/img90.jpg\ntoc: true\ncategories: Android\ndate: 2018/06/15\n---\n\n\n\n##  UI绘制流程\n\n### View被添加到屏幕窗口的过程\n1、创建顶层布局容器DecroView，DecroView是一个ViewGroup容器，继承FrameLayout，是PhoneWindow类中持有的实例，所有应用程序的顶层View，在系统内部进行初始化，当DecroView初始化完成后，系统会根据应用的主题特性，加载一个基础容器，如NoActionBar或DarkActionBar，不同主题加载的基础容器不同，基础容器中一定有OnDraw.R.id.content的容器，该容器是一个FrameLayout，通过setCOntentView的xml文件被解析后添加到FrameLayout中\n2、在顶层布局中加载基础布局ViewGroup\n3、将ContentView添加到基础布局中的FrameLayout中\n\n\nView的绘制流程\n1、绘制入口\n    Actvityhread.handleResumeActivity\n    ——>WindowManagerImpl.addView(decorView,layoutParams) \n    ——>WindowManagerGlobal.addView()\n2、绘制类及方法\n    ViewRootImpl.setView(decorView,layoutParama,parentView)\n    ——>ViewRootImpl.requestLayout()——>scheduleTraversals()——> doTraversal()\n    ——> perfoemTraversals()\n3、绘制三大步骤\n    测量：ViewRootImpl.performMeasure\n    布局：ViewRootImpl.performLayout\n    绘制：ViewRootImpl.performDraw       \n\n\n\n### 在Android 7.0 下的绘制流程\n1、从setContentView()开始\n在Activity源码中\n\n```java\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n        initWindowDecorActionBar();\n    }\n```\n`Window`是一个抽象类，其只有一个实现类是`android.view.PhoneWindow`\n```java\n    //...\n    public Window getWindow() {\n        return mWindow;\n    }\n```\n`PhoneWindow`中`setContentView()`方法\n```java\n\n @Override\n    public void setContentView(int layoutResID) {\n        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n        // decor, when theme attributes and the like are crystalized. Do not check the feature\n        // before this happens.\n        if (mContentParent == null) {\n            installDecor();\n        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            mContentParent.removeAllViews();\n        }\n\n        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                    getContext());\n            transitionTo(newScene);\n        } else {\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n        }\n        mContentParent.requestApplyInsets();\n        final Callback cb = getCallback();\n        if (cb != null && !isDestroyed()) {\n            cb.onContentChanged();\n        }\n        mContentParentExplicitlySet = true;\n    }\n\n\n```\n\n```java\n private void installDecor() {\n        mForceDecorInstall = false;\n        if (mDecor == null) {\n            mDecor = generateDecor(-1);\n            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n            mDecor.setIsRootNamespace(true);\n            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n            }\n        } else {\n            mDecor.setWindow(this);\n        }\n        if (mContentParent == null) {\n            mContentParent = generateLayout(mDecor);\n\n            // Set up decor part of UI to ignore fitsSystemWindows if appropriate.\n            mDecor.makeOptionalFitsSystemWindows();\n\n            final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(\n                    R.id.decor_content_parent);\n\n            if (decorContentParent != null) {\n                mDecorContentParent = decorContentParent;\n                mDecorContentParent.setWindowCallback(getCallback());\n                if (mDecorContentParent.getTitle() == null) {\n                    mDecorContentParent.setWindowTitle(mTitle);\n                }\n\n                final int localFeatures = getLocalFeatures();\n                for (int i = 0; i < FEATURE_MAX; i++) {\n                    if ((localFeatures & (1 << i)) != 0) {\n                        mDecorContentParent.initFeature(i);\n                    }\n                }\n\n                mDecorContentParent.setUiOptions(mUiOptions);\n\n                if ((mResourcesSetFlags & FLAG_RESOURCE_SET_ICON) != 0 ||\n                        (mIconRes != 0 && !mDecorContentParent.hasIcon())) {\n                    mDecorContentParent.setIcon(mIconRes);\n                } else if ((mResourcesSetFlags & FLAG_RESOURCE_SET_ICON) == 0 &&\n                        mIconRes == 0 && !mDecorContentParent.hasIcon()) {\n                    mDecorContentParent.setIcon(\n                            getContext().getPackageManager().getDefaultActivityIcon());\n                    mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;\n                }\n                if ((mResourcesSetFlags & FLAG_RESOURCE_SET_LOGO) != 0 ||\n                        (mLogoRes != 0 && !mDecorContentParent.hasLogo())) {\n                    mDecorContentParent.setLogo(mLogoRes);\n                }\n\n                // Invalidate if the panel menu hasn't been created before this.\n                // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu\n                // being called in the middle of onCreate or similar.\n                // A pending invalidation will typically be resolved before the posted message\n                // would run normally in order to satisfy instance state restoration.\n                PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);\n                if (!isDestroyed() && (st == null || st.menu == null) && !mIsStartingWindow) {\n                    invalidatePanelMenu(FEATURE_ACTION_BAR);\n                }\n            } else {\n                mTitleView = (TextView) findViewById(R.id.title);\n                if (mTitleView != null) {\n                    if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {\n                        final View titleContainer = findViewById(R.id.title_container);\n                        if (titleContainer != null) {\n                            titleContainer.setVisibility(View.GONE);\n                        } else {\n                            mTitleView.setVisibility(View.GONE);\n                        }\n                        mContentParent.setForeground(null);\n                    } else {\n                        mTitleView.setText(mTitle);\n                    }\n                }\n            }\n\n            if (mDecor.getBackground() == null && mBackgroundFallbackResource != 0) {\n                mDecor.setBackgroundFallback(mBackgroundFallbackResource);\n            }\n\n            // Only inflate or create a new TransitionManager if the caller hasn't\n            // already set a custom one.\n            if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) {\n                if (mTransitionManager == null) {\n                    final int transitionRes = getWindowStyle().getResourceId(\n                            R.styleable.Window_windowContentTransitionManager,\n                            0);\n                    if (transitionRes != 0) {\n                        final TransitionInflater inflater = TransitionInflater.from(getContext());\n                        mTransitionManager = inflater.inflateTransitionManager(transitionRes,\n                                mContentParent);\n                    } else {\n                        mTransitionManager = new TransitionManager();\n                    }\n                }\n                 //.... \n                 //用于对主题进行处理\n                mEnterTransition = getTransition(mEnterTransition, null,\n                        R.styleable.Window_windowEnterTransition);\n                 //....\n            }\n        }\n    }\n\n\n```\n\n在布局资源加载的过程中，创建出一个`DecrorView`\n```java\n    protected DecorView generateDecor(int featureId) {\n        // System process doesn't have application context and in that case we need to directly use\n        // the context we have. Otherwise we want the application context, so we don't cling to the\n        // activity.\n        /....\n        return new DecorView(context, featureId, this, getAttributes());\n    }\n\n\n```\n\n\n`DecrorView`继承自`FramLayout`，其是一个容器;\n\n```java\n    public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks {\n\n    }\n\n```\n\n```java\n  protected ViewGroup generateLayout(DecorView decor) {\n        // Apply data from current theme.\n\n        TypedArray a = getWindowStyle();\n\n        //根据 `R.styleable`设置窗口的主题\n        // .....\n        // Inflate the window decor.，解析窗口的View\n\n        int layoutResource;\n        int features = getLocalFeatures();\n        // System.out.println(\"Features: 0x\" + Integer.toHexString(features));\n        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n            layoutResource = R.layout.screen_swipe_dismiss;\n        } \n\n        //根据features的不同，加载不同的layoutResources\n\n        mDecor.startChanging();\n        //对layoutResource对应的不同布局进行解析，解析完成后加载到DecorView上\n        mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n\n        //ID_ANDROID_CONTENT主容器ID具有的值，而且一定存在\n        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n        if (contentParent == null) {\n            throw new RuntimeException(\"Window couldn't find content container view\");\n        }\n\n        return contentParent;\n    }\n\n\n```\n\n`onResourcesLoaded()`永不解析布局文件，并将解析出的布局文件,通过`addView`添加到`DecorView`中\n\n```java\n    void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n        mStackId = getStackId();\n\n       // .....\n        final View root = inflater.inflate(layoutResource, null);\n        if (mDecorCaptionView != null) {\n            if (mDecorCaptionView.getParent() == null) {\n                addView(mDecorCaptionView,\n                        new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n            }\n            mDecorCaptionView.addView(root,\n                    new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));\n        } \n          // .....\n      \n    }\n\n```\n\n### 在Android 9.0 下的绘制流程\n\n<center/>\n```flow\nst=>start: Start\nop=>operation: Your\ncond=>condition: Yes or No?\ne=>end: End\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n</center>\n\n### \n","slug":"Android/View/UI绘制流程","published":1,"updated":"2021-01-05T12:14:15.188Z","_id":"ckjju0m1j004v20uagvc3f4yb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"UI绘制流程\"><a href=\"#UI绘制流程\" class=\"headerlink\" title=\"UI绘制流程\"></a>UI绘制流程</h2><h3 id=\"View被添加到屏幕窗口的过程\"><a href=\"#View被添加到屏幕窗口的过程\" class=\"headerlink\" title=\"View被添加到屏幕窗口的过程\"></a>View被添加到屏幕窗口的过程</h3><p>1、创建顶层布局容器DecroView，DecroView是一个ViewGroup容器，继承FrameLayout，是PhoneWindow类中持有的实例，所有应用程序的顶层View，在系统内部进行初始化，当DecroView初始化完成后，系统会根据应用的主题特性，加载一个基础容器，如NoActionBar或DarkActionBar，不同主题加载的基础容器不同，基础容器中一定有OnDraw.R.id.content的容器，该容器是一个FrameLayout，通过setCOntentView的xml文件被解析后添加到FrameLayout中<br>2、在顶层布局中加载基础布局ViewGroup<br>3、将ContentView添加到基础布局中的FrameLayout中</p>\n<p>View的绘制流程<br>1、绘制入口<br>    Actvityhread.handleResumeActivity<br>    ——&gt;WindowManagerImpl.addView(decorView,layoutParams)<br>    ——&gt;WindowManagerGlobal.addView()<br>2、绘制类及方法<br>    ViewRootImpl.setView(decorView,layoutParama,parentView)<br>    ——&gt;ViewRootImpl.requestLayout()——&gt;scheduleTraversals()——&gt; doTraversal()<br>    ——&gt; perfoemTraversals()<br>3、绘制三大步骤<br>    测量：ViewRootImpl.performMeasure<br>    布局：ViewRootImpl.performLayout<br>    绘制：ViewRootImpl.performDraw       </p>\n<h3 id=\"在Android-7-0-下的绘制流程\"><a href=\"#在Android-7-0-下的绘制流程\" class=\"headerlink\" title=\"在Android 7.0 下的绘制流程\"></a>在Android 7.0 下的绘制流程</h3><p>1、从setContentView()开始<br>在Activity源码中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">    getWindow().setContentView(layoutResID);</span><br><span class=\"line\">    initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Window</code>是一个抽象类，其只有一个实现类是<code>android.view.PhoneWindow</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Window <span class=\"title\">getWindow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mWindow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>PhoneWindow</code>中<code>setContentView()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class=\"line\">       <span class=\"comment\">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class=\"line\">       <span class=\"comment\">// before this happens.</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           installDecor();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">           mContentParent.removeAllViews();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class=\"line\">                   getContext());</span><br><span class=\"line\">           transitionTo(newScene);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       mContentParent.requestApplyInsets();</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">           cb.onContentChanged();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       mForceDecorInstall = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mDecor = generateDecor(-<span class=\"number\">1</span>);</span><br><span class=\"line\">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class=\"line\">           mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           mDecor.setWindow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mContentParent = generateLayout(mDecor);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class=\"line\">           mDecor.makeOptionalFitsSystemWindows();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class=\"line\">                   R.id.decor_content_parent);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (decorContentParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               mDecorContentParent = decorContentParent;</span><br><span class=\"line\">               mDecorContentParent.setWindowCallback(getCallback());</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (mDecorContentParent.getTitle() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setWindowTitle(mTitle);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localFeatures = getLocalFeatures();</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> ((localFeatures &amp; (<span class=\"number\">1</span> &lt;&lt; i)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                       mDecorContentParent.initFeature(i);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != <span class=\"number\">0</span> ||</span><br><span class=\"line\">                       (mIconRes != <span class=\"number\">0</span> &amp;&amp; !mDecorContentParent.hasIcon())) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setIcon(mIconRes);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                       mIconRes == <span class=\"number\">0</span> &amp;&amp; !mDecorContentParent.hasIcon()) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setIcon(</span><br><span class=\"line\">                           getContext().getPackageManager().getDefaultActivityIcon());</span><br><span class=\"line\">                   mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != <span class=\"number\">0</span> ||</span><br><span class=\"line\">                       (mLogoRes != <span class=\"number\">0</span> &amp;&amp; !mDecorContentParent.hasLogo())) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setLogo(mLogoRes);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">// Invalidate if the panel menu hasn&#x27;t been created before this.</span></span><br><span class=\"line\">               <span class=\"comment\">// Panel menu invalidation is deferred avoiding application onCreateOptionsMenu</span></span><br><span class=\"line\">               <span class=\"comment\">// being called in the middle of onCreate or similar.</span></span><br><span class=\"line\">               <span class=\"comment\">// A pending invalidation will typically be resolved before the posted message</span></span><br><span class=\"line\">               <span class=\"comment\">// would run normally in order to satisfy instance state restoration.</span></span><br><span class=\"line\">               PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!isDestroyed() &amp;&amp; (st == <span class=\"keyword\">null</span> || st.menu == <span class=\"keyword\">null</span>) &amp;&amp; !mIsStartingWindow) &#123;</span><br><span class=\"line\">                   invalidatePanelMenu(FEATURE_ACTION_BAR);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               mTitleView = (TextView) findViewById(R.id.title);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (mTitleView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> ((getLocalFeatures() &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">final</span> View titleContainer = findViewById(R.id.title_container);</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (titleContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                           titleContainer.setVisibility(View.GONE);</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                           mTitleView.setVisibility(View.GONE);</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                       mContentParent.setForeground(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       mTitleView.setText(mTitle);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (mDecor.getBackground() == <span class=\"keyword\">null</span> &amp;&amp; mBackgroundFallbackResource != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Only inflate or create a new TransitionManager if the caller hasn&#x27;t</span></span><br><span class=\"line\">           <span class=\"comment\">// already set a custom one.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (mTransitionManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> transitionRes = getWindowStyle().getResourceId(</span><br><span class=\"line\">                           R.styleable.Window_windowContentTransitionManager,</span><br><span class=\"line\">                           <span class=\"number\">0</span>);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (transitionRes != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">final</span> TransitionInflater inflater = TransitionInflater.from(getContext());</span><br><span class=\"line\">                       mTransitionManager = inflater.inflateTransitionManager(transitionRes,</span><br><span class=\"line\">                               mContentParent);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       mTransitionManager = <span class=\"keyword\">new</span> TransitionManager();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">                <span class=\"comment\">//.... </span></span><br><span class=\"line\">                <span class=\"comment\">//用于对主题进行处理</span></span><br><span class=\"line\">               mEnterTransition = getTransition(mEnterTransition, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                       R.styleable.Window_windowEnterTransition);</span><br><span class=\"line\">                <span class=\"comment\">//....</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在布局资源加载的过程中，创建出一个<code>DecrorView</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DecorView <span class=\"title\">generateDecor</span><span class=\"params\">(<span class=\"keyword\">int</span> featureId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// System process doesn&#x27;t have application context and in that case we need to directly use</span></span><br><span class=\"line\">    <span class=\"comment\">// the context we have. Otherwise we want the application context, so we don&#x27;t cling to the</span></span><br><span class=\"line\">    <span class=\"comment\">// activity.</span></span><br><span class=\"line\">    /....</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DecorView(context, featureId, <span class=\"keyword\">this</span>, getAttributes());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>DecrorView</code>继承自<code>FramLayout</code>，其是一个容器;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorView</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrameLayout</span> <span class=\"keyword\">implements</span> <span class=\"title\">RootViewSurfaceTaker</span>, <span class=\"title\">WindowCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ViewGroup <span class=\"title\">generateLayout</span><span class=\"params\">(DecorView decor)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// Apply data from current theme.</span></span><br><span class=\"line\"></span><br><span class=\"line\">      TypedArray a = getWindowStyle();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//根据 `R.styleable`设置窗口的主题</span></span><br><span class=\"line\">      <span class=\"comment\">// .....</span></span><br><span class=\"line\">      <span class=\"comment\">// Inflate the window decor.，解析窗口的View</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int</span> layoutResource;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> features = getLocalFeatures();</span><br><span class=\"line\">      <span class=\"comment\">// System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//根据features的不同，加载不同的layoutResources</span></span><br><span class=\"line\"></span><br><span class=\"line\">      mDecor.startChanging();</span><br><span class=\"line\">      <span class=\"comment\">//对layoutResource对应的不同布局进行解析，解析完成后加载到DecorView上</span></span><br><span class=\"line\">      mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//ID_ANDROID_CONTENT主容器ID具有的值，而且一定存在</span></span><br><span class=\"line\">      ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (contentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Window couldn&#x27;t find content container view&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> contentParent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>onResourcesLoaded()</code>永不解析布局文件，并将解析出的布局文件,通过<code>addView</code>添加到<code>DecorView</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onResourcesLoaded</span><span class=\"params\">(LayoutInflater inflater, <span class=\"keyword\">int</span> layoutResource)</span> </span>&#123;</span><br><span class=\"line\">    mStackId = getStackId();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// .....</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> View root = inflater.inflate(layoutResource, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDecorCaptionView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDecorCaptionView.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            addView(mDecorCaptionView,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mDecorCaptionView.addView(root,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"comment\">// .....</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"在Android-9-0-下的绘制流程\"><a href=\"#在Android-9-0-下的绘制流程\" class=\"headerlink\" title=\"在Android 9.0 下的绘制流程\"></a>在Android 9.0 下的绘制流程</h3><center/>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st&#x3D;&gt;start: Start</span><br><span class=\"line\">op&#x3D;&gt;operation: Your</span><br><span class=\"line\">cond&#x3D;&gt;condition: Yes or No?</span><br><span class=\"line\">e&#x3D;&gt;end: End</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n</center>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"UI绘制流程\"><a href=\"#UI绘制流程\" class=\"headerlink\" title=\"UI绘制流程\"></a>UI绘制流程</h2><h3 id=\"View被添加到屏幕窗口的过程\"><a href=\"#View被添加到屏幕窗口的过程\" class=\"headerlink\" title=\"View被添加到屏幕窗口的过程\"></a>View被添加到屏幕窗口的过程</h3><p>1、创建顶层布局容器DecroView，DecroView是一个ViewGroup容器，继承FrameLayout，是PhoneWindow类中持有的实例，所有应用程序的顶层View，在系统内部进行初始化，当DecroView初始化完成后，系统会根据应用的主题特性，加载一个基础容器，如NoActionBar或DarkActionBar，不同主题加载的基础容器不同，基础容器中一定有OnDraw.R.id.content的容器，该容器是一个FrameLayout，通过setCOntentView的xml文件被解析后添加到FrameLayout中<br>2、在顶层布局中加载基础布局ViewGroup<br>3、将ContentView添加到基础布局中的FrameLayout中</p>\n<p>View的绘制流程<br>1、绘制入口<br>    Actvityhread.handleResumeActivity<br>    ——&gt;WindowManagerImpl.addView(decorView,layoutParams)<br>    ——&gt;WindowManagerGlobal.addView()<br>2、绘制类及方法<br>    ViewRootImpl.setView(decorView,layoutParama,parentView)<br>    ——&gt;ViewRootImpl.requestLayout()——&gt;scheduleTraversals()——&gt; doTraversal()<br>    ——&gt; perfoemTraversals()<br>3、绘制三大步骤<br>    测量：ViewRootImpl.performMeasure<br>    布局：ViewRootImpl.performLayout<br>    绘制：ViewRootImpl.performDraw       </p>\n<h3 id=\"在Android-7-0-下的绘制流程\"><a href=\"#在Android-7-0-下的绘制流程\" class=\"headerlink\" title=\"在Android 7.0 下的绘制流程\"></a>在Android 7.0 下的绘制流程</h3><p>1、从setContentView()开始<br>在Activity源码中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">    getWindow().setContentView(layoutResID);</span><br><span class=\"line\">    initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Window</code>是一个抽象类，其只有一个实现类是<code>android.view.PhoneWindow</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Window <span class=\"title\">getWindow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mWindow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>PhoneWindow</code>中<code>setContentView()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class=\"line\">       <span class=\"comment\">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class=\"line\">       <span class=\"comment\">// before this happens.</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           installDecor();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">           mContentParent.removeAllViews();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class=\"line\">                   getContext());</span><br><span class=\"line\">           transitionTo(newScene);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       mContentParent.requestApplyInsets();</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">           cb.onContentChanged();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       mForceDecorInstall = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mDecor = generateDecor(-<span class=\"number\">1</span>);</span><br><span class=\"line\">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class=\"line\">           mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           mDecor.setWindow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           mContentParent = generateLayout(mDecor);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class=\"line\">           mDecor.makeOptionalFitsSystemWindows();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class=\"line\">                   R.id.decor_content_parent);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (decorContentParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               mDecorContentParent = decorContentParent;</span><br><span class=\"line\">               mDecorContentParent.setWindowCallback(getCallback());</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (mDecorContentParent.getTitle() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setWindowTitle(mTitle);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> localFeatures = getLocalFeatures();</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; FEATURE_MAX; i++) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> ((localFeatures &amp; (<span class=\"number\">1</span> &lt;&lt; i)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                       mDecorContentParent.initFeature(i);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               mDecorContentParent.setUiOptions(mUiOptions);</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != <span class=\"number\">0</span> ||</span><br><span class=\"line\">                       (mIconRes != <span class=\"number\">0</span> &amp;&amp; !mDecorContentParent.hasIcon())) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setIcon(mIconRes);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                       mIconRes == <span class=\"number\">0</span> &amp;&amp; !mDecorContentParent.hasIcon()) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setIcon(</span><br><span class=\"line\">                           getContext().getPackageManager().getDefaultActivityIcon());</span><br><span class=\"line\">                   mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != <span class=\"number\">0</span> ||</span><br><span class=\"line\">                       (mLogoRes != <span class=\"number\">0</span> &amp;&amp; !mDecorContentParent.hasLogo())) &#123;</span><br><span class=\"line\">                   mDecorContentParent.setLogo(mLogoRes);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">// Invalidate if the panel menu hasn&#x27;t been created before this.</span></span><br><span class=\"line\">               <span class=\"comment\">// Panel menu invalidation is deferred avoiding application onCreateOptionsMenu</span></span><br><span class=\"line\">               <span class=\"comment\">// being called in the middle of onCreate or similar.</span></span><br><span class=\"line\">               <span class=\"comment\">// A pending invalidation will typically be resolved before the posted message</span></span><br><span class=\"line\">               <span class=\"comment\">// would run normally in order to satisfy instance state restoration.</span></span><br><span class=\"line\">               PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (!isDestroyed() &amp;&amp; (st == <span class=\"keyword\">null</span> || st.menu == <span class=\"keyword\">null</span>) &amp;&amp; !mIsStartingWindow) &#123;</span><br><span class=\"line\">                   invalidatePanelMenu(FEATURE_ACTION_BAR);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               mTitleView = (TextView) findViewById(R.id.title);</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (mTitleView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> ((getLocalFeatures() &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">final</span> View titleContainer = findViewById(R.id.title_container);</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (titleContainer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                           titleContainer.setVisibility(View.GONE);</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                           mTitleView.setVisibility(View.GONE);</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                       mContentParent.setForeground(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       mTitleView.setText(mTitle);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (mDecor.getBackground() == <span class=\"keyword\">null</span> &amp;&amp; mBackgroundFallbackResource != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// Only inflate or create a new TransitionManager if the caller hasn&#x27;t</span></span><br><span class=\"line\">           <span class=\"comment\">// already set a custom one.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (mTransitionManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> transitionRes = getWindowStyle().getResourceId(</span><br><span class=\"line\">                           R.styleable.Window_windowContentTransitionManager,</span><br><span class=\"line\">                           <span class=\"number\">0</span>);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (transitionRes != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">final</span> TransitionInflater inflater = TransitionInflater.from(getContext());</span><br><span class=\"line\">                       mTransitionManager = inflater.inflateTransitionManager(transitionRes,</span><br><span class=\"line\">                               mContentParent);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       mTransitionManager = <span class=\"keyword\">new</span> TransitionManager();</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">                <span class=\"comment\">//.... </span></span><br><span class=\"line\">                <span class=\"comment\">//用于对主题进行处理</span></span><br><span class=\"line\">               mEnterTransition = getTransition(mEnterTransition, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                       R.styleable.Window_windowEnterTransition);</span><br><span class=\"line\">                <span class=\"comment\">//....</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在布局资源加载的过程中，创建出一个<code>DecrorView</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DecorView <span class=\"title\">generateDecor</span><span class=\"params\">(<span class=\"keyword\">int</span> featureId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// System process doesn&#x27;t have application context and in that case we need to directly use</span></span><br><span class=\"line\">    <span class=\"comment\">// the context we have. Otherwise we want the application context, so we don&#x27;t cling to the</span></span><br><span class=\"line\">    <span class=\"comment\">// activity.</span></span><br><span class=\"line\">    /....</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DecorView(context, featureId, <span class=\"keyword\">this</span>, getAttributes());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>DecrorView</code>继承自<code>FramLayout</code>，其是一个容器;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorView</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrameLayout</span> <span class=\"keyword\">implements</span> <span class=\"title\">RootViewSurfaceTaker</span>, <span class=\"title\">WindowCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ViewGroup <span class=\"title\">generateLayout</span><span class=\"params\">(DecorView decor)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// Apply data from current theme.</span></span><br><span class=\"line\"></span><br><span class=\"line\">      TypedArray a = getWindowStyle();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//根据 `R.styleable`设置窗口的主题</span></span><br><span class=\"line\">      <span class=\"comment\">// .....</span></span><br><span class=\"line\">      <span class=\"comment\">// Inflate the window decor.，解析窗口的View</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int</span> layoutResource;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> features = getLocalFeatures();</span><br><span class=\"line\">      <span class=\"comment\">// System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//根据features的不同，加载不同的layoutResources</span></span><br><span class=\"line\"></span><br><span class=\"line\">      mDecor.startChanging();</span><br><span class=\"line\">      <span class=\"comment\">//对layoutResource对应的不同布局进行解析，解析完成后加载到DecorView上</span></span><br><span class=\"line\">      mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//ID_ANDROID_CONTENT主容器ID具有的值，而且一定存在</span></span><br><span class=\"line\">      ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (contentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Window couldn&#x27;t find content container view&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> contentParent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>onResourcesLoaded()</code>永不解析布局文件，并将解析出的布局文件,通过<code>addView</code>添加到<code>DecorView</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onResourcesLoaded</span><span class=\"params\">(LayoutInflater inflater, <span class=\"keyword\">int</span> layoutResource)</span> </span>&#123;</span><br><span class=\"line\">    mStackId = getStackId();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// .....</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> View root = inflater.inflate(layoutResource, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDecorCaptionView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDecorCaptionView.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            addView(mDecorCaptionView,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mDecorCaptionView.addView(root,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"comment\">// .....</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"在Android-9-0-下的绘制流程\"><a href=\"#在Android-9-0-下的绘制流程\" class=\"headerlink\" title=\"在Android 9.0 下的绘制流程\"></a>在Android 9.0 下的绘制流程</h3><center/>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st&#x3D;&gt;start: Start</span><br><span class=\"line\">op&#x3D;&gt;operation: Your</span><br><span class=\"line\">cond&#x3D;&gt;condition: Yes or No?</span><br><span class=\"line\">e&#x3D;&gt;end: End</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n</center>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>"},{"title":"Android 事件分发机制","type":["Android"],"description":"Android 事件分发机制","cover":"/cover/img91.jpg","toc":true,"date":"2018-07-19T16:00:00.000Z","_content":"\n## 事件分发机制\n\n事件定义：当用户触摸屏幕时，讲产生的触摸行为(Touch事件)\n\n事件类型:\n* MotionEvent.ACTION_DOWN 手指刚接触屏幕\n* MotionEvent.ACTION_UP 手指从屏幕上松开\n* MotionEvent.ACTION_MOVE 手指在屏幕上滑动\n* MotionEvent.ACTION_CANCEL非人为因素取消\n\n\n事件序列\n\n正常情况下，一次手指触摸屏幕的行为会出发一系列点击事件\n\n1、点击屏幕后立即松开，事件序列为DOWN->UP；\n\n2、点击屏幕滑动一会再松开，事件序列为DOWN->MOVE->....->MOVE->UP；\n\n3、正常情况下，一个事件序列只能被一个View进行拦截并消耗；\n\n4、某个View一旦决定拦截，那么这个事件序列都将由它的 onTouchEvent 处理，并且它的 onInterceptTouchEvent 不会再调用；\n5、某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中其他事件都不会再交给它处理。并且重新交由它的父元素处理(父元素onTouchEvent被调用)；\n\n6、事件的传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowIntercept方法可以在子VIew中干预父元素的事件分发过程，但ACTION_DOWN除外；\n\n7、ViewGroup默认不拦截任何事件，即onInterceptTouchEvent默认返回false。View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用；\n\n8、View的onTouchEvent默认会消耗事件（返回true），除非它是不可点击的(clickable和longCLickable同时为false)。View的longClickable默认都是false，clickable分情况，Button的clickable默认为true，TextView的clickable默认为false。\n\n9、View的enable属性不影响onTouchEvent的默认返回值。即使View是disable状态的，只要它的clickable和longClickable有一个为true,那么其onToucheEvent就返回true\n\n10、onClick会相应的前提是当前View是可以点击的，并且收到了ACTION_DOWN和ACTION_UP的事件，并且受长按事件的影响，当长按事件返回true时，onClick不会响应\n\n11、onLongClick在ACTION_DOWN里判断是否进行相应，要想执行长按事件，该View必须是longClickable的并且设置了OnClickListener\n\n\n\n\n\n事件分发的对象\n\n* Activity：控制生命周期& 处理事件\n* ViewGroup： 一组View的集合（含有多个子View）\n* View：所有UI组件的基类\n\n事件分发主要方法\n\n* dispatchTouchEvent(MotionEvent ev)：用来进行事件分发\n* onInterceptTouchEvent(MotionEvent ev)：判断是否拦截事件（只存在于ViewGroup中）\n* onTouchEvent（MotionEvent ev）：处理点击事件，消费事件\n\nAndroid事件分发是先传到ViewGroup,再传到View中，ViewGroup中可以通过 `onInterceptTouchEvent(MotionEvent ev) `方法对事件进行拦截，返回true表示允许继续向子View进行传递，返回false表示不对事件进行拦截，默认false；当ViewGroup对事件进行拦截后，`onInterceptTouchEvent(MotionEvent ev) `方法不会被调用。\n\nViewGroup中`dispatchTouchEvent()` 真正对事件进行分发，而View中`dispatchTouchEvent()`方法，不对事件进行分发，或者起分发对象为自己本身。\n\n在 `dispatchTouchEvent()` 方法中做的永远是事件分发工作，而在`onTouchEvent()`方法中真正处理事件；在ViewGroup中没有`onTouchEvent()`方法，而直接调用View中的`onTouchEvent()`方法。\n\n当ViewGroup所有的子View返回false，其`onTouchEvent()`事件才会被触发。\n\n\n源码分析：\n\n在Activity中 `dispatchTouchEvent()` 方法的返回值代表事件是否被消费。\n`onUserInteraction()`是一个空方法，可以由子类实现。如果`getWindow().superDispatchTouchEvent(ev)`方法返回`true`代表事件结束（实际是由ViewGroup 的`dispatchTouchEvent(MotionEvent ev)`方法返回的`true`，见下文），如果返回`false`则执行onTouchEvent(ev);\n```java\n  public boolean dispatchTouchEvent(MotionEvent ev) {\n         if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n             \n             onUserInteraction();\n         }\n         if (getWindow().superDispatchTouchEvent(ev)) {\n             return true;\n         }\n         return onTouchEvent(ev);\n     }\n\n```\n`onTouchEvent(ev)`在Activty中的源码，首先判断是否超出边界，如果超出边界直接finish()掉，如果没有超出边界，表示该事件也结束。\n```java\n public boolean onTouchEvent(MotionEvent event) {\n        if (mWindow.shouldCloseOnTouch(this, event)) {\n            finish();\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n\n`getWindow().superDispatchTouchEvent(ev)` 调用的是`PhoneWindow`类中的方法，其中`mDecror`（DecorView类型）是window的一个顶层view,包含window的`decor`\n\n``` java\n    @Override\n    public boolean superDispatchTouchEvent(MotionEvent event) {\n        return mDecor.superDispatchTouchEvent(event);\n    }\n\n```\nDecorView是FrameLayout的子类，`superDispatchTouchEvent(event)`源码，其实际上调用的是`VieGroup`中的`dispatchTouchEvent(MotionEvent ev) `方法\n\n```java\n\n   public boolean superDispatchTouchEvent(MotionEvent event) {\n        return super.dispatchTouchEvent(event);\n    }\n\n```    \n`VieGroup`中的`dispatchTouchEvent(MotionEvent ev) `方法伪代码\n\n```java\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        //伪代码\n        boolon consume=false;\n        //调用onInterceptTouchEvent判断是否拦截\n        if(onInterceptTouchEvent(ev)){\n            //拦截则调用自身的onTouchEvent\n            consume=onTouchEvent(ev);\n        }else{\n            //不拦截，将事件分发给子View\n            consume=child.dispatchTouchEvent(ev);\n        }\n        return consume;\n\n    }\n\n```\n` cancelAndClearTouchTargets(ev);`源码，该方法将`mFirstTouchTarget`进行置空操作\n\n```java\n /**\n     * Cancels and clears all touch targets.\n     */\n private void cancelAndClearTouchTargets(MotionEvent event) {\n        if (mFirstTouchTarget != null) {\n            boolean syntheticEvent = false;\n            if (event == null) {\n                final long now = SystemClock.uptimeMillis();\n                event = MotionEvent.obtain(now, now,\n                        MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);\n                event.setSource(InputDevice.SOURCE_TOUCHSCREEN);\n                syntheticEvent = true;\n            }\n\n            for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {\n                resetCancelNextUpFlag(target.child);\n                dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);\n            }\n            clearTouchTargets();\n\n            if (syntheticEvent) {\n                event.recycle();\n            }\n        }\n    }\n\n```\n在`ViewGroup`中`resetTouchState()`源码\n```java\n    private void resetTouchState() {\n        clearTouchTargets();\n        resetCancelNextUpFlag(this);\n        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        mNestedScrollAxes = SCROLL_AXIS_NONE;\n    }\n\n```\n在`ViewGroup`中`requestDisallowInterceptTouchEvent(boolean disallowIntercept)`源码\n```java\n    @Override\n    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {\n            // We're already in this state, assume our ancestors are too\n            return;\n        }\n\n        if (disallowIntercept) {\n            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;\n        } else {\n            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        }\n\n        // Pass it up to our parent\n        if (mParent != null) {\n            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n```\n\nViewGroup中的 onInterceptTouchEvent方法源码，默认为false即不发生拦截\n\n```java\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)\n                && ev.getAction() == MotionEvent.ACTION_DOWN\n                && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)\n                && isOnScrollbarThumb(ev.getX(), ev.getY())) {\n            return true;\n        }\n        return false;\n    }\n\n```\n\nViewGroup的事件分发，dispatchransformedTouchEvent()\n\n```java\nprivate boolean dispatchransformedTouchEvent(MotionEvent event,boolean cancel,View child,int disiredPointerBits){\n    final boolean handled;\n    //...\n    if(child==null){\n        handled=super.dispatchTouchEvent(event);  //调用到View的dispatchTouchEvent(event)\n    }else{\n        handled=child.dispatchTouchEvent(event);  //调用到child的dispatchTouchEvent(event)\n    }\n    //...\n    event.setAction(oldAction);\n    return handled;\n    //...\n}\n\n```\n\nView的事件分发\n```java\npublic boolean diapatchTouchEvent(MotionEvent ev){\n    //...\n    boolean result =false;\n    //当前View是否可见（未被其他窗口遮盖且未隐藏）\n    if(onFilterTouchEventForSecurity(event)){\n        ListenerInfo li=mListenerInfo;\n        //如果设置TouchListener，先响应TouchListener.onTouch\n        if(li!=null&&li.mOnTouchListener!=null&&(mViewFlags&ENABLE_MASK)==ENABLE&&li.mOnTouchListener.onTouch(this,event)){\n            return true;\n        }\n        if(!result&&onTouchEvent(event)){\n            //如果TouchListener.onTouch返回false才执行onTouchEvent\n            result=true;\n        }\n    }\n\n    //...\n    return result;\n}\n\n```\n\nView的事件消费\n\n```java\n    public boolean onTouchEvent(MotionEvent event){\n        //...\n        //如果当前的View是DISABLE状态，是可点击的/可长按，则会消费掉事件，不让它继续\n        if((viewFlags&ENABLED_MASK)==DISABLED){\n            //...\n            return((viewFlags&CLICKABLE)==CLICKABLE\n            ||(viewFlags&LONG_CLICKABLE)==LONG_CLICKABLE\n            ||(viewFlags&CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE);\n        }\n\n        //如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true\n        if(mTouchDelegate!=null){\n            if(mTouchDelegate.onTouchEvent(event)){\n                //如果有TouchDelegate的话，优先交给它处理\n                return true; //处理成功返回true，否则接着往下走\n            }\n        }\n\n        //如果View可点击/长按，则最终一定会return true\n        if(((viewFlags&CLICKABLE)==CLICKABLE\n            ||(viewFlags&LONG_CLICKABLE)==LONG_CLICKABLE)\n            ||(viewFlags&CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE)){\n                switch(action){\n                    case MotionEvent.ACTION_UP: //抬起，判断是否处理点击事件\n                    break;\n                    case MotionEvent.ACTION_DOWN: //按下，处理长事件\n                    break;\n                    case MotionEvent.ACTION_MOVE: //移动，检测触摸是否划出了控件，移除响应事件\n                    break;\n                }\n                return true;\n            }\n            return false;\n    }\n\n\n```\n\n\n### Android事件流程图\n","source":"_posts/Android/View/事件分发机制.md","raw":"---\ntitle: Android 事件分发机制\ntype: [Android]\ndescription:  Android 事件分发机制\ncover: /cover/img91.jpg\ntoc: true\ncategories: Android\ndate: 2018/07/20\n---\n\n## 事件分发机制\n\n事件定义：当用户触摸屏幕时，讲产生的触摸行为(Touch事件)\n\n事件类型:\n* MotionEvent.ACTION_DOWN 手指刚接触屏幕\n* MotionEvent.ACTION_UP 手指从屏幕上松开\n* MotionEvent.ACTION_MOVE 手指在屏幕上滑动\n* MotionEvent.ACTION_CANCEL非人为因素取消\n\n\n事件序列\n\n正常情况下，一次手指触摸屏幕的行为会出发一系列点击事件\n\n1、点击屏幕后立即松开，事件序列为DOWN->UP；\n\n2、点击屏幕滑动一会再松开，事件序列为DOWN->MOVE->....->MOVE->UP；\n\n3、正常情况下，一个事件序列只能被一个View进行拦截并消耗；\n\n4、某个View一旦决定拦截，那么这个事件序列都将由它的 onTouchEvent 处理，并且它的 onInterceptTouchEvent 不会再调用；\n5、某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中其他事件都不会再交给它处理。并且重新交由它的父元素处理(父元素onTouchEvent被调用)；\n\n6、事件的传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowIntercept方法可以在子VIew中干预父元素的事件分发过程，但ACTION_DOWN除外；\n\n7、ViewGroup默认不拦截任何事件，即onInterceptTouchEvent默认返回false。View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用；\n\n8、View的onTouchEvent默认会消耗事件（返回true），除非它是不可点击的(clickable和longCLickable同时为false)。View的longClickable默认都是false，clickable分情况，Button的clickable默认为true，TextView的clickable默认为false。\n\n9、View的enable属性不影响onTouchEvent的默认返回值。即使View是disable状态的，只要它的clickable和longClickable有一个为true,那么其onToucheEvent就返回true\n\n10、onClick会相应的前提是当前View是可以点击的，并且收到了ACTION_DOWN和ACTION_UP的事件，并且受长按事件的影响，当长按事件返回true时，onClick不会响应\n\n11、onLongClick在ACTION_DOWN里判断是否进行相应，要想执行长按事件，该View必须是longClickable的并且设置了OnClickListener\n\n\n\n\n\n事件分发的对象\n\n* Activity：控制生命周期& 处理事件\n* ViewGroup： 一组View的集合（含有多个子View）\n* View：所有UI组件的基类\n\n事件分发主要方法\n\n* dispatchTouchEvent(MotionEvent ev)：用来进行事件分发\n* onInterceptTouchEvent(MotionEvent ev)：判断是否拦截事件（只存在于ViewGroup中）\n* onTouchEvent（MotionEvent ev）：处理点击事件，消费事件\n\nAndroid事件分发是先传到ViewGroup,再传到View中，ViewGroup中可以通过 `onInterceptTouchEvent(MotionEvent ev) `方法对事件进行拦截，返回true表示允许继续向子View进行传递，返回false表示不对事件进行拦截，默认false；当ViewGroup对事件进行拦截后，`onInterceptTouchEvent(MotionEvent ev) `方法不会被调用。\n\nViewGroup中`dispatchTouchEvent()` 真正对事件进行分发，而View中`dispatchTouchEvent()`方法，不对事件进行分发，或者起分发对象为自己本身。\n\n在 `dispatchTouchEvent()` 方法中做的永远是事件分发工作，而在`onTouchEvent()`方法中真正处理事件；在ViewGroup中没有`onTouchEvent()`方法，而直接调用View中的`onTouchEvent()`方法。\n\n当ViewGroup所有的子View返回false，其`onTouchEvent()`事件才会被触发。\n\n\n源码分析：\n\n在Activity中 `dispatchTouchEvent()` 方法的返回值代表事件是否被消费。\n`onUserInteraction()`是一个空方法，可以由子类实现。如果`getWindow().superDispatchTouchEvent(ev)`方法返回`true`代表事件结束（实际是由ViewGroup 的`dispatchTouchEvent(MotionEvent ev)`方法返回的`true`，见下文），如果返回`false`则执行onTouchEvent(ev);\n```java\n  public boolean dispatchTouchEvent(MotionEvent ev) {\n         if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n             \n             onUserInteraction();\n         }\n         if (getWindow().superDispatchTouchEvent(ev)) {\n             return true;\n         }\n         return onTouchEvent(ev);\n     }\n\n```\n`onTouchEvent(ev)`在Activty中的源码，首先判断是否超出边界，如果超出边界直接finish()掉，如果没有超出边界，表示该事件也结束。\n```java\n public boolean onTouchEvent(MotionEvent event) {\n        if (mWindow.shouldCloseOnTouch(this, event)) {\n            finish();\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n\n`getWindow().superDispatchTouchEvent(ev)` 调用的是`PhoneWindow`类中的方法，其中`mDecror`（DecorView类型）是window的一个顶层view,包含window的`decor`\n\n``` java\n    @Override\n    public boolean superDispatchTouchEvent(MotionEvent event) {\n        return mDecor.superDispatchTouchEvent(event);\n    }\n\n```\nDecorView是FrameLayout的子类，`superDispatchTouchEvent(event)`源码，其实际上调用的是`VieGroup`中的`dispatchTouchEvent(MotionEvent ev) `方法\n\n```java\n\n   public boolean superDispatchTouchEvent(MotionEvent event) {\n        return super.dispatchTouchEvent(event);\n    }\n\n```    \n`VieGroup`中的`dispatchTouchEvent(MotionEvent ev) `方法伪代码\n\n```java\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        //伪代码\n        boolon consume=false;\n        //调用onInterceptTouchEvent判断是否拦截\n        if(onInterceptTouchEvent(ev)){\n            //拦截则调用自身的onTouchEvent\n            consume=onTouchEvent(ev);\n        }else{\n            //不拦截，将事件分发给子View\n            consume=child.dispatchTouchEvent(ev);\n        }\n        return consume;\n\n    }\n\n```\n` cancelAndClearTouchTargets(ev);`源码，该方法将`mFirstTouchTarget`进行置空操作\n\n```java\n /**\n     * Cancels and clears all touch targets.\n     */\n private void cancelAndClearTouchTargets(MotionEvent event) {\n        if (mFirstTouchTarget != null) {\n            boolean syntheticEvent = false;\n            if (event == null) {\n                final long now = SystemClock.uptimeMillis();\n                event = MotionEvent.obtain(now, now,\n                        MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);\n                event.setSource(InputDevice.SOURCE_TOUCHSCREEN);\n                syntheticEvent = true;\n            }\n\n            for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {\n                resetCancelNextUpFlag(target.child);\n                dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);\n            }\n            clearTouchTargets();\n\n            if (syntheticEvent) {\n                event.recycle();\n            }\n        }\n    }\n\n```\n在`ViewGroup`中`resetTouchState()`源码\n```java\n    private void resetTouchState() {\n        clearTouchTargets();\n        resetCancelNextUpFlag(this);\n        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        mNestedScrollAxes = SCROLL_AXIS_NONE;\n    }\n\n```\n在`ViewGroup`中`requestDisallowInterceptTouchEvent(boolean disallowIntercept)`源码\n```java\n    @Override\n    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {\n            // We're already in this state, assume our ancestors are too\n            return;\n        }\n\n        if (disallowIntercept) {\n            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;\n        } else {\n            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;\n        }\n\n        // Pass it up to our parent\n        if (mParent != null) {\n            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);\n        }\n    }\n\n```\n\nViewGroup中的 onInterceptTouchEvent方法源码，默认为false即不发生拦截\n\n```java\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)\n                && ev.getAction() == MotionEvent.ACTION_DOWN\n                && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)\n                && isOnScrollbarThumb(ev.getX(), ev.getY())) {\n            return true;\n        }\n        return false;\n    }\n\n```\n\nViewGroup的事件分发，dispatchransformedTouchEvent()\n\n```java\nprivate boolean dispatchransformedTouchEvent(MotionEvent event,boolean cancel,View child,int disiredPointerBits){\n    final boolean handled;\n    //...\n    if(child==null){\n        handled=super.dispatchTouchEvent(event);  //调用到View的dispatchTouchEvent(event)\n    }else{\n        handled=child.dispatchTouchEvent(event);  //调用到child的dispatchTouchEvent(event)\n    }\n    //...\n    event.setAction(oldAction);\n    return handled;\n    //...\n}\n\n```\n\nView的事件分发\n```java\npublic boolean diapatchTouchEvent(MotionEvent ev){\n    //...\n    boolean result =false;\n    //当前View是否可见（未被其他窗口遮盖且未隐藏）\n    if(onFilterTouchEventForSecurity(event)){\n        ListenerInfo li=mListenerInfo;\n        //如果设置TouchListener，先响应TouchListener.onTouch\n        if(li!=null&&li.mOnTouchListener!=null&&(mViewFlags&ENABLE_MASK)==ENABLE&&li.mOnTouchListener.onTouch(this,event)){\n            return true;\n        }\n        if(!result&&onTouchEvent(event)){\n            //如果TouchListener.onTouch返回false才执行onTouchEvent\n            result=true;\n        }\n    }\n\n    //...\n    return result;\n}\n\n```\n\nView的事件消费\n\n```java\n    public boolean onTouchEvent(MotionEvent event){\n        //...\n        //如果当前的View是DISABLE状态，是可点击的/可长按，则会消费掉事件，不让它继续\n        if((viewFlags&ENABLED_MASK)==DISABLED){\n            //...\n            return((viewFlags&CLICKABLE)==CLICKABLE\n            ||(viewFlags&LONG_CLICKABLE)==LONG_CLICKABLE\n            ||(viewFlags&CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE);\n        }\n\n        //如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true\n        if(mTouchDelegate!=null){\n            if(mTouchDelegate.onTouchEvent(event)){\n                //如果有TouchDelegate的话，优先交给它处理\n                return true; //处理成功返回true，否则接着往下走\n            }\n        }\n\n        //如果View可点击/长按，则最终一定会return true\n        if(((viewFlags&CLICKABLE)==CLICKABLE\n            ||(viewFlags&LONG_CLICKABLE)==LONG_CLICKABLE)\n            ||(viewFlags&CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE)){\n                switch(action){\n                    case MotionEvent.ACTION_UP: //抬起，判断是否处理点击事件\n                    break;\n                    case MotionEvent.ACTION_DOWN: //按下，处理长事件\n                    break;\n                    case MotionEvent.ACTION_MOVE: //移动，检测触摸是否划出了控件，移除响应事件\n                    break;\n                }\n                return true;\n            }\n            return false;\n    }\n\n\n```\n\n\n### Android事件流程图\n","slug":"Android/View/事件分发机制","published":1,"updated":"2021-01-05T12:14:16.856Z","_id":"ckjju0m1j004y20uabf9f7w1g","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h2><p>事件定义：当用户触摸屏幕时，讲产生的触摸行为(Touch事件)</p>\n<p>事件类型:</p>\n<ul>\n<li>MotionEvent.ACTION_DOWN 手指刚接触屏幕</li>\n<li>MotionEvent.ACTION_UP 手指从屏幕上松开</li>\n<li>MotionEvent.ACTION_MOVE 手指在屏幕上滑动</li>\n<li>MotionEvent.ACTION_CANCEL非人为因素取消</li>\n</ul>\n<p>事件序列</p>\n<p>正常情况下，一次手指触摸屏幕的行为会出发一系列点击事件</p>\n<p>1、点击屏幕后立即松开，事件序列为DOWN-&gt;UP；</p>\n<p>2、点击屏幕滑动一会再松开，事件序列为DOWN-&gt;MOVE-&gt;….-&gt;MOVE-&gt;UP；</p>\n<p>3、正常情况下，一个事件序列只能被一个View进行拦截并消耗；</p>\n<p>4、某个View一旦决定拦截，那么这个事件序列都将由它的 onTouchEvent 处理，并且它的 onInterceptTouchEvent 不会再调用；<br>5、某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中其他事件都不会再交给它处理。并且重新交由它的父元素处理(父元素onTouchEvent被调用)；</p>\n<p>6、事件的传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowIntercept方法可以在子VIew中干预父元素的事件分发过程，但ACTION_DOWN除外；</p>\n<p>7、ViewGroup默认不拦截任何事件，即onInterceptTouchEvent默认返回false。View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用；</p>\n<p>8、View的onTouchEvent默认会消耗事件（返回true），除非它是不可点击的(clickable和longCLickable同时为false)。View的longClickable默认都是false，clickable分情况，Button的clickable默认为true，TextView的clickable默认为false。</p>\n<p>9、View的enable属性不影响onTouchEvent的默认返回值。即使View是disable状态的，只要它的clickable和longClickable有一个为true,那么其onToucheEvent就返回true</p>\n<p>10、onClick会相应的前提是当前View是可以点击的，并且收到了ACTION_DOWN和ACTION_UP的事件，并且受长按事件的影响，当长按事件返回true时，onClick不会响应</p>\n<p>11、onLongClick在ACTION_DOWN里判断是否进行相应，要想执行长按事件，该View必须是longClickable的并且设置了OnClickListener</p>\n<p>事件分发的对象</p>\n<ul>\n<li>Activity：控制生命周期&amp; 处理事件</li>\n<li>ViewGroup： 一组View的集合（含有多个子View）</li>\n<li>View：所有UI组件的基类</li>\n</ul>\n<p>事件分发主要方法</p>\n<ul>\n<li>dispatchTouchEvent(MotionEvent ev)：用来进行事件分发</li>\n<li>onInterceptTouchEvent(MotionEvent ev)：判断是否拦截事件（只存在于ViewGroup中）</li>\n<li>onTouchEvent（MotionEvent ev）：处理点击事件，消费事件</li>\n</ul>\n<p>Android事件分发是先传到ViewGroup,再传到View中，ViewGroup中可以通过 <code>onInterceptTouchEvent(MotionEvent ev) </code>方法对事件进行拦截，返回true表示允许继续向子View进行传递，返回false表示不对事件进行拦截，默认false；当ViewGroup对事件进行拦截后，<code>onInterceptTouchEvent(MotionEvent ev) </code>方法不会被调用。</p>\n<p>ViewGroup中<code>dispatchTouchEvent()</code> 真正对事件进行分发，而View中<code>dispatchTouchEvent()</code>方法，不对事件进行分发，或者起分发对象为自己本身。</p>\n<p>在 <code>dispatchTouchEvent()</code> 方法中做的永远是事件分发工作，而在<code>onTouchEvent()</code>方法中真正处理事件；在ViewGroup中没有<code>onTouchEvent()</code>方法，而直接调用View中的<code>onTouchEvent()</code>方法。</p>\n<p>当ViewGroup所有的子View返回false，其<code>onTouchEvent()</code>事件才会被触发。</p>\n<p>源码分析：</p>\n<p>在Activity中 <code>dispatchTouchEvent()</code> 方法的返回值代表事件是否被消费。<br><code>onUserInteraction()</code>是一个空方法，可以由子类实现。如果<code>getWindow().superDispatchTouchEvent(ev)</code>方法返回<code>true</code>代表事件结束（实际是由ViewGroup 的<code>dispatchTouchEvent(MotionEvent ev)</code>方法返回的<code>true</code>，见下文），如果返回<code>false</code>则执行onTouchEvent(ev);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">           onUserInteraction();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> onTouchEvent(ev);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>onTouchEvent(ev)</code>在Activty中的源码，首先判断是否超出边界，如果超出边界直接finish()掉，如果没有超出边界，表示该事件也结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mWindow.shouldCloseOnTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">           finish();</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>getWindow().superDispatchTouchEvent(ev)</code> 调用的是<code>PhoneWindow</code>类中的方法，其中<code>mDecror</code>（DecorView类型）是window的一个顶层view,包含window的<code>decor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">superDispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>DecorView是FrameLayout的子类，<code>superDispatchTouchEvent(event)</code>源码，其实际上调用的是<code>VieGroup</code>中的<code>dispatchTouchEvent(MotionEvent ev) </code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">superDispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```    </span><br><span class=\"line\">`VieGroup`中的`dispatchTouchEvent(MotionEvent ev) `方法伪代码</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//伪代码</span></span><br><span class=\"line\">        boolon consume=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用onInterceptTouchEvent判断是否拦截</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(onInterceptTouchEvent(ev))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//拦截则调用自身的onTouchEvent</span></span><br><span class=\"line\">            consume=onTouchEvent(ev);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//不拦截，将事件分发给子View</span></span><br><span class=\"line\">            consume=child.dispatchTouchEvent(ev);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> consume;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code> cancelAndClearTouchTargets(ev);</code>源码，该方法将<code>mFirstTouchTarget</code>进行置空操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Cancels and clears all touch targets.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAndClearTouchTargets</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">boolean</span> syntheticEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (event == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">               event = MotionEvent.obtain(now, now,</span><br><span class=\"line\">                       MotionEvent.ACTION_CANCEL, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">               event.setSource(InputDevice.SOURCE_TOUCHSCREEN);</span><br><span class=\"line\">               syntheticEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class=\"keyword\">null</span>; target = target.next) &#123;</span><br><span class=\"line\">               resetCancelNextUpFlag(target.child);</span><br><span class=\"line\">               dispatchTransformedTouchEvent(event, <span class=\"keyword\">true</span>, target.child, target.pointerIdBits);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           clearTouchTargets();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (syntheticEvent) &#123;</span><br><span class=\"line\">               event.recycle();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>ViewGroup</code>中<code>resetTouchState()</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resetTouchState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    clearTouchTargets();</span><br><span class=\"line\">    resetCancelNextUpFlag(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">    mNestedScrollAxes = SCROLL_AXIS_NONE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>ViewGroup</code>中<code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestDisallowInterceptTouchEvent</span><span class=\"params\">(<span class=\"keyword\">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We&#x27;re already in this state, assume our ancestors are too</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disallowIntercept) &#123;</span><br><span class=\"line\">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pass it up to our parent</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ViewGroup中的 onInterceptTouchEvent方法源码，默认为false即不发生拦截</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class=\"line\">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class=\"line\">            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ViewGroup的事件分发，dispatchransformedTouchEvent()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchransformedTouchEvent</span><span class=\"params\">(MotionEvent event,<span class=\"keyword\">boolean</span> cancel,View child,<span class=\"keyword\">int</span> disiredPointerBits)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(child==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        handled=<span class=\"keyword\">super</span>.dispatchTouchEvent(event);  <span class=\"comment\">//调用到View的dispatchTouchEvent(event)</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        handled=child.dispatchTouchEvent(event);  <span class=\"comment\">//调用到child的dispatchTouchEvent(event)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    event.setAction(oldAction);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>View的事件分发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">diapatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result =<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//当前View是否可见（未被其他窗口遮盖且未隐藏）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(onFilterTouchEventForSecurity(event))&#123;</span><br><span class=\"line\">        ListenerInfo li=mListenerInfo;</span><br><span class=\"line\">        <span class=\"comment\">//如果设置TouchListener，先响应TouchListener.onTouch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(li!=<span class=\"keyword\">null</span>&amp;&amp;li.mOnTouchListener!=<span class=\"keyword\">null</span>&amp;&amp;(mViewFlags&amp;ENABLE_MASK)==ENABLE&amp;&amp;li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>,event))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!result&amp;&amp;onTouchEvent(event))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果TouchListener.onTouch返回false才执行onTouchEvent</span></span><br><span class=\"line\">            result=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>View的事件消费</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//如果当前的View是DISABLE状态，是可点击的/可长按，则会消费掉事件，不让它继续</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((viewFlags&amp;ENABLED_MASK)==DISABLED)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>((viewFlags&amp;CLICKABLE)==CLICKABLE</span><br><span class=\"line\">        ||(viewFlags&amp;LONG_CLICKABLE)==LONG_CLICKABLE</span><br><span class=\"line\">        ||(viewFlags&amp;CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mTouchDelegate!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mTouchDelegate.onTouchEvent(event))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果有TouchDelegate的话，优先交给它处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">//处理成功返回true，否则接着往下走</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果View可点击/长按，则最终一定会return true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(((viewFlags&amp;CLICKABLE)==CLICKABLE</span><br><span class=\"line\">        ||(viewFlags&amp;LONG_CLICKABLE)==LONG_CLICKABLE)</span><br><span class=\"line\">        ||(viewFlags&amp;CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(action)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MotionEvent.ACTION_UP: <span class=\"comment\">//抬起，判断是否处理点击事件</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN: <span class=\"comment\">//按下，处理长事件</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE: <span class=\"comment\">//移动，检测触摸是否划出了控件，移除响应事件</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Android事件流程图\"><a href=\"#Android事件流程图\" class=\"headerlink\" title=\"Android事件流程图\"></a>Android事件流程图</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h2><p>事件定义：当用户触摸屏幕时，讲产生的触摸行为(Touch事件)</p>\n<p>事件类型:</p>\n<ul>\n<li>MotionEvent.ACTION_DOWN 手指刚接触屏幕</li>\n<li>MotionEvent.ACTION_UP 手指从屏幕上松开</li>\n<li>MotionEvent.ACTION_MOVE 手指在屏幕上滑动</li>\n<li>MotionEvent.ACTION_CANCEL非人为因素取消</li>\n</ul>\n<p>事件序列</p>\n<p>正常情况下，一次手指触摸屏幕的行为会出发一系列点击事件</p>\n<p>1、点击屏幕后立即松开，事件序列为DOWN-&gt;UP；</p>\n<p>2、点击屏幕滑动一会再松开，事件序列为DOWN-&gt;MOVE-&gt;….-&gt;MOVE-&gt;UP；</p>\n<p>3、正常情况下，一个事件序列只能被一个View进行拦截并消耗；</p>\n<p>4、某个View一旦决定拦截，那么这个事件序列都将由它的 onTouchEvent 处理，并且它的 onInterceptTouchEvent 不会再调用；<br>5、某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列中其他事件都不会再交给它处理。并且重新交由它的父元素处理(父元素onTouchEvent被调用)；</p>\n<p>6、事件的传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowIntercept方法可以在子VIew中干预父元素的事件分发过程，但ACTION_DOWN除外；</p>\n<p>7、ViewGroup默认不拦截任何事件，即onInterceptTouchEvent默认返回false。View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用；</p>\n<p>8、View的onTouchEvent默认会消耗事件（返回true），除非它是不可点击的(clickable和longCLickable同时为false)。View的longClickable默认都是false，clickable分情况，Button的clickable默认为true，TextView的clickable默认为false。</p>\n<p>9、View的enable属性不影响onTouchEvent的默认返回值。即使View是disable状态的，只要它的clickable和longClickable有一个为true,那么其onToucheEvent就返回true</p>\n<p>10、onClick会相应的前提是当前View是可以点击的，并且收到了ACTION_DOWN和ACTION_UP的事件，并且受长按事件的影响，当长按事件返回true时，onClick不会响应</p>\n<p>11、onLongClick在ACTION_DOWN里判断是否进行相应，要想执行长按事件，该View必须是longClickable的并且设置了OnClickListener</p>\n<p>事件分发的对象</p>\n<ul>\n<li>Activity：控制生命周期&amp; 处理事件</li>\n<li>ViewGroup： 一组View的集合（含有多个子View）</li>\n<li>View：所有UI组件的基类</li>\n</ul>\n<p>事件分发主要方法</p>\n<ul>\n<li>dispatchTouchEvent(MotionEvent ev)：用来进行事件分发</li>\n<li>onInterceptTouchEvent(MotionEvent ev)：判断是否拦截事件（只存在于ViewGroup中）</li>\n<li>onTouchEvent（MotionEvent ev）：处理点击事件，消费事件</li>\n</ul>\n<p>Android事件分发是先传到ViewGroup,再传到View中，ViewGroup中可以通过 <code>onInterceptTouchEvent(MotionEvent ev) </code>方法对事件进行拦截，返回true表示允许继续向子View进行传递，返回false表示不对事件进行拦截，默认false；当ViewGroup对事件进行拦截后，<code>onInterceptTouchEvent(MotionEvent ev) </code>方法不会被调用。</p>\n<p>ViewGroup中<code>dispatchTouchEvent()</code> 真正对事件进行分发，而View中<code>dispatchTouchEvent()</code>方法，不对事件进行分发，或者起分发对象为自己本身。</p>\n<p>在 <code>dispatchTouchEvent()</code> 方法中做的永远是事件分发工作，而在<code>onTouchEvent()</code>方法中真正处理事件；在ViewGroup中没有<code>onTouchEvent()</code>方法，而直接调用View中的<code>onTouchEvent()</code>方法。</p>\n<p>当ViewGroup所有的子View返回false，其<code>onTouchEvent()</code>事件才会被触发。</p>\n<p>源码分析：</p>\n<p>在Activity中 <code>dispatchTouchEvent()</code> 方法的返回值代表事件是否被消费。<br><code>onUserInteraction()</code>是一个空方法，可以由子类实现。如果<code>getWindow().superDispatchTouchEvent(ev)</code>方法返回<code>true</code>代表事件结束（实际是由ViewGroup 的<code>dispatchTouchEvent(MotionEvent ev)</code>方法返回的<code>true</code>，见下文），如果返回<code>false</code>则执行onTouchEvent(ev);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">           onUserInteraction();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> onTouchEvent(ev);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>onTouchEvent(ev)</code>在Activty中的源码，首先判断是否超出边界，如果超出边界直接finish()掉，如果没有超出边界，表示该事件也结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mWindow.shouldCloseOnTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">           finish();</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>getWindow().superDispatchTouchEvent(ev)</code> 调用的是<code>PhoneWindow</code>类中的方法，其中<code>mDecror</code>（DecorView类型）是window的一个顶层view,包含window的<code>decor</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">superDispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>DecorView是FrameLayout的子类，<code>superDispatchTouchEvent(event)</code>源码，其实际上调用的是<code>VieGroup</code>中的<code>dispatchTouchEvent(MotionEvent ev) </code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">superDispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```    </span><br><span class=\"line\">`VieGroup`中的`dispatchTouchEvent(MotionEvent ev) `方法伪代码</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//伪代码</span></span><br><span class=\"line\">        boolon consume=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用onInterceptTouchEvent判断是否拦截</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(onInterceptTouchEvent(ev))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//拦截则调用自身的onTouchEvent</span></span><br><span class=\"line\">            consume=onTouchEvent(ev);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//不拦截，将事件分发给子View</span></span><br><span class=\"line\">            consume=child.dispatchTouchEvent(ev);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> consume;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code> cancelAndClearTouchTargets(ev);</code>源码，该方法将<code>mFirstTouchTarget</code>进行置空操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Cancels and clears all touch targets.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAndClearTouchTargets</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">boolean</span> syntheticEvent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (event == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">               event = MotionEvent.obtain(now, now,</span><br><span class=\"line\">                       MotionEvent.ACTION_CANCEL, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">               event.setSource(InputDevice.SOURCE_TOUCHSCREEN);</span><br><span class=\"line\">               syntheticEvent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class=\"keyword\">null</span>; target = target.next) &#123;</span><br><span class=\"line\">               resetCancelNextUpFlag(target.child);</span><br><span class=\"line\">               dispatchTransformedTouchEvent(event, <span class=\"keyword\">true</span>, target.child, target.pointerIdBits);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           clearTouchTargets();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (syntheticEvent) &#123;</span><br><span class=\"line\">               event.recycle();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>ViewGroup</code>中<code>resetTouchState()</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resetTouchState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    clearTouchTargets();</span><br><span class=\"line\">    resetCancelNextUpFlag(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">    mNestedScrollAxes = SCROLL_AXIS_NONE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>ViewGroup</code>中<code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestDisallowInterceptTouchEvent</span><span class=\"params\">(<span class=\"keyword\">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We&#x27;re already in this state, assume our ancestors are too</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (disallowIntercept) &#123;</span><br><span class=\"line\">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pass it up to our parent</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ViewGroup中的 onInterceptTouchEvent方法源码，默认为false即不发生拦截</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class=\"line\">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class=\"line\">            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ViewGroup的事件分发，dispatchransformedTouchEvent()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchransformedTouchEvent</span><span class=\"params\">(MotionEvent event,<span class=\"keyword\">boolean</span> cancel,View child,<span class=\"keyword\">int</span> disiredPointerBits)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(child==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        handled=<span class=\"keyword\">super</span>.dispatchTouchEvent(event);  <span class=\"comment\">//调用到View的dispatchTouchEvent(event)</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        handled=child.dispatchTouchEvent(event);  <span class=\"comment\">//调用到child的dispatchTouchEvent(event)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    event.setAction(oldAction);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>View的事件分发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">diapatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result =<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//当前View是否可见（未被其他窗口遮盖且未隐藏）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(onFilterTouchEventForSecurity(event))&#123;</span><br><span class=\"line\">        ListenerInfo li=mListenerInfo;</span><br><span class=\"line\">        <span class=\"comment\">//如果设置TouchListener，先响应TouchListener.onTouch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(li!=<span class=\"keyword\">null</span>&amp;&amp;li.mOnTouchListener!=<span class=\"keyword\">null</span>&amp;&amp;(mViewFlags&amp;ENABLE_MASK)==ENABLE&amp;&amp;li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>,event))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!result&amp;&amp;onTouchEvent(event))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果TouchListener.onTouch返回false才执行onTouchEvent</span></span><br><span class=\"line\">            result=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>View的事件消费</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//如果当前的View是DISABLE状态，是可点击的/可长按，则会消费掉事件，不让它继续</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((viewFlags&amp;ENABLED_MASK)==DISABLED)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>((viewFlags&amp;CLICKABLE)==CLICKABLE</span><br><span class=\"line\">        ||(viewFlags&amp;LONG_CLICKABLE)==LONG_CLICKABLE</span><br><span class=\"line\">        ||(viewFlags&amp;CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mTouchDelegate!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mTouchDelegate.onTouchEvent(event))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果有TouchDelegate的话，优先交给它处理</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">//处理成功返回true，否则接着往下走</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果View可点击/长按，则最终一定会return true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(((viewFlags&amp;CLICKABLE)==CLICKABLE</span><br><span class=\"line\">        ||(viewFlags&amp;LONG_CLICKABLE)==LONG_CLICKABLE)</span><br><span class=\"line\">        ||(viewFlags&amp;CONTEXT_CLICKABLE)==CONTEXT_CLICKABLE))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(action)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MotionEvent.ACTION_UP: <span class=\"comment\">//抬起，判断是否处理点击事件</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN: <span class=\"comment\">//按下，处理长事件</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE: <span class=\"comment\">//移动，检测触摸是否划出了控件，移除响应事件</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Android事件流程图\"><a href=\"#Android事件流程图\" class=\"headerlink\" title=\"Android事件流程图\"></a>Android事件流程图</h3>"},{"title":"使用SearchView以及RecyclerView实现条目删选","cover":"/cover/img23.jpg","toc":true,"description":"使用SearchView以及RecyclerView实现条目删选","type":["Android"],"date":"2018-07-29T16:00:00.000Z","_content":"\n# 使用SearchView以及RecyclerView实现条目删选\n\n\\#\\# 使用SearchView以及RecyclerView实现条目删选\n\n## SearchView介绍\n<!--more-->\nSearchView继承图 ![SearchView&#x7EE7;&#x627F;&#x56FE;](https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表\n\n## RecyclerView介绍\n\nRecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。\n\n## 代码实现\n\n### 搜索框的添加\n\n1、在res/menu文件夹下添加menu\\_main，即MainActivity的菜单栏\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_search\"\n        android:icon=\"@android:drawable/ic_menu_search\"\n        android:title=\"@string/action_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always|collapseActionView\" />\n\n</menu>\n```\n\n2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件\n\n注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView\n\n```text\n java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView\n```\n\nMainActivity中的代码\n\n```java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.menu_main,menu);\n        MenuItem menuItem=menu.findItem(R.id.action_search);\n        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);\n        searchView.setOnQueryTextListener(this);\n        return true;\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        return false;\n    }\n}\n```\n\n显示效果如图所示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### RecylerViewAdapter编写\n\n1、在build.gradle\\(Module:app\\)中添加依赖\n\n```text\ndependencies {\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n}\n```\n\n2、RecyclerView列表中每一个item布局文件item\\_recyclerview的编写\n\n```markup\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <android.support.v7.widget.CardView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:cardCornerRadius=\"5dp\">\n\n        <TextView\n            android:id=\"@+id/word_tv\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:layout_gravity=\"center\"\n            android:text=\"word\"\n            android:textSize=\"25sp\" />\n    </android.support.v7.widget.CardView>\n</LinearLayout>\n```\n\n3、RecylerViewAdapter编写\n\n```text\npublic class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder>{\n\n    private List<String>strings;\n\n    public RecyclerViewAdapter(List<String>strings) {\n        this.strings=strings;\n    }\n\n\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);\n        ViewHolder viewHolder=new ViewHolder(view);\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        ((ViewHolder)holder).words.setText(strings.get(position));\n    }\n\n    @Override\n    public int getItemCount() {\n        return strings.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder{\n\n        TextView words;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            words=(TextView)itemView.findViewById(R.id.word_tv);\n        }\n    }\n\n}\n```\n\n### 在MainActivity中添加RecyclerView布局\n\n1、在布局文件activity\\_main中添加RecyclerView布局\n\n```text\n<android.support.v7.widget.RecyclerView\n    android:id=\"@+id/main_recyclerview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n</android.support.v7.widget.RecyclerView>\n```\n\n2、在MainActivity中为RecyclerView添加适配器\n\n```text\n    //省略部分代码\n\n    private RecyclerView recyclerView;\n    private RecyclerViewAdapter recyclerViewAdapter;\n\n    private List<String>words;\n\n    private RecyclerView.LayoutManager layoutManager;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        recyclerView=findViewById(R.id.main_recyclerview);\n        layoutManager=new LinearLayoutManager(MainActivity.this);\n        words=new ArrayList<>();\n        words.add(\"abc\");\n        words.add(\"abc\");\n        words.add(\"abc\");\n        recyclerViewAdapter=new RecyclerViewAdapter(words);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setAdapter(recyclerViewAdapter);\n\n    }\n```\n\n结果显示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### 在MainActivity中添加筛选方法\n\n```text\n    private List<String>filter(List<String>strings,String text){\n        filterString=new ArrayList<>();\n\n        for (String word:words){\n            if (word.contains(text))\n                filterString.add(word);\n        }\n        return filterString;\n    }\n```\n\n### 在RecyclerViewAdapter中设置筛选后的单词的显示\n\n```text\n   //省略部分代码\n public void setFilter(List<String>filterWords){\n        words=filterWords;\n        notifyDataSetChanged();\n    }\n```\n\n### 当检测到SearchView中输入变化时进行单词筛选\n\n```text\n    @Override\n    public boolean onQueryTextChange(String newText) {\n\n        filterString=filter(words,newText);\n        recyclerViewAdapter.setFilter(filterString);\n        return true;\n    }\n```\n\n## 运行结果\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n![源码地址](https://download.csdn.net/download/qq_36422743/10468538%20源码地址)\n\n","source":"_posts/Android/View/使用RecyclerView和SearchView实现查找删除.md","raw":"---\ntitle: 使用SearchView以及RecyclerView实现条目删选\ncover: /cover/img23.jpg\ntoc: true\ndescription: 使用SearchView以及RecyclerView实现条目删选\ncategories: Android\ntype: [Android]\ndate: 2018/07/30\n---\n\n# 使用SearchView以及RecyclerView实现条目删选\n\n\\#\\# 使用SearchView以及RecyclerView实现条目删选\n\n## SearchView介绍\n<!--more-->\nSearchView继承图 ![SearchView&#x7EE7;&#x627F;&#x56FE;](https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表\n\n## RecyclerView介绍\n\nRecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。\n\n## 代码实现\n\n### 搜索框的添加\n\n1、在res/menu文件夹下添加menu\\_main，即MainActivity的菜单栏\n\n```text\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/action_search\"\n        android:icon=\"@android:drawable/ic_menu_search\"\n        android:title=\"@string/action_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always|collapseActionView\" />\n\n</menu>\n```\n\n2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件\n\n注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView\n\n```text\n java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView\n```\n\nMainActivity中的代码\n\n```java\npublic class MainActivity extends AppCompatActivity implements SearchView.OnQueryTextListener{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n\n        getMenuInflater().inflate(R.menu.menu_main,menu);\n        MenuItem menuItem=menu.findItem(R.id.action_search);\n        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);\n        searchView.setOnQueryTextListener(this);\n        return true;\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        return false;\n    }\n}\n```\n\n显示效果如图所示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### RecylerViewAdapter编写\n\n1、在build.gradle\\(Module:app\\)中添加依赖\n\n```text\ndependencies {\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n}\n```\n\n2、RecyclerView列表中每一个item布局文件item\\_recyclerview的编写\n\n```markup\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <android.support.v7.widget.CardView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:cardCornerRadius=\"5dp\">\n\n        <TextView\n            android:id=\"@+id/word_tv\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:layout_gravity=\"center\"\n            android:text=\"word\"\n            android:textSize=\"25sp\" />\n    </android.support.v7.widget.CardView>\n</LinearLayout>\n```\n\n3、RecylerViewAdapter编写\n\n```text\npublic class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.ViewHolder>{\n\n    private List<String>strings;\n\n    public RecyclerViewAdapter(List<String>strings) {\n        this.strings=strings;\n    }\n\n\n    @NonNull\n    @Override\n    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);\n        ViewHolder viewHolder=new ViewHolder(view);\n        return viewHolder;\n    }\n\n    @Override\n    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {\n        ((ViewHolder)holder).words.setText(strings.get(position));\n    }\n\n    @Override\n    public int getItemCount() {\n        return strings.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder{\n\n        TextView words;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            words=(TextView)itemView.findViewById(R.id.word_tv);\n        }\n    }\n\n}\n```\n\n### 在MainActivity中添加RecyclerView布局\n\n1、在布局文件activity\\_main中添加RecyclerView布局\n\n```text\n<android.support.v7.widget.RecyclerView\n    android:id=\"@+id/main_recyclerview\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n</android.support.v7.widget.RecyclerView>\n```\n\n2、在MainActivity中为RecyclerView添加适配器\n\n```text\n    //省略部分代码\n\n    private RecyclerView recyclerView;\n    private RecyclerViewAdapter recyclerViewAdapter;\n\n    private List<String>words;\n\n    private RecyclerView.LayoutManager layoutManager;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        recyclerView=findViewById(R.id.main_recyclerview);\n        layoutManager=new LinearLayoutManager(MainActivity.this);\n        words=new ArrayList<>();\n        words.add(\"abc\");\n        words.add(\"abc\");\n        words.add(\"abc\");\n        recyclerViewAdapter=new RecyclerViewAdapter(words);\n        recyclerView.setLayoutManager(layoutManager);\n        recyclerView.setAdapter(recyclerViewAdapter);\n\n    }\n```\n\n结果显示：\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n### 在MainActivity中添加筛选方法\n\n```text\n    private List<String>filter(List<String>strings,String text){\n        filterString=new ArrayList<>();\n\n        for (String word:words){\n            if (word.contains(text))\n                filterString.add(word);\n        }\n        return filterString;\n    }\n```\n\n### 在RecyclerViewAdapter中设置筛选后的单词的显示\n\n```text\n   //省略部分代码\n public void setFilter(List<String>filterWords){\n        words=filterWords;\n        notifyDataSetChanged();\n    }\n```\n\n### 当检测到SearchView中输入变化时进行单词筛选\n\n```text\n    @Override\n    public boolean onQueryTextChange(String newText) {\n\n        filterString=filter(words,newText);\n        recyclerViewAdapter.setFilter(filterString);\n        return true;\n    }\n```\n\n## 运行结果\n\n!\\[这里写图片描述\\]\\(https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\)\n\n![源码地址](https://download.csdn.net/download/qq_36422743/10468538%20源码地址)\n\n","slug":"Android/View/使用RecyclerView和SearchView实现查找删除","published":1,"updated":"2021-01-05T12:14:18.078Z","_id":"ckjju0m1l005120ua29jj0m2p","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用SearchView以及RecyclerView实现条目删选\"><a href=\"#使用SearchView以及RecyclerView实现条目删选\" class=\"headerlink\" title=\"使用SearchView以及RecyclerView实现条目删选\"></a>使用SearchView以及RecyclerView实现条目删选</h1><p>## 使用SearchView以及RecyclerView实现条目删选</p>\n<h2 id=\"SearchView介绍\"><a href=\"#SearchView介绍\" class=\"headerlink\" title=\"SearchView介绍\"></a>SearchView介绍</h2><a id=\"more\"></a>\n<p>SearchView继承图 <img src=\"https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"SearchView&#x7EE7;&#x627F;&#x56FE;\"> SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表</p>\n<h2 id=\"RecyclerView介绍\"><a href=\"#RecyclerView介绍\" class=\"headerlink\" title=\"RecyclerView介绍\"></a>RecyclerView介绍</h2><p>RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"搜索框的添加\"><a href=\"#搜索框的添加\" class=\"headerlink\" title=\"搜索框的添加\"></a>搜索框的添加</h3><p>1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id=&quot;@+id/action_search&quot;</span><br><span class=\"line\">        android:icon=&quot;@android:drawable/ic_menu_search&quot;</span><br><span class=\"line\">        android:title=&quot;@string/action_search&quot;</span><br><span class=\"line\">        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction=&quot;always|collapseActionView&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>\n<p>2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件</p>\n<p>注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView</span><br></pre></td></tr></table></figure>\n<p>MainActivity中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SearchView</span>.<span class=\"title\">OnQueryTextListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        getMenuInflater().inflate(R.menu.menu_main,menu);</span><br><span class=\"line\">        MenuItem menuItem=menu.findItem(R.id.action_search);</span><br><span class=\"line\">        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);</span><br><span class=\"line\">        searchView.setOnQueryTextListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextSubmit</span><span class=\"params\">(String query)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextChange</span><span class=\"params\">(String newText)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示效果如图所示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70%5C\">https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"RecylerViewAdapter编写\"><a href=\"#RecylerViewAdapter编写\" class=\"headerlink\" title=\"RecylerViewAdapter编写\"></a>RecylerViewAdapter编写</h3><p>1、在build.gradle(Module:app)中添加依赖</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#x27;com.android.support:recyclerview-v7:27.1.0&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、RecyclerView列表中每一个item布局文件item_recyclerview的编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v7.widget.CardView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class=\"line\">        app:cardCornerRadius&#x3D;&quot;5dp&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:id&#x3D;&quot;@+id&#x2F;word_tv&quot;</span><br><span class=\"line\">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">            android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:text&#x3D;&quot;word&quot;</span><br><span class=\"line\">            android:textSize&#x3D;&quot;25sp&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>3、RecylerViewAdapter编写</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt;strings;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RecyclerViewAdapter(List&lt;String&gt;strings) &#123;</span><br><span class=\"line\">        this.strings=strings;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);</span><br><span class=\"line\">        ViewHolder viewHolder=new ViewHolder(view);</span><br><span class=\"line\">        return viewHolder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;</span><br><span class=\"line\">        ((ViewHolder)holder).words.setText(strings.get(position));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemCount() &#123;</span><br><span class=\"line\">        return strings.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        TextView words;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ViewHolder(View itemView) &#123;</span><br><span class=\"line\">            super(itemView);</span><br><span class=\"line\">            words=(TextView)itemView.findViewById(R.id.word_tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在MainActivity中添加RecyclerView布局\"><a href=\"#在MainActivity中添加RecyclerView布局\" class=\"headerlink\" title=\"在MainActivity中添加RecyclerView布局\"></a>在MainActivity中添加RecyclerView布局</h3><p>1、在布局文件activity_main中添加RecyclerView布局</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">    android:id=&quot;@+id/main_recyclerview&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v7.widget.RecyclerView&gt;</span><br></pre></td></tr></table></figure>\n<p>2、在MainActivity中为RecyclerView添加适配器</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//省略部分代码</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView recyclerView;</span><br><span class=\"line\">private RecyclerViewAdapter recyclerViewAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">private List&lt;String&gt;words;</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView.LayoutManager layoutManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    recyclerView=findViewById(R.id.main_recyclerview);</span><br><span class=\"line\">    layoutManager=new LinearLayoutManager(MainActivity.this);</span><br><span class=\"line\">    words=new ArrayList&lt;&gt;();</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    recyclerViewAdapter=new RecyclerViewAdapter(words);</span><br><span class=\"line\">    recyclerView.setLayoutManager(layoutManager);</span><br><span class=\"line\">    recyclerView.setAdapter(recyclerViewAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果显示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70%5C\">https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"在MainActivity中添加筛选方法\"><a href=\"#在MainActivity中添加筛选方法\" class=\"headerlink\" title=\"在MainActivity中添加筛选方法\"></a>在MainActivity中添加筛选方法</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;String&gt;filter(List&lt;String&gt;strings,String text)&#123;</span><br><span class=\"line\">    filterString=new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (String word:words)&#123;</span><br><span class=\"line\">        if (word.contains(text))</span><br><span class=\"line\">            filterString.add(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return filterString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"><a href=\"#在RecyclerViewAdapter中设置筛选后的单词的显示\" class=\"headerlink\" title=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"></a>在RecyclerViewAdapter中设置筛选后的单词的显示</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  //省略部分代码</span><br><span class=\"line\">public void setFilter(List&lt;String&gt;filterWords)&#123;</span><br><span class=\"line\">       words=filterWords;</span><br><span class=\"line\">       notifyDataSetChanged();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"当检测到SearchView中输入变化时进行单词筛选\"><a href=\"#当检测到SearchView中输入变化时进行单词筛选\" class=\"headerlink\" title=\"当检测到SearchView中输入变化时进行单词筛选\"></a>当检测到SearchView中输入变化时进行单词筛选</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onQueryTextChange(String newText) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    filterString=filter(words,newText);</span><br><span class=\"line\">    recyclerViewAdapter.setFilter(filterString);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70%5C\">https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<p><img src=\"https://download.csdn.net/download/qq_36422743/10468538%20%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80\" alt=\"源码地址\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用SearchView以及RecyclerView实现条目删选\"><a href=\"#使用SearchView以及RecyclerView实现条目删选\" class=\"headerlink\" title=\"使用SearchView以及RecyclerView实现条目删选\"></a>使用SearchView以及RecyclerView实现条目删选</h1><p>## 使用SearchView以及RecyclerView实现条目删选</p>\n<h2 id=\"SearchView介绍\"><a href=\"#SearchView介绍\" class=\"headerlink\" title=\"SearchView介绍\"></a>SearchView介绍</h2>","more":"<p>SearchView继承图 <img src=\"https://img-blog.csdn.net/20180609094538321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"SearchView&#x7EE7;&#x627F;&#x56FE;\"> SearchView为用户提供一个接口，用户在输入到搜索信息后，会从数据源对数据进行筛选，然后获取筛选列表</p>\n<h2 id=\"RecyclerView介绍\"><a href=\"#RecyclerView介绍\" class=\"headerlink\" title=\"RecyclerView介绍\"></a>RecyclerView介绍</h2><p>RecyclerView是一个比ListView布局更加强大的与灵活的布局方式，在使用的过程中可以通LayoutManager布局管理器控制每一个item的布局方式,通过ItemAnimator每一个Item增加与删除的动画效果，通过ItemDecoration设置Item之间的间隔控制，如果要是打算为每一个item添加点击事件，自己写吧，哈哈哈哈哈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"搜索框的添加\"><a href=\"#搜索框的添加\" class=\"headerlink\" title=\"搜索框的添加\"></a>搜索框的添加</h3><p>1、在res/menu文件夹下添加menu_main，即MainActivity的菜单栏</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id=&quot;@+id/action_search&quot;</span><br><span class=\"line\">        android:icon=&quot;@android:drawable/ic_menu_search&quot;</span><br><span class=\"line\">        android:title=&quot;@string/action_search&quot;</span><br><span class=\"line\">        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction=&quot;always|collapseActionView&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>\n<p>2、在MainActivity中添加搜索框，以及为搜索框添加文字输入监听事件</p>\n<p>注：有时会出现下面的错误，这时需要将MainActivity导入的import android.widget.SearchView;替换为import android.support.v7.widget.SearchView</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassCastException: android.support.v7.widget.SearchView cannot be cast to android.widget.SearchView</span><br></pre></td></tr></table></figure>\n<p>MainActivity中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">SearchView</span>.<span class=\"title\">OnQueryTextListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreateOptionsMenu</span><span class=\"params\">(Menu menu)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        getMenuInflater().inflate(R.menu.menu_main,menu);</span><br><span class=\"line\">        MenuItem menuItem=menu.findItem(R.id.action_search);</span><br><span class=\"line\">        SearchView searchView=(SearchView) MenuItemCompat.getActionView(menuItem);</span><br><span class=\"line\">        searchView.setOnQueryTextListener(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextSubmit</span><span class=\"params\">(String query)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onQueryTextChange</span><span class=\"params\">(String newText)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示效果如图所示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70%5C\">https://img-blog.csdn.net/20180609095410214?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"RecylerViewAdapter编写\"><a href=\"#RecylerViewAdapter编写\" class=\"headerlink\" title=\"RecylerViewAdapter编写\"></a>RecylerViewAdapter编写</h3><p>1、在build.gradle(Module:app)中添加依赖</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#x27;com.android.support:recyclerview-v7:27.1.0&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、RecyclerView列表中每一个item布局文件item_recyclerview的编写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class=\"line\">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.v7.widget.CardView</span><br><span class=\"line\">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">        android:layout_height&#x3D;&quot;50dp&quot;</span><br><span class=\"line\">        app:cardCornerRadius&#x3D;&quot;5dp&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;TextView</span><br><span class=\"line\">            android:id&#x3D;&quot;@+id&#x2F;word_tv&quot;</span><br><span class=\"line\">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">            android:gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class=\"line\">            android:text&#x3D;&quot;word&quot;</span><br><span class=\"line\">            android:textSize&#x3D;&quot;25sp&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br><span class=\"line\">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>3、RecylerViewAdapter编写</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private List&lt;String&gt;strings;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RecyclerViewAdapter(List&lt;String&gt;strings) &#123;</span><br><span class=\"line\">        this.strings=strings;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @NonNull</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;</span><br><span class=\"line\">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recyclerview, parent, false);</span><br><span class=\"line\">        ViewHolder viewHolder=new ViewHolder(view);</span><br><span class=\"line\">        return viewHolder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onBindViewHolder(@NonNull ViewHolder holder, int position) &#123;</span><br><span class=\"line\">        ((ViewHolder)holder).words.setText(strings.get(position));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int getItemCount() &#123;</span><br><span class=\"line\">        return strings.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ViewHolder extends RecyclerView.ViewHolder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        TextView words;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ViewHolder(View itemView) &#123;</span><br><span class=\"line\">            super(itemView);</span><br><span class=\"line\">            words=(TextView)itemView.findViewById(R.id.word_tv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在MainActivity中添加RecyclerView布局\"><a href=\"#在MainActivity中添加RecyclerView布局\" class=\"headerlink\" title=\"在MainActivity中添加RecyclerView布局\"></a>在MainActivity中添加RecyclerView布局</h3><p>1、在布局文件activity_main中添加RecyclerView布局</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.RecyclerView</span><br><span class=\"line\">    android:id=&quot;@+id/main_recyclerview&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v7.widget.RecyclerView&gt;</span><br></pre></td></tr></table></figure>\n<p>2、在MainActivity中为RecyclerView添加适配器</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//省略部分代码</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView recyclerView;</span><br><span class=\"line\">private RecyclerViewAdapter recyclerViewAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">private List&lt;String&gt;words;</span><br><span class=\"line\"></span><br><span class=\"line\">private RecyclerView.LayoutManager layoutManager;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    recyclerView=findViewById(R.id.main_recyclerview);</span><br><span class=\"line\">    layoutManager=new LinearLayoutManager(MainActivity.this);</span><br><span class=\"line\">    words=new ArrayList&lt;&gt;();</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    words.add(&quot;abc&quot;);</span><br><span class=\"line\">    recyclerViewAdapter=new RecyclerViewAdapter(words);</span><br><span class=\"line\">    recyclerView.setLayoutManager(layoutManager);</span><br><span class=\"line\">    recyclerView.setAdapter(recyclerViewAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果显示：</p>\n<p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70%5C\">https://img-blog.csdn.net/20180609101323167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<h3 id=\"在MainActivity中添加筛选方法\"><a href=\"#在MainActivity中添加筛选方法\" class=\"headerlink\" title=\"在MainActivity中添加筛选方法\"></a>在MainActivity中添加筛选方法</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;String&gt;filter(List&lt;String&gt;strings,String text)&#123;</span><br><span class=\"line\">    filterString=new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    for (String word:words)&#123;</span><br><span class=\"line\">        if (word.contains(text))</span><br><span class=\"line\">            filterString.add(word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return filterString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"><a href=\"#在RecyclerViewAdapter中设置筛选后的单词的显示\" class=\"headerlink\" title=\"在RecyclerViewAdapter中设置筛选后的单词的显示\"></a>在RecyclerViewAdapter中设置筛选后的单词的显示</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  //省略部分代码</span><br><span class=\"line\">public void setFilter(List&lt;String&gt;filterWords)&#123;</span><br><span class=\"line\">       words=filterWords;</span><br><span class=\"line\">       notifyDataSetChanged();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"当检测到SearchView中输入变化时进行单词筛选\"><a href=\"#当检测到SearchView中输入变化时进行单词筛选\" class=\"headerlink\" title=\"当检测到SearchView中输入变化时进行单词筛选\"></a>当检测到SearchView中输入变化时进行单词筛选</h3><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onQueryTextChange(String newText) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    filterString=filter(words,newText);</span><br><span class=\"line\">    recyclerViewAdapter.setFilter(filterString);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p>![这里写图片描述](<a href=\"https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70%5C\">https://img-blog.csdn.net/20180609101729113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NDIyNzQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\\</a>)</p>\n<p><img src=\"https://download.csdn.net/download/qq_36422743/10468538%20%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80\" alt=\"源码地址\"></p>"},{"title":"Java关键字介绍","type":["Java"],"description":"Java关键字介绍","cover":"/cover/img52.jpg","toc":true,"_content":"\n## Java关键字介绍\n\n### static\n\n### volatile\n\n\n<!--more-->\n\n### final\nfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；\n\n#### 在数据中使用final\n一个数据不可改变有两种原因：\n* 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。\n* 在运行时赋初值后不可改变；\n\n当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。\n\n\n#### 在方法中使用final\n final作为方法参数使用时，表示该引用不能被修改；\n \n final直接修饰方法时，有两个原因\n * 防止子类修改该方法，避免该方法被重写(overridden)\n * 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）\n \n\n\n#### 在类中使用final\n\n禁止该类被继承\n\n### transient\n\n### long关键字\n\n在Java开发过程中，如果需要long类型的变量，需要在变量后加`l`\n\n```\n     long a=1000000000000l;\n     //long b=1000000000000;        //会报出Integer number too large\n     //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large\n     //long b1=100*1000*1000*1000;  //b1会输出一个奇怪的值 1215752192\n     //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围\n     //long b1=(long)(100*1000*1000*1000);;  //使用功强制类型转换，b1会输出一个奇怪的值 1215752192\n     long b1=100l*1000l*1000l*1000l;   //正确写法\n     //long b1=100*1000*1000l*1000l;     //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果\n   \n\n```","source":"_posts/Java/Java基础/Java关键字.md","raw":"---\ntitle: Java关键字介绍\ntype: [Java]\ndescription: Java关键字介绍\ncover:  /cover/img52.jpg\ntoc: true\ncategories: Java\n---\n\n## Java关键字介绍\n\n### static\n\n### volatile\n\n\n<!--more-->\n\n### final\nfinal关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；\n\n#### 在数据中使用final\n一个数据不可改变有两种原因：\n* 在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。\n* 在运行时赋初值后不可改变；\n\n当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。\n\n\n#### 在方法中使用final\n final作为方法参数使用时，表示该引用不能被修改；\n \n final直接修饰方法时，有两个原因\n * 防止子类修改该方法，避免该方法被重写(overridden)\n * 在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）\n \n\n\n#### 在类中使用final\n\n禁止该类被继承\n\n### transient\n\n### long关键字\n\n在Java开发过程中，如果需要long类型的变量，需要在变量后加`l`\n\n```\n     long a=1000000000000l;\n     //long b=1000000000000;        //会报出Integer number too large\n     //long b = (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large\n     //long b1=100*1000*1000*1000;  //b1会输出一个奇怪的值 1215752192\n     //这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围\n     //long b1=(long)(100*1000*1000*1000);;  //使用功强制类型转换，b1会输出一个奇怪的值 1215752192\n     long b1=100l*1000l*1000l*1000l;   //正确写法\n     //long b1=100*1000*1000l*1000l;     //可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果\n   \n\n```","slug":"Java/Java基础/Java关键字","published":1,"date":"2020-05-08T09:44:43.212Z","updated":"2021-01-05T12:15:12.868Z","_id":"ckjju0m1m005420uab3yr4j95","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Java关键字介绍\"><a href=\"#Java关键字介绍\" class=\"headerlink\" title=\"Java关键字介绍\"></a>Java关键字介绍</h2><h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><a id=\"more\"></a>\n\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；</p>\n<h4 id=\"在数据中使用final\"><a href=\"#在数据中使用final\" class=\"headerlink\" title=\"在数据中使用final\"></a>在数据中使用final</h4><p>一个数据不可改变有两种原因：</p>\n<ul>\n<li>在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。</li>\n<li>在运行时赋初值后不可改变；</li>\n</ul>\n<p>当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。</p>\n<h4 id=\"在方法中使用final\"><a href=\"#在方法中使用final\" class=\"headerlink\" title=\"在方法中使用final\"></a>在方法中使用final</h4><p> final作为方法参数使用时，表示该引用不能被修改；</p>\n<p> final直接修饰方法时，有两个原因</p>\n<ul>\n<li>防止子类修改该方法，避免该方法被重写(overridden)</li>\n<li>在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）</li>\n</ul>\n<h4 id=\"在类中使用final\"><a href=\"#在类中使用final\" class=\"headerlink\" title=\"在类中使用final\"></a>在类中使用final</h4><p>禁止该类被继承</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><h3 id=\"long关键字\"><a href=\"#long关键字\" class=\"headerlink\" title=\"long关键字\"></a>long关键字</h3><p>在Java开发过程中，如果需要long类型的变量，需要在变量后加<code>l</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a&#x3D;1000000000000l;</span><br><span class=\"line\">&#x2F;&#x2F;long b&#x3D;1000000000000;        &#x2F;&#x2F;会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b &#x3D; (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000*1000;  &#x2F;&#x2F;b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">&#x2F;&#x2F;这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;(long)(100*1000*1000*1000);;  &#x2F;&#x2F;使用功强制类型转换，b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">long b1&#x3D;100l*1000l*1000l*1000l;   &#x2F;&#x2F;正确写法</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000l*1000l;     &#x2F;&#x2F;可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Java关键字介绍\"><a href=\"#Java关键字介绍\" class=\"headerlink\" title=\"Java关键字介绍\"></a>Java关键字介绍</h2><h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3>","more":"<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final关键字在不同的上下文环境中可能有不同含义，主要含义是“不可改变的”；</p>\n<h4 id=\"在数据中使用final\"><a href=\"#在数据中使用final\" class=\"headerlink\" title=\"在数据中使用final\"></a>在数据中使用final</h4><p>一个数据不可改变有两种原因：</p>\n<ul>\n<li>在编译时不可改变；当一个数据值需要在编译时使用，那么在定义时就需要进行赋初值。当一个数据同时被static以及final修饰时，表示在编译时不可改变。</li>\n<li>在运行时赋初值后不可改变；</li>\n</ul>\n<p>当final修饰基础类型时，基础类型的值不可改变；当final修饰引用类型时，一旦该引用类型被初始化为Object后，其不可以引用另外的Object，但其引用的Object可以被修改。</p>\n<h4 id=\"在方法中使用final\"><a href=\"#在方法中使用final\" class=\"headerlink\" title=\"在方法中使用final\"></a>在方法中使用final</h4><p> final作为方法参数使用时，表示该引用不能被修改；</p>\n<p> final直接修饰方法时，有两个原因</p>\n<ul>\n<li>防止子类修改该方法，避免该方法被重写(overridden)</li>\n<li>在早起Java实现中，使用final可以加快编译效率（现在已经不需要考虑）</li>\n</ul>\n<h4 id=\"在类中使用final\"><a href=\"#在类中使用final\" class=\"headerlink\" title=\"在类中使用final\"></a>在类中使用final</h4><p>禁止该类被继承</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><h3 id=\"long关键字\"><a href=\"#long关键字\" class=\"headerlink\" title=\"long关键字\"></a>long关键字</h3><p>在Java开发过程中，如果需要long类型的变量，需要在变量后加<code>l</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long a&#x3D;1000000000000l;</span><br><span class=\"line\">&#x2F;&#x2F;long b&#x3D;1000000000000;        &#x2F;&#x2F;会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b &#x3D; (long)1000000000000;使用强制类型转换，依旧会报出Integer number too large</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000*1000;  &#x2F;&#x2F;b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">&#x2F;&#x2F;这是因为100*1000*1000*1000是按照整型变量来进行计算，结果超出整型变量的表示范围</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;(long)(100*1000*1000*1000);;  &#x2F;&#x2F;使用功强制类型转换，b1会输出一个奇怪的值 1215752192</span><br><span class=\"line\">long b1&#x3D;100l*1000l*1000l*1000l;   &#x2F;&#x2F;正确写法</span><br><span class=\"line\">&#x2F;&#x2F;long b1&#x3D;100*1000*1000l*1000l;     &#x2F;&#x2F;可以看到结果依旧正确，这是因为100*1000没有超出整型变量表示范围，如果超出则显示错误结果</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"java 内部类","type":["Java"],"description":"java 内部类","cover":"/cover/img53.jpg","toc":true,"_content":"\n### java 内部类\n\n内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。\n<!--more-->\n\n### 内部类的作用\n\n实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。\n\n内部类可以同时用多个实例，每个实例都有自己的状态信息；\n\n内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；\n\n\n### 内部类分类\n\n#### 局部内部类\n\n嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。\n\n#### 静态内部类\n\n静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式\n\n \n```java\n    public class Singleton {  \n        private static class SingletonHolder {  \n            private static final Singleton INSTANCE = new Singleton();  \n        }  \n        private Singleton (){}  \n        public static final Singleton getInstance() {  \n            return SingletonHolder.INSTANCE; \n        }  \n    }\n \n```   \n\n#### 匿名内部类\n\n匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型\n\n```java\n\n    new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello\");\n            }\n        }).start();\n\n\n```\n\n\n#### 内部类与闭包\n\n内部类会包含对外部类的引用，形成闭包\n\n```java\n        \n    public class Outer{\n        private int a=1;\n        \n        public class Inner{\n            private int b=2;\n            public int multi(){\n            return a*b;\n        }\n    }\n        \n\n```\n\n\n","source":"_posts/Java/Java基础/Java内部类.md","raw":"---\ntitle: java 内部类\ntype: [Java]\ndescription: java 内部类\ncover:  /cover/img53.jpg\ntoc: true\ncategories: Java\n---\n\n### java 内部类\n\n内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。\n<!--more-->\n\n### 内部类的作用\n\n实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。\n\n内部类可以同时用多个实例，每个实例都有自己的状态信息；\n\n内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；\n\n\n### 内部类分类\n\n#### 局部内部类\n\n嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。\n\n#### 静态内部类\n\n静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式\n\n \n```java\n    public class Singleton {  \n        private static class SingletonHolder {  \n            private static final Singleton INSTANCE = new Singleton();  \n        }  \n        private Singleton (){}  \n        public static final Singleton getInstance() {  \n            return SingletonHolder.INSTANCE; \n        }  \n    }\n \n```   \n\n#### 匿名内部类\n\n匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为final类型\n\n```java\n\n    new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"hello\");\n            }\n        }).start();\n\n\n```\n\n\n#### 内部类与闭包\n\n内部类会包含对外部类的引用，形成闭包\n\n```java\n        \n    public class Outer{\n        private int a=1;\n        \n        public class Inner{\n            private int b=2;\n            public int multi(){\n            return a*b;\n        }\n    }\n        \n\n```\n\n\n","slug":"Java/Java基础/Java内部类","published":1,"date":"2020-05-08T09:44:43.213Z","updated":"2021-01-05T12:15:14.767Z","_id":"ckjju0m1n005720ua05iyg8ui","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"java-内部类\"><a href=\"#java-内部类\" class=\"headerlink\" title=\"java 内部类\"></a>java 内部类</h3><p>内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"内部类的作用\"><a href=\"#内部类的作用\" class=\"headerlink\" title=\"内部类的作用\"></a>内部类的作用</h3><p>实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。</p>\n<p>内部类可以同时用多个实例，每个实例都有自己的状态信息；</p>\n<p>内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；</p>\n<h3 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h3><h4 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h4><p>嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">#### 匿名内部类</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为<span class=\"keyword\">final</span>类型</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内部类与闭包\"><a href=\"#内部类与闭包\" class=\"headerlink\" title=\"内部类与闭包\"></a>内部类与闭包</h4><p>内部类会包含对外部类的引用，形成闭包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"java-内部类\"><a href=\"#java-内部类\" class=\"headerlink\" title=\"java 内部类\"></a>java 内部类</h3><p>内部类依赖于外部类而存在，即内部类存在指向外部类的引用，可以访问外部类private类型的属性。</p>","more":"<h3 id=\"内部类的作用\"><a href=\"#内部类的作用\" class=\"headerlink\" title=\"内部类的作用\"></a>内部类的作用</h3><p>实现多重继承，每个内部类都能独立继承一个类，在Java中没有多重继承，如果一个类需要同时继承两个类，则可以使用内部类。</p>\n<p>内部类可以同时用多个实例，每个实例都有自己的状态信息；</p>\n<p>内部类有更好的封装，除了其自身的外部类，其他类都不能访问内部类；</p>\n<h3 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h3><h4 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h4><p>嵌套在方法里或者某个作用域内，内部类非公共可用，在方法外或者作用域外不能进行使用。</p>\n<h4 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h4><p>静态内部类创建不依赖于外部类，没有指向外部类的引用，不能使用外部类任何非static的静态成员方法，可以用来创建线程安全的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">#### 匿名内部类</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类依赖于接口实现，如果匿名内部类需要访问局部变量，则该局部变量需要表示为<span class=\"keyword\">final</span>类型</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内部类与闭包\"><a href=\"#内部类与闭包\" class=\"headerlink\" title=\"内部类与闭包\"></a>内部类与闭包</h4><p>内部类会包含对外部类的引用，形成闭包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Java引用","type":["Java"],"description":"Java引用","cover":"/cover/img54.jpg","toc":true,"_content":"\n\n\n## Java引用\n\n在`java.lang.ref`包中有一系列可以辅助GC灵活进行处理的类；抽象类`Reference`有三个子类`SoftReference`(软引用),`WeakReference`(弱引用),和`PhantomReference`(虚引用)，三个子类的可达性依次减弱。\n\n当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用`Reference`，如果GC发现一个Object是可达的，那么不会回收该对象。\n\n\n|引用类型 |GC回收时间 |用途 |生存时间|\n|-|-|-|-|\n|HardReference|从不|对象的一般状态|JVM停止运行时|\n|SoftReference|内存不足时|对象缓存|内存不足时停止|\n|WeakReference|GC时|对象缓存|GC后终止|\n|PhantomReference|unknown|unknown|unknown|\n\n`SoftReference`和`WeakReference`可以选择是否将其放入`ReferenceQueue`，而`PhantomReference`必须放入`ReferenceQueue`中。\n\n注：`ReferenceQueue`用于`PhantomReference`的清理\n\n\n\n### Java基本类型与引用类型\n\n注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。\n\n#### ReferenceQueue\n\n引用队列，在检测到适当的可达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。\n\n\n#### WeakReferenceQueue\n\n源码如下\n\n构造函数`WeakReference(T referent)` 中的 `referent`是被弱引用对象，弱引用对象没有被添加到任何对象中；\n\n构造函数`public WeakReference(T referent, ReferenceQueue<? super T> q)` ，会将弱引用的对象添加到队列中\n\n```\n\npublic class WeakReference<T> extends Reference<T> {\n\n\n    public WeakReference(T referent) {\n        super(referent);\n    }\n\n   \n    public WeakReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n\n}\n\n\n\n```\n","source":"_posts/Java/Java基础/Java引用.md","raw":"---\ntitle: Java引用\ntype: [Java]\ndescription: Java引用\ncover:  /cover/img54.jpg\ntoc: true\ncategories: Java\n---\n\n\n\n## Java引用\n\n在`java.lang.ref`包中有一系列可以辅助GC灵活进行处理的类；抽象类`Reference`有三个子类`SoftReference`(软引用),`WeakReference`(弱引用),和`PhantomReference`(虚引用)，三个子类的可达性依次减弱。\n\n当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用`Reference`，如果GC发现一个Object是可达的，那么不会回收该对象。\n\n\n|引用类型 |GC回收时间 |用途 |生存时间|\n|-|-|-|-|\n|HardReference|从不|对象的一般状态|JVM停止运行时|\n|SoftReference|内存不足时|对象缓存|内存不足时停止|\n|WeakReference|GC时|对象缓存|GC后终止|\n|PhantomReference|unknown|unknown|unknown|\n\n`SoftReference`和`WeakReference`可以选择是否将其放入`ReferenceQueue`，而`PhantomReference`必须放入`ReferenceQueue`中。\n\n注：`ReferenceQueue`用于`PhantomReference`的清理\n\n\n\n### Java基本类型与引用类型\n\n注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。\n\n#### ReferenceQueue\n\n引用队列，在检测到适当的可达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。\n\n\n#### WeakReferenceQueue\n\n源码如下\n\n构造函数`WeakReference(T referent)` 中的 `referent`是被弱引用对象，弱引用对象没有被添加到任何对象中；\n\n构造函数`public WeakReference(T referent, ReferenceQueue<? super T> q)` ，会将弱引用的对象添加到队列中\n\n```\n\npublic class WeakReference<T> extends Reference<T> {\n\n\n    public WeakReference(T referent) {\n        super(referent);\n    }\n\n   \n    public WeakReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n\n}\n\n\n\n```\n","slug":"Java/Java基础/Java引用","published":1,"date":"2020-05-08T09:44:43.215Z","updated":"2021-01-05T12:15:16.009Z","_id":"ckjju0m1n005c20ua28zd0jst","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Java引用\"><a href=\"#Java引用\" class=\"headerlink\" title=\"Java引用\"></a>Java引用</h2><p>在<code>java.lang.ref</code>包中有一系列可以辅助GC灵活进行处理的类；抽象类<code>Reference</code>有三个子类<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),和<code>PhantomReference</code>(虚引用)，三个子类的可达性依次减弱。</p>\n<p>当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用<code>Reference</code>，如果GC发现一个Object是可达的，那么不会回收该对象。</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>GC回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HardReference</td>\n<td>从不</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时停止</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>GC时</td>\n<td>对象缓存</td>\n<td>GC后终止</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>unknown</td>\n<td>unknown</td>\n<td>unknown</td>\n</tr>\n</tbody></table>\n<p><code>SoftReference</code>和<code>WeakReference</code>可以选择是否将其放入<code>ReferenceQueue</code>，而<code>PhantomReference</code>必须放入<code>ReferenceQueue</code>中。</p>\n<p>注：<code>ReferenceQueue</code>用于<code>PhantomReference</code>的清理</p>\n<h3 id=\"Java基本类型与引用类型\"><a href=\"#Java基本类型与引用类型\" class=\"headerlink\" title=\"Java基本类型与引用类型\"></a>Java基本类型与引用类型</h3><p>注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。</p>\n<h4 id=\"ReferenceQueue\"><a href=\"#ReferenceQueue\" class=\"headerlink\" title=\"ReferenceQueue\"></a>ReferenceQueue</h4><p>引用队列，在检测到适当的可达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。</p>\n<h4 id=\"WeakReferenceQueue\"><a href=\"#WeakReferenceQueue\" class=\"headerlink\" title=\"WeakReferenceQueue\"></a>WeakReferenceQueue</h4><p>源码如下</p>\n<p>构造函数<code>WeakReference(T referent)</code> 中的 <code>referent</code>是被弱引用对象，弱引用对象没有被添加到任何对象中；</p>\n<p>构造函数<code>public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)</code> ，会将弱引用的对象添加到队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public WeakReference(T referent) &#123;</span><br><span class=\"line\">        super(referent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class=\"line\">        super(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java引用\"><a href=\"#Java引用\" class=\"headerlink\" title=\"Java引用\"></a>Java引用</h2><p>在<code>java.lang.ref</code>包中有一系列可以辅助GC灵活进行处理的类；抽象类<code>Reference</code>有三个子类<code>SoftReference</code>(软引用),<code>WeakReference</code>(弱引用),和<code>PhantomReference</code>(虚引用)，三个子类的可达性依次减弱。</p>\n<p>当你可能需要再次使用某一个Object，也允许GC处理它时，可以使用<code>Reference</code>，如果GC发现一个Object是可达的，那么不会回收该对象。</p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>GC回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HardReference</td>\n<td>从不</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时停止</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>GC时</td>\n<td>对象缓存</td>\n<td>GC后终止</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>unknown</td>\n<td>unknown</td>\n<td>unknown</td>\n</tr>\n</tbody></table>\n<p><code>SoftReference</code>和<code>WeakReference</code>可以选择是否将其放入<code>ReferenceQueue</code>，而<code>PhantomReference</code>必须放入<code>ReferenceQueue</code>中。</p>\n<p>注：<code>ReferenceQueue</code>用于<code>PhantomReference</code>的清理</p>\n<h3 id=\"Java基本类型与引用类型\"><a href=\"#Java基本类型与引用类型\" class=\"headerlink\" title=\"Java基本类型与引用类型\"></a>Java基本类型与引用类型</h3><p>注：Java方法中参数传递的方式（值传递，只是传递的值不同）：如果参数是基本类型，传递的是基本类型的字面值的拷贝；如果参数是引用类型，传递的是该参数变量所引用对象在堆中地址值的拷贝。</p>\n<h4 id=\"ReferenceQueue\"><a href=\"#ReferenceQueue\" class=\"headerlink\" title=\"ReferenceQueue\"></a>ReferenceQueue</h4><p>引用队列，在检测到适当的可达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。</p>\n<h4 id=\"WeakReferenceQueue\"><a href=\"#WeakReferenceQueue\" class=\"headerlink\" title=\"WeakReferenceQueue\"></a>WeakReferenceQueue</h4><p>源码如下</p>\n<p>构造函数<code>WeakReference(T referent)</code> 中的 <code>referent</code>是被弱引用对象，弱引用对象没有被添加到任何对象中；</p>\n<p>构造函数<code>public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)</code> ，会将弱引用的对象添加到队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public WeakReference(T referent) &#123;</span><br><span class=\"line\">        super(referent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class=\"line\">        super(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Java文件操作","type":["Java"],"description":"Java文件操作","cover":"/cover/img99.jpg","toc":true,"date":"2018-12-09T16:00:00.000Z","_content":"\n# Java文件读取\n\n## 以数据流的形式整体进行读入\n\n```java\n    try{\n        File file=new File(path);\n        byte[] fileData=new byte[(int)file.length()];\n        DataInputStream dataInputStream=new DataInputStream(new FileInputStream(file));\n        dataInputStream.readFully(fileData);\n        dataInputStream.close();\n    }cache(IOException io){\n        e.printStackTrace();\n    }\n\n```\n\n\n## 文件逐行读入\n```java\n    try{\n        StringBuilder stringBuilder=new StringBuilder();\n        File file=new File(path);\n        InputStream inputStream=new FileInputStream(file);\n        if(inputStream!=null){\n            InputStreamReader inputReader=new InputStreamReader(inputSream);\n            BufferedReader bufferedReader=new BufferedReader(inputReader);\n            String line;\n            while(line=bufferedReader.readLine()!=null){\n               stringBuilder.append(line);\n            }\n            inputStream.close();\n        }\n\n    }cache(IOException io){\n        e.printStackTrace();\n    }\n\n```","source":"_posts/Java/Java基础/Java文件操作.md","raw":"---\ntitle: Java文件操作\ntype: [Java]\ndescription:  Java文件操作\ncover:  /cover/img99.jpg\ntoc: true\ncategories: Java\ndate: 2018/12/10\n---\n\n# Java文件读取\n\n## 以数据流的形式整体进行读入\n\n```java\n    try{\n        File file=new File(path);\n        byte[] fileData=new byte[(int)file.length()];\n        DataInputStream dataInputStream=new DataInputStream(new FileInputStream(file));\n        dataInputStream.readFully(fileData);\n        dataInputStream.close();\n    }cache(IOException io){\n        e.printStackTrace();\n    }\n\n```\n\n\n## 文件逐行读入\n```java\n    try{\n        StringBuilder stringBuilder=new StringBuilder();\n        File file=new File(path);\n        InputStream inputStream=new FileInputStream(file);\n        if(inputStream!=null){\n            InputStreamReader inputReader=new InputStreamReader(inputSream);\n            BufferedReader bufferedReader=new BufferedReader(inputReader);\n            String line;\n            while(line=bufferedReader.readLine()!=null){\n               stringBuilder.append(line);\n            }\n            inputStream.close();\n        }\n\n    }cache(IOException io){\n        e.printStackTrace();\n    }\n\n```","slug":"Java/Java基础/Java文件操作","published":1,"updated":"2021-01-05T12:15:17.151Z","_id":"ckjju0m1o005f20uaa1clbvsn","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Java文件读取\"><a href=\"#Java文件读取\" class=\"headerlink\" title=\"Java文件读取\"></a>Java文件读取</h1><h2 id=\"以数据流的形式整体进行读入\"><a href=\"#以数据流的形式整体进行读入\" class=\"headerlink\" title=\"以数据流的形式整体进行读入\"></a>以数据流的形式整体进行读入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    File file=<span class=\"keyword\">new</span> File(path);</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] fileData=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[(<span class=\"keyword\">int</span>)file.length()];</span><br><span class=\"line\">    DataInputStream dataInputStream=<span class=\"keyword\">new</span> DataInputStream(<span class=\"keyword\">new</span> FileInputStream(file));</span><br><span class=\"line\">    dataInputStream.readFully(fileData);</span><br><span class=\"line\">    dataInputStream.close();</span><br><span class=\"line\">&#125;cache(IOException io)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件逐行读入\"><a href=\"#文件逐行读入\" class=\"headerlink\" title=\"文件逐行读入\"></a>文件逐行读入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    StringBuilder stringBuilder=<span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    File file=<span class=\"keyword\">new</span> File(path);</span><br><span class=\"line\">    InputStream inputStream=<span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inputStream!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        InputStreamReader inputReader=<span class=\"keyword\">new</span> InputStreamReader(inputSream);</span><br><span class=\"line\">        BufferedReader bufferedReader=<span class=\"keyword\">new</span> BufferedReader(inputReader);</span><br><span class=\"line\">        String line;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(line=bufferedReader.readLine()!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           stringBuilder.append(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;cache(IOException io)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java文件读取\"><a href=\"#Java文件读取\" class=\"headerlink\" title=\"Java文件读取\"></a>Java文件读取</h1><h2 id=\"以数据流的形式整体进行读入\"><a href=\"#以数据流的形式整体进行读入\" class=\"headerlink\" title=\"以数据流的形式整体进行读入\"></a>以数据流的形式整体进行读入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    File file=<span class=\"keyword\">new</span> File(path);</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] fileData=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[(<span class=\"keyword\">int</span>)file.length()];</span><br><span class=\"line\">    DataInputStream dataInputStream=<span class=\"keyword\">new</span> DataInputStream(<span class=\"keyword\">new</span> FileInputStream(file));</span><br><span class=\"line\">    dataInputStream.readFully(fileData);</span><br><span class=\"line\">    dataInputStream.close();</span><br><span class=\"line\">&#125;cache(IOException io)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件逐行读入\"><a href=\"#文件逐行读入\" class=\"headerlink\" title=\"文件逐行读入\"></a>文件逐行读入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    StringBuilder stringBuilder=<span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    File file=<span class=\"keyword\">new</span> File(path);</span><br><span class=\"line\">    InputStream inputStream=<span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inputStream!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        InputStreamReader inputReader=<span class=\"keyword\">new</span> InputStreamReader(inputSream);</span><br><span class=\"line\">        BufferedReader bufferedReader=<span class=\"keyword\">new</span> BufferedReader(inputReader);</span><br><span class=\"line\">        String line;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(line=bufferedReader.readLine()!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           stringBuilder.append(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;cache(IOException io)&#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Java泛型","type":["Java"],"description":"Java泛型","cover":"/cover/img55.jpg","toc":true,"_content":"\n# Generics(泛型)\n\n一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。\n<!--more-->\nGeneric Programming\\(泛型编程\\)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming\\(泛型编程\\)可以使得对象\\(object\\)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。\n\n如果没有泛型，参数的类型会被忽略，\n\n\n\n## 装箱和拆箱\n\n在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。\n\n将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，**会返回之前缓存的对象**，\n\n```java\n    \n    int a=100;\n    int b=100;\n    int c=200;\n    int d=200;\n    System.out.println(a==b);\n    System.out.println(c==d);\n\n```\n输出结果为\n\n```java\n    true;\n    false;\n```\n\nJava通过泛型可以自动进行装箱与拆箱。\n\n```java\n\n    Integer i=new Integer(xx);\n\n```\n**会触发自动装箱**\n\n```java\n    Integer i=xx;\n```\n**不会触发自动装箱**\n\n**注意：**操作符`==` 在基础类型中以及引用类型中采用不同的定义方式，在`int`类型中，`==`用于通过值的大小定义的，而在`Integer`中是通过对象定义的。在比较两个类对象时应使用euqal\n\n\n\n## 遍历循环\n\nfor循环可以被用于实现Iterable<E>接口的任何类中，\n\n```java\n    List<Integer>ints=Arrays.asList(1,2,3);\n    int s=0;\n    for(int n:ints){\n       s+=n;\n    }\n```\n等价于\n\n```java\n    for(Iterators<Integer>it=ints.iterator();it.hasNext();){\n       int n=it.next();\n       s+=n;\n    }\n```\n\n\n## Iterable<E>接口\n\n所有的`Collection`都实现了Iterable<E>接口\n\n\n## 泛型方法和可变参数(Generic Methods and Varargs)\n\n将任意类型的array转换成List\n\n```java\n    class List{\n       public static<T> List<T> toList(T[] arr){\n           List<T>list=new ArrayList<T>();\n           for(T elt:arr)list.add(elt);\n           return list;\n       }\n    }\n```\n\n将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将`T[]`使用`T...`来替代。\n\n```java\n\nclass Lists{\n        public static<T>List<T>toList(T...arr){\n            List<T>list=new ArrayList<T>();\n            for(T elt:arr)list.add(elt);\n            return list;\n        }\n}\n```\n调用方式\n\n```java\n     List<Integer> ints = Lists.toList(1, 2, 3); \n     List<String> words = Lists.toList(\"hello\", \"world\");\n```\n\n### 子类型和通配符(SubTyping and Wildcards)\n\n**子类型和替换原则**\n\n子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。\n\n```java\n    List<Number>nums=new ArrayList<Number>();\n    nums.add(2);\n    nums.add(3.14);\n```\n\n根据替换规则可以在Number的List中添加`Integer`和`Double`类型的对象。\n\n\n```java\n    List<Integer>ints=new ArrayList<Integer>();\n    ints.add(2);\n    ints.add(3);\n    List<Number>nums=ints;    //在编译时报错\n    nums.add(3.14);\n\n```\n\n报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用`List<? extends Number>nums=ints`，因为List<Integer>是List<? extends Number>的子类型。\n\n### 带有extends的通配符\n\n以Collection接口中的addAll方法为例\n\n```java\n    interface Collection<E>{\n     \n     ...\n     public boolean addAll(Collection<? extends E>c);\n     ...\n    \n    }\n```\n\n`? extends E`表示可以使用E的子类型作为参数添加到Collection中\n\n```java\n\n    List<Number>nums=new ArrayList<Number>();\n    List<Integer>ints=Array.asList(1,2);\n    List<Double>dbls=Array.asList(2.23,3.55);\n    nums.addAll(ints);\n    nums.addAll(dbls);\n```\n在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection<? extends Number>的子类型。如果addAll(Collection<? extends E>c)中没有通配符，那么上面的语句在编译时会报错。\n\n### 带有super的通配符\n\n将一个List拷贝到另外一个List\n\n```java\n\n    public static <T>void copy(List<? super T>dst,List<? extend T>src)\n    {\n       for(int i=0;i<src.size();i++){\n           dst.set(i,src.get(i));\n       }\n    }\n\n```\n\n`? super T`的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;\n典型例子\n\n```java\n    List<Object>objs=Array.<Object>asList(2,3,\"four\");\n    List<Integer>ints=Array.asList(5,6);\n    Collection.copy(objs,ints);\n    Collection.<Object>copy(objs,ints);\n    Collection.<Number>copy(objs,ints);\n    Collection.<Integer>copy(objs,ints);\n    \n```\n\n通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。\n\n### Get和Put原则\n？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的\n\n### 数组\n\n在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。\n```java\n    \n    Integer[] ints=new Integer[]{1,2,3};\n    Number[] nums=ints;\n    num[2]=3.14;  //运行时错误\n\n```\n\nInteger[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。\n\n与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List<? extends T>的子类型。\n\n```java\n    List<Integer>ints=Array.asList(1,2,3);\n    List<Number nums>=ints;      //在编译时会报错\n    List<? extends Number>nums1=ints; //编译通过\n    nums1.set(2,3.14)           //编译错误\n\n```\n\n第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。\n\n\n在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List<? super T>的子类型，数组不支持子类型的逆变。\n\nArrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。\n\n### 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\n\n* 使用通配符判断Collection中是否有指定的对象\n\n```java\n    interface Collection<E>{\n        ...\n        public boolean contains(Object o);\n        public boolean containsAll(Collection<?>c);\n        ...\n    }\n    \n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);\n    ints.containsAll(objs);\n    ...\n```\n\n在`containsAll(Collection<?>c)`方法中 `Collection<?>c`是`Collection<?>c`的缩写(abbreviation)，继承Object是通配符常用的方式。\n\n* 类型参数\n可以通过类型参数来替换通配符的编码方式\n\n```java\n\n    interface Collection<E>{\n        ...\n        public boolean contains(E o);\n        public boolean containsAll(Collection<? extend E>c);\n        ...\n    }\n    \n\n\n```\n\n但实际在编译的过程中使用\n\n```java\n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);     //编译时报错\n    ints.containsAll(objs); //编译时报错\n    ...\n```\n\n两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。\n\n### \n\n\n\n\n\n\n\n","source":"_posts/Java/Java基础/Java泛型.md","raw":"---\ntitle: Java泛型\ntype: [Java]\ndescription: Java泛型\ncover:  /cover/img55.jpg\ntoc: true\ncategories: Java\n---\n\n# Generics(泛型)\n\n一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。\n<!--more-->\nGeneric Programming\\(泛型编程\\)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming\\(泛型编程\\)可以使得对象\\(object\\)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。\n\n如果没有泛型，参数的类型会被忽略，\n\n\n\n## 装箱和拆箱\n\n在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。\n\n将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 '\\u0000'在'\\u007f'、byte类型、boolean类型，**会返回之前缓存的对象**，\n\n```java\n    \n    int a=100;\n    int b=100;\n    int c=200;\n    int d=200;\n    System.out.println(a==b);\n    System.out.println(c==d);\n\n```\n输出结果为\n\n```java\n    true;\n    false;\n```\n\nJava通过泛型可以自动进行装箱与拆箱。\n\n```java\n\n    Integer i=new Integer(xx);\n\n```\n**会触发自动装箱**\n\n```java\n    Integer i=xx;\n```\n**不会触发自动装箱**\n\n**注意：**操作符`==` 在基础类型中以及引用类型中采用不同的定义方式，在`int`类型中，`==`用于通过值的大小定义的，而在`Integer`中是通过对象定义的。在比较两个类对象时应使用euqal\n\n\n\n## 遍历循环\n\nfor循环可以被用于实现Iterable<E>接口的任何类中，\n\n```java\n    List<Integer>ints=Arrays.asList(1,2,3);\n    int s=0;\n    for(int n:ints){\n       s+=n;\n    }\n```\n等价于\n\n```java\n    for(Iterators<Integer>it=ints.iterator();it.hasNext();){\n       int n=it.next();\n       s+=n;\n    }\n```\n\n\n## Iterable<E>接口\n\n所有的`Collection`都实现了Iterable<E>接口\n\n\n## 泛型方法和可变参数(Generic Methods and Varargs)\n\n将任意类型的array转换成List\n\n```java\n    class List{\n       public static<T> List<T> toList(T[] arr){\n           List<T>list=new ArrayList<T>();\n           for(T elt:arr)list.add(elt);\n           return list;\n       }\n    }\n```\n\n将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将`T[]`使用`T...`来替代。\n\n```java\n\nclass Lists{\n        public static<T>List<T>toList(T...arr){\n            List<T>list=new ArrayList<T>();\n            for(T elt:arr)list.add(elt);\n            return list;\n        }\n}\n```\n调用方式\n\n```java\n     List<Integer> ints = Lists.toList(1, 2, 3); \n     List<String> words = Lists.toList(\"hello\", \"world\");\n```\n\n### 子类型和通配符(SubTyping and Wildcards)\n\n**子类型和替换原则**\n\n子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。\n\n```java\n    List<Number>nums=new ArrayList<Number>();\n    nums.add(2);\n    nums.add(3.14);\n```\n\n根据替换规则可以在Number的List中添加`Integer`和`Double`类型的对象。\n\n\n```java\n    List<Integer>ints=new ArrayList<Integer>();\n    ints.add(2);\n    ints.add(3);\n    List<Number>nums=ints;    //在编译时报错\n    nums.add(3.14);\n\n```\n\n报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用`List<? extends Number>nums=ints`，因为List<Integer>是List<? extends Number>的子类型。\n\n### 带有extends的通配符\n\n以Collection接口中的addAll方法为例\n\n```java\n    interface Collection<E>{\n     \n     ...\n     public boolean addAll(Collection<? extends E>c);\n     ...\n    \n    }\n```\n\n`? extends E`表示可以使用E的子类型作为参数添加到Collection中\n\n```java\n\n    List<Number>nums=new ArrayList<Number>();\n    List<Integer>ints=Array.asList(1,2);\n    List<Double>dbls=Array.asList(2.23,3.55);\n    nums.addAll(ints);\n    nums.addAll(dbls);\n```\n在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection<? extends Number>的子类型。如果addAll(Collection<? extends E>c)中没有通配符，那么上面的语句在编译时会报错。\n\n### 带有super的通配符\n\n将一个List拷贝到另外一个List\n\n```java\n\n    public static <T>void copy(List<? super T>dst,List<? extend T>src)\n    {\n       for(int i=0;i<src.size();i++){\n           dst.set(i,src.get(i));\n       }\n    }\n\n```\n\n`? super T`的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;\n典型例子\n\n```java\n    List<Object>objs=Array.<Object>asList(2,3,\"four\");\n    List<Integer>ints=Array.asList(5,6);\n    Collection.copy(objs,ints);\n    Collection.<Object>copy(objs,ints);\n    Collection.<Number>copy(objs,ints);\n    Collection.<Integer>copy(objs,ints);\n    \n```\n\n通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。\n\n### Get和Put原则\n？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的\n\n### 数组\n\n在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。\n```java\n    \n    Integer[] ints=new Integer[]{1,2,3};\n    Number[] nums=ints;\n    num[2]=3.14;  //运行时错误\n\n```\n\nInteger[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。\n\n与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List<? extends T>的子类型。\n\n```java\n    List<Integer>ints=Array.asList(1,2,3);\n    List<Number nums>=ints;      //在编译时会报错\n    List<? extends Number>nums1=ints; //编译通过\n    nums1.set(2,3.14)           //编译错误\n\n```\n\n第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。\n\n\n在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List<? super T>的子类型，数组不支持子类型的逆变。\n\nArrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。\n\n### 通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\n\n* 使用通配符判断Collection中是否有指定的对象\n\n```java\n    interface Collection<E>{\n        ...\n        public boolean contains(Object o);\n        public boolean containsAll(Collection<?>c);\n        ...\n    }\n    \n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);\n    ints.containsAll(objs);\n    ...\n```\n\n在`containsAll(Collection<?>c)`方法中 `Collection<?>c`是`Collection<?>c`的缩写(abbreviation)，继承Object是通配符常用的方式。\n\n* 类型参数\n可以通过类型参数来替换通配符的编码方式\n\n```java\n\n    interface Collection<E>{\n        ...\n        public boolean contains(E o);\n        public boolean containsAll(Collection<? extend E>c);\n        ...\n    }\n    \n\n\n```\n\n但实际在编译的过程中使用\n\n```java\n    ...\n    Object obj=\"one\";\n    List<Object>objs=Arrays.<Object>asList(\"one\",2,3.14,4);\n    List<Integer>ints=Arrays.asList(2,4);\n    objs.contains(obj);\n    objs.containsAll(ints);\n    ints.contains(obj);     //编译时报错\n    ints.containsAll(objs); //编译时报错\n    ...\n```\n\n两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。\n\n### \n\n\n\n\n\n\n\n","slug":"Java/Java基础/Java泛型","published":1,"date":"2020-05-08T09:44:43.216Z","updated":"2021-01-05T12:15:19.084Z","_id":"ckjju0m1p005g20ua4se242w2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Generics-泛型\"><a href=\"#Generics-泛型\" class=\"headerlink\" title=\"Generics(泛型)\"></a>Generics(泛型)</h1><p>一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。</p>\n<a id=\"more\"></a>\n<p>Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。</p>\n<p>如果没有泛型，参数的类型会被忽略，</p>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><p>在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。</p>\n<p>将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，<strong>会返回之前缓存的对象</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c=<span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d=<span class=\"number\">200</span>;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>Java通过泛型可以自动进行装箱与拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer i=<span class=\"keyword\">new</span> Integer(xx);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>会触发自动装箱</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i=xx;</span><br></pre></td></tr></table></figure>\n<p><strong>不会触发自动装箱</strong></p>\n<p><strong>注意：</strong>操作符<code>==</code> 在基础类型中以及引用类型中采用不同的定义方式，在<code>int</code>类型中，<code>==</code>用于通过值的大小定义的，而在<code>Integer</code>中是通过对象定义的。在比较两个类对象时应使用euqal</p>\n<h2 id=\"遍历循环\"><a href=\"#遍历循环\" class=\"headerlink\" title=\"遍历循环\"></a>遍历循环</h2><p>for循环可以被用于实现Iterable<E>接口的任何类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n:ints)&#123;</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n=it.next();</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable<E>接口</h2><p>所有的<code>Collection</code>都实现了Iterable<E>接口</p>\n<h2 id=\"泛型方法和可变参数-Generic-Methods-and-Varargs\"><a href=\"#泛型方法和可变参数-Generic-Methods-and-Varargs\" class=\"headerlink\" title=\"泛型方法和可变参数(Generic Methods and Varargs)\"></a>泛型方法和可变参数(Generic Methods and Varargs)</h2><p>将任意类型的array转换成List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; List&lt;T&gt; <span class=\"title\">toList</span><span class=\"params\">(T[] arr)</span></span>&#123;</span><br><span class=\"line\">       List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将<code>T[]</code>使用<code>T...</code>来替代。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lists</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt;List&lt;T&gt;toList(T...arr)&#123;</span><br><span class=\"line\">            List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ints = Lists.toList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">List&lt;String&gt; words = Lists.toList(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"子类型和通配符-SubTyping-and-Wildcards\"><a href=\"#子类型和通配符-SubTyping-and-Wildcards\" class=\"headerlink\" title=\"子类型和通配符(SubTyping and Wildcards)\"></a>子类型和通配符(SubTyping and Wildcards)</h3><p><strong>子类型和替换原则</strong></p>\n<p>子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n<p>根据替换规则可以在Number的List中添加<code>Integer</code>和<code>Double</code>类型的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">ints.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">ints.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number&gt;nums=ints;    <span class=\"comment\">//在编译时报错</span></span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用<code>List&lt;? extends Number&gt;nums=ints</code>，因为List<Integer>是List&lt;? extends Number&gt;的子类型。</p>\n<h3 id=\"带有extends的通配符\"><a href=\"#带有extends的通配符\" class=\"headerlink\" title=\"带有extends的通配符\"></a>带有extends的通配符</h3><p>以Collection接口中的addAll方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt;c)</span></span>;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>? extends E</code>表示可以使用E的子类型作为参数添加到Collection中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">List&lt;Double&gt;dbls=Array.asList(<span class=\"number\">2.23</span>,<span class=\"number\">3.55</span>);</span><br><span class=\"line\">nums.addAll(ints);</span><br><span class=\"line\">nums.addAll(dbls);</span><br></pre></td></tr></table></figure>\n<p>在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。</p>\n<h3 id=\"带有super的通配符\"><a href=\"#带有super的通配符\" class=\"headerlink\" title=\"带有super的通配符\"></a>带有super的通配符</h3><p>将一个List拷贝到另外一个List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt;dst,List&lt;? extend T&gt;src)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;src.size();i++)&#123;</span><br><span class=\"line\">       dst.set(i,src.get(i));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>? super T</code>的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;<br>典型例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">&quot;four&quot;</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">Collection.copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Object&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Number&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Integer&gt;copy(objs,ints);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。</p>\n<h3 id=\"Get和Put原则\"><a href=\"#Get和Put原则\" class=\"headerlink\" title=\"Get和Put原则\"></a>Get和Put原则</h3><p>？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer[] ints=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Number[] nums=ints;</span><br><span class=\"line\">num[<span class=\"number\">2</span>]=<span class=\"number\">3.14</span>;  <span class=\"comment\">//运行时错误</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。</p>\n<p>与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List&lt;? extends T&gt;的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number nums&gt;=ints;      <span class=\"comment\">//在编译时会报错</span></span><br><span class=\"line\">List&lt;? extends Number&gt;nums1=ints; <span class=\"comment\">//编译通过</span></span><br><span class=\"line\">nums1.set(<span class=\"number\">2</span>,<span class=\"number\">3.14</span>)           <span class=\"comment\">//编译错误</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。</p>\n<p>在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。</p>\n<p>Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。</p>\n<h3 id=\"通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\"><a href=\"#通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\" class=\"headerlink\" title=\"通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\"></a>通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）</h3><ul>\n<li>使用通配符判断Collection中是否有指定的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">&quot;one&quot;</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">&quot;one&quot;</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);</span><br><span class=\"line\">ints.containsAll(objs);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在<code>containsAll(Collection&lt;?&gt;c)</code>方法中 <code>Collection&lt;?&gt;c</code>是<code>Collection&lt;?&gt;c</code>的缩写(abbreviation)，继承Object是通配符常用的方式。</p>\n<ul>\n<li>类型参数<br>可以通过类型参数来替换通配符的编码方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(E o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;? extend E&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但实际在编译的过程中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">&quot;one&quot;</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">&quot;one&quot;</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);     <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">ints.containsAll(objs); <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"excerpt":"<h1 id=\"Generics-泛型\"><a href=\"#Generics-泛型\" class=\"headerlink\" title=\"Generics(泛型)\"></a>Generics(泛型)</h1><p>一个接口或类可能被声明为一个或者多个类型的参数，该类或接口写在尖括号中，提供的实体类需要属于该接口或类。</p>","more":"<p>Generic Programming(泛型编程)，泛型类可以是编码更安全以及方便阅读，尤其是在集合类中；Java中的泛型与C++中的模板类有着相似之处。Generic Programming(泛型编程)可以使得对象(object)在多种场合下被重复使用。例如：ArrayList类可以表示各种不同类的集合。</p>\n<p>如果没有泛型，参数的类型会被忽略，</p>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><p>在Java中使用引用类型或基础类型，引用类型有class、interface、array所有的引用类型都是类对象，；每一个基础类型都在java.lang包中有一个相应的引用类型。</p>\n<p>将基础类型转换为引用类型称为装箱，将引用类型转换为基础类型称为拆箱。在自动装箱的过程中value会被缓存，当int值在-128~127之间、char值在 ‘\\u0000’在’\\u007f’、byte类型、boolean类型，<strong>会返回之前缓存的对象</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c=<span class=\"number\">200</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d=<span class=\"number\">200</span>;</span><br><span class=\"line\">System.out.println(a==b);</span><br><span class=\"line\">System.out.println(c==d);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>Java通过泛型可以自动进行装箱与拆箱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer i=<span class=\"keyword\">new</span> Integer(xx);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>会触发自动装箱</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i=xx;</span><br></pre></td></tr></table></figure>\n<p><strong>不会触发自动装箱</strong></p>\n<p><strong>注意：</strong>操作符<code>==</code> 在基础类型中以及引用类型中采用不同的定义方式，在<code>int</code>类型中，<code>==</code>用于通过值的大小定义的，而在<code>Integer</code>中是通过对象定义的。在比较两个类对象时应使用euqal</p>\n<h2 id=\"遍历循环\"><a href=\"#遍历循环\" class=\"headerlink\" title=\"遍历循环\"></a>遍历循环</h2><p>for循环可以被用于实现Iterable<E>接口的任何类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n:ints)&#123;</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterators&lt;Integer&gt;it=ints.iterator();it.hasNext();)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n=it.next();</span><br><span class=\"line\">   s+=n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable<E>接口</h2><p>所有的<code>Collection</code>都实现了Iterable<E>接口</p>\n<h2 id=\"泛型方法和可变参数-Generic-Methods-and-Varargs\"><a href=\"#泛型方法和可变参数-Generic-Methods-and-Varargs\" class=\"headerlink\" title=\"泛型方法和可变参数(Generic Methods and Varargs)\"></a>泛型方法和可变参数(Generic Methods and Varargs)</h2><p>将任意类型的array转换成List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; List&lt;T&gt; <span class=\"title\">toList</span><span class=\"params\">(T[] arr)</span></span>&#123;</span><br><span class=\"line\">       List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将参数写进数组中显的麻烦，可变参数的作用是将数组参数使用一种更方便与简洁的编码方式来代替，将<code>T[]</code>使用<code>T...</code>来替代。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lists</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt;List&lt;T&gt;toList(T...arr)&#123;</span><br><span class=\"line\">            List&lt;T&gt;list=<span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(T elt:arr)list.add(elt);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; ints = Lists.toList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\">List&lt;String&gt; words = Lists.toList(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"子类型和通配符-SubTyping-and-Wildcards\"><a href=\"#子类型和通配符-SubTyping-and-Wildcards\" class=\"headerlink\" title=\"子类型和通配符(SubTyping and Wildcards)\"></a>子类型和通配符(SubTyping and Wildcards)</h3><p><strong>子类型和替换原则</strong></p>\n<p>子类型具有传递性，即A是B的子类型，B是C的子类型，那么A也是C的子类型。在替换原则中当需要某一类型时可以提供该类型的子类型。如：Integer、Double都是Number的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">nums.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br></pre></td></tr></table></figure>\n<p>根据替换规则可以在Number的List中添加<code>Integer</code>和<code>Double</code>类型的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">ints.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">ints.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number&gt;nums=ints;    <span class=\"comment\">//在编译时报错</span></span><br><span class=\"line\">nums.add(<span class=\"number\">3.14</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>报错的原因是List<Integer>不是List<Number>的子类型，反过来写也不要可以。但可以使用<code>List&lt;? extends Number&gt;nums=ints</code>，因为List<Integer>是List&lt;? extends Number&gt;的子类型。</p>\n<h3 id=\"带有extends的通配符\"><a href=\"#带有extends的通配符\" class=\"headerlink\" title=\"带有extends的通配符\"></a>带有extends的通配符</h3><p>以Collection接口中的addAll方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt;c)</span></span>;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>? extends E</code>表示可以使用E的子类型作为参数添加到Collection中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;Number&gt;nums=<span class=\"keyword\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">List&lt;Double&gt;dbls=Array.asList(<span class=\"number\">2.23</span>,<span class=\"number\">3.55</span>);</span><br><span class=\"line\">nums.addAll(ints);</span><br><span class=\"line\">nums.addAll(dbls);</span><br></pre></td></tr></table></figure>\n<p>在此情况下是被允许的，因为List<Number>是Collection<Number>的一个子类型，同时ints的数据类型List<Integer>是Collection&lt;? extends Number&gt;的子类型。如果addAll(Collection&lt;? extends E&gt;c)中没有通配符，那么上面的语句在编译时会报错。</p>\n<h3 id=\"带有super的通配符\"><a href=\"#带有super的通配符\" class=\"headerlink\" title=\"带有super的通配符\"></a>带有super的通配符</h3><p>将一个List拷贝到另外一个List</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt;dst,List&lt;? extend T&gt;src)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;src.size();i++)&#123;</span><br><span class=\"line\">       dst.set(i,src.get(i));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>? super T</code>的表达方式表示目的List中的元素是T的supertype,源List是T的subtype;<br>典型例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt;objs=Array.&lt;Object&gt;asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">&quot;four&quot;</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">Collection.copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Object&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Number&gt;copy(objs,ints);</span><br><span class=\"line\">Collection.&lt;Integer&gt;copy(objs,ints);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过泛型方法，可以通过显式的方式指定复制的类型，上述四种写法都是正确的。</p>\n<h3 id=\"Get和Put原则\"><a href=\"#Get和Put原则\" class=\"headerlink\" title=\"Get和Put原则\"></a>Get和Put原则</h3><p>？？？？协变（covariance）与逆变（contravariance）统称为变体或变型（variance）   不变（invariant）的</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在Java中数组的子类型是协变（covariance）的，当S是T的子类型时，可认为S[]是T[]的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Integer[] ints=<span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Number[] nums=ints;</span><br><span class=\"line\">num[<span class=\"number\">2</span>]=<span class=\"number\">3.14</span>;  <span class=\"comment\">//运行时错误</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Integer[]可被视为Number[]的子类型，根据替换原则第二行是正确的。当一个数组被赋值后，就会被打上它的实例的标签（在这种状态下是Integer）,因此第三行赋值为Double类型在运行是会出错。</p>\n<p>与数组的替换原则相反的是，泛型的子类型时不变的（invarient）,即List<S>不会被认为是List<T>的子类型。引入通配符协变(convariance)泛型，在此情况下当S是T的子类型时，List<S>会被认为是List&lt;? extends T&gt;的子类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt;ints=Array.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">List&lt;Number nums&gt;=ints;      <span class=\"comment\">//在编译时会报错</span></span><br><span class=\"line\">List&lt;? extends Number&gt;nums1=ints; <span class=\"comment\">//编译通过</span></span><br><span class=\"line\">nums1.set(<span class=\"number\">2</span>,<span class=\"number\">3.14</span>)           <span class=\"comment\">//编译错误</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第四行中的赋值，在数组中是运行时报错而在List是运行时报错，根据Get和Put原则不能为已经声明的具有extends的通配符赋值不同的类型。</p>\n<p>在通配符中同时会给泛型引入逆变（contravariance），在此情况下当S是T的超类型，List<S>被认为是List&lt;? super T&gt;的子类型，数组不支持子类型的逆变。</p>\n<p>Arrays和Collection各有自己的优势，Collection支持很多操作而Arrays中没有。基础类型（primary type）的数组，具有更高的效率，因为其没有装箱和拆箱操作，基础类型的数组没有自己的子类型，因此在数组中存储是不进行类型验证，因此其存储错误在代码运行时进行检验；而Collection的数据存储在代码编译的过程中进行错误检验。</p>\n<h3 id=\"通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\"><a href=\"#通配符VS（Versus）类型参数（Wildcard-Versus-Type-Parameters）\" class=\"headerlink\" title=\"通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）\"></a>通配符VS（Versus）类型参数（Wildcard Versus Type Parameters）</h3><ul>\n<li>使用通配符判断Collection中是否有指定的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">&quot;one&quot;</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">&quot;one&quot;</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);</span><br><span class=\"line\">ints.containsAll(objs);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>在<code>containsAll(Collection&lt;?&gt;c)</code>方法中 <code>Collection&lt;?&gt;c</code>是<code>Collection&lt;?&gt;c</code>的缩写(abbreviation)，继承Object是通配符常用的方式。</p>\n<ul>\n<li>类型参数<br>可以通过类型参数来替换通配符的编码方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(E o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;? extend E&gt;c)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但实际在编译的过程中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Object obj=<span class=\"string\">&quot;one&quot;</span>;</span><br><span class=\"line\">List&lt;Object&gt;objs=Arrays.&lt;Object&gt;asList(<span class=\"string\">&quot;one&quot;</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt;ints=Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">objs.contains(obj);</span><br><span class=\"line\">objs.containsAll(ints);</span><br><span class=\"line\">ints.contains(obj);     <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">ints.containsAll(objs); <span class=\"comment\">//编译时报错</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>两行代码在编译时报错，因为类型声明后只能来判断list是否含有该类型的对象，或者该类型的子类型对象，所以判断非类型声明的中对象会报错。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>"},{"title":"Java集合","type":["Java"],"description":"Java集合","cover":"/cover/img56.jpg","toc":true,"_content":"\n\n\n# Collection的使用方法\n\n接口`Collection`继承自`Iterable`接口    \n\n用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。\n<!--more-->\n## Queue 接口\n\n只能在队尾入队，队首出队\n### BlockingQueue接口\n实现类 \n* ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小\n* DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口\n* LinkedBlockingQueue 内部以链表的形式实现\n* PriorityBlockingQueue 无界并发队列\n* SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；\n\n方法\n* add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常\n* remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* offer  添加一个元素并返回true，如果队列已满，则返回false\n* poll  移除并返问队列头部的元素，，如果队列为空，则返回null\n* peek  返回队列头部的元素，如果队列为空，则返回null\n* put  添加一个元素，如果队列满，则阻塞\n* take 移除并返回队列头部的元素，如果队列为空，则阻塞\n\n## Deque接口\n\n队首、队尾都可以进行入队和出队操作\n\n\n \n\n## List接口：实现类 ArrayList LinkedList Vector\n### ArrayList\n\nArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；\n\nArrayList在循环中删除元素可能会出现问题：\n1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏\n2、使用for-each进行删除，实际是调用它的迭代器来实现，\n\n### LinkedList\nLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） \n\n### Vector\n\nVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；\n\n    \n    \n**Java Doc里建议用Deque替代Stack接口完成栈的功能**\n\n\n## Set接口：实现类 Hashset、TreeSet、LinkedHashSet\n\n*  Hashset：按照哈希算法存取集合中的对象，不保证有序，存取速度快；允许null数据；\n*  TreeSet：实现Sorted接口，能够对集合中的对象进行排序，插入速度最慢；\n* LinkedHashSet：主要用于保证FIFO，集合有序；允许null数据；\n\n共同点：非线程安全，如果需要线程安全需要使用 `collection.synchronized()`\n\n### TreeSet的排序方式\n\n1、实现Comparable接口\n\n```java\n\npublic class TestBean implements Comparable<TestBean> {\n    @Override\n    public int compareTo(TestBean testBean) {\n        return 0;\n    }\n}\n\n```\n\n\n2、实现Comparator接口\n\n```java\npublic class TestBean implements Comparator<TestBean> {\n\n    @Override\n    public int compare(TestBean testBean, TestBean t1) {\n        return 0;\n    }\n}\n\n```\n\n\n\n## Map接口\n\n### HashMap和HashTable\n1、HashMap是非线程安全的，HashTable是线程安全的；\n2、HashMap的键值都为null,HashTable不可；\n3、HashMap的效率高于HashTable;\n\n\n### LinkedHashMap\n\nLinkedHashMap<K,V>可以进行访问排序\n\nLruCache可以使用LinkedHashMap进行实现\n\n### WeakHashMap\n\nWeakHashMap继承AbstractMap，实现Map接口，是一个散列表；将一组 key-value 插入WeakHashMap中不能阻止改key被GC回收，除非在WeakHashMap外对该Key有强引用；因此其可用来做缓存。\n\n\n### HashMap遍历\n\n\n\n##  Iterable和Iterator(迭代器)\n\n\n\n## TreeMap和TreeSet\n\n\n\n","source":"_posts/Java/Java基础/Java集合.md","raw":"---\ntitle: Java集合\ntype: [Java]\ndescription: Java集合\ncover:  /cover/img56.jpg\ntoc: true\ncategories: Java\n---\n\n\n\n# Collection的使用方法\n\n接口`Collection`继承自`Iterable`接口    \n\n用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。\n<!--more-->\n## Queue 接口\n\n只能在队尾入队，队首出队\n### BlockingQueue接口\n实现类 \n* ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小\n* DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口\n* LinkedBlockingQueue 内部以链表的形式实现\n* PriorityBlockingQueue 无界并发队列\n* SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；\n\n方法\n* add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常\n* remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常\n* offer  添加一个元素并返回true，如果队列已满，则返回false\n* poll  移除并返问队列头部的元素，，如果队列为空，则返回null\n* peek  返回队列头部的元素，如果队列为空，则返回null\n* put  添加一个元素，如果队列满，则阻塞\n* take 移除并返回队列头部的元素，如果队列为空，则阻塞\n\n## Deque接口\n\n队首、队尾都可以进行入队和出队操作\n\n\n \n\n## List接口：实现类 ArrayList LinkedList Vector\n### ArrayList\n\nArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；\n\nArrayList在循环中删除元素可能会出现问题：\n1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏\n2、使用for-each进行删除，实际是调用它的迭代器来实现，\n\n### LinkedList\nLinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） \n\n### Vector\n\nVector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；\n\n    \n    \n**Java Doc里建议用Deque替代Stack接口完成栈的功能**\n\n\n## Set接口：实现类 Hashset、TreeSet、LinkedHashSet\n\n*  Hashset：按照哈希算法存取集合中的对象，不保证有序，存取速度快；允许null数据；\n*  TreeSet：实现Sorted接口，能够对集合中的对象进行排序，插入速度最慢；\n* LinkedHashSet：主要用于保证FIFO，集合有序；允许null数据；\n\n共同点：非线程安全，如果需要线程安全需要使用 `collection.synchronized()`\n\n### TreeSet的排序方式\n\n1、实现Comparable接口\n\n```java\n\npublic class TestBean implements Comparable<TestBean> {\n    @Override\n    public int compareTo(TestBean testBean) {\n        return 0;\n    }\n}\n\n```\n\n\n2、实现Comparator接口\n\n```java\npublic class TestBean implements Comparator<TestBean> {\n\n    @Override\n    public int compare(TestBean testBean, TestBean t1) {\n        return 0;\n    }\n}\n\n```\n\n\n\n## Map接口\n\n### HashMap和HashTable\n1、HashMap是非线程安全的，HashTable是线程安全的；\n2、HashMap的键值都为null,HashTable不可；\n3、HashMap的效率高于HashTable;\n\n\n### LinkedHashMap\n\nLinkedHashMap<K,V>可以进行访问排序\n\nLruCache可以使用LinkedHashMap进行实现\n\n### WeakHashMap\n\nWeakHashMap继承AbstractMap，实现Map接口，是一个散列表；将一组 key-value 插入WeakHashMap中不能阻止改key被GC回收，除非在WeakHashMap外对该Key有强引用；因此其可用来做缓存。\n\n\n### HashMap遍历\n\n\n\n##  Iterable和Iterator(迭代器)\n\n\n\n## TreeMap和TreeSet\n\n\n\n","slug":"Java/Java基础/Java集合","published":1,"date":"2020-05-08T09:44:43.217Z","updated":"2021-01-05T12:15:21.335Z","_id":"ckjju0m1q005k20ua680872k5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Collection的使用方法\"><a href=\"#Collection的使用方法\" class=\"headerlink\" title=\"Collection的使用方法\"></a>Collection的使用方法</h1><p>接口<code>Collection</code>继承自<code>Iterable</code>接口    </p>\n<p>用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。</p>\n<a id=\"more\"></a>\n<h2 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h2><p>只能在队尾入队，队首出队</p>\n<h3 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h3><p>实现类 </p>\n<ul>\n<li>ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小</li>\n<li>DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口</li>\n<li>LinkedBlockingQueue 内部以链表的形式实现</li>\n<li>PriorityBlockingQueue 无界并发队列</li>\n<li>SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li>\n<li>remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>offer  添加一个元素并返回true，如果队列已满，则返回false</li>\n<li>poll  移除并返问队列头部的元素，，如果队列为空，则返回null</li>\n<li>peek  返回队列头部的元素，如果队列为空，则返回null</li>\n<li>put  添加一个元素，如果队列满，则阻塞</li>\n<li>take 移除并返回队列头部的元素，如果队列为空，则阻塞</li>\n</ul>\n<h2 id=\"Deque接口\"><a href=\"#Deque接口\" class=\"headerlink\" title=\"Deque接口\"></a>Deque接口</h2><p>队首、队尾都可以进行入队和出队操作</p>\n<h2 id=\"List接口：实现类-ArrayList-LinkedList-Vector\"><a href=\"#List接口：实现类-ArrayList-LinkedList-Vector\" class=\"headerlink\" title=\"List接口：实现类 ArrayList LinkedList Vector\"></a>List接口：实现类 ArrayList LinkedList Vector</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；</p>\n<p>ArrayList在循环中删除元素可能会出现问题：<br>1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏<br>2、使用for-each进行删除，实际是调用它的迭代器来实现，</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） </p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；</p>\n<p><strong>Java Doc里建议用Deque替代Stack接口完成栈的功能</strong></p>\n<h2 id=\"Set接口：实现类-Hashset、TreeSet、LinkedHashSet\"><a href=\"#Set接口：实现类-Hashset、TreeSet、LinkedHashSet\" class=\"headerlink\" title=\"Set接口：实现类 Hashset、TreeSet、LinkedHashSet\"></a>Set接口：实现类 Hashset、TreeSet、LinkedHashSet</h2><ul>\n<li> Hashset：按照哈希算法存取集合中的对象，不保证有序，存取速度快；允许null数据；</li>\n<li> TreeSet：实现Sorted接口，能够对集合中的对象进行排序，插入速度最慢；</li>\n<li>LinkedHashSet：主要用于保证FIFO，集合有序；允许null数据；</li>\n</ul>\n<p>共同点：非线程安全，如果需要线程安全需要使用 <code>collection.synchronized()</code></p>\n<h3 id=\"TreeSet的排序方式\"><a href=\"#TreeSet的排序方式\" class=\"headerlink\" title=\"TreeSet的排序方式\"></a>TreeSet的排序方式</h3><p>1、实现Comparable接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">TestBean</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(TestBean testBean)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2、实现Comparator接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">TestBean</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(TestBean testBean, TestBean t1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap和HashTable\"><a href=\"#HashMap和HashTable\" class=\"headerlink\" title=\"HashMap和HashTable\"></a>HashMap和HashTable</h3><p>1、HashMap是非线程安全的，HashTable是线程安全的；<br>2、HashMap的键值都为null,HashTable不可；<br>3、HashMap的效率高于HashTable;</p>\n<h3 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h3><p>LinkedHashMap&lt;K,V&gt;可以进行访问排序</p>\n<p>LruCache可以使用LinkedHashMap进行实现</p>\n<h3 id=\"WeakHashMap\"><a href=\"#WeakHashMap\" class=\"headerlink\" title=\"WeakHashMap\"></a>WeakHashMap</h3><p>WeakHashMap继承AbstractMap，实现Map接口，是一个散列表；将一组 key-value 插入WeakHashMap中不能阻止改key被GC回收，除非在WeakHashMap外对该Key有强引用；因此其可用来做缓存。</p>\n<h3 id=\"HashMap遍历\"><a href=\"#HashMap遍历\" class=\"headerlink\" title=\"HashMap遍历\"></a>HashMap遍历</h3><h2 id=\"Iterable和Iterator-迭代器\"><a href=\"#Iterable和Iterator-迭代器\" class=\"headerlink\" title=\"Iterable和Iterator(迭代器)\"></a>Iterable和Iterator(迭代器)</h2><h2 id=\"TreeMap和TreeSet\"><a href=\"#TreeMap和TreeSet\" class=\"headerlink\" title=\"TreeMap和TreeSet\"></a>TreeMap和TreeSet</h2>","site":{"data":{}},"excerpt":"<h1 id=\"Collection的使用方法\"><a href=\"#Collection的使用方法\" class=\"headerlink\" title=\"Collection的使用方法\"></a>Collection的使用方法</h1><p>接口<code>Collection</code>继承自<code>Iterable</code>接口    </p>\n<p>用于表示一系列的独立元素，其中List按照元素插入的顺序存储，Set中不能含有相同的元素，Queue用于队列的表示，并按照插入的顺序进行存储。</p>","more":"<h2 id=\"Queue-接口\"><a href=\"#Queue-接口\" class=\"headerlink\" title=\"Queue 接口\"></a>Queue 接口</h2><p>只能在队尾入队，队首出队</p>\n<h3 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h3><p>实现类 </p>\n<ul>\n<li>ArrayBlockingQueue 有界阻塞队列，内部使用数组实现，初始化大小后无法改变大小</li>\n<li>DelayQueue 注入其中的元素必须实现 java.util.concurrent.Delayed 接口</li>\n<li>LinkedBlockingQueue 内部以链表的形式实现</li>\n<li>PriorityBlockingQueue 无界并发队列</li>\n<li>SynchronousQueue 其是一个特殊的队列，内部只能容纳单个元素；</li>\n</ul>\n<p>方法</p>\n<ul>\n<li>add 增加一个元索，如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li>\n<li>remove   移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>element  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</li>\n<li>offer  添加一个元素并返回true，如果队列已满，则返回false</li>\n<li>poll  移除并返问队列头部的元素，，如果队列为空，则返回null</li>\n<li>peek  返回队列头部的元素，如果队列为空，则返回null</li>\n<li>put  添加一个元素，如果队列满，则阻塞</li>\n<li>take 移除并返回队列头部的元素，如果队列为空，则阻塞</li>\n</ul>\n<h2 id=\"Deque接口\"><a href=\"#Deque接口\" class=\"headerlink\" title=\"Deque接口\"></a>Deque接口</h2><p>队首、队尾都可以进行入队和出队操作</p>\n<h2 id=\"List接口：实现类-ArrayList-LinkedList-Vector\"><a href=\"#List接口：实现类-ArrayList-LinkedList-Vector\" class=\"headerlink\" title=\"List接口：实现类 ArrayList LinkedList Vector\"></a>List接口：实现类 ArrayList LinkedList Vector</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList使用数组实现，在频繁做增删元素的时候效率会降低，底层需要判断新建一个多长的数组存放操作之后的数组；其可以精确设置数组长度；查询快，增删慢；</p>\n<p>ArrayList在循环中删除元素可能会出现问题：<br>1、使用for(;;)正序删除，会有元素发生位移，导致删除遗漏<br>2、使用for-each进行删除，实际是调用它的迭代器来实现，</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>LinkedList使用双向链表实现；增删快，查询慢（按照下标增删元素一样慢） </p>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>Vector使用数组实现，线程安全，ArrrayList线程不安全；Java不建议使用此类，使用ArrayList进行代替；</p>\n<p><strong>Java Doc里建议用Deque替代Stack接口完成栈的功能</strong></p>\n<h2 id=\"Set接口：实现类-Hashset、TreeSet、LinkedHashSet\"><a href=\"#Set接口：实现类-Hashset、TreeSet、LinkedHashSet\" class=\"headerlink\" title=\"Set接口：实现类 Hashset、TreeSet、LinkedHashSet\"></a>Set接口：实现类 Hashset、TreeSet、LinkedHashSet</h2><ul>\n<li> Hashset：按照哈希算法存取集合中的对象，不保证有序，存取速度快；允许null数据；</li>\n<li> TreeSet：实现Sorted接口，能够对集合中的对象进行排序，插入速度最慢；</li>\n<li>LinkedHashSet：主要用于保证FIFO，集合有序；允许null数据；</li>\n</ul>\n<p>共同点：非线程安全，如果需要线程安全需要使用 <code>collection.synchronized()</code></p>\n<h3 id=\"TreeSet的排序方式\"><a href=\"#TreeSet的排序方式\" class=\"headerlink\" title=\"TreeSet的排序方式\"></a>TreeSet的排序方式</h3><p>1、实现Comparable接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">TestBean</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(TestBean testBean)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2、实现Comparator接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">TestBean</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(TestBean testBean, TestBean t1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap和HashTable\"><a href=\"#HashMap和HashTable\" class=\"headerlink\" title=\"HashMap和HashTable\"></a>HashMap和HashTable</h3><p>1、HashMap是非线程安全的，HashTable是线程安全的；<br>2、HashMap的键值都为null,HashTable不可；<br>3、HashMap的效率高于HashTable;</p>\n<h3 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h3><p>LinkedHashMap&lt;K,V&gt;可以进行访问排序</p>\n<p>LruCache可以使用LinkedHashMap进行实现</p>\n<h3 id=\"WeakHashMap\"><a href=\"#WeakHashMap\" class=\"headerlink\" title=\"WeakHashMap\"></a>WeakHashMap</h3><p>WeakHashMap继承AbstractMap，实现Map接口，是一个散列表；将一组 key-value 插入WeakHashMap中不能阻止改key被GC回收，除非在WeakHashMap外对该Key有强引用；因此其可用来做缓存。</p>\n<h3 id=\"HashMap遍历\"><a href=\"#HashMap遍历\" class=\"headerlink\" title=\"HashMap遍历\"></a>HashMap遍历</h3><h2 id=\"Iterable和Iterator-迭代器\"><a href=\"#Iterable和Iterator-迭代器\" class=\"headerlink\" title=\"Iterable和Iterator(迭代器)\"></a>Iterable和Iterator(迭代器)</h2><h2 id=\"TreeMap和TreeSet\"><a href=\"#TreeMap和TreeSet\" class=\"headerlink\" title=\"TreeMap和TreeSet\"></a>TreeMap和TreeSet</h2>"},{"title":"Lambda介绍","type":["Java"],"description":"Lambda介绍","cover":"/cover/img57.jpg","toc":true,"_content":"\n### Lambda介绍\nLambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的**；\n\n<!--more-->\n\n### Java Lambda表达式的写法\n\nJava中的Lambda表达式通常用`(argument)->(body)`的语法表示\n\n```java\n    (arg1, arg2...) -> { body }\n    (type1 arg1, type2 arg2...) -> { body }\n```\n\n* 一个Lambda表达式可以有零个或多个参数；\n* Lambda表达式的主体可以包括零条或多条语句；\n* 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。\n\n\n### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface），`java.lang.Runnable`接口是只有一个`run()`方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建`Runnable`接口引用如下：\n\n```java\n    Runnable r=()->Log.i(\"测试\",\"Hello Word\");\n    //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口\n    new Thread(()->Log.i(\"测试\",\"Hello Word\")).start();\n \n```\n\n###  Lambda表达式与匿名类的区别\n\n* 对于关键字的使用：对于匿名类，关键字`this`解读为匿名类，而对于Lambda表达式，关键字`this`解读为Lambda的外部类\n\n* Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。\n\n\n### 使用Lambda表达式将List中的元素按照长度进行排序\n\n```java\n    \n    //采用匿名内部类写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, new Comparator<String>(){\n        @Override\n        public int compare(String s1, String s2){\n            return s1.length()-s2.length();\n        }\n    });\n    \n    //采用Lambda写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, (s1, s2) ->{\n        return s1.length()-s2.length();\n    });\n            \n```\n\n### 使用Lambda将List中的每个值平方，并计算和\n\n`java.util.stream.Stream`接口，在Java8引入，必须使用Lambda表达式作为参数，`map()`将input stream的元素，映射成out stream；`reduce()`方法用于将stream元素组合起来。\n\n```java\n    \n    //常用写法\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = 0;\n    for(Integer tmp : list) {\n        int x = tmp +tmp;\n        sum = sum + x;\n    }\n    System.out.println(sum);\n\n    // 使用Lambda写法，\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();\n    System.out.println(sum);\n\n\n```\n\n\n#### Lambda表达式使用注意事项\n\n在Lambda表达式中不能有指向其自己的引用，关键字`this`指向的是闭包，而在匿名内部类中`this`关键字指向的是匿名函数自己，\n\n\n### Lambda表达式的常用方法\n\n#### 使用lambda表达式替换匿名类\n使用lambda表达式替换匿名类，需要用到函数式接口,如`Runnable接口`；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。\n\n``` java\n    //使用匿名内部类表达式方法\n    new Thread(new Runnable(){\n        @Override\n        public void run() {\n        System.out.println(\"Test Runnable 1\");\n    }\n    \n    ).start();\n    \n    //使用匿名内部类的方式\n    new Thread( () -> System.out.println(\"Test Runnable 2\") ).start();\n\n```\n\n在使用lambda表达式进行排序时，`Comparator<String>`中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    \n\n\n```java\n    //使用匿名内部类方式对list进行排序\n    Collections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n        }\n    });\n    //使用lambda表达式方式对list进行排序\n    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n\n```\n\n\n\n#### 使用Lambda表达式进行点击事件处理\n\n```java\n    //非lambda表达式方法\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n        Log.i(\"info\",\"点击\");\n        }\n    });\n\n    //使用lambda表达式方式\n    button.setOnClickListener((e)->{\n        Log.i(\"info\",\"点击\");\n    });\n\n\n```\n\n但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，`setOnClickListener()`方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式\n\n```\n        hello.setOnClickListener(object : View.OnClickListener {\n            override fun onClick(v: View?) {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n        })\n        \n        //或者\n       hello.setOnClickListener{\n          Log.i(\"info\",\"点击\");\n        }\n\n\n```\n\n\n#### 在Java中使用lambda表达式和函数式接口Predicate\n\n在`java.util.function`包中，包含多个类用于支持Java的函数式编程，使用`java.util.function.Predicate`函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java基础/Lambda表达式.md","raw":"---\ntitle: Lambda介绍\ntype: [Java]\ndescription: Lambda介绍\ncover:  /cover/img57.jpg\ntoc: true\ncategories: Java\n---\n\n### Lambda介绍\nLambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。\n\nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。**在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的**；\n\n<!--more-->\n\n### Java Lambda表达式的写法\n\nJava中的Lambda表达式通常用`(argument)->(body)`的语法表示\n\n```java\n    (arg1, arg2...) -> { body }\n    (type1 arg1, type2 arg2...) -> { body }\n```\n\n* 一个Lambda表达式可以有零个或多个参数；\n* Lambda表达式的主体可以包括零条或多条语句；\n* 如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。\n\n\n### 函数式接口\n把只有一个抽象方法的接口叫做函数式接口（functional interface），`java.lang.Runnable`接口是只有一个`run()`方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建`Runnable`接口引用如下：\n\n```java\n    Runnable r=()->Log.i(\"测试\",\"Hello Word\");\n    //当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口\n    new Thread(()->Log.i(\"测试\",\"Hello Word\")).start();\n \n```\n\n###  Lambda表达式与匿名类的区别\n\n* 对于关键字的使用：对于匿名类，关键字`this`解读为匿名类，而对于Lambda表达式，关键字`this`解读为Lambda的外部类\n\n* Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。\n\n\n### 使用Lambda表达式将List中的元素按照长度进行排序\n\n```java\n    \n    //采用匿名内部类写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, new Comparator<String>(){\n        @Override\n        public int compare(String s1, String s2){\n            return s1.length()-s2.length();\n        }\n    });\n    \n    //采用Lambda写法\n    List<String> list = Arrays.asList(\"System\", \"out\", \"println\", \"hello\");\n    Collections.sort(list, (s1, s2) ->{\n        return s1.length()-s2.length();\n    });\n            \n```\n\n### 使用Lambda将List中的每个值平方，并计算和\n\n`java.util.stream.Stream`接口，在Java8引入，必须使用Lambda表达式作为参数，`map()`将input stream的元素，映射成out stream；`reduce()`方法用于将stream元素组合起来。\n\n```java\n    \n    //常用写法\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = 0;\n    for(Integer tmp : list) {\n        int x = tmp +tmp;\n        sum = sum + x;\n    }\n    System.out.println(sum);\n\n    // 使用Lambda写法，\n    List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);\n    int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();\n    System.out.println(sum);\n\n\n```\n\n\n#### Lambda表达式使用注意事项\n\n在Lambda表达式中不能有指向其自己的引用，关键字`this`指向的是闭包，而在匿名内部类中`this`关键字指向的是匿名函数自己，\n\n\n### Lambda表达式的常用方法\n\n#### 使用lambda表达式替换匿名类\n使用lambda表达式替换匿名类，需要用到函数式接口,如`Runnable接口`；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。\n\n``` java\n    //使用匿名内部类表达式方法\n    new Thread(new Runnable(){\n        @Override\n        public void run() {\n        System.out.println(\"Test Runnable 1\");\n    }\n    \n    ).start();\n    \n    //使用匿名内部类的方式\n    new Thread( () -> System.out.println(\"Test Runnable 2\") ).start();\n\n```\n\n在使用lambda表达式进行排序时，`Comparator<String>`中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    \n\n\n```java\n    //使用匿名内部类方式对list进行排序\n    Collections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n        }\n    });\n    //使用lambda表达式方式对list进行排序\n    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));\n\n```\n\n\n\n#### 使用Lambda表达式进行点击事件处理\n\n```java\n    //非lambda表达式方法\n    button.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n        Log.i(\"info\",\"点击\");\n        }\n    });\n\n    //使用lambda表达式方式\n    button.setOnClickListener((e)->{\n        Log.i(\"info\",\"点击\");\n    });\n\n\n```\n\n但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，`setOnClickListener()`方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式\n\n```\n        hello.setOnClickListener(object : View.OnClickListener {\n            override fun onClick(v: View?) {\n                TODO(\"not implemented\") //To change body of created functions use File | Settings | File Templates.\n            }\n        })\n        \n        //或者\n       hello.setOnClickListener{\n          Log.i(\"info\",\"点击\");\n        }\n\n\n```\n\n\n#### 在Java中使用lambda表达式和函数式接口Predicate\n\n在`java.util.function`包中，包含多个类用于支持Java的函数式编程，使用`java.util.function.Predicate`函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为\n\n\n\n\n\n\n\n\n","slug":"Java/Java基础/Lambda表达式","published":1,"date":"2020-05-08T09:44:43.218Z","updated":"2021-01-06T01:17:26.501Z","_id":"ckjju0m1q005m20ua1lkfdyuk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Lambda介绍\"><a href=\"#Lambda介绍\" class=\"headerlink\" title=\"Lambda介绍\"></a>Lambda介绍</h3><p>Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<strong>在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的</strong>；</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Java-Lambda表达式的写法\"><a href=\"#Java-Lambda表达式的写法\" class=\"headerlink\" title=\"Java Lambda表达式的写法\"></a>Java Lambda表达式的写法</h3><p>Java中的Lambda表达式通常用<code>(argument)-&gt;(body)</code>的语法表示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class=\"line\">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个Lambda表达式可以有零个或多个参数；</li>\n<li>Lambda表达式的主体可以包括零条或多条语句；</li>\n<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。</li>\n</ul>\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>把只有一个抽象方法的接口叫做函数式接口（functional interface），<code>java.lang.Runnable</code>接口是只有一个<code>run()</code>方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建<code>Runnable</code>接口引用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r=()-&gt;Log.i(<span class=\"string\">&quot;测试&quot;</span>,<span class=\"string\">&quot;Hello Word&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;Log.i(<span class=\"string\">&quot;测试&quot;</span>,<span class=\"string\">&quot;Hello Word&quot;</span>)).start();</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<h3 id=\"Lambda表达式与匿名类的区别\"><a href=\"#Lambda表达式与匿名类的区别\" class=\"headerlink\" title=\"Lambda表达式与匿名类的区别\"></a>Lambda表达式与匿名类的区别</h3><ul>\n<li><p>对于关键字的使用：对于匿名类，关键字<code>this</code>解读为匿名类，而对于Lambda表达式，关键字<code>this</code>解读为Lambda的外部类</p>\n</li>\n<li><p>Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。</p>\n</li>\n</ul>\n<h3 id=\"使用Lambda表达式将List中的元素按照长度进行排序\"><a href=\"#使用Lambda表达式将List中的元素按照长度进行排序\" class=\"headerlink\" title=\"使用Lambda表达式将List中的元素按照长度进行排序\"></a>使用Lambda表达式将List中的元素按照长度进行排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;System&quot;</span>, <span class=\"string\">&quot;out&quot;</span>, <span class=\"string\">&quot;println&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用Lambda写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;System&quot;</span>, <span class=\"string\">&quot;out&quot;</span>, <span class=\"string\">&quot;println&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Lambda将List中的每个值平方，并计算和\"><a href=\"#使用Lambda将List中的每个值平方，并计算和\" class=\"headerlink\" title=\"使用Lambda将List中的每个值平方，并计算和\"></a>使用Lambda将List中的每个值平方，并计算和</h3><p><code>java.util.stream.Stream</code>接口，在Java8引入，必须使用Lambda表达式作为参数，<code>map()</code>将input stream的元素，映射成out stream；<code>reduce()</code>方法用于将stream元素组合起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常用写法</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer tmp : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = tmp +tmp;</span><br><span class=\"line\">    sum = sum + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Lambda写法，</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Lambda表达式使用注意事项\"><a href=\"#Lambda表达式使用注意事项\" class=\"headerlink\" title=\"Lambda表达式使用注意事项\"></a>Lambda表达式使用注意事项</h4><p>在Lambda表达式中不能有指向其自己的引用，关键字<code>this</code>指向的是闭包，而在匿名内部类中<code>this</code>关键字指向的是匿名函数自己，</p>\n<h3 id=\"Lambda表达式的常用方法\"><a href=\"#Lambda表达式的常用方法\" class=\"headerlink\" title=\"Lambda表达式的常用方法\"></a>Lambda表达式的常用方法</h3><h4 id=\"使用lambda表达式替换匿名类\"><a href=\"#使用lambda表达式替换匿名类\" class=\"headerlink\" title=\"使用lambda表达式替换匿名类\"></a>使用lambda表达式替换匿名类</h4><p>使用lambda表达式替换匿名类，需要用到函数式接口,如<code>Runnable接口</code>；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类表达式方法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Test Runnable 1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用匿名内部类的方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread( () -&gt; System.out.println(<span class=\"string\">&quot;Test Runnable 2&quot;</span>) ).start();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在使用lambda表达式进行排序时，<code>Comparator&lt;String&gt;</code>中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"使用Lambda表达式进行点击事件处理\"><a href=\"#使用Lambda表达式进行点击事件处理\" class=\"headerlink\" title=\"使用Lambda表达式进行点击事件处理\"></a>使用Lambda表达式进行点击事件处理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非lambda表达式方法</span></span><br><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;info&quot;</span>,<span class=\"string\">&quot;点击&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式</span></span><br><span class=\"line\">button.setOnClickListener((e)-&gt;&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;info&quot;</span>,<span class=\"string\">&quot;点击&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，<code>setOnClickListener()</code>方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> hello.setOnClickListener(object : View.OnClickListener &#123;</span><br><span class=\"line\">     override fun onClick(v: View?) &#123;</span><br><span class=\"line\">         TODO(&quot;not implemented&quot;) &#x2F;&#x2F;To change body of created functions use File | Settings | File Templates.</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> &#x2F;&#x2F;或者</span><br><span class=\"line\">hello.setOnClickListener&#123;</span><br><span class=\"line\">   Log.i(&quot;info&quot;,&quot;点击&quot;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在Java中使用lambda表达式和函数式接口Predicate\"><a href=\"#在Java中使用lambda表达式和函数式接口Predicate\" class=\"headerlink\" title=\"在Java中使用lambda表达式和函数式接口Predicate\"></a>在Java中使用lambda表达式和函数式接口Predicate</h4><p>在<code>java.util.function</code>包中，包含多个类用于支持Java的函数式编程，使用<code>java.util.function.Predicate</code>函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Lambda介绍\"><a href=\"#Lambda介绍\" class=\"headerlink\" title=\"Lambda介绍\"></a>Lambda介绍</h3><p>Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，它是推动 Java 8 发布的最重要新特性。</p>\n<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<strong>在Java中Lambda表达式与函数式接口是不可分割的，都是结合起来使用的</strong>；</p>","more":"<h3 id=\"Java-Lambda表达式的写法\"><a href=\"#Java-Lambda表达式的写法\" class=\"headerlink\" title=\"Java Lambda表达式的写法\"></a>Java Lambda表达式的写法</h3><p>Java中的Lambda表达式通常用<code>(argument)-&gt;(body)</code>的语法表示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(arg1, arg2...) -&gt; &#123; body &#125;</span><br><span class=\"line\">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个Lambda表达式可以有零个或多个参数；</li>\n<li>Lambda表达式的主体可以包括零条或多条语句；</li>\n<li>如果Lambda表达式的主体包含一条以上语句，则表达式必须包括在花括号{}中，返回值与代码块的返回类型一致，若没有则返回值为空。</li>\n</ul>\n<h3 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h3><p>把只有一个抽象方法的接口叫做函数式接口（functional interface），<code>java.lang.Runnable</code>接口是只有一个<code>run()</code>方法的函数式接口；Lambda表达式能隐式地赋值给函数式接口，通过Lambda表达式创建<code>Runnable</code>接口引用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r=()-&gt;Log.i(<span class=\"string\">&quot;测试&quot;</span>,<span class=\"string\">&quot;Hello Word&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//当不指明函数式接口时，编译器会自动解释这种转化,将Lambda表达式赋值给Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;Log.i(<span class=\"string\">&quot;测试&quot;</span>,<span class=\"string\">&quot;Hello Word&quot;</span>)).start();</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<h3 id=\"Lambda表达式与匿名类的区别\"><a href=\"#Lambda表达式与匿名类的区别\" class=\"headerlink\" title=\"Lambda表达式与匿名类的区别\"></a>Lambda表达式与匿名类的区别</h3><ul>\n<li><p>对于关键字的使用：对于匿名类，关键字<code>this</code>解读为匿名类，而对于Lambda表达式，关键字<code>this</code>解读为Lambda的外部类</p>\n</li>\n<li><p>Lambda表达式不能取代所有的匿名内部类，只能用来取代函数接口(Functional Interface)的简写。</p>\n</li>\n</ul>\n<h3 id=\"使用Lambda表达式将List中的元素按照长度进行排序\"><a href=\"#使用Lambda表达式将List中的元素按照长度进行排序\" class=\"headerlink\" title=\"使用Lambda表达式将List中的元素按照长度进行排序\"></a>使用Lambda表达式将List中的元素按照长度进行排序</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;System&quot;</span>, <span class=\"string\">&quot;out&quot;</span>, <span class=\"string\">&quot;println&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//采用Lambda写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;System&quot;</span>, <span class=\"string\">&quot;out&quot;</span>, <span class=\"string\">&quot;println&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Lambda将List中的每个值平方，并计算和\"><a href=\"#使用Lambda将List中的每个值平方，并计算和\" class=\"headerlink\" title=\"使用Lambda将List中的每个值平方，并计算和\"></a>使用Lambda将List中的每个值平方，并计算和</h3><p><code>java.util.stream.Stream</code>接口，在Java8引入，必须使用Lambda表达式作为参数，<code>map()</code>将input stream的元素，映射成out stream；<code>reduce()</code>方法用于将stream元素组合起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常用写法</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer tmp : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = tmp +tmp;</span><br><span class=\"line\">    sum = sum + x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Lambda写法，</span></span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class=\"line\">System.out.println(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Lambda表达式使用注意事项\"><a href=\"#Lambda表达式使用注意事项\" class=\"headerlink\" title=\"Lambda表达式使用注意事项\"></a>Lambda表达式使用注意事项</h4><p>在Lambda表达式中不能有指向其自己的引用，关键字<code>this</code>指向的是闭包，而在匿名内部类中<code>this</code>关键字指向的是匿名函数自己，</p>\n<h3 id=\"Lambda表达式的常用方法\"><a href=\"#Lambda表达式的常用方法\" class=\"headerlink\" title=\"Lambda表达式的常用方法\"></a>Lambda表达式的常用方法</h3><h4 id=\"使用lambda表达式替换匿名类\"><a href=\"#使用lambda表达式替换匿名类\" class=\"headerlink\" title=\"使用lambda表达式替换匿名类\"></a>使用lambda表达式替换匿名类</h4><p>使用lambda表达式替换匿名类，需要用到函数式接口,如<code>Runnable接口</code>；在匿名类中只有函数式接口可以使用Lambda表达式进行替代，如果需要一个抽象类的匿名实例，只能使用功匿名类的形式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类表达式方法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Test Runnable 1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用匿名内部类的方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread( () -&gt; System.out.println(<span class=\"string\">&quot;Test Runnable 2&quot;</span>) ).start();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在使用lambda表达式进行排序时，<code>Comparator&lt;String&gt;</code>中的参数类型以及返回值，都没有显式地写出，编译器会根据上下文推断出使用的数据类型    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用匿名内部类方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式对list进行排序</span></span><br><span class=\"line\">Collections.sort(words, (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"使用Lambda表达式进行点击事件处理\"><a href=\"#使用Lambda表达式进行点击事件处理\" class=\"headerlink\" title=\"使用Lambda表达式进行点击事件处理\"></a>使用Lambda表达式进行点击事件处理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非lambda表达式方法</span></span><br><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;info&quot;</span>,<span class=\"string\">&quot;点击&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式方式</span></span><br><span class=\"line\">button.setOnClickListener((e)-&gt;&#123;</span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;info&quot;</span>,<span class=\"string\">&quot;点击&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但在使用Kotlin添加点击事件，Java中使用lambda表达式不同，<code>setOnClickListener()</code>方法在Kotlin中调用时只支持匿名内部类的方式，不支持lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> hello.setOnClickListener(object : View.OnClickListener &#123;</span><br><span class=\"line\">     override fun onClick(v: View?) &#123;</span><br><span class=\"line\">         TODO(&quot;not implemented&quot;) &#x2F;&#x2F;To change body of created functions use File | Settings | File Templates.</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> &#x2F;&#x2F;或者</span><br><span class=\"line\">hello.setOnClickListener&#123;</span><br><span class=\"line\">   Log.i(&quot;info&quot;,&quot;点击&quot;);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在Java中使用lambda表达式和函数式接口Predicate\"><a href=\"#在Java中使用lambda表达式和函数式接口Predicate\" class=\"headerlink\" title=\"在Java中使用lambda表达式和函数式接口Predicate\"></a>在Java中使用lambda表达式和函数式接口Predicate</h4><p>在<code>java.util.function</code>包中，包含多个类用于支持Java的函数式编程，使用<code>java.util.function.Predicate</code>函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更的动态行为</p>"},{"title":"String、StringBuffer、StringBuilder","type":["Java"],"description":"String、StringBuffer、StringBuilder","cover":"/cover/img58.jpg","toc":true,"_content":"\n### String、StringBuffer、StringBuilder\n\n`String`类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的`String`对象；\n\n`StringBuffer`和`StringBuilder`对象是可以改变的，变化时基于原来的对象基础上机型改变。\n\n### StringBuffer VS. String Builder\n\nStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。\n\n### '+' VS. StringBuilder\n\n如果有多个字符串需要使用StringBuilder，因为`+`每一次都会创建并返回新的对象；\n\n\n### byte[]和String类型相互转化\n\nbyte[]转换为String,如果是非法值，可能转换不成功\n\n```\n    //用于测试String和byte之间的相互转化\n    String testString=\"1234566789\";\n    byte[] testByte=testString.getBytes();\n    try {\n        String string=new String(testByte, \"UTF-8\");\n        System.out.println(string);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n```","source":"_posts/Java/Java基础/String、StringBuffer、StringBuilder区别.md","raw":"---\ntitle: String、StringBuffer、StringBuilder\ntype: [Java]\ndescription: String、StringBuffer、StringBuilder\ncover:  /cover/img58.jpg\ntoc: true\ncategories: Java\n---\n\n### String、StringBuffer、StringBuilder\n\n`String`类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的`String`对象；\n\n`StringBuffer`和`StringBuilder`对象是可以改变的，变化时基于原来的对象基础上机型改变。\n\n### StringBuffer VS. String Builder\n\nStringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。\n\n### '+' VS. StringBuilder\n\n如果有多个字符串需要使用StringBuilder，因为`+`每一次都会创建并返回新的对象；\n\n\n### byte[]和String类型相互转化\n\nbyte[]转换为String,如果是非法值，可能转换不成功\n\n```\n    //用于测试String和byte之间的相互转化\n    String testString=\"1234566789\";\n    byte[] testByte=testString.getBytes();\n    try {\n        String string=new String(testByte, \"UTF-8\");\n        System.out.println(string);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n```","slug":"Java/Java基础/String、StringBuffer、StringBuilder区别","published":1,"date":"2020-05-08T09:44:43.218Z","updated":"2021-01-05T12:15:30.025Z","_id":"ckjju0m1r005r20ua416v024o","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h3><p><code>String</code>类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的<code>String</code>对象；</p>\n<p><code>StringBuffer</code>和<code>StringBuilder</code>对象是可以改变的，变化时基于原来的对象基础上机型改变。</p>\n<h3 id=\"StringBuffer-VS-String-Builder\"><a href=\"#StringBuffer-VS-String-Builder\" class=\"headerlink\" title=\"StringBuffer VS. String Builder\"></a>StringBuffer VS. String Builder</h3><p>StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。</p>\n<h3 id=\"‘-’-VS-StringBuilder\"><a href=\"#‘-’-VS-StringBuilder\" class=\"headerlink\" title=\"‘+’ VS. StringBuilder\"></a>‘+’ VS. StringBuilder</h3><p>如果有多个字符串需要使用StringBuilder，因为<code>+</code>每一次都会创建并返回新的对象；</p>\n<h3 id=\"byte-和String类型相互转化\"><a href=\"#byte-和String类型相互转化\" class=\"headerlink\" title=\"byte[]和String类型相互转化\"></a>byte[]和String类型相互转化</h3><p>byte[]转换为String,如果是非法值，可能转换不成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用于测试String和byte之间的相互转化</span><br><span class=\"line\">String testString&#x3D;&quot;1234566789&quot;;</span><br><span class=\"line\">byte[] testByte&#x3D;testString.getBytes();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    String string&#x3D;new String(testByte, &quot;UTF-8&quot;);</span><br><span class=\"line\">    System.out.println(string);</span><br><span class=\"line\">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h3><p><code>String</code>类对象是immutable,即不可改变的，在源码对String操作的方法中，返回的都是一个新的<code>String</code>对象；</p>\n<p><code>StringBuffer</code>和<code>StringBuilder</code>对象是可以改变的，变化时基于原来的对象基础上机型改变。</p>\n<h3 id=\"StringBuffer-VS-String-Builder\"><a href=\"#StringBuffer-VS-String-Builder\" class=\"headerlink\" title=\"StringBuffer VS. String Builder\"></a>StringBuffer VS. String Builder</h3><p>StringBuffer是线程安全的，有加锁开销，效率低；StringBuilder非线程安全，不需要加锁，效率高；StringBuilder是JDK 1.5之后引入的，之前只能使用StringBuilder。</p>\n<h3 id=\"‘-’-VS-StringBuilder\"><a href=\"#‘-’-VS-StringBuilder\" class=\"headerlink\" title=\"‘+’ VS. StringBuilder\"></a>‘+’ VS. StringBuilder</h3><p>如果有多个字符串需要使用StringBuilder，因为<code>+</code>每一次都会创建并返回新的对象；</p>\n<h3 id=\"byte-和String类型相互转化\"><a href=\"#byte-和String类型相互转化\" class=\"headerlink\" title=\"byte[]和String类型相互转化\"></a>byte[]和String类型相互转化</h3><p>byte[]转换为String,如果是非法值，可能转换不成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用于测试String和byte之间的相互转化</span><br><span class=\"line\">String testString&#x3D;&quot;1234566789&quot;;</span><br><span class=\"line\">byte[] testByte&#x3D;testString.getBytes();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    String string&#x3D;new String(testByte, &quot;UTF-8&quot;);</span><br><span class=\"line\">    System.out.println(string);</span><br><span class=\"line\">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"加密算法","type":["Java"],"description":"加密算法","cover":"/cover/img59.jpg","toc":true,"_content":"\n## AES加密\n\n AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，\n\n 在线测试工具  https://oktools.net/aes \n  \n### AES在Java中的使用\n\n JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。\n Java中的加解密由Cipher组件提供。\n \n**注：**\n* Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding \n* Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)\n\n#### 生成秘钥\n\n```\n     KeyGenerator generator=KeyGenerator.getInstance(\"AES/ECB/PKCS5PADDING\");\n     //用于指定秘钥长度\n     generator.init(Secret_Key_Size);\n\n     SecretKey secretKey=generator.generateKey();\n\n```\n\n\n#### PKCS7Padding/PKCS5Padding/ZeroPadding 三种填充模式的区别\n\n某些加密算法要求明文需要按一定长度对齐，叫做块大小(BlockSize)，比如16字节，那么对于一段任意的数据，加密前需要对最后一个块填充到16 字节，解密后需要删除掉填充的数据。\n\n* ZeroPadding，数据长度不对齐时使用0填充，否则不填充。\n* PKCS7Padding，假设数据长度需要填充n(n>0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。\n*  PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。\n\n由于使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后可以准确删除填充的数据，而使用ZeroPadding填充时，没办法区分真实数据与填充数据，所以只适合以\\0结尾的字符串加解密。\n","source":"_posts/Java/Java基础/加密算法.md","raw":"---\ntitle: 加密算法\ntype: [Java]\ndescription: 加密算法\ncover:  /cover/img59.jpg\ntoc: true\ncategories: Java\n---\n\n## AES加密\n\n AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，\n\n 在线测试工具  https://oktools.net/aes \n  \n### AES在Java中的使用\n\n JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。\n Java中的加解密由Cipher组件提供。\n \n**注：**\n* Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding \n* Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)\n\n#### 生成秘钥\n\n```\n     KeyGenerator generator=KeyGenerator.getInstance(\"AES/ECB/PKCS5PADDING\");\n     //用于指定秘钥长度\n     generator.init(Secret_Key_Size);\n\n     SecretKey secretKey=generator.generateKey();\n\n```\n\n\n#### PKCS7Padding/PKCS5Padding/ZeroPadding 三种填充模式的区别\n\n某些加密算法要求明文需要按一定长度对齐，叫做块大小(BlockSize)，比如16字节，那么对于一段任意的数据，加密前需要对最后一个块填充到16 字节，解密后需要删除掉填充的数据。\n\n* ZeroPadding，数据长度不对齐时使用0填充，否则不填充。\n* PKCS7Padding，假设数据长度需要填充n(n>0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。\n*  PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。\n\n由于使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后可以准确删除填充的数据，而使用ZeroPadding填充时，没办法区分真实数据与填充数据，所以只适合以\\0结尾的字符串加解密。\n","slug":"Java/Java基础/加密算法","published":1,"date":"2020-05-08T09:44:43.219Z","updated":"2021-01-05T12:15:30.272Z","_id":"ckjju0m1s005u20ua62ye17n3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h2><p> AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，</p>\n<p> 在线测试工具  <a href=\"https://oktools.net/aes\">https://oktools.net/aes</a> </p>\n<h3 id=\"AES在Java中的使用\"><a href=\"#AES在Java中的使用\" class=\"headerlink\" title=\"AES在Java中的使用\"></a>AES在Java中的使用</h3><p> JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。<br> Java中的加解密由Cipher组件提供。</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding </li>\n<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)</li>\n</ul>\n<h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeyGenerator generator&#x3D;KeyGenerator.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5PADDING&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;用于指定秘钥长度</span><br><span class=\"line\">generator.init(Secret_Key_Size);</span><br><span class=\"line\"></span><br><span class=\"line\">SecretKey secretKey&#x3D;generator.generateKey();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PKCS7Padding-PKCS5Padding-ZeroPadding-三种填充模式的区别\"><a href=\"#PKCS7Padding-PKCS5Padding-ZeroPadding-三种填充模式的区别\" class=\"headerlink\" title=\"PKCS7Padding/PKCS5Padding/ZeroPadding 三种填充模式的区别\"></a>PKCS7Padding/PKCS5Padding/ZeroPadding 三种填充模式的区别</h4><p>某些加密算法要求明文需要按一定长度对齐，叫做块大小(BlockSize)，比如16字节，那么对于一段任意的数据，加密前需要对最后一个块填充到16 字节，解密后需要删除掉填充的数据。</p>\n<ul>\n<li>ZeroPadding，数据长度不对齐时使用0填充，否则不填充。</li>\n<li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。</li>\n<li> PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li>\n</ul>\n<p>由于使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后可以准确删除填充的数据，而使用ZeroPadding填充时，没办法区分真实数据与填充数据，所以只适合以\\0结尾的字符串加解密。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"AES加密\"><a href=\"#AES加密\" class=\"headerlink\" title=\"AES加密\"></a>AES加密</h2><p> AES加密算法，全称：Advanced Encryption Standard，用来替代原有的DES加密算法，可以使用128位、192位和256位秘钥，</p>\n<p> 在线测试工具  <a href=\"https://oktools.net/aes\">https://oktools.net/aes</a> </p>\n<h3 id=\"AES在Java中的使用\"><a href=\"#AES在Java中的使用\" class=\"headerlink\" title=\"AES在Java中的使用\"></a>AES在Java中的使用</h3><p> JCE的API都在javax.crypto包下，核心功能包括：加解密、密钥生成（对称）、MAC生成、密钥协商。<br> Java中的加解密由Cipher组件提供。</p>\n<p><strong>注：</strong></p>\n<ul>\n<li>Cipher在使用时需以参数方式指定transformation，格式为algorithm/mode/padding </li>\n<li>Cipher有4种操作模式: ENCRYPT_MODE(加密), DECRYPT_MODE(解密), WRAP_MODE(导出Key), UNWRAP_MODE(导入Key)</li>\n</ul>\n<h4 id=\"生成秘钥\"><a href=\"#生成秘钥\" class=\"headerlink\" title=\"生成秘钥\"></a>生成秘钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KeyGenerator generator&#x3D;KeyGenerator.getInstance(&quot;AES&#x2F;ECB&#x2F;PKCS5PADDING&quot;);</span><br><span class=\"line\">&#x2F;&#x2F;用于指定秘钥长度</span><br><span class=\"line\">generator.init(Secret_Key_Size);</span><br><span class=\"line\"></span><br><span class=\"line\">SecretKey secretKey&#x3D;generator.generateKey();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PKCS7Padding-PKCS5Padding-ZeroPadding-三种填充模式的区别\"><a href=\"#PKCS7Padding-PKCS5Padding-ZeroPadding-三种填充模式的区别\" class=\"headerlink\" title=\"PKCS7Padding/PKCS5Padding/ZeroPadding 三种填充模式的区别\"></a>PKCS7Padding/PKCS5Padding/ZeroPadding 三种填充模式的区别</h4><p>某些加密算法要求明文需要按一定长度对齐，叫做块大小(BlockSize)，比如16字节，那么对于一段任意的数据，加密前需要对最后一个块填充到16 字节，解密后需要删除掉填充的数据。</p>\n<ul>\n<li>ZeroPadding，数据长度不对齐时使用0填充，否则不填充。</li>\n<li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。</li>\n<li> PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li>\n</ul>\n<p>由于使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后可以准确删除填充的数据，而使用ZeroPadding填充时，没办法区分真实数据与填充数据，所以只适合以\\0结尾的字符串加解密。</p>\n"},{"title":"Dagger2 介绍与使用","cover":"/cover/img33.jpg","toc":true,"description":"Dagger2 介绍与使用","type":["Android"],"date":"2019-10-09T16:00:00.000Z","_content":"\n# 在Android中使用Dagger2\n\n## Dagger2介绍\n\n### 为什么我们需要注解依赖注入？\n\nDependency Injection\\(注解依赖\\)是在IOC\\(Inversion of cnontrol\\)的基础上实现的，为了将类的实例的实现与类进行分离。\n\n如果一个类使用`new`操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。\n<!--more-->\n### 注入模式\n\n* 构造函数注入：以传递参数的方式\n* 字段注入：以变量的方式\n* 方法注入：\n\n“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”\n\n* Dependency provider:使用注解`@Module`表示的类，用于提供可以进行注入的对象。类中的方法使用注解`@Providers`表示该方法的返回对象可以被依赖注入。`@Moudle`可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用`@Inject`即可\n* Dependency consumer：注解`@Inject`用于定义一个依赖。\n* Connection consumer and producer：使用注解`@Component`的接口定义module对象中`provider`与依赖对象之间的连接，接口的实现类由Dagger自动生成。\n\n## Dagger2的局限性\n\n* Dagger2不能自动注入域\n* Dagger2不能注入private类型\n* Dagger2\n\n## 工程结构图\n\n假装有图\n\n","source":"_posts/Android/框架/Dagger2.md","raw":"---\ntitle: Dagger2 介绍与使用\ncover: /cover/img33.jpg\ntoc: true\ndescription: Dagger2 介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2019/10/10\n---\n\n# 在Android中使用Dagger2\n\n## Dagger2介绍\n\n### 为什么我们需要注解依赖注入？\n\nDependency Injection\\(注解依赖\\)是在IOC\\(Inversion of cnontrol\\)的基础上实现的，为了将类的实例的实现与类进行分离。\n\n如果一个类使用`new`操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。\n<!--more-->\n### 注入模式\n\n* 构造函数注入：以传递参数的方式\n* 字段注入：以变量的方式\n* 方法注入：\n\n“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”\n\n* Dependency provider:使用注解`@Module`表示的类，用于提供可以进行注入的对象。类中的方法使用注解`@Providers`表示该方法的返回对象可以被依赖注入。`@Moudle`可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用`@Inject`即可\n* Dependency consumer：注解`@Inject`用于定义一个依赖。\n* Connection consumer and producer：使用注解`@Component`的接口定义module对象中`provider`与依赖对象之间的连接，接口的实现类由Dagger自动生成。\n\n## Dagger2的局限性\n\n* Dagger2不能自动注入域\n* Dagger2不能注入private类型\n* Dagger2\n\n## 工程结构图\n\n假装有图\n\n","slug":"Android/框架/Dagger2","published":1,"updated":"2021-01-05T12:14:19.254Z","_id":"ckjju0m1t005x20uaf50bgahi","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"在Android中使用Dagger2\"><a href=\"#在Android中使用Dagger2\" class=\"headerlink\" title=\"在Android中使用Dagger2\"></a>在Android中使用Dagger2</h1><h2 id=\"Dagger2介绍\"><a href=\"#Dagger2介绍\" class=\"headerlink\" title=\"Dagger2介绍\"></a>Dagger2介绍</h2><h3 id=\"为什么我们需要注解依赖注入？\"><a href=\"#为什么我们需要注解依赖注入？\" class=\"headerlink\" title=\"为什么我们需要注解依赖注入？\"></a>为什么我们需要注解依赖注入？</h3><p>Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。</p>\n<p>如果一个类使用<code>new</code>操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。</p>\n<a id=\"more\"></a>\n<h3 id=\"注入模式\"><a href=\"#注入模式\" class=\"headerlink\" title=\"注入模式\"></a>注入模式</h3><ul>\n<li>构造函数注入：以传递参数的方式</li>\n<li>字段注入：以变量的方式</li>\n<li>方法注入：</li>\n</ul>\n<p>“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”</p>\n<ul>\n<li>Dependency provider:使用注解<code>@Module</code>表示的类，用于提供可以进行注入的对象。类中的方法使用注解<code>@Providers</code>表示该方法的返回对象可以被依赖注入。<code>@Moudle</code>可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用<code>@Inject</code>即可</li>\n<li>Dependency consumer：注解<code>@Inject</code>用于定义一个依赖。</li>\n<li>Connection consumer and producer：使用注解<code>@Component</code>的接口定义module对象中<code>provider</code>与依赖对象之间的连接，接口的实现类由Dagger自动生成。</li>\n</ul>\n<h2 id=\"Dagger2的局限性\"><a href=\"#Dagger2的局限性\" class=\"headerlink\" title=\"Dagger2的局限性\"></a>Dagger2的局限性</h2><ul>\n<li>Dagger2不能自动注入域</li>\n<li>Dagger2不能注入private类型</li>\n<li>Dagger2</li>\n</ul>\n<h2 id=\"工程结构图\"><a href=\"#工程结构图\" class=\"headerlink\" title=\"工程结构图\"></a>工程结构图</h2><p>假装有图</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"在Android中使用Dagger2\"><a href=\"#在Android中使用Dagger2\" class=\"headerlink\" title=\"在Android中使用Dagger2\"></a>在Android中使用Dagger2</h1><h2 id=\"Dagger2介绍\"><a href=\"#Dagger2介绍\" class=\"headerlink\" title=\"Dagger2介绍\"></a>Dagger2介绍</h2><h3 id=\"为什么我们需要注解依赖注入？\"><a href=\"#为什么我们需要注解依赖注入？\" class=\"headerlink\" title=\"为什么我们需要注解依赖注入？\"></a>为什么我们需要注解依赖注入？</h3><p>Dependency Injection(注解依赖)是在IOC(Inversion of cnontrol)的基础上实现的，为了将类的实例的实现与类进行分离。</p>\n<p>如果一个类使用<code>new</code>操作符来实例化另外一个类，那么这两个类直接就产生依赖关系，被称为Hard dependency。</p>","more":"<h3 id=\"注入模式\"><a href=\"#注入模式\" class=\"headerlink\" title=\"注入模式\"></a>注入模式</h3><ul>\n<li>构造函数注入：以传递参数的方式</li>\n<li>字段注入：以变量的方式</li>\n<li>方法注入：</li>\n</ul>\n<p>“依赖调用者”通过一个“连接器”从“依赖提供者”调用“依赖对象”</p>\n<ul>\n<li>Dependency provider:使用注解<code>@Module</code>表示的类，用于提供可以进行注入的对象。类中的方法使用注解<code>@Providers</code>表示该方法的返回对象可以被依赖注入。<code>@Moudle</code>可将引用的类（非自己编码的类）的注入，如果是自己编码的类仅用<code>@Inject</code>即可</li>\n<li>Dependency consumer：注解<code>@Inject</code>用于定义一个依赖。</li>\n<li>Connection consumer and producer：使用注解<code>@Component</code>的接口定义module对象中<code>provider</code>与依赖对象之间的连接，接口的实现类由Dagger自动生成。</li>\n</ul>\n<h2 id=\"Dagger2的局限性\"><a href=\"#Dagger2的局限性\" class=\"headerlink\" title=\"Dagger2的局限性\"></a>Dagger2的局限性</h2><ul>\n<li>Dagger2不能自动注入域</li>\n<li>Dagger2不能注入private类型</li>\n<li>Dagger2</li>\n</ul>\n<h2 id=\"工程结构图\"><a href=\"#工程结构图\" class=\"headerlink\" title=\"工程结构图\"></a>工程结构图</h2><p>假装有图</p>"},{"title":"Fasetjson 介绍与使用","cover":"/cover/img34.jpg","toc":true,"description":"Fasetjson 介绍与使用","type":["Android"],"date":"2018-05-05T16:00:00.000Z","_content":"\n\n#### JSONString与HashMap之间的转换\n\n* HashMap转换为JsonString\n<!--more-->\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    String JSONString=JSON.toJSONString(hashMap);\n```\n\n\n* JsonString转换为HashMap\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap= JSON.parseObject(JSONString, Map.class);\n    \n    //错误方式\n    hashMap= (Map<String, String>) JSON.parse(JSONString);\n```\n\n**注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**\n\n\n#### 知识点\n\n* 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败\n","source":"_posts/Android/框架/fastjson的使用.md","raw":"---\ntitle: Fasetjson 介绍与使用\ncover: /cover/img34.jpg\ntoc: true\ndescription: Fasetjson 介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2018/05/06\n---\n\n\n#### JSONString与HashMap之间的转换\n\n* HashMap转换为JsonString\n<!--more-->\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    String JSONString=JSON.toJSONString(hashMap);\n```\n\n\n* JsonString转换为HashMap\n```java\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap= JSON.parseObject(JSONString, Map.class);\n    \n    //错误方式\n    hashMap= (Map<String, String>) JSON.parse(JSONString);\n```\n\n**注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**\n\n\n#### 知识点\n\n* 在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败\n","slug":"Android/框架/fastjson的使用","published":1,"updated":"2021-01-05T12:14:20.223Z","_id":"ckjju0m1t006020ua0h1mgnqh","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"JSONString与HashMap之间的转换\"><a href=\"#JSONString与HashMap之间的转换\" class=\"headerlink\" title=\"JSONString与HashMap之间的转换\"></a>JSONString与HashMap之间的转换</h4><ul>\n<li><p>HashMap转换为JsonString</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String JSONString=JSON.toJSONString(hashMap);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JsonString转换为HashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap= JSON.parseObject(JSONString, Map.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误方式</span></span><br><span class=\"line\">hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString);</span><br></pre></td></tr></table></figure></li>\n<li><p>*注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**</p>\n</li>\n</ul>\n<h4 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h4><ul>\n<li>在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"JSONString与HashMap之间的转换\"><a href=\"#JSONString与HashMap之间的转换\" class=\"headerlink\" title=\"JSONString与HashMap之间的转换\"></a>JSONString与HashMap之间的转换</h4><ul>\n<li><p>HashMap转换为JsonString</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">String JSONString=JSON.toJSONString(hashMap);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JsonString转换为HashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">hashMap= JSON.parseObject(JSONString, Map.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//错误方式</span></span><br><span class=\"line\">hashMap= (Map&lt;String, String&gt;) JSON.parse(JSONString);</span><br></pre></td></tr></table></figure></li>\n<li><p>*注：使用错误方式将JsonString转换为HashMap，会导致HashMap中只有一组数据**</p>\n</li>\n</ul>\n<h4 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h4><ul>\n<li>在使用fastjson进行转换的过程中，需要保证Object需要有默认的构造函数，如果Object中有其他Object变量，Object变量也需要有默认构造函数，否则会造成转化失败</li>\n</ul>"},{"title":"Java Queue","cover":"/cover/img98.jpg","toc":true,"description":"Java Queue","type":["Java"],"date":"2019-04-02T16:00:00.000Z","_content":"\n## 队列（Queue）\n\n## 阻塞队列（Blocking Queue）\n当插入数据时，如果队列已满，则插入操作会被阻塞；在取出数据是，如果队列为空，则取出操作会被阻塞；\n\n阻塞队列支持生产者和消费者模式，在阻塞队列中生产者和消费者，不能同时对队列进行操作；其会将要操作的对象，放入\"to do\"列表，在某时间后进行处理，而不是对数据立即进行处理。在阻塞队列的生产者和消费者的模式下，当生产者可操作时，将数据插入队列中；当消费者可操作时，其从队列中取出数据。可以具有多个生产者和多个消费者；\n\n\n### 子类\n\n* LinkedBlockingQueue\n   与LinkedList相似\n   `put()` 在队列满的时候会阻塞，直到有成员被消费;\n   `take()`在队列空的时候会被阻塞，直到有成员被加入队列；\n\n* ArrayBlockingQueue\n   与ArrayList相似 \n* PriorityBlockingQueue \n    是一个优先级队列，可以对实现 Comparable 接口的元素进行优先级排序\n* SynchronousQueue\n    不是一个真正的队列，其没有用于保存元素的空间。它持有一个队列线程列表，等待入队或者出队，节省从生产者将数据移交给消费者的时间延时。因为其没有存储空间，在有足够多的消费者，且总有一个在等待处理信息的消费者的时候进行使用。\n\n\n## 并发队列（ConcurrentLinkedQueue）  \n\n基于链表实现的队列，队列中每一个Node同时拥有下一个Node的的引用\n","source":"_posts/Java/Java多线程/Java Queue.md","raw":"---\ntitle: Java Queue\ncover: /cover/img98.jpg\ntoc: true\ndescription: Java Queue\ntype: [Java]\ncategories:  Java \ndate: 2019/04/03\n---\n\n## 队列（Queue）\n\n## 阻塞队列（Blocking Queue）\n当插入数据时，如果队列已满，则插入操作会被阻塞；在取出数据是，如果队列为空，则取出操作会被阻塞；\n\n阻塞队列支持生产者和消费者模式，在阻塞队列中生产者和消费者，不能同时对队列进行操作；其会将要操作的对象，放入\"to do\"列表，在某时间后进行处理，而不是对数据立即进行处理。在阻塞队列的生产者和消费者的模式下，当生产者可操作时，将数据插入队列中；当消费者可操作时，其从队列中取出数据。可以具有多个生产者和多个消费者；\n\n\n### 子类\n\n* LinkedBlockingQueue\n   与LinkedList相似\n   `put()` 在队列满的时候会阻塞，直到有成员被消费;\n   `take()`在队列空的时候会被阻塞，直到有成员被加入队列；\n\n* ArrayBlockingQueue\n   与ArrayList相似 \n* PriorityBlockingQueue \n    是一个优先级队列，可以对实现 Comparable 接口的元素进行优先级排序\n* SynchronousQueue\n    不是一个真正的队列，其没有用于保存元素的空间。它持有一个队列线程列表，等待入队或者出队，节省从生产者将数据移交给消费者的时间延时。因为其没有存储空间，在有足够多的消费者，且总有一个在等待处理信息的消费者的时候进行使用。\n\n\n## 并发队列（ConcurrentLinkedQueue）  \n\n基于链表实现的队列，队列中每一个Node同时拥有下一个Node的的引用\n","slug":"Java/Java多线程/Java Queue","published":1,"updated":"2021-01-05T12:15:30.589Z","_id":"ckjju0m1u006320uab0pfh9et","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"队列（Queue）\"><a href=\"#队列（Queue）\" class=\"headerlink\" title=\"队列（Queue）\"></a>队列（Queue）</h2><h2 id=\"阻塞队列（Blocking-Queue）\"><a href=\"#阻塞队列（Blocking-Queue）\" class=\"headerlink\" title=\"阻塞队列（Blocking Queue）\"></a>阻塞队列（Blocking Queue）</h2><p>当插入数据时，如果队列已满，则插入操作会被阻塞；在取出数据是，如果队列为空，则取出操作会被阻塞；</p>\n<p>阻塞队列支持生产者和消费者模式，在阻塞队列中生产者和消费者，不能同时对队列进行操作；其会将要操作的对象，放入”to do”列表，在某时间后进行处理，而不是对数据立即进行处理。在阻塞队列的生产者和消费者的模式下，当生产者可操作时，将数据插入队列中；当消费者可操作时，其从队列中取出数据。可以具有多个生产者和多个消费者；</p>\n<h3 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h3><ul>\n<li><p>LinkedBlockingQueue<br> 与LinkedList相似<br> <code>put()</code> 在队列满的时候会阻塞，直到有成员被消费;<br> <code>take()</code>在队列空的时候会被阻塞，直到有成员被加入队列；</p>\n</li>\n<li><p>ArrayBlockingQueue<br> 与ArrayList相似 </p>\n</li>\n<li><p>PriorityBlockingQueue<br>  是一个优先级队列，可以对实现 Comparable 接口的元素进行优先级排序</p>\n</li>\n<li><p>SynchronousQueue<br>  不是一个真正的队列，其没有用于保存元素的空间。它持有一个队列线程列表，等待入队或者出队，节省从生产者将数据移交给消费者的时间延时。因为其没有存储空间，在有足够多的消费者，且总有一个在等待处理信息的消费者的时候进行使用。</p>\n</li>\n</ul>\n<h2 id=\"并发队列（ConcurrentLinkedQueue）\"><a href=\"#并发队列（ConcurrentLinkedQueue）\" class=\"headerlink\" title=\"并发队列（ConcurrentLinkedQueue）\"></a>并发队列（ConcurrentLinkedQueue）</h2><p>基于链表实现的队列，队列中每一个Node同时拥有下一个Node的的引用</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"队列（Queue）\"><a href=\"#队列（Queue）\" class=\"headerlink\" title=\"队列（Queue）\"></a>队列（Queue）</h2><h2 id=\"阻塞队列（Blocking-Queue）\"><a href=\"#阻塞队列（Blocking-Queue）\" class=\"headerlink\" title=\"阻塞队列（Blocking Queue）\"></a>阻塞队列（Blocking Queue）</h2><p>当插入数据时，如果队列已满，则插入操作会被阻塞；在取出数据是，如果队列为空，则取出操作会被阻塞；</p>\n<p>阻塞队列支持生产者和消费者模式，在阻塞队列中生产者和消费者，不能同时对队列进行操作；其会将要操作的对象，放入”to do”列表，在某时间后进行处理，而不是对数据立即进行处理。在阻塞队列的生产者和消费者的模式下，当生产者可操作时，将数据插入队列中；当消费者可操作时，其从队列中取出数据。可以具有多个生产者和多个消费者；</p>\n<h3 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h3><ul>\n<li><p>LinkedBlockingQueue<br> 与LinkedList相似<br> <code>put()</code> 在队列满的时候会阻塞，直到有成员被消费;<br> <code>take()</code>在队列空的时候会被阻塞，直到有成员被加入队列；</p>\n</li>\n<li><p>ArrayBlockingQueue<br> 与ArrayList相似 </p>\n</li>\n<li><p>PriorityBlockingQueue<br>  是一个优先级队列，可以对实现 Comparable 接口的元素进行优先级排序</p>\n</li>\n<li><p>SynchronousQueue<br>  不是一个真正的队列，其没有用于保存元素的空间。它持有一个队列线程列表，等待入队或者出队，节省从生产者将数据移交给消费者的时间延时。因为其没有存储空间，在有足够多的消费者，且总有一个在等待处理信息的消费者的时候进行使用。</p>\n</li>\n</ul>\n<h2 id=\"并发队列（ConcurrentLinkedQueue）\"><a href=\"#并发队列（ConcurrentLinkedQueue）\" class=\"headerlink\" title=\"并发队列（ConcurrentLinkedQueue）\"></a>并发队列（ConcurrentLinkedQueue）</h2><p>基于链表实现的队列，队列中每一个Node同时拥有下一个Node的的引用</p>\n"},{"title":"Java单例模式","cover":"/cover/img60.jpg","toc":true,"description":"Java单例模式","type":["Java"],"date":"2019-03-24T16:00:00.000Z","_content":"\n### 不同单例模式在多线程下的特点\n\n* 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；\n<!--more-->\n```java\n\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton (){}\n\n    public static Singleton getInstance() {\n     if (instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n    }\n}\n```\n\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。\n\n```java\n\npublic static synchronized Singleton getInstance() {\n    if (instance == null) {\n        instance = new Singleton();\n    }\n    return instance;\n}\n\n```\n* 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。\n\n```java\npublic static Singleton getSingleton() {\n    if (instance == null) {                         //Single Checked\n        synchronized (Singleton.class) {\n            if (instance == null) {                 //Double Checked\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance ;\n}\n\n```\n**在使用`synchronized`关键字之后，每次只有一个线程可以进入到该方法中，但是使用`synchronized`关键字会造成开销过大**\n\n于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。\n\n1、给 instance 分配内存\n2、调用 Singleton 的构造函数来初始化成员变量\n3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。\n\n```java\n\npublic class Singleton {\n    private volatile static Singleton instance; //声明成 volatile\n    private Singleton (){}\n\n    public static Singleton getSingleton() {\n        if (instance == null) {                         \n            synchronized (Singleton.class) {\n                if (instance == null) {       \n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n   \n}\n\n```\n`volatile`具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）\n\n\n* 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\n\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n* 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n\n```\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java多线程/Java多线程与单例模式.md","raw":"---\ntitle: Java单例模式\ncover:  /cover/img60.jpg\ntoc: true\ndescription: Java单例模式\ncategories: Java\ntype: [Java]\ndate: 2019/03/25\n---\n\n### 不同单例模式在多线程下的特点\n\n* 懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；\n<!--more-->\n```java\n\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton (){}\n\n    public static Singleton getInstance() {\n     if (instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n    }\n}\n```\n\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。\n\n```java\n\npublic static synchronized Singleton getInstance() {\n    if (instance == null) {\n        instance = new Singleton();\n    }\n    return instance;\n}\n\n```\n* 双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。\n\n```java\npublic static Singleton getSingleton() {\n    if (instance == null) {                         //Single Checked\n        synchronized (Singleton.class) {\n            if (instance == null) {                 //Double Checked\n                instance = new Singleton();\n            }\n        }\n    }\n    return instance ;\n}\n\n```\n**在使用`synchronized`关键字之后，每次只有一个线程可以进入到该方法中，但是使用`synchronized`关键字会造成开销过大**\n\n于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。\n\n1、给 instance 分配内存\n2、调用 Singleton 的构造函数来初始化成员变量\n3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。\n\n```java\n\npublic class Singleton {\n    private volatile static Singleton instance; //声明成 volatile\n    private Singleton (){}\n\n    public static Singleton getSingleton() {\n        if (instance == null) {                         \n            synchronized (Singleton.class) {\n                if (instance == null) {       \n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n   \n}\n\n```\n`volatile`具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）\n\n\n* 饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\n\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n* 静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n\n```\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/Java多线程/Java多线程与单例模式","published":1,"updated":"2021-01-05T12:15:30.883Z","_id":"ckjju0m1u006620uafbkz2c2p","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"不同单例模式在多线程下的特点\"><a href=\"#不同单例模式在多线程下的特点\" class=\"headerlink\" title=\"不同单例模式在多线程下的特点\"></a>不同单例模式在多线程下的特点</h3><ul>\n<li>懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         <span class=\"comment\">//Single Checked</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                 <span class=\"comment\">//Double Checked</span></span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>synchronized</code>关键字之后，每次只有一个线程可以进入到该方法中，但是使用<code>synchronized</code>关键字会造成开销过大</strong></p>\n<p>于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。</p>\n<p>1、给 instance 分配内存<br>2、调用 Singleton 的构造函数来初始化成员变量<br>3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance; <span class=\"comment\">//声明成 volatile</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;       </span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）</p>\n<ul>\n<li>饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<ul>\n<li>静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"不同单例模式在多线程下的特点\"><a href=\"#不同单例模式在多线程下的特点\" class=\"headerlink\" title=\"不同单例模式在多线程下的特点\"></a>不同单例模式在多线程下的特点</h3><ul>\n<li>懒汉式：该加载模式是非线程安全的，当有多个线程并行调用getInstance()时，会创建多个实例；","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n懒汉式线程安全代码，将整个getInstance()方法设置为同步(synchronized)；但在任何一个时候只能有一个线程调用getInstance()方式，而同步操作只需要在第一次调用时需要。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法；因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         <span class=\"comment\">//Single Checked</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                 <span class=\"comment\">//Double Checked</span></span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>synchronized</code>关键字之后，每次只有一个线程可以进入到该方法中，但是使用<code>synchronized</code>关键字会造成开销过大</strong></p>\n<p>于instance = new Singleton()这条语句，这并非是一个原子操作，在 JVM 中这句话大概做了下面 3 件事情。</p>\n<p>1、给 instance 分配内存<br>2、调用 Singleton 的构造函数来初始化成员变量<br>3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</p>\n<p>但是在 JVM 的即时编译器中存在指令重排序的优化。上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错；我们只需要将 instance 变量声明成 volatile 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance; <span class=\"comment\">//声明成 volatile</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;                         </span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;       </span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>具有可见性；还有另一个特性：禁止指令重排优化。在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）</p>\n<ul>\n<li>饿汉式( static final field)单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<ul>\n<li>静态内部类 static nested class,这种方法也是《Effective Java》上所推荐的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>"},{"title":"Java多线程之间的协作","cover":"/cover/img61.jpg","toc":true,"description":"Java多线程之间的协作","type":["Java"],"date":"2019-02-14T16:00:00.000Z","_content":"\n## Java多线程协作\n\nJava多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在`Object`对象中有`wait()`和`notifyAll()`方法，在Java  SE 5多任务库中添加`Condition`类，其中有`await()`和`singal()`方法。\n<!--more-->\n\n### join\n\n当一个在线程**m**中调用`t.join()`，**m**线程会被挂起，直至**t**执行结束(`t.isAlive`为false)；如果**t**线程调用`t.interrupt()`(在**m**线程之外)，则线程**m**中会继续执行任务。\n\n\n","source":"_posts/Java/Java多线程/Java多线程之间的协作.md","raw":"---\ntitle: Java多线程之间的协作\ncover:  /cover/img61.jpg\ntoc: true\ndescription: Java多线程之间的协作\ncategories: Java\ntype: [Java]\ndate: 2019/02/15\n---\n\n## Java多线程协作\n\nJava多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在`Object`对象中有`wait()`和`notifyAll()`方法，在Java  SE 5多任务库中添加`Condition`类，其中有`await()`和`singal()`方法。\n<!--more-->\n\n### join\n\n当一个在线程**m**中调用`t.join()`，**m**线程会被挂起，直至**t**执行结束(`t.isAlive`为false)；如果**t**线程调用`t.interrupt()`(在**m**线程之外)，则线程**m**中会继续执行任务。\n\n\n","slug":"Java/Java多线程/Java多线程之间的协作","published":1,"updated":"2021-01-05T12:15:31.188Z","_id":"ckjju0m1v006920ua3doobtbf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Java多线程协作\"><a href=\"#Java多线程协作\" class=\"headerlink\" title=\"Java多线程协作\"></a>Java多线程协作</h2><p>Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在<code>Object</code>对象中有<code>wait()</code>和<code>notifyAll()</code>方法，在Java  SE 5多任务库中添加<code>Condition</code>类，其中有<code>await()</code>和<code>singal()</code>方法。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>当一个在线程<strong>m</strong>中调用<code>t.join()</code>，<strong>m</strong>线程会被挂起，直至<strong>t</strong>执行结束(<code>t.isAlive</code>为false)；如果<strong>t</strong>线程调用<code>t.interrupt()</code>(在<strong>m</strong>线程之外)，则线程<strong>m</strong>中会继续执行任务。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Java多线程协作\"><a href=\"#Java多线程协作\" class=\"headerlink\" title=\"Java多线程协作\"></a>Java多线程协作</h2><p>Java多线程之间的协作需要解决的一个问题是任务之间的握手操作，要完成握手操作，需要互斥量，互斥量可以保证每次只有一个任务可以获取该信号，在某一互斥量的状态下将任务挂起，或通过某一操作恢复任务操作。在<code>Object</code>对象中有<code>wait()</code>和<code>notifyAll()</code>方法，在Java  SE 5多任务库中添加<code>Condition</code>类，其中有<code>await()</code>和<code>singal()</code>方法。</p>","more":"<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p>当一个在线程<strong>m</strong>中调用<code>t.join()</code>，<strong>m</strong>线程会被挂起，直至<strong>t</strong>执行结束(<code>t.isAlive</code>为false)；如果<strong>t</strong>线程调用<code>t.interrupt()</code>(在<strong>m</strong>线程之外)，则线程<strong>m</strong>中会继续执行任务。</p>"},{"title":"Java多线程基础","cover":"/cover/img62.jpg","toc":true,"description":"Java多线程基础","type":["Android"],"date":"2018-11-24T16:00:00.000Z","_content":"\n### Runnable接口\n\n仅调用Runnable的`run()`方法不能产生一个新的线程，新线程的执行必须通过`Thread.start()`方法来执行。\n\n通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。\n<!--more-->\n实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。\n\nThread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。\n\n### Thread类\n\nThread类的构造函数需要Runnable实例，调用Thread类的`start()`方法，可以对线程进行必要额初始化，然后执行Runnable实例的`run()`方法。\n\n静态方法`Thread.yield()`用于通知CPU从一个线程切换至另外一个线程；\n\n**注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。**\n\n\n### 多线程框架Executor的使用\nExecutors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。\n\n ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。\n \n Executors中的`shutdown()`方法用于停止向Executor中提交新的任务，在`shutdown()`方法调用之前提交的同步线程任务则会继续执行。\n \n ***注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理***\n \n#### Executor、Executors、ExecutorService区别\n\n* Executor是一个接口，用于并发提交的任务，只有`execute()`一个方法，没有返回值，不能对任务进行任何操作。\n\n```java\n    public interface Executor {\n        void execute(Runnable var1);\n    }\n```\n\n* Executors类提供不同的工厂方法来创建不同类型的线程池，包括：`newSingleThreadExecutor()`、`newFixedThreadPool(int numOfThreads)`、`newCachedThreadPool()`\n\n```java\n\n    public class Executors {\n            //...\n            public static ExecutorService newFixedThreadPool(int var0) {\n            return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());\n        }\n        \n        //...\n    }\n\n```\n\n\n* ExecutorService 是继承自`Exxecutor`的接口，其中有异步执行和关闭线程池的方法。可以通过`submit()`方法来提交任务，同时可以对任务进行取消等操作。\n\n```java\n    public interface ExecutorService extends Executor {\n        //...\n        void shutdown();\n\n        List<Runnable> shutdownNow();\n\n        boolean isShutdown();\n\n        boolean isTerminated();\n        //...          \n          \n    }\n```\n\n \n ### 不同线程池的使用\n\nCachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。\n\n ```java\n     ExecutorService exec = Executors.newCachedThreadPool();\n ```\n \n FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。\n \n ```java\n     ExecutorService exec = Executors.newFixedThreadPool(5); \n ```\n \n SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。\n \n ```java\n     Executors.newSingleThreadExecutor(); \n ```\n \n ### 任务的回调\n \n使用Callable和Future,一个产生结果，一个拿到结果\n \n每一个**Runnable**都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用**Callable**接口，而非**Runnable接口**。\n\nCallable接口带有`type`类型参数，该参数表示`call()`方法（非`run()`）方法执行完成后的返回值，必须通过调用` ExecutorService submit()`调用来执行。\n\n`submit()`方法返回一个一个Future对象，可以通过调用Future的`isDone()`方法来判断当前任务是否执行结束。调用Future的`get()`方法，如果当前任务没有结束，则会被阻塞，直至任务结束\n\n```java\n     class CallableResult implements Callable<String> {   \n        private int id;    \n        public TaskWithResult(int id) {     \n          this.id = id; \n         } \n           public String call() {    \n            return \"result\" + id;  \n           }\n        }\n        \n      public class CallableDemo {   \n        public static void main(String[] args) {   \n        ExecutorService exec = Executors.newCachedThreadPool();                    \n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();               \n         for(int i = 0; i < 10; i++)\n          results.add(exec.submit(new CallableResult(i)));  \n         for(Future<String> fs : results)     \n                try {               \n                   System.out.println(fs.get()); \n                } catch(InterruptedException e) {\n                    System.out.println(e);         \n                    return;      \n                } catch(ExecutionException e) {     \n                    System.out.println(e);      \n                } finally{        \n                     exec.shutdown(); \n                 } \n             } \n     }\n\n```\n\n### 任务的暂停\n\n通过调用`TimeUnit.MILLISECONDS.sleep(100);`来阻塞当前线程指定的时间。\n\n\n### 线程优先级\n \n JDK有十中不同的优先级。\n \n 线程优先级`Thread.MIN_PRIORIT`、`Thread.MAX_PRIORITY`，通过`setPriority()`方法进行设置，以及`getPriority()`方法进行获取。\n\n```\n     public void run() {Thread.currentThread().setPriority(priority);\n```\n\n\n### 守护线程Daemon threads \n\n守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在`thread.start();`之前调用`daemon.setDaemon(true)`;\n\n如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用`isDaemon()`方法进行查看是否为守护线程。\n\n\n\n### 数据共享\n\n#### synchronized关键字\n\n使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。\n```java\n\n    synchronized void f() { /* ... */ }\n```\n\n当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。\n\n在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。\n\n\n#### Lock对象的使用\n\n在调用`lock()`方法后，一定需要添加在`try-finally`的代码块，并在finally中调用`unlock()`方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在`try`代码块中实现，这样可以保证锁释放之前返回需要的值。***如果`lock.lock()`方法调用失败会出现什么情况***\n\n```\n     private Lock lock = new ReentrantLock();\n     int num=0;\n     \n     public int f(){\n        lock.lock();    \n        try {       \n             Thread.yield();   \n             return num++;    \n         }finally {      \n            lock.unlock();  \n        }   \n```\n当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。\n\n```java\n     boolean captured = false;    \n      try {      \n        captured = lock.tryLock(2, TimeUnit.SECONDS);   //限制请求次数\n        //captured = lock.tryLock();          //不限制请求次数\n       } catch(InterruptedException e) {      \n         throw new RuntimeException(e);     \n       } \n      try {       \n         System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured);    \n       } finally {     \n              if(captured)        \n              lock.unlock();    \n       }   \n\n```\n\n#### 原子性和波动性（Atomicity and Volality（易变的））\n原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是`synchronized`而非`volatile`。\n\n原子操作被应用于除`long`和`double`的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（`long`和`double`类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在`long`和`double`数据类型使用`volatile`关键字可以保证其操作的原子性。\n\n在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。\n\n当一个变量`volatile`关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。`volatile`关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。`volatile`关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。\n\n atomicity和volatility是两个不同的概念，原子性操作如果是非`volatile`类型的，那么其不会被立即刷到内存中；如果一个变量在一个` synchronized `的方法或者代码块中，那么变量也会被刷到内存中。\n\n\n#### Atomic classes （原子类）\n\n在Java SE 5中介绍了特殊的原子类：`Atomiclnteger`, `AtomicLong`, `AtomicReference`；对其操作时提供了原子类型的状态。\n\n#### 临界区\n\n在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。\n\n\n使用`synchronized`创建临界区\n```java\n     synchronized(syncObject) {  \n       // This code can be accessed \n      }\n    \n    \n    class PairManager2 extends PairManager { \n     public void increment() { \n         Pair temp;     \n         synchronized(this) {   \n             p.incrementX();    \n             p.incrementY();     \n             emp = getPair();   \n         }   \n         store(temp); \n        }\n    } \n   \n```\n\n使用功`Lock`锁创建临界区\n\n```java\n    class ExplicitPairManager2 extends PairManager {\n      private Lock lock = new ReentrantLock();  \n      public void increment() {    \n         Pair temp;     \n         lock.lock();    \n         try {     \n           p.incrementX();    \n           p.incrementY();     \n           temp = getPair();   \n           } finally {     \n             lock.unlock();   \n             }   \n           store(temp);  \n     } \n    }\n\n```\n\n\n\n\n\n\n\n\n \n ","source":"_posts/Java/Java多线程/Java多线程基础.md","raw":"---\ntitle: Java多线程基础\ncover:  /cover/img62.jpg\ntoc: true\ndescription: Java多线程基础\ncategories: Android\ntype: [Android]\ndate: 2018/11/25\n---\n\n### Runnable接口\n\n仅调用Runnable的`run()`方法不能产生一个新的线程，新线程的执行必须通过`Thread.start()`方法来执行。\n\n通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。\n<!--more-->\n实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。\n\nThread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。\n\n### Thread类\n\nThread类的构造函数需要Runnable实例，调用Thread类的`start()`方法，可以对线程进行必要额初始化，然后执行Runnable实例的`run()`方法。\n\n静态方法`Thread.yield()`用于通知CPU从一个线程切换至另外一个线程；\n\n**注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。**\n\n\n### 多线程框架Executor的使用\nExecutors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。\n\n ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。\n \n Executors中的`shutdown()`方法用于停止向Executor中提交新的任务，在`shutdown()`方法调用之前提交的同步线程任务则会继续执行。\n \n ***注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理***\n \n#### Executor、Executors、ExecutorService区别\n\n* Executor是一个接口，用于并发提交的任务，只有`execute()`一个方法，没有返回值，不能对任务进行任何操作。\n\n```java\n    public interface Executor {\n        void execute(Runnable var1);\n    }\n```\n\n* Executors类提供不同的工厂方法来创建不同类型的线程池，包括：`newSingleThreadExecutor()`、`newFixedThreadPool(int numOfThreads)`、`newCachedThreadPool()`\n\n```java\n\n    public class Executors {\n            //...\n            public static ExecutorService newFixedThreadPool(int var0) {\n            return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());\n        }\n        \n        //...\n    }\n\n```\n\n\n* ExecutorService 是继承自`Exxecutor`的接口，其中有异步执行和关闭线程池的方法。可以通过`submit()`方法来提交任务，同时可以对任务进行取消等操作。\n\n```java\n    public interface ExecutorService extends Executor {\n        //...\n        void shutdown();\n\n        List<Runnable> shutdownNow();\n\n        boolean isShutdown();\n\n        boolean isTerminated();\n        //...          \n          \n    }\n```\n\n \n ### 不同线程池的使用\n\nCachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。\n\n ```java\n     ExecutorService exec = Executors.newCachedThreadPool();\n ```\n \n FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。\n \n ```java\n     ExecutorService exec = Executors.newFixedThreadPool(5); \n ```\n \n SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。\n \n ```java\n     Executors.newSingleThreadExecutor(); \n ```\n \n ### 任务的回调\n \n使用Callable和Future,一个产生结果，一个拿到结果\n \n每一个**Runnable**都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用**Callable**接口，而非**Runnable接口**。\n\nCallable接口带有`type`类型参数，该参数表示`call()`方法（非`run()`）方法执行完成后的返回值，必须通过调用` ExecutorService submit()`调用来执行。\n\n`submit()`方法返回一个一个Future对象，可以通过调用Future的`isDone()`方法来判断当前任务是否执行结束。调用Future的`get()`方法，如果当前任务没有结束，则会被阻塞，直至任务结束\n\n```java\n     class CallableResult implements Callable<String> {   \n        private int id;    \n        public TaskWithResult(int id) {     \n          this.id = id; \n         } \n           public String call() {    \n            return \"result\" + id;  \n           }\n        }\n        \n      public class CallableDemo {   \n        public static void main(String[] args) {   \n        ExecutorService exec = Executors.newCachedThreadPool();                    \n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();               \n         for(int i = 0; i < 10; i++)\n          results.add(exec.submit(new CallableResult(i)));  \n         for(Future<String> fs : results)     \n                try {               \n                   System.out.println(fs.get()); \n                } catch(InterruptedException e) {\n                    System.out.println(e);         \n                    return;      \n                } catch(ExecutionException e) {     \n                    System.out.println(e);      \n                } finally{        \n                     exec.shutdown(); \n                 } \n             } \n     }\n\n```\n\n### 任务的暂停\n\n通过调用`TimeUnit.MILLISECONDS.sleep(100);`来阻塞当前线程指定的时间。\n\n\n### 线程优先级\n \n JDK有十中不同的优先级。\n \n 线程优先级`Thread.MIN_PRIORIT`、`Thread.MAX_PRIORITY`，通过`setPriority()`方法进行设置，以及`getPriority()`方法进行获取。\n\n```\n     public void run() {Thread.currentThread().setPriority(priority);\n```\n\n\n### 守护线程Daemon threads \n\n守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在`thread.start();`之前调用`daemon.setDaemon(true)`;\n\n如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用`isDaemon()`方法进行查看是否为守护线程。\n\n\n\n### 数据共享\n\n#### synchronized关键字\n\n使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。\n```java\n\n    synchronized void f() { /* ... */ }\n```\n\n当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。\n\n在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。\n\n\n#### Lock对象的使用\n\n在调用`lock()`方法后，一定需要添加在`try-finally`的代码块，并在finally中调用`unlock()`方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在`try`代码块中实现，这样可以保证锁释放之前返回需要的值。***如果`lock.lock()`方法调用失败会出现什么情况***\n\n```\n     private Lock lock = new ReentrantLock();\n     int num=0;\n     \n     public int f(){\n        lock.lock();    \n        try {       \n             Thread.yield();   \n             return num++;    \n         }finally {      \n            lock.unlock();  \n        }   \n```\n当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。\n\n```java\n     boolean captured = false;    \n      try {      \n        captured = lock.tryLock(2, TimeUnit.SECONDS);   //限制请求次数\n        //captured = lock.tryLock();          //不限制请求次数\n       } catch(InterruptedException e) {      \n         throw new RuntimeException(e);     \n       } \n      try {       \n         System.out.println(\"tryLock(2, TimeUnit.SECONDS): \" + captured);    \n       } finally {     \n              if(captured)        \n              lock.unlock();    \n       }   \n\n```\n\n#### 原子性和波动性（Atomicity and Volality（易变的））\n原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是`synchronized`而非`volatile`。\n\n原子操作被应用于除`long`和`double`的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（`long`和`double`类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在`long`和`double`数据类型使用`volatile`关键字可以保证其操作的原子性。\n\n在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。\n\n当一个变量`volatile`关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。`volatile`关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。`volatile`关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。\n\n atomicity和volatility是两个不同的概念，原子性操作如果是非`volatile`类型的，那么其不会被立即刷到内存中；如果一个变量在一个` synchronized `的方法或者代码块中，那么变量也会被刷到内存中。\n\n\n#### Atomic classes （原子类）\n\n在Java SE 5中介绍了特殊的原子类：`Atomiclnteger`, `AtomicLong`, `AtomicReference`；对其操作时提供了原子类型的状态。\n\n#### 临界区\n\n在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。\n\n\n使用`synchronized`创建临界区\n```java\n     synchronized(syncObject) {  \n       // This code can be accessed \n      }\n    \n    \n    class PairManager2 extends PairManager { \n     public void increment() { \n         Pair temp;     \n         synchronized(this) {   \n             p.incrementX();    \n             p.incrementY();     \n             emp = getPair();   \n         }   \n         store(temp); \n        }\n    } \n   \n```\n\n使用功`Lock`锁创建临界区\n\n```java\n    class ExplicitPairManager2 extends PairManager {\n      private Lock lock = new ReentrantLock();  \n      public void increment() {    \n         Pair temp;     \n         lock.lock();    \n         try {     \n           p.incrementX();    \n           p.incrementY();     \n           temp = getPair();   \n           } finally {     \n             lock.unlock();   \n             }   \n           store(temp);  \n     } \n    }\n\n```\n\n\n\n\n\n\n\n\n \n ","slug":"Java/Java多线程/Java多线程基础","published":1,"updated":"2021-01-05T12:15:31.401Z","_id":"ckjju0m1w006c20ua9v58e155","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Runnable接口\"><a href=\"#Runnable接口\" class=\"headerlink\" title=\"Runnable接口\"></a>Runnable接口</h3><p>仅调用Runnable的<code>run()</code>方法不能产生一个新的线程，新线程的执行必须通过<code>Thread.start()</code>方法来执行。</p>\n<p>通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。</p>\n<a id=\"more\"></a>\n<p>实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。</p>\n<p>Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p>Thread类的构造函数需要Runnable实例，调用Thread类的<code>start()</code>方法，可以对线程进行必要额初始化，然后执行Runnable实例的<code>run()</code>方法。</p>\n<p>静态方法<code>Thread.yield()</code>用于通知CPU从一个线程切换至另外一个线程；</p>\n<p><strong>注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</strong></p>\n<h3 id=\"多线程框架Executor的使用\"><a href=\"#多线程框架Executor的使用\" class=\"headerlink\" title=\"多线程框架Executor的使用\"></a>多线程框架Executor的使用</h3><p>Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。</p>\n<p> ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。</p>\n<p> Executors中的<code>shutdown()</code>方法用于停止向Executor中提交新的任务，在<code>shutdown()</code>方法调用之前提交的同步线程任务则会继续执行。</p>\n<p> <strong><em>注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理</em></strong></p>\n<h4 id=\"Executor、Executors、ExecutorService区别\"><a href=\"#Executor、Executors、ExecutorService区别\" class=\"headerlink\" title=\"Executor、Executors、ExecutorService区别\"></a>Executor、Executors、ExecutorService区别</h4><ul>\n<li>Executor是一个接口，用于并发提交的任务，只有<code>execute()</code>一个方法，没有返回值，不能对任务进行任何操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Executors类提供不同的工厂方法来创建不同类型的线程池，包括：<code>newSingleThreadExecutor()</code>、<code>newFixedThreadPool(int numOfThreads)</code>、<code>newCachedThreadPool()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Executors</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(var0, var0, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ExecutorService 是继承自<code>Exxecutor</code>的接口，其中有异步执行和关闭线程池的方法。可以通过<code>submit()</code>方法来提交任务，同时可以对任务进行取消等操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//...          </span></span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同线程池的使用\"><a href=\"#不同线程池的使用\" class=\"headerlink\" title=\"不同线程池的使用\"></a>不同线程池的使用</h3><p>CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p> FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>); </span><br></pre></td></tr></table></figure>\n\n<p> SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadExecutor(); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的回调\"><a href=\"#任务的回调\" class=\"headerlink\" title=\"任务的回调\"></a>任务的回调</h3><p>使用Callable和Future,一个产生结果，一个拿到结果</p>\n<p>每一个<strong>Runnable</strong>都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用<strong>Callable</strong>接口，而非<strong>Runnable接口</strong>。</p>\n<p>Callable接口带有<code>type</code>类型参数，该参数表示<code>call()</code>方法（非<code>run()</code>）方法执行完成后的返回值，必须通过调用<code> ExecutorService submit()</code>调用来执行。</p>\n<p><code>submit()</code>方法返回一个一个Future对象，可以通过调用Future的<code>isDone()</code>方法来判断当前任务是否执行结束。调用Future的<code>get()</code>方法，如果当前任务没有结束，则会被阻塞，直至任务结束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;result&quot;</span> + id;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;   </span><br><span class=\"line\">   ExecutorService exec = Executors.newCachedThreadPool();                    </span><br><span class=\"line\">   ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();               </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">     results.add(exec.submit(<span class=\"keyword\">new</span> CallableResult(i)));  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Future&lt;String&gt; fs : results)     </span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;               </span><br><span class=\"line\">              System.out.println(fs.get()); </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">               System.out.println(e);         </span><br><span class=\"line\">               <span class=\"keyword\">return</span>;      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(ExecutionException e) &#123;     </span><br><span class=\"line\">               System.out.println(e);      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span>&#123;        </span><br><span class=\"line\">                exec.shutdown(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"任务的暂停\"><a href=\"#任务的暂停\" class=\"headerlink\" title=\"任务的暂停\"></a>任务的暂停</h3><p>通过调用<code>TimeUnit.MILLISECONDS.sleep(100);</code>来阻塞当前线程指定的时间。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p> JDK有十中不同的优先级。</p>\n<p> 线程优先级<code>Thread.MIN_PRIORIT</code>、<code>Thread.MAX_PRIORITY</code>，通过<code>setPriority()</code>方法进行设置，以及<code>getPriority()</code>方法进行获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;Thread.currentThread().setPriority(priority);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"守护线程Daemon-threads\"><a href=\"#守护线程Daemon-threads\" class=\"headerlink\" title=\"守护线程Daemon threads\"></a>守护线程Daemon threads</h3><p>守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在<code>thread.start();</code>之前调用<code>daemon.setDaemon(true)</code>;</p>\n<p>如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用<code>isDaemon()</code>方法进行查看是否为守护线程。</p>\n<h3 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h3><h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。</p>\n<p>在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。</p>\n<h4 id=\"Lock对象的使用\"><a href=\"#Lock对象的使用\" class=\"headerlink\" title=\"Lock对象的使用\"></a>Lock对象的使用</h4><p>在调用<code>lock()</code>方法后，一定需要添加在<code>try-finally</code>的代码块，并在finally中调用<code>unlock()</code>方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在<code>try</code>代码块中实现，这样可以保证锁释放之前返回需要的值。**<em>如果<code>lock.lock()</code>方法调用失败会出现什么情况**</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Lock lock &#x3D; new ReentrantLock();</span><br><span class=\"line\">int num&#x3D;0;</span><br><span class=\"line\"></span><br><span class=\"line\">public int f()&#123;</span><br><span class=\"line\">   lock.lock();    </span><br><span class=\"line\">   try &#123;       </span><br><span class=\"line\">        Thread.yield();   </span><br><span class=\"line\">        return num++;    </span><br><span class=\"line\">    &#125;finally &#123;      </span><br><span class=\"line\">       lock.unlock();  </span><br><span class=\"line\">   &#125;   </span><br></pre></td></tr></table></figure>\n<p>当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;    </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;      </span><br><span class=\"line\">   captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);   <span class=\"comment\">//限制请求次数</span></span><br><span class=\"line\">   <span class=\"comment\">//captured = lock.tryLock();          //不限制请求次数</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);     </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;       </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> + captured);    </span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         <span class=\"keyword\">if</span>(captured)        </span><br><span class=\"line\">         lock.unlock();    </span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"原子性和波动性（Atomicity-and-Volality（易变的））\"><a href=\"#原子性和波动性（Atomicity-and-Volality（易变的））\" class=\"headerlink\" title=\"原子性和波动性（Atomicity and Volality（易变的））\"></a>原子性和波动性（Atomicity and Volality（易变的））</h4><p>原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是<code>synchronized</code>而非<code>volatile</code>。</p>\n<p>原子操作被应用于除<code>long</code>和<code>double</code>的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（<code>long</code>和<code>double</code>类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在<code>long</code>和<code>double</code>数据类型使用<code>volatile</code>关键字可以保证其操作的原子性。</p>\n<p>在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。</p>\n<p>当一个变量<code>volatile</code>关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。<code>volatile</code>关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。<code>volatile</code>关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。</p>\n<p> atomicity和volatility是两个不同的概念，原子性操作如果是非<code>volatile</code>类型的，那么其不会被立即刷到内存中；如果一个变量在一个<code>synchronized</code>的方法或者代码块中，那么变量也会被刷到内存中。</p>\n<h4 id=\"Atomic-classes-（原子类）\"><a href=\"#Atomic-classes-（原子类）\" class=\"headerlink\" title=\"Atomic classes （原子类）\"></a>Atomic classes （原子类）</h4><p>在Java SE 5中介绍了特殊的原子类：<code>Atomiclnteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>；对其操作时提供了原子类型的状态。</p>\n<h4 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h4><p>在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。</p>\n<p>使用<code>synchronized</code>创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">synchronized</span>(syncObject) &#123;  </span><br><span class=\"line\">   <span class=\"comment\">// This code can be accessed </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;   </span><br><span class=\"line\">         p.incrementX();    </span><br><span class=\"line\">         p.incrementY();     </span><br><span class=\"line\">         emp = getPair();   </span><br><span class=\"line\">     &#125;   </span><br><span class=\"line\">     store(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n<p>使用功<code>Lock</code>锁创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExplicitPairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     lock.lock();    </span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;     </span><br><span class=\"line\">       p.incrementX();    </span><br><span class=\"line\">       p.incrementY();     </span><br><span class=\"line\">       temp = getPair();   </span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         lock.unlock();   </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">       store(temp);  </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Runnable接口\"><a href=\"#Runnable接口\" class=\"headerlink\" title=\"Runnable接口\"></a>Runnable接口</h3><p>仅调用Runnable的<code>run()</code>方法不能产生一个新的线程，新线程的执行必须通过<code>Thread.start()</code>方法来执行。</p>\n<p>通常将一个Runnable对象转换成一个任务，需要将其传递给一个Thread构造函数。</p>","more":"<p>实现Runnable接口，并在一个独立的线程中运行Runnable.run()方法中的代码；一个或多个Runnable对象执行不同的操作，有时也被称为任务。</p>\n<p>Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</p>\n<h3 id=\"Thread类\"><a href=\"#Thread类\" class=\"headerlink\" title=\"Thread类\"></a>Thread类</h3><p>Thread类的构造函数需要Runnable实例，调用Thread类的<code>start()</code>方法，可以对线程进行必要额初始化，然后执行Runnable实例的<code>run()</code>方法。</p>\n<p>静态方法<code>Thread.yield()</code>用于通知CPU从一个线程切换至另外一个线程；</p>\n<p><strong>注：Thread以及Runnable是基类，只有有限的功能，事实上他们也是HandlerThread,AsyTask以及IntentService的基类，也同时是ThreadPoolExcutor的基类。ThreadPoolExcutor可以自动管理线程以及任务队列，甚至可以同时运行多个线程。</strong></p>\n<h3 id=\"多线程框架Executor的使用\"><a href=\"#多线程框架Executor的使用\" class=\"headerlink\" title=\"多线程框架Executor的使用\"></a>多线程框架Executor的使用</h3><p>Executors在client以及任务之前提供了一个间接层，而不是有client直接执行相应的任务，即用于对线程进行管理操作。</p>\n<p> ExecutorService是一个带有生命周期的服务Executor，可以提供合适的上下文执行Runnable对象。</p>\n<p> Executors中的<code>shutdown()</code>方法用于停止向Executor中提交新的任务，在<code>shutdown()</code>方法调用之前提交的同步线程任务则会继续执行。</p>\n<p> <strong><em>注：在Java SE 1.5之前使用 thread group来对线程运行过程中出现的异常情况进行处理，在Java SE 1.5之后使用 Executor进行处理</em></strong></p>\n<h4 id=\"Executor、Executors、ExecutorService区别\"><a href=\"#Executor、Executors、ExecutorService区别\" class=\"headerlink\" title=\"Executor、Executors、ExecutorService区别\"></a>Executor、Executors、ExecutorService区别</h4><ul>\n<li>Executor是一个接口，用于并发提交的任务，只有<code>execute()</code>一个方法，没有返回值，不能对任务进行任何操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable var1)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Executors类提供不同的工厂方法来创建不同类型的线程池，包括：<code>newSingleThreadExecutor()</code>、<code>newFixedThreadPool(int numOfThreads)</code>、<code>newCachedThreadPool()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Executors</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(var0, var0, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ExecutorService 是继承自<code>Exxecutor</code>的接口，其中有异步执行和关闭线程池的方法。可以通过<code>submit()</code>方法来提交任务，同时可以对任务进行取消等操作。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//...          </span></span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同线程池的使用\"><a href=\"#不同线程池的使用\" class=\"headerlink\" title=\"不同线程池的使用\"></a>不同线程池的使用</h3><p>CachedThreadPool没有线程数量限制，会按照需要创建足够的线程，当循环使用到旧的线程时会停止创建新的线程。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p> FixedThreadPool可以控制提交到Executor的任务的数量，线程池中的线程会自动被重新使用。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>); </span><br></pre></td></tr></table></figure>\n\n<p> SingleThreadExecutor可以看做是只有一个线程的FixedThreadPool，当有一个需要长时间存活的任务时使用SingleThreadExecutor。SingleThreadExecutor在执行时使用同一个线程，并将提交的任务使用队列进行管理。当使用文件系统时，可以使用SingleThreadExecutor，这样就不需要对文件资源进行同步处理。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executors.newSingleThreadExecutor(); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务的回调\"><a href=\"#任务的回调\" class=\"headerlink\" title=\"任务的回调\"></a>任务的回调</h3><p>使用Callable和Future,一个产生结果，一个拿到结果</p>\n<p>每一个<strong>Runnable</strong>都是一个没有返回值的独立的任务，当该任务执行完成后，如果需要一个返回值，可以使用<strong>Callable</strong>接口，而非<strong>Runnable接口</strong>。</p>\n<p>Callable接口带有<code>type</code>类型参数，该参数表示<code>call()</code>方法（非<code>run()</code>）方法执行完成后的返回值，必须通过调用<code> ExecutorService submit()</code>调用来执行。</p>\n<p><code>submit()</code>方法返回一个一个Future对象，可以通过调用Future的<code>isDone()</code>方法来判断当前任务是否执行结束。调用Future的<code>get()</code>方法，如果当前任务没有结束，则会被阻塞，直至任务结束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;    </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;     </span><br><span class=\"line\">     <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;result&quot;</span> + id;  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;   </span><br><span class=\"line\">   ExecutorService exec = Executors.newCachedThreadPool();                    </span><br><span class=\"line\">   ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();               </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">     results.add(exec.submit(<span class=\"keyword\">new</span> CallableResult(i)));  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Future&lt;String&gt; fs : results)     </span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;               </span><br><span class=\"line\">              System.out.println(fs.get()); </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">               System.out.println(e);         </span><br><span class=\"line\">               <span class=\"keyword\">return</span>;      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span>(ExecutionException e) &#123;     </span><br><span class=\"line\">               System.out.println(e);      </span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span>&#123;        </span><br><span class=\"line\">                exec.shutdown(); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"任务的暂停\"><a href=\"#任务的暂停\" class=\"headerlink\" title=\"任务的暂停\"></a>任务的暂停</h3><p>通过调用<code>TimeUnit.MILLISECONDS.sleep(100);</code>来阻塞当前线程指定的时间。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p> JDK有十中不同的优先级。</p>\n<p> 线程优先级<code>Thread.MIN_PRIORIT</code>、<code>Thread.MAX_PRIORITY</code>，通过<code>setPriority()</code>方法进行设置，以及<code>getPriority()</code>方法进行获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;Thread.currentThread().setPriority(priority);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"守护线程Daemon-threads\"><a href=\"#守护线程Daemon-threads\" class=\"headerlink\" title=\"守护线程Daemon threads\"></a>守护线程Daemon threads</h3><p>守护线程试图为程序提供一个后台服务，不是程序必须的线程，当程序即终止时，会杀死所有的守护线程执行。在使用守护线程时，需要在<code>thread.start();</code>之前调用<code>daemon.setDaemon(true)</code>;</p>\n<p>如果一个线程是守护线程，那么其创建的所有子线程都是守护线程，可以通过调用<code>isDaemon()</code>方法进行查看是否为守护线程。</p>\n<h3 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h3><h4 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h4><p>使用synchronized关键字保护的代码段，在运行在之前会检测是否加锁，如果没有锁则执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>当调用被synchronized关键字修饰的方法时，该方法所在的对象会被自动加锁，只有当该锁被释放后，其他方法才可以被调用。</p>\n<p>在使用并发操作时，需要将数据域设置为private，否则synchronized关键字不能保证其他线程直接获取数据域操作，造成冲突。</p>\n<h4 id=\"Lock对象的使用\"><a href=\"#Lock对象的使用\" class=\"headerlink\" title=\"Lock对象的使用\"></a>Lock对象的使用</h4><p>在调用<code>lock()</code>方法后，一定需要添加在<code>try-finally</code>的代码块，并在finally中调用<code>unlock()</code>方法。这是唯一可以保证锁可以释放的方式。return关键字一定要在<code>try</code>代码块中实现，这样可以保证锁释放之前返回需要的值。**<em>如果<code>lock.lock()</code>方法调用失败会出现什么情况**</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Lock lock &#x3D; new ReentrantLock();</span><br><span class=\"line\">int num&#x3D;0;</span><br><span class=\"line\"></span><br><span class=\"line\">public int f()&#123;</span><br><span class=\"line\">   lock.lock();    </span><br><span class=\"line\">   try &#123;       </span><br><span class=\"line\">        Thread.yield();   </span><br><span class=\"line\">        return num++;    </span><br><span class=\"line\">    &#125;finally &#123;      </span><br><span class=\"line\">       lock.unlock();  </span><br><span class=\"line\">   &#125;   </span><br></pre></td></tr></table></figure>\n<p>当使用synchronized关键字不能解决并发问题时，需要使用Lock进行处理，如：使用synchronized不能获取到代码锁，或者尝试多次获取到锁之后停止代码运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> captured = <span class=\"keyword\">false</span>;    </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;      </span><br><span class=\"line\">   captured = lock.tryLock(<span class=\"number\">2</span>, TimeUnit.SECONDS);   <span class=\"comment\">//限制请求次数</span></span><br><span class=\"line\">   <span class=\"comment\">//captured = lock.tryLock();          //不限制请求次数</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;      </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);     </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;       </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> + captured);    </span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         <span class=\"keyword\">if</span>(captured)        </span><br><span class=\"line\">         lock.unlock();    </span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"原子性和波动性（Atomicity-and-Volality（易变的））\"><a href=\"#原子性和波动性（Atomicity-and-Volality（易变的））\" class=\"headerlink\" title=\"原子性和波动性（Atomicity and Volality（易变的））\"></a>原子性和波动性（Atomicity and Volality（易变的））</h4><p>原子性操作不可以被打断，一旦其开始执行，就会执行至操作结束，不需要进行同步。按照《Thinking In Java》书中所讲：“依赖于原子性操作是困难以及危险的，除非开发者是并发的专家，或者是这方面的专家，才可以使用原子操作，来避开线程同步。”所以我们的第一选择是<code>synchronized</code>而非<code>volatile</code>。</p>\n<p>原子操作被应用于除<code>long</code>和<code>double</code>的基础数据类型中，读和写基础类型保证了对内存的操作是原子性的。JVM将64位数据（<code>long</code>和<code>double</code>类型）是为两个独立的32位操作，因此在操作的过程中会被打断。在<code>long</code>和<code>double</code>数据类型使用<code>volatile</code>关键字可以保证其操作的原子性。</p>\n<p>在多处理器系统中，与单处理器系统相比可见性比原子性更重要。在一个任务对数据做出改变即使其是原子性的，改变的数据其他线程也可能观察不到（数据的改变可能被临时存放在寄存器中），造成不同的任务获取到统一数据的不同状态。在同步操作机制中，可以保证数据的改变可以被不同的任务观察到相同的数据，即将改变的数据刷到内存中。</p>\n<p>当一个变量<code>volatile</code>关键字，则其在修改后会被其他任务立即观察到数据改变，即使该变量是一个局部变量。<code>volatile</code>关键字只在多任务中使用，如果一个变量只在单任务中，那么其改变后一定会被观察到。<code>volatile</code>关键字在使用的过程中，如果一个值依赖于其之前的值（自增）那么该关键字将会失效，或者其值有上界或者下界也会失效。</p>\n<p> atomicity和volatility是两个不同的概念，原子性操作如果是非<code>volatile</code>类型的，那么其不会被立即刷到内存中；如果一个变量在一个<code>synchronized</code>的方法或者代码块中，那么变量也会被刷到内存中。</p>\n<h4 id=\"Atomic-classes-（原子类）\"><a href=\"#Atomic-classes-（原子类）\" class=\"headerlink\" title=\"Atomic classes （原子类）\"></a>Atomic classes （原子类）</h4><p>在Java SE 5中介绍了特殊的原子类：<code>Atomiclnteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>；对其操作时提供了原子类型的状态。</p>\n<h4 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h4><p>在多线程操作时只需将对部分代码进行操作，而非整个方法进行同步，则可使用临界区进行实现。</p>\n<p>使用<code>synchronized</code>创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">synchronized</span>(syncObject) &#123;  </span><br><span class=\"line\">   <span class=\"comment\">// This code can be accessed </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;   </span><br><span class=\"line\">         p.incrementX();    </span><br><span class=\"line\">         p.incrementY();     </span><br><span class=\"line\">         emp = getPair();   </span><br><span class=\"line\">     &#125;   </span><br><span class=\"line\">     store(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n<p>使用功<code>Lock</code>锁创建临界区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExplicitPairManager2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PairManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;    </span><br><span class=\"line\">     Pair temp;     </span><br><span class=\"line\">     lock.lock();    </span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;     </span><br><span class=\"line\">       p.incrementX();    </span><br><span class=\"line\">       p.incrementY();     </span><br><span class=\"line\">       temp = getPair();   </span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;     </span><br><span class=\"line\">         lock.unlock();   </span><br><span class=\"line\">         &#125;   </span><br><span class=\"line\">       store(temp);  </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Java线程间通信","cover":"/cover/img63.jpg","toc":true,"description":"Java线程间通信","type":["Java"],"date":"2018-10-04T16:00:00.000Z","_content":"\n# 线程间通信\n\n* 使用单向管道（Pipe）传递数据\n* 共享内存（Shared Memory）通信\n* 使用阻塞队列（Blocking Queue）实现生产者-消费者模式\n* 处理消息队列（Message Queue）\n\n<!--more-->\n## wait/notify机制\n\n等待/通知机制主要由Object类中的三个方法进行保证\n\n1、wait()；notify();notifyAll()\n上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；`wait();notify();notifyAll()`只有在被`synchronized `修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出`IllegalMonitorStateException`异常。\n\n1)wait()\n让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用`notify()`或者`notifyAll()`时唤醒当前线程。`wait()`也可以作为任务同步的一种方式。\n\n**注：调用`sleep()`和`yield()`方法不能释放当前的对象锁**\n`wait()`方法有两种用法：\n* ` wait(long timeout)`等待一定的时间，但与`sleep()`方法不同，其会释放对象锁\n* 使用`wait()`等待`notify()`或者`notifyAll()`唤醒。 \n\n\n2)notify()\n唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；\n\n3)notifyAll()\n唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过`synchronized(x)`来获取对象锁。\n\n```java\n     synchronized(x) { \n       x.notifyAll();\n     }\n\n```\n\n\n2、方法调用与线程状态关系\n\n每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列\n\n## Condition\n\nCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；\n\n对应关系\n\n* Condition中的await()对应Object的wait()\n* Condition中的signal()对应Object的notify()\n* Condition中的signalAll()对应Object中的notifyAll();\n\n**Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同**\n\n### 生产者消费者模型\n\n线程锁控制代码\n```java\npublic class Service {\n\n    //线程锁\n    private ReentrantLock lock=new ReentrantLock();\n    //生产者线程控制\n    private Condition conditionCustomer=lock.newCondition();\n    //消费者线程控制\n    private Condition conditionProducer=lock.newCondition();\n    //用于表示需要生产\n    private boolean hasValue=false;\n    //用于随机消费时间；\n    private static Random rand = new Random(2000);\n\n    //用于生产者\n    public void produce(){\n        try {\n            lock.lock();\n            while (hasValue){\n                System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionCustomer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\");\n            Thread.sleep(rand.nextInt(500));\n            hasValue=true;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的消费者线程\n            conditionProducer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //用于消费者\n    public void custome(){\n        try{\n            lock.lock();\n            while (!hasValue){\n                System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionProducer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\");\n            Thread.sleep(rand.nextInt(4000));\n            hasValue=false;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的生产者线程\n            conditionCustomer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n消费者线程\n\n```java\npublic class CustomerThread extends Thread {\n\n    private Service service;\n    public CustomerThread(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        while (true){\n            service.custome();\n        }\n    }\n}\n\n```\n测试代码\n```java\n\npublic class Customer_ServiceMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n        CustomerThread[] customerThread=new CustomerThread[10];\n        ProducerThread[] producerThreads=new ProducerThread[10];\n        for (int i=0;i<3;i++){\n            customerThread[i]=new CustomerThread(service);\n            customerThread[i].setName(\"生产者Thread：\"+i);\n            producerThreads[i]=new ProducerThread(service);\n            producerThreads[i].setName(\"消费者Thread：\"+i);\n            customerThread[i].start();\n            producerThreads[i].start();\n\n        }\n    }\n    }\n\n```\n\n运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。\n\n```xml\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：2await\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：2await\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n\n```\n\n\n### 线程间通信管道模式\n\n#### CountDownLatch的使用\n\n用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。\n\n任务执行线程\n```java\n    public class Task extends Thread {\n\n    private static Random random = new Random(100);\n\n    private final CountDownLatch latch;\n\n    //使用CountDownLatch会被自动要求加上此构造函数\n    public Task(CountDownLatch latch, String name) {\n        this.latch = latch;\n        this.setName(name);\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            doWork();\n            //用于倒数技术\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doWork() throws InterruptedException {\n        //random.nextInt(2000)在Java中是线程安全的来自TIJ\n        TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));\n        System.out.println(this.getName() + \"completed\");\n    }\n}\n```\n等待任务执行完毕，需要唤醒的线程\n```java\n  public class WaitingTask implements Runnable {\n    \n    private final CountDownLatch latch;\n\n    public WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            latch.await();\n            System.out.println(\"Latch阻塞运行至waiting class\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n\n```\n测试代码\n```java\npublic class TestCountDown {\n\n    static final int SIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n\n        ExecutorService exec = Executors.newFixedThreadPool(5);\n        //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数\n        CountDownLatch latch = new CountDownLatch(SIZE);\n      // for (int i=0;i<10;i++){   //可以有多个等待线程\n        exec.execute(new WaitingTask(latch));\n      // }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new Task(latch,\"线程\"+i));\n        }\n        System.out.println(\"启动所有任务\");\n        exec.shutdown();  //任务只有在执行完毕后才会结束\n    }\n}\n\n```\n任务执行结果\n```xml\n启动所有任务\n线程0completed\n线程4completed\n线程1completed\n线程2completed\n线程3completed\nLatch阻塞运行至waiting class\n\nProcess finished with exit code 0\n\n```\n\n\n#### CyclicBarrier的使用\n\n`CyclicBarrier`类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于`join`)，与`CountDownLatch`类的使用类似，`CountDownLatch`类只能执行一次，而`CyclicBarrier`可以进行多次使用。\n以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；\n\n运动员代码\n```java\n\npublic class Athlete extends Thread {\n\n    //用于表示耗时\n    private double time =90;\n\n    private static Random rand = new Random(1);\n\n    private static CyclicBarrier cyclicBarrier;\n\n    public Athlete(CyclicBarrier cyclicBarrier){\n        this.cyclicBarrier=cyclicBarrier;\n    }\n\n    public synchronized double getTime(){\n        return time;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()){\n                synchronized (this){\n                    time =(double)(rand.nextInt(20)+90)/10;\n                    System.out.println(getName()+\"跑步耗时：\"+ getTime());\n                }\n                Thread.sleep(1000);\n                cyclicBarrier.await();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n所有运动员跑完标志输出代码\n\n```java\npublic class RunningCtrl extends Thread{\n\n    public RunningCtrl(){\n\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n    }\n}\n\n```\n\n测试代码\n\n```java\npublic class CyclicBarrierMain {\n\n    public static void main(String[] args) {\n\n        RunningCtrl  runningCtrl=new RunningCtrl();\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i <5; i++) {\n            Athlete athlete = new Athlete(cyclicBarrier);\n            athlete.setName(\"选手：\"+i);\n            exec.execute(athlete);\n        }\n    }\n}\n\n```\n\n运行结果\n```xml\n\n选手：0跑步耗时：9.5\n选手：1跑步耗时：9.8\n选手：4跑步耗时：10.4\n选手：2跑步耗时：9.7\n选手：3跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：0跑步耗时：10.4\n选手：2跑步耗时：9.8\n选手：1跑步耗时：9.6\n选手：4跑步耗时：9.4\n选手：3跑步耗时：10.8\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：9.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：9.2\n选手：2跑步耗时：9.3\n选手：0跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：1跑步耗时：10.4\n选手：2跑步耗时：9.2\n选手：0跑步耗时：9.9\n选手：3跑步耗时：10.2\n选手：4跑步耗时：10.6\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：10.2\n选手：2跑步耗时：10.9\n选手：0跑步耗时：10.6\n选手：3跑步耗时：10.0\n选手：1跑步耗时：10.4\n++++++++++++++++++++++++++++++++\n选手：2跑步耗时：10.8\n选手：4跑步耗时：10.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：10.3\n选手：0跑步耗时：9.2\n++++++++++++++++++++++++++++++++\n```\n\n#### `DelayQueue`的使用\n\n`DelayQueue`是一个无界的阻塞队列，实现`Delayed`接口。只有当`delay`被激发时，该对象才能从队列中获取数据\n\n\n\n### 线程间通信管道模式\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/Java多线程/Java线程间通信.md","raw":"---\ntitle: Java线程间通信\ncover:  /cover/img63.jpg\ntoc: true\ndescription: Java线程间通信\ncategories: Java\ntype: [Java]\ndate: 2018/10/05\n---\n\n# 线程间通信\n\n* 使用单向管道（Pipe）传递数据\n* 共享内存（Shared Memory）通信\n* 使用阻塞队列（Blocking Queue）实现生产者-消费者模式\n* 处理消息队列（Message Queue）\n\n<!--more-->\n## wait/notify机制\n\n等待/通知机制主要由Object类中的三个方法进行保证\n\n1、wait()；notify();notifyAll()\n上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；`wait();notify();notifyAll()`只有在被`synchronized `修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出`IllegalMonitorStateException`异常。\n\n1)wait()\n让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用`notify()`或者`notifyAll()`时唤醒当前线程。`wait()`也可以作为任务同步的一种方式。\n\n**注：调用`sleep()`和`yield()`方法不能释放当前的对象锁**\n`wait()`方法有两种用法：\n* ` wait(long timeout)`等待一定的时间，但与`sleep()`方法不同，其会释放对象锁\n* 使用`wait()`等待`notify()`或者`notifyAll()`唤醒。 \n\n\n2)notify()\n唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；\n\n3)notifyAll()\n唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过`synchronized(x)`来获取对象锁。\n\n```java\n     synchronized(x) { \n       x.notifyAll();\n     }\n\n```\n\n\n2、方法调用与线程状态关系\n\n每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列\n\n## Condition\n\nCondition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；\n\n对应关系\n\n* Condition中的await()对应Object的wait()\n* Condition中的signal()对应Object的notify()\n* Condition中的signalAll()对应Object中的notifyAll();\n\n**Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同**\n\n### 生产者消费者模型\n\n线程锁控制代码\n```java\npublic class Service {\n\n    //线程锁\n    private ReentrantLock lock=new ReentrantLock();\n    //生产者线程控制\n    private Condition conditionCustomer=lock.newCondition();\n    //消费者线程控制\n    private Condition conditionProducer=lock.newCondition();\n    //用于表示需要生产\n    private boolean hasValue=false;\n    //用于随机消费时间；\n    private static Random rand = new Random(2000);\n\n    //用于生产者\n    public void produce(){\n        try {\n            lock.lock();\n            while (hasValue){\n                System.out.println(\"生产线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionCustomer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产中\");\n            Thread.sleep(rand.nextInt(500));\n            hasValue=true;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"生产完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有消费者线程 \"+\"....\");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的消费者线程\n            conditionProducer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //用于消费者\n    public void custome(){\n        try{\n            lock.lock();\n            while (!hasValue){\n                System.out.println(\"消费线程：\"+Thread.currentThread().getName()+\"await\");\n                conditionProducer.await();\n            }\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费中\");\n            Thread.sleep(rand.nextInt(4000));\n            hasValue=false;\n            System.out.println(\"线程：\"+Thread.currentThread().getName()+\"消费完毕\");\n            System.out.println(Thread.currentThread().getName()+\"唤醒所有生产者线程 \");\n            System.out.println(\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\");\n            //唤起所有的生产者线程\n            conditionCustomer.signalAll();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n消费者线程\n\n```java\npublic class CustomerThread extends Thread {\n\n    private Service service;\n    public CustomerThread(Service service) {\n        this.service = service;\n    }\n    @Override\n    public void run() {\n        while (true){\n            service.custome();\n        }\n    }\n}\n\n```\n测试代码\n```java\n\npublic class Customer_ServiceMain {\n\n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n        CustomerThread[] customerThread=new CustomerThread[10];\n        ProducerThread[] producerThreads=new ProducerThread[10];\n        for (int i=0;i<3;i++){\n            customerThread[i]=new CustomerThread(service);\n            customerThread[i].setName(\"生产者Thread：\"+i);\n            producerThreads[i]=new ProducerThread(service);\n            producerThreads[i].setName(\"消费者Thread：\"+i);\n            customerThread[i].start();\n            producerThreads[i].start();\n\n        }\n    }\n    }\n\n```\n\n运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。\n\n```xml\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：2await\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n生产线程：消费者Thread：1await\n生产线程：消费者Thread：0await\n线程：生产者Thread：2消费中\n线程：生产者Thread：2消费完毕\n生产者Thread：2唤醒所有生产者线程 \n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n消费线程：生产者Thread：2await\n消费线程：生产者Thread：1await\n消费线程：生产者Thread：0await\n线程：消费者Thread：2生产中\n线程：消费者Thread：2生产完毕\n消费者Thread：2唤醒所有消费者线程 ....\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.\n\n```\n\n\n### 线程间通信管道模式\n\n#### CountDownLatch的使用\n\n用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。\n\n任务执行线程\n```java\n    public class Task extends Thread {\n\n    private static Random random = new Random(100);\n\n    private final CountDownLatch latch;\n\n    //使用CountDownLatch会被自动要求加上此构造函数\n    public Task(CountDownLatch latch, String name) {\n        this.latch = latch;\n        this.setName(name);\n    }\n\n    @Override\n    public void run() {\n\n        try {\n            doWork();\n            //用于倒数技术\n            latch.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void doWork() throws InterruptedException {\n        //random.nextInt(2000)在Java中是线程安全的来自TIJ\n        TimeUnit.MILLISECONDS.sleep(random.nextInt(1000));\n        System.out.println(this.getName() + \"completed\");\n    }\n}\n```\n等待任务执行完毕，需要唤醒的线程\n```java\n  public class WaitingTask implements Runnable {\n    \n    private final CountDownLatch latch;\n\n    public WaitingTask(CountDownLatch latch) {\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            latch.await();\n            System.out.println(\"Latch阻塞运行至waiting class\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n }\n\n\n```\n测试代码\n```java\npublic class TestCountDown {\n\n    static final int SIZE = 10;\n\n    public static void main(String[] args) throws Exception {\n\n        ExecutorService exec = Executors.newFixedThreadPool(5);\n        //所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数\n        CountDownLatch latch = new CountDownLatch(SIZE);\n      // for (int i=0;i<10;i++){   //可以有多个等待线程\n        exec.execute(new WaitingTask(latch));\n      // }\n        for (int i = 0; i < SIZE; i++) {\n            exec.execute(new Task(latch,\"线程\"+i));\n        }\n        System.out.println(\"启动所有任务\");\n        exec.shutdown();  //任务只有在执行完毕后才会结束\n    }\n}\n\n```\n任务执行结果\n```xml\n启动所有任务\n线程0completed\n线程4completed\n线程1completed\n线程2completed\n线程3completed\nLatch阻塞运行至waiting class\n\nProcess finished with exit code 0\n\n```\n\n\n#### CyclicBarrier的使用\n\n`CyclicBarrier`类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于`join`)，与`CountDownLatch`类的使用类似，`CountDownLatch`类只能执行一次，而`CyclicBarrier`可以进行多次使用。\n以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；\n\n运动员代码\n```java\n\npublic class Athlete extends Thread {\n\n    //用于表示耗时\n    private double time =90;\n\n    private static Random rand = new Random(1);\n\n    private static CyclicBarrier cyclicBarrier;\n\n    public Athlete(CyclicBarrier cyclicBarrier){\n        this.cyclicBarrier=cyclicBarrier;\n    }\n\n    public synchronized double getTime(){\n        return time;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()){\n                synchronized (this){\n                    time =(double)(rand.nextInt(20)+90)/10;\n                    System.out.println(getName()+\"跑步耗时：\"+ getTime());\n                }\n                Thread.sleep(1000);\n                cyclicBarrier.await();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n所有运动员跑完标志输出代码\n\n```java\npublic class RunningCtrl extends Thread{\n\n    public RunningCtrl(){\n\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n    }\n}\n\n```\n\n测试代码\n\n```java\npublic class CyclicBarrierMain {\n\n    public static void main(String[] args) {\n\n        RunningCtrl  runningCtrl=new RunningCtrl();\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(5,runningCtrl);\n        ExecutorService exec = Executors.newCachedThreadPool();\n        for (int i = 0; i <5; i++) {\n            Athlete athlete = new Athlete(cyclicBarrier);\n            athlete.setName(\"选手：\"+i);\n            exec.execute(athlete);\n        }\n    }\n}\n\n```\n\n运行结果\n```xml\n\n选手：0跑步耗时：9.5\n选手：1跑步耗时：9.8\n选手：4跑步耗时：10.4\n选手：2跑步耗时：9.7\n选手：3跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：0跑步耗时：10.4\n选手：2跑步耗时：9.8\n选手：1跑步耗时：9.6\n选手：4跑步耗时：9.4\n选手：3跑步耗时：10.8\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：9.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：9.2\n选手：2跑步耗时：9.3\n选手：0跑步耗时：10.3\n++++++++++++++++++++++++++++++++\n选手：1跑步耗时：10.4\n选手：2跑步耗时：9.2\n选手：0跑步耗时：9.9\n选手：3跑步耗时：10.2\n选手：4跑步耗时：10.6\n++++++++++++++++++++++++++++++++\n选手：4跑步耗时：10.2\n选手：2跑步耗时：10.9\n选手：0跑步耗时：10.6\n选手：3跑步耗时：10.0\n选手：1跑步耗时：10.4\n++++++++++++++++++++++++++++++++\n选手：2跑步耗时：10.8\n选手：4跑步耗时：10.9\n选手：1跑步耗时：10.7\n选手：3跑步耗时：10.3\n选手：0跑步耗时：9.2\n++++++++++++++++++++++++++++++++\n```\n\n#### `DelayQueue`的使用\n\n`DelayQueue`是一个无界的阻塞队列，实现`Delayed`接口。只有当`delay`被激发时，该对象才能从队列中获取数据\n\n\n\n### 线程间通信管道模式\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/Java多线程/Java线程间通信","published":1,"updated":"2021-01-05T12:15:32.601Z","_id":"ckjju0m1w006f20uabus27d47","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><ul>\n<li>使用单向管道（Pipe）传递数据</li>\n<li>共享内存（Shared Memory）通信</li>\n<li>使用阻塞队列（Blocking Queue）实现生产者-消费者模式</li>\n<li>处理消息队列（Message Queue）</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"wait-notify机制\"><a href=\"#wait-notify机制\" class=\"headerlink\" title=\"wait/notify机制\"></a>wait/notify机制</h2><p>等待/通知机制主要由Object类中的三个方法进行保证</p>\n<p>1、wait()；notify();notifyAll()<br>上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；<code>wait();notify();notifyAll()</code>只有在被<code>synchronized </code>修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出<code>IllegalMonitorStateException</code>异常。</p>\n<p>1)wait()<br>让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用<code>notify()</code>或者<code>notifyAll()</code>时唤醒当前线程。<code>wait()</code>也可以作为任务同步的一种方式。</p>\n<p><strong>注：调用<code>sleep()</code>和<code>yield()</code>方法不能释放当前的对象锁</strong><br><code>wait()</code>方法有两种用法：</p>\n<ul>\n<li><code> wait(long timeout)</code>等待一定的时间，但与<code>sleep()</code>方法不同，其会释放对象锁</li>\n<li>使用<code>wait()</code>等待<code>notify()</code>或者<code>notifyAll()</code>唤醒。 </li>\n</ul>\n<p>2)notify()<br>唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；</p>\n<p>3)notifyAll()<br>唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过<code>synchronized(x)</code>来获取对象锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(x) &#123; </span><br><span class=\"line\">  x.notifyAll();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2、方法调用与线程状态关系</p>\n<p>每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列</p>\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p>Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；</p>\n<p>对应关系</p>\n<ul>\n<li>Condition中的await()对应Object的wait()</li>\n<li>Condition中的signal()对应Object的notify()</li>\n<li>Condition中的signalAll()对应Object中的notifyAll();</li>\n</ul>\n<p><strong>Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同</strong></p>\n<h3 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h3><p>线程锁控制代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">//生产者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionCustomer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//消费者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionProducer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//用于表示需要生产</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用于随机消费时间；</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于生产者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;生产线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;await&quot;</span>);</span><br><span class=\"line\">                conditionCustomer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;生产中&quot;</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">500</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;生产完毕&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;唤醒所有消费者线程 &quot;</span>+<span class=\"string\">&quot;....&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的消费者线程</span></span><br><span class=\"line\">            conditionProducer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">custome</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;消费线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;await&quot;</span>);</span><br><span class=\"line\">                conditionProducer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;消费中&quot;</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">4000</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;消费完毕&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;唤醒所有生产者线程 &quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的生产者线程</span></span><br><span class=\"line\">            conditionCustomer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>消费者线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomerThread</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            service.custome();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer_ServiceMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Service service=<span class=\"keyword\">new</span> Service();</span><br><span class=\"line\">        CustomerThread[] customerThread=<span class=\"keyword\">new</span> CustomerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        ProducerThread[] producerThreads=<span class=\"keyword\">new</span> ProducerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            customerThread[i]=<span class=\"keyword\">new</span> CustomerThread(service);</span><br><span class=\"line\">            customerThread[i].setName(<span class=\"string\">&quot;生产者Thread：&quot;</span>+i);</span><br><span class=\"line\">            producerThreads[i]=<span class=\"keyword\">new</span> ProducerThread(service);</span><br><span class=\"line\">            producerThreads[i].setName(<span class=\"string\">&quot;消费者Thread：&quot;</span>+i);</span><br><span class=\"line\">            customerThread[i].start();</span><br><span class=\"line\">            producerThreads[i].start();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：2await</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：2await</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"线程间通信管道模式\"><a href=\"#线程间通信管道模式\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3><h4 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h4><p>用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。</p>\n<p>任务执行线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用CountDownLatch会被自动要求加上此构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setName(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doWork();</span><br><span class=\"line\">            <span class=\"comment\">//用于倒数技术</span></span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//random.nextInt(2000)在Java中是线程安全的来自TIJ</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">&quot;completed&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等待任务执行完毕，需要唤醒的线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitingTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WaitingTask</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           latch.await();</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;Latch阻塞运行至waiting class&quot;</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCountDown</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数</span></span><br><span class=\"line\">        CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(SIZE);</span><br><span class=\"line\">      <span class=\"comment\">// for (int i=0;i&lt;10;i++)&#123;   //可以有多个等待线程</span></span><br><span class=\"line\">        exec.execute(<span class=\"keyword\">new</span> WaitingTask(latch));</span><br><span class=\"line\">      <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> Task(latch,<span class=\"string\">&quot;线程&quot;</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;启动所有任务&quot;</span>);</span><br><span class=\"line\">        exec.shutdown();  <span class=\"comment\">//任务只有在执行完毕后才会结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>任务执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动所有任务</span><br><span class=\"line\">线程0completed</span><br><span class=\"line\">线程4completed</span><br><span class=\"line\">线程1completed</span><br><span class=\"line\">线程2completed</span><br><span class=\"line\">线程3completed</span><br><span class=\"line\">Latch阻塞运行至waiting class</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h4><p><code>CyclicBarrier</code>类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于<code>join</code>)，与<code>CountDownLatch</code>类的使用类似，<code>CountDownLatch</code>类只能执行一次，而<code>CyclicBarrier</code>可以进行多次使用。<br>以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；</p>\n<p>运动员代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Athlete</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示耗时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> time =<span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Athlete</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cyclicBarrier=cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">double</span> <span class=\"title\">getTime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.interrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                    time =(<span class=\"keyword\">double</span>)(rand.nextInt(<span class=\"number\">20</span>)+<span class=\"number\">90</span>)/<span class=\"number\">10</span>;</span><br><span class=\"line\">                    System.out.println(getName()+<span class=\"string\">&quot;跑步耗时：&quot;</span>+ getTime());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>所有运动员跑完标志输出代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunningCtrl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RunningCtrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RunningCtrl  runningCtrl=<span class=\"keyword\">new</span> RunningCtrl();</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>,runningCtrl);</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Athlete athlete = <span class=\"keyword\">new</span> Athlete(cyclicBarrier);</span><br><span class=\"line\">            athlete.setName(<span class=\"string\">&quot;选手：&quot;</span>+i);</span><br><span class=\"line\">            exec.execute(athlete);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">选手：0跑步耗时：9.5</span><br><span class=\"line\">选手：1跑步耗时：9.8</span><br><span class=\"line\">选手：4跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：0跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.8</span><br><span class=\"line\">选手：1跑步耗时：9.6</span><br><span class=\"line\">选手：4跑步耗时：9.4</span><br><span class=\"line\">选手：3跑步耗时：10.8</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：9.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：9.2</span><br><span class=\"line\">选手：2跑步耗时：9.3</span><br><span class=\"line\">选手：0跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.2</span><br><span class=\"line\">选手：0跑步耗时：9.9</span><br><span class=\"line\">选手：3跑步耗时：10.2</span><br><span class=\"line\">选手：4跑步耗时：10.6</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：10.2</span><br><span class=\"line\">选手：2跑步耗时：10.9</span><br><span class=\"line\">选手：0跑步耗时：10.6</span><br><span class=\"line\">选手：3跑步耗时：10.0</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：2跑步耗时：10.8</span><br><span class=\"line\">选手：4跑步耗时：10.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">选手：0跑步耗时：9.2</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>\n<h4 id=\"DelayQueue的使用\"><a href=\"#DelayQueue的使用\" class=\"headerlink\" title=\"DelayQueue的使用\"></a><code>DelayQueue</code>的使用</h4><p><code>DelayQueue</code>是一个无界的阻塞队列，实现<code>Delayed</code>接口。只有当<code>delay</code>被激发时，该对象才能从队列中获取数据</p>\n<h3 id=\"线程间通信管道模式-1\"><a href=\"#线程间通信管道模式-1\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3>","site":{"data":{}},"excerpt":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><ul>\n<li>使用单向管道（Pipe）传递数据</li>\n<li>共享内存（Shared Memory）通信</li>\n<li>使用阻塞队列（Blocking Queue）实现生产者-消费者模式</li>\n<li>处理消息队列（Message Queue）</li>\n</ul>","more":"<h2 id=\"wait-notify机制\"><a href=\"#wait-notify机制\" class=\"headerlink\" title=\"wait/notify机制\"></a>wait/notify机制</h2><p>等待/通知机制主要由Object类中的三个方法进行保证</p>\n<p>1、wait()；notify();notifyAll()<br>上述三个方法均为Object类中声明的方法，而非在Thread类中进行声明；每一个对象都拥有monitor，等待该对象的锁，应该通过操作该对象进行操作，而非通过当前线程来操作；<code>wait();notify();notifyAll()</code>只有在被<code>synchronized </code>修饰的方法中，或者在锁中，可以进行调用，如果在其他地点调用，则会抛出<code>IllegalMonitorStateException</code>异常。</p>\n<p>1)wait()<br>让当前线程（Thread.cocurrentThread()方法所返回的线程）释放对象所锁并进入阻塞状态,等待另一线程改变外界变量唤醒；调用<code>notify()</code>或者<code>notifyAll()</code>时唤醒当前线程。<code>wait()</code>也可以作为任务同步的一种方式。</p>\n<p><strong>注：调用<code>sleep()</code>和<code>yield()</code>方法不能释放当前的对象锁</strong><br><code>wait()</code>方法有两种用法：</p>\n<ul>\n<li><code> wait(long timeout)</code>等待一定的时间，但与<code>sleep()</code>方法不同，其会释放对象锁</li>\n<li>使用<code>wait()</code>等待<code>notify()</code>或者<code>notifyAll()</code>唤醒。 </li>\n</ul>\n<p>2)notify()<br>唤醒一个正在等待相应对象锁的线程，使其进入就绪队列；</p>\n<p>3)notifyAll()<br>唤醒所有正在等待相应对象锁的线程，相对于，使他们进入就绪队列，在调用该方法时，首先需要获取到对象锁，在可以进行调用;通过<code>synchronized(x)</code>来获取对象锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(x) &#123; </span><br><span class=\"line\">  x.notifyAll();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>2、方法调用与线程状态关系</p>\n<p>每个对象锁都有两个队列，一个是就绪队列，一个是阻塞队列</p>\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p>Condition是在Java 1.5中出现的，用于替代传统的Object的wait()/notify(),它的使用依赖于Lock;Condition的await()/sigmal()比Object的wait()/notify()更高效与安全。Condition的await()/signal()的使用都必须在lock的保护之内，即在lock.lock()与lock.unlock()之间使用；</p>\n<p>对应关系</p>\n<ul>\n<li>Condition中的await()对应Object的wait()</li>\n<li>Condition中的signal()对应Object的notify()</li>\n<li>Condition中的signalAll()对应Object中的notifyAll();</li>\n</ul>\n<p><strong>Condition实现一种分组机制，将所有对临街资源进行访问的线程进行分组，以便实现线程间更精细化的操作，例如通知部分线程；多个线程可以竞争一把锁，一把锁也可以关联多个Condition,以便多个线程进行通信和协同</strong></p>\n<h3 id=\"生产者消费者模型\"><a href=\"#生产者消费者模型\" class=\"headerlink\" title=\"生产者消费者模型\"></a>生产者消费者模型</h3><p>线程锁控制代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">//生产者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionCustomer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//消费者线程控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition conditionProducer=lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">//用于表示需要生产</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//用于随机消费时间；</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于生产者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;生产线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;await&quot;</span>);</span><br><span class=\"line\">                conditionCustomer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;生产中&quot;</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">500</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;生产完毕&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;唤醒所有消费者线程 &quot;</span>+<span class=\"string\">&quot;....&quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的消费者线程</span></span><br><span class=\"line\">            conditionProducer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于消费者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">custome</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!hasValue)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;消费线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;await&quot;</span>);</span><br><span class=\"line\">                conditionProducer.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;消费中&quot;</span>);</span><br><span class=\"line\">            Thread.sleep(rand.nextInt(<span class=\"number\">4000</span>));</span><br><span class=\"line\">            hasValue=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class=\"string\">&quot;消费完毕&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;唤醒所有生产者线程 &quot;</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//唤起所有的生产者线程</span></span><br><span class=\"line\">            conditionCustomer.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>消费者线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomerThread</span><span class=\"params\">(Service service)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            service.custome();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer_ServiceMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Service service=<span class=\"keyword\">new</span> Service();</span><br><span class=\"line\">        CustomerThread[] customerThread=<span class=\"keyword\">new</span> CustomerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        ProducerThread[] producerThreads=<span class=\"keyword\">new</span> ProducerThread[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">            customerThread[i]=<span class=\"keyword\">new</span> CustomerThread(service);</span><br><span class=\"line\">            customerThread[i].setName(<span class=\"string\">&quot;生产者Thread：&quot;</span>+i);</span><br><span class=\"line\">            producerThreads[i]=<span class=\"keyword\">new</span> ProducerThread(service);</span><br><span class=\"line\">            producerThreads[i].setName(<span class=\"string\">&quot;消费者Thread：&quot;</span>+i);</span><br><span class=\"line\">            customerThread[i].start();</span><br><span class=\"line\">            producerThreads[i].start();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果,出现未被唤起的线程，我认为是当前线程正在执行生产或者消费任务，无需进行唤起操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：2await</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">生产线程：消费者Thread：1await</span><br><span class=\"line\">生产线程：消费者Thread：0await</span><br><span class=\"line\">线程：生产者Thread：2消费中</span><br><span class=\"line\">线程：生产者Thread：2消费完毕</span><br><span class=\"line\">生产者Thread：2唤醒所有生产者线程 </span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\">消费线程：生产者Thread：2await</span><br><span class=\"line\">消费线程：生产者Thread：1await</span><br><span class=\"line\">消费线程：生产者Thread：0await</span><br><span class=\"line\">线程：消费者Thread：2生产中</span><br><span class=\"line\">线程：消费者Thread：2生产完毕</span><br><span class=\"line\">消费者Thread：2唤醒所有消费者线程 ....</span><br><span class=\"line\">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"线程间通信管道模式\"><a href=\"#线程间通信管道模式\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3><h4 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h4><p>用于同步一个或者多个任务，强制它们等待一系列的其他任务操作的结束。</p>\n<p>任务执行线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用CountDownLatch会被自动要求加上此构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(CountDownLatch latch, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setName(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doWork();</span><br><span class=\"line\">            <span class=\"comment\">//用于倒数技术</span></span><br><span class=\"line\">            latch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//random.nextInt(2000)在Java中是线程安全的来自TIJ</span></span><br><span class=\"line\">        TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.getName() + <span class=\"string\">&quot;completed&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等待任务执行完毕，需要唤醒的线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitingTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch latch;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WaitingTask</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           latch.await();</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;Latch阻塞运行至waiting class&quot;</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCountDown</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService exec = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">//所有需要同时结束的线程，需要使用同一个CountDownLatch对象，构造函数用于表示需要等待的线程的个数</span></span><br><span class=\"line\">        CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(SIZE);</span><br><span class=\"line\">      <span class=\"comment\">// for (int i=0;i&lt;10;i++)&#123;   //可以有多个等待线程</span></span><br><span class=\"line\">        exec.execute(<span class=\"keyword\">new</span> WaitingTask(latch));</span><br><span class=\"line\">      <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> Task(latch,<span class=\"string\">&quot;线程&quot;</span>+i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;启动所有任务&quot;</span>);</span><br><span class=\"line\">        exec.shutdown();  <span class=\"comment\">//任务只有在执行完毕后才会结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>任务执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动所有任务</span><br><span class=\"line\">线程0completed</span><br><span class=\"line\">线程4completed</span><br><span class=\"line\">线程1completed</span><br><span class=\"line\">线程2completed</span><br><span class=\"line\">线程3completed</span><br><span class=\"line\">Latch阻塞运行至waiting class</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h4><p><code>CyclicBarrier</code>类用于创建一组并行的类，等待它们全部执行完成进入后续的任务(类似于<code>join</code>)，与<code>CountDownLatch</code>类的使用类似，<code>CountDownLatch</code>类只能执行一次，而<code>CyclicBarrier</code>可以进行多次使用。<br>以运动员百米跑步测试为例，有五名运动员，会进行多次百米测试，只有所有运动员都跑完一百米后才进入下一轮；</p>\n<p>运动员代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Athlete</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示耗时</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> time =<span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random rand = <span class=\"keyword\">new</span> Random(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Athlete</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cyclicBarrier=cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">double</span> <span class=\"title\">getTime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> time;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.interrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                    time =(<span class=\"keyword\">double</span>)(rand.nextInt(<span class=\"number\">20</span>)+<span class=\"number\">90</span>)/<span class=\"number\">10</span>;</span><br><span class=\"line\">                    System.out.println(getName()+<span class=\"string\">&quot;跑步耗时：&quot;</span>+ getTime());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>所有运动员跑完标志输出代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunningCtrl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RunningCtrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>测试代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RunningCtrl  runningCtrl=<span class=\"keyword\">new</span> RunningCtrl();</span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>,runningCtrl);</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Athlete athlete = <span class=\"keyword\">new</span> Athlete(cyclicBarrier);</span><br><span class=\"line\">            athlete.setName(<span class=\"string\">&quot;选手：&quot;</span>+i);</span><br><span class=\"line\">            exec.execute(athlete);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">选手：0跑步耗时：9.5</span><br><span class=\"line\">选手：1跑步耗时：9.8</span><br><span class=\"line\">选手：4跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：0跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.8</span><br><span class=\"line\">选手：1跑步耗时：9.6</span><br><span class=\"line\">选手：4跑步耗时：9.4</span><br><span class=\"line\">选手：3跑步耗时：10.8</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：9.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：9.2</span><br><span class=\"line\">选手：2跑步耗时：9.3</span><br><span class=\"line\">选手：0跑步耗时：10.3</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">选手：2跑步耗时：9.2</span><br><span class=\"line\">选手：0跑步耗时：9.9</span><br><span class=\"line\">选手：3跑步耗时：10.2</span><br><span class=\"line\">选手：4跑步耗时：10.6</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：4跑步耗时：10.2</span><br><span class=\"line\">选手：2跑步耗时：10.9</span><br><span class=\"line\">选手：0跑步耗时：10.6</span><br><span class=\"line\">选手：3跑步耗时：10.0</span><br><span class=\"line\">选手：1跑步耗时：10.4</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br><span class=\"line\">选手：2跑步耗时：10.8</span><br><span class=\"line\">选手：4跑步耗时：10.9</span><br><span class=\"line\">选手：1跑步耗时：10.7</span><br><span class=\"line\">选手：3跑步耗时：10.3</span><br><span class=\"line\">选手：0跑步耗时：9.2</span><br><span class=\"line\">++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>\n<h4 id=\"DelayQueue的使用\"><a href=\"#DelayQueue的使用\" class=\"headerlink\" title=\"DelayQueue的使用\"></a><code>DelayQueue</code>的使用</h4><p><code>DelayQueue</code>是一个无界的阻塞队列，实现<code>Delayed</code>接口。只有当<code>delay</code>被激发时，该对象才能从队列中获取数据</p>\n<h3 id=\"线程间通信管道模式-1\"><a href=\"#线程间通信管道模式-1\" class=\"headerlink\" title=\"线程间通信管道模式\"></a>线程间通信管道模式</h3>"},{"title":"Kotlin Lambda表达式","cover":"/cover/img66.jpg","toc":true,"description":"Kotlin Lambda表达式","type":["Kotlin"],"date":"2019-07-29T16:00:00.000Z","_content":"\n\n\n### 使用Lambda表达式遍历数组\n\n```kotlin\n    //val\n    stringArrays.forEach({\n        it->println(it)\n     })\n\n```\n<!--more-->\nKotlin中Array的`forEach()`函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；`action: (T) -> Unit`中`(T) -> Unit`是lambda表达式的类型，即函数的类型，此函数参数类型为`T`返回值为`Unit`\n\n```kotlin\n\n    public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n        for (element in this) action(element)\n    }\n```\n\nlambda表达式作为形参的类型\n\n```kotlin\n    ()->Int          //无参数，返回Int类型\n    (Int,Int)->Int   //两个整型参数，返回Int\n    (()->Unit,Int)->Int //一个lambda表达式参数，一个整型参数，返回Int \n\n```\n\n\n在kotlin中，可以把函数的最后一个lambda表达式移到括号外\n\n```kotlin\n    stringArrays.forEach(){\n        it->println(it)\n    }\n\n```\n\n如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用\n\n```kotlin\n    stringArrays.forEach(::println)\n\n```\n\n使用标签从Lambda表达式中返回,其中`forEachItem`为自定义标签，`@forEachItem`与return之间不能存在空格\n```kotlin\n    stringArrays.forEach forEachItem@{\n            if (it==1) return@forEachItem\n    }\n```\n\n\n\n在Lambda中最后一个表达式的值是默认的返回值\n\n\n\n#### 高阶函数\n\n高阶函数是将函数用作参数或返回值的函数\n","source":"_posts/Kotlin/Kotlin基础/Lambda表达式.md","raw":"---\ntitle: Kotlin Lambda表达式\ncover:  /cover/img66.jpg\ntoc: true\ndescription: Kotlin Lambda表达式\ncategories: Kotlin\ntype: [Kotlin]\ndate: 2019/07/30\n---\n\n\n\n### 使用Lambda表达式遍历数组\n\n```kotlin\n    //val\n    stringArrays.forEach({\n        it->println(it)\n     })\n\n```\n<!--more-->\nKotlin中Array的`forEach()`函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；`action: (T) -> Unit`中`(T) -> Unit`是lambda表达式的类型，即函数的类型，此函数参数类型为`T`返回值为`Unit`\n\n```kotlin\n\n    public inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n        for (element in this) action(element)\n    }\n```\n\nlambda表达式作为形参的类型\n\n```kotlin\n    ()->Int          //无参数，返回Int类型\n    (Int,Int)->Int   //两个整型参数，返回Int\n    (()->Unit,Int)->Int //一个lambda表达式参数，一个整型参数，返回Int \n\n```\n\n\n在kotlin中，可以把函数的最后一个lambda表达式移到括号外\n\n```kotlin\n    stringArrays.forEach(){\n        it->println(it)\n    }\n\n```\n\n如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用\n\n```kotlin\n    stringArrays.forEach(::println)\n\n```\n\n使用标签从Lambda表达式中返回,其中`forEachItem`为自定义标签，`@forEachItem`与return之间不能存在空格\n```kotlin\n    stringArrays.forEach forEachItem@{\n            if (it==1) return@forEachItem\n    }\n```\n\n\n\n在Lambda中最后一个表达式的值是默认的返回值\n\n\n\n#### 高阶函数\n\n高阶函数是将函数用作参数或返回值的函数\n","slug":"Kotlin/Kotlin基础/Lambda表达式","published":1,"updated":"2021-01-05T12:15:34.075Z","_id":"ckjju0m1x006i20uacu3vcnvs","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"使用Lambda表达式遍历数组\"><a href=\"#使用Lambda表达式遍历数组\" class=\"headerlink\" title=\"使用Lambda表达式遍历数组\"></a>使用Lambda表达式遍历数组</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//val</span></span><br><span class=\"line\">stringArrays.forEach(&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>Kotlin中Array的<code>forEach()</code>函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；<code>action: (T) -&gt; Unit</code>中<code>(T) -&gt; Unit</code>是lambda表达式的类型，即函数的类型，此函数参数类型为<code>T</code>返回值为<code>Unit</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lambda表达式作为形参的类型</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">()-&gt;<span class=\"built_in\">Int</span>          <span class=\"comment\">//无参数，返回Int类型</span></span><br><span class=\"line\">(<span class=\"built_in\">Int</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span>   <span class=\"comment\">//两个整型参数，返回Int</span></span><br><span class=\"line\">(()-&gt;<span class=\"built_in\">Unit</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span> <span class=\"comment\">//一个lambda表达式参数，一个整型参数，返回Int </span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在kotlin中，可以把函数的最后一个lambda表达式移到括号外</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach()&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach(::println)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>使用标签从Lambda表达式中返回,其中<code>forEachItem</code>为自定义标签，<code>@forEachItem</code>与return之间不能存在空格</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach <span class=\"symbol\">forEachItem@</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it==<span class=\"number\">1</span>) <span class=\"keyword\">return</span><span class=\"symbol\">@forEachItem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在Lambda中最后一个表达式的值是默认的返回值</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>高阶函数是将函数用作参数或返回值的函数</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"使用Lambda表达式遍历数组\"><a href=\"#使用Lambda表达式遍历数组\" class=\"headerlink\" title=\"使用Lambda表达式遍历数组\"></a>使用Lambda表达式遍历数组</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//val</span></span><br><span class=\"line\">stringArrays.forEach(&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","more":"<p>Kotlin中Array的<code>forEach()</code>函数源码如下，它是一个扩展方法，在for循环中调用我们传入的lambda表达式；<code>action: (T) -&gt; Unit</code>中<code>(T) -&gt; Unit</code>是lambda表达式的类型，即函数的类型，此函数参数类型为<code>T</code>返回值为<code>Unit</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">inline</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> Array<span class=\"type\">&lt;out T&gt;</span>.<span class=\"title\">forEach</span><span class=\"params\">(action: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Unit</span>)</span></span>: <span class=\"built_in\">Unit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>) action(element)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lambda表达式作为形参的类型</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">()-&gt;<span class=\"built_in\">Int</span>          <span class=\"comment\">//无参数，返回Int类型</span></span><br><span class=\"line\">(<span class=\"built_in\">Int</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span>   <span class=\"comment\">//两个整型参数，返回Int</span></span><br><span class=\"line\">(()-&gt;<span class=\"built_in\">Unit</span>,<span class=\"built_in\">Int</span>)-&gt;<span class=\"built_in\">Int</span> <span class=\"comment\">//一个lambda表达式参数，一个整型参数，返回Int </span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在kotlin中，可以把函数的最后一个lambda表达式移到括号外</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach()&#123;</span><br><span class=\"line\">    it-&gt;println(it)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果lambda表达式里只有一个函数调用，并且这个函数的参数也是Lambda表达式的参数，那么可以使用函数引用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach(::println)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>使用标签从Lambda表达式中返回,其中<code>forEachItem</code>为自定义标签，<code>@forEachItem</code>与return之间不能存在空格</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stringArrays.forEach <span class=\"symbol\">forEachItem@</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (it==<span class=\"number\">1</span>) <span class=\"keyword\">return</span><span class=\"symbol\">@forEachItem</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>在Lambda中最后一个表达式的值是默认的返回值</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>高阶函数是将函数用作参数或返回值的函数</p>"},{"title":"Java代理模式","cover":"/cover/img64.jpg","description":"Java代理模式","toc":true,"type":["Java"],"date":"2019-08-19T16:00:00.000Z","_content":"\n# 代理模式\n\n### 代理模式介绍\n\n代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。\n<!--more-->\n代理模式主要由三部分组成：\n* Subject：一个将方法暴露给client的接口\n* Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类\n* Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。\n\n代理模式的结构\n![](public/img/Java/proxy-design-pattern.jpg)\n\n\n### 静态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyTest extends RealSubject {\n        @Override\n        public void doSomething() {\n            System.out.println(\"proxy输出\");\n            super.doSomething();\n        }\n    }\n```\n测试类client\n```java\n    public class Client {\n\n        public static void main(String[] args) {\n            RealSubject proxy=new ProxyTest();\n            proxy.doSomething();\n        }\n    }\n    \n    //输出\n    //proxy输出\n    //RealSubject 输出\n\n```\n\n### 动态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyHandler implements InvocationHandler {\n\n        private Object tar;\n\n        //绑定委托对象，并返回代理类\n        public Object bind(Object tar){\n            this.tar=tar;\n            return                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this);\n        }\n\n        @Override\n        public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        \n            Object result=null;\n            //这里可以进行所谓的AOP编程\n            //在调用具体函数方法项之前，执行功能处理\n            result=method.invoke(tar,objects);\n            //在调用具体函数方法项之后，执行功能处理\n            return result;\n        }\n    }\n\n```\n\nClient\n```java\n    public class Client {\n\n    public static void main(String[] args) {\n\n        ProxyHandler proxyHandler=new ProxyHandler();\n        //绑定该类实现的所有接口\n        Subject sub=(Subject)proxyHandler.bind(new RealSubject());\n        sub.doSomething();\n        }\n    }\n```\n\n#### 动态代理模式详解\n\n#### InvocationHandler接口介绍\nInvocationHandler 源码\n```java\n    public interface InvocationHandler {\n        Object invoke(Object var1, Method var2, Object[] var3) throws     Throwable;\n    }\n```\nInvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。\n\n`invoke(Object var1, Method var2, Object[] var3)`方法中有三个参数：\n* Object var1：指代代理的真实对象\n* Method method：指代真实对象调用的方法\n* Object[] args：指代真实对象调用方法时的参数\n\n\n\n#### Proxy 类介绍\n\nProxy用来动态创建一个代理对象的类，\n`newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2)`方法中的参数\n\n* ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区\n* Class<?>[] var1：给代理对象提供的接口类型\n* InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法\n\n源码\n\n```java\n    public class Proxy implements Serializable {\n\n        public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) throws IllegalArgumentException {\n            Objects.requireNonNull(var2);\n            Class[] var3 = (Class[])var1.clone();                //用于将传入的Class进行复制       \n            SecurityManager var4 = System.getSecurityManager();\n            if (var4 != null) {\n                checkProxyAccess(Reflection.getCallerClass(), var0, var3);\n            }\n            //调用 getProxyClass0() 方法\n            Class var5 = getProxyClass0(var0, var3);\n\n            try {\n                if (var4 != null) {\n                    checkNewProxyPermission(Reflection.getCallerClass(), var5);\n                }\n                final Constructor var6 = var5.getConstructor(constructorParams);  //通过反射类中的Constructor获取构造函数\n                if (!Modifier.isPublic(var5.getModifiers())) {\n                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        var6.setAccessible(true);\n                        return null;\n                        }\n                    });\n                }\n               // 通过Constructor返回代理类的实例\n                return var6.newInstance(var2);\n            } //catch省略\n        }\n\n\n```\n`getProxyClass0()`源码，从缓存中获取代理类对象\n\n```java\n    public class Proxy implements Serializable {\n       //proxyClassCache对象定义\n        private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n        \n        //......\n        private static Class<?> getProxyClass0(ClassLoader var0, Class<?>... var1) {\n        if (var1.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        } else {\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        //......\n    }\n\n```java\n\n\n\n\n\n\n\n\n","source":"_posts/Java/设计模式/代理模式.md","raw":"---\ntitle: Java代理模式\ncover:  /cover/img64.jpg\ndescription: Java代理模式\ntoc: true\ncategories: Java\ntype: [Java]\ndate: 2019/08/20\n---\n\n# 代理模式\n\n### 代理模式介绍\n\n代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。\n<!--more-->\n代理模式主要由三部分组成：\n* Subject：一个将方法暴露给client的接口\n* Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类\n* Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。\n\n代理模式的结构\n![](public/img/Java/proxy-design-pattern.jpg)\n\n\n### 静态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyTest extends RealSubject {\n        @Override\n        public void doSomething() {\n            System.out.println(\"proxy输出\");\n            super.doSomething();\n        }\n    }\n```\n测试类client\n```java\n    public class Client {\n\n        public static void main(String[] args) {\n            RealSubject proxy=new ProxyTest();\n            proxy.doSomething();\n        }\n    }\n    \n    //输出\n    //proxy输出\n    //RealSubject 输出\n\n```\n\n### 动态代理实现方式\nSubject\n```java\n    public interface Subject{\n        public void doSomething();\n    }\n    \n```\n\nReal Subject\n```java\n    public class RealSubject implements Subject{\n         @Override\n        public void doSomething() {\n          System.out.println(\"RealSubject 输出\");\n        }\n    }\n```\nProxy\n```java\n    public class ProxyHandler implements InvocationHandler {\n\n        private Object tar;\n\n        //绑定委托对象，并返回代理类\n        public Object bind(Object tar){\n            this.tar=tar;\n            return                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),this);\n        }\n\n        @Override\n        public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        \n            Object result=null;\n            //这里可以进行所谓的AOP编程\n            //在调用具体函数方法项之前，执行功能处理\n            result=method.invoke(tar,objects);\n            //在调用具体函数方法项之后，执行功能处理\n            return result;\n        }\n    }\n\n```\n\nClient\n```java\n    public class Client {\n\n    public static void main(String[] args) {\n\n        ProxyHandler proxyHandler=new ProxyHandler();\n        //绑定该类实现的所有接口\n        Subject sub=(Subject)proxyHandler.bind(new RealSubject());\n        sub.doSomething();\n        }\n    }\n```\n\n#### 动态代理模式详解\n\n#### InvocationHandler接口介绍\nInvocationHandler 源码\n```java\n    public interface InvocationHandler {\n        Object invoke(Object var1, Method var2, Object[] var3) throws     Throwable;\n    }\n```\nInvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。\n\n`invoke(Object var1, Method var2, Object[] var3)`方法中有三个参数：\n* Object var1：指代代理的真实对象\n* Method method：指代真实对象调用的方法\n* Object[] args：指代真实对象调用方法时的参数\n\n\n\n#### Proxy 类介绍\n\nProxy用来动态创建一个代理对象的类，\n`newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2)`方法中的参数\n\n* ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区\n* Class<?>[] var1：给代理对象提供的接口类型\n* InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法\n\n源码\n\n```java\n    public class Proxy implements Serializable {\n\n        public static Object newProxyInstance(ClassLoader var0, Class<?>[] var1, InvocationHandler var2) throws IllegalArgumentException {\n            Objects.requireNonNull(var2);\n            Class[] var3 = (Class[])var1.clone();                //用于将传入的Class进行复制       \n            SecurityManager var4 = System.getSecurityManager();\n            if (var4 != null) {\n                checkProxyAccess(Reflection.getCallerClass(), var0, var3);\n            }\n            //调用 getProxyClass0() 方法\n            Class var5 = getProxyClass0(var0, var3);\n\n            try {\n                if (var4 != null) {\n                    checkNewProxyPermission(Reflection.getCallerClass(), var5);\n                }\n                final Constructor var6 = var5.getConstructor(constructorParams);  //通过反射类中的Constructor获取构造函数\n                if (!Modifier.isPublic(var5.getModifiers())) {\n                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        var6.setAccessible(true);\n                        return null;\n                        }\n                    });\n                }\n               // 通过Constructor返回代理类的实例\n                return var6.newInstance(var2);\n            } //catch省略\n        }\n\n\n```\n`getProxyClass0()`源码，从缓存中获取代理类对象\n\n```java\n    public class Proxy implements Serializable {\n       //proxyClassCache对象定义\n        private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n        \n        //......\n        private static Class<?> getProxyClass0(ClassLoader var0, Class<?>... var1) {\n        if (var1.length > 65535) {\n            throw new IllegalArgumentException(\"interface limit exceeded\");\n        } else {\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        }\n        }\n        //......\n    }\n\n```java\n\n\n\n\n\n\n\n\n","slug":"Java/设计模式/代理模式","published":1,"updated":"2021-01-06T01:05:16.006Z","_id":"ckjju0m1x006l20ua1cbc1tw3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"代理模式介绍\"><a href=\"#代理模式介绍\" class=\"headerlink\" title=\"代理模式介绍\"></a>代理模式介绍</h3><p>代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。</p>\n<a id=\"more\"></a>\n<p>代理模式主要由三部分组成：</p>\n<ul>\n<li>Subject：一个将方法暴露给client的接口</li>\n<li>Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类</li>\n<li>Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。</li>\n</ul>\n<p>代理模式的结构<br><img src=\"public/img/Java/proxy-design-pattern.jpg\"></p>\n<h3 id=\"静态代理实现方式\"><a href=\"#静态代理实现方式\" class=\"headerlink\" title=\"静态代理实现方式\"></a>静态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;RealSubject 输出&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RealSubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;proxy输出&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RealSubject proxy=<span class=\"keyword\">new</span> ProxyTest();</span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//proxy输出</span></span><br><span class=\"line\"><span class=\"comment\">//RealSubject 输出</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"动态代理实现方式\"><a href=\"#动态代理实现方式\" class=\"headerlink\" title=\"动态代理实现方式\"></a>动态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;RealSubject 输出&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object tar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定委托对象，并返回代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tar=tar;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Object result=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里可以进行所谓的AOP编程</span></span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之前，执行功能处理</span></span><br><span class=\"line\">        result=method.invoke(tar,objects);</span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之后，执行功能处理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyHandler proxyHandler=<span class=\"keyword\">new</span> ProxyHandler();</span><br><span class=\"line\">    <span class=\"comment\">//绑定该类实现的所有接口</span></span><br><span class=\"line\">    Subject sub=(Subject)proxyHandler.bind(<span class=\"keyword\">new</span> RealSubject());</span><br><span class=\"line\">    sub.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态代理模式详解\"><a href=\"#动态代理模式详解\" class=\"headerlink\" title=\"动态代理模式详解\"></a>动态代理模式详解</h4><h4 id=\"InvocationHandler接口介绍\"><a href=\"#InvocationHandler接口介绍\" class=\"headerlink\" title=\"InvocationHandler接口介绍\"></a>InvocationHandler接口介绍</h4><p>InvocationHandler 源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Method var2, Object[] var3)</span> <span class=\"keyword\">throws</span>     Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>\n<p><code>invoke(Object var1, Method var2, Object[] var3)</code>方法中有三个参数：</p>\n<ul>\n<li>Object var1：指代代理的真实对象</li>\n<li>Method method：指代真实对象调用的方法</li>\n<li>Object[] args：指代真实对象调用方法时的参数</li>\n</ul>\n<h4 id=\"Proxy-类介绍\"><a href=\"#Proxy-类介绍\" class=\"headerlink\" title=\"Proxy 类介绍\"></a>Proxy 类介绍</h4><p>Proxy用来动态创建一个代理对象的类，<br><code>newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</code>方法中的参数</p>\n<ul>\n<li>ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区</li>\n<li>Class&lt;?&gt;[] var1：给代理对象提供的接口类型</li>\n<li>InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法</li>\n</ul>\n<p>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(var2);</span><br><span class=\"line\">        Class[] var3 = (Class[])var1.clone();                <span class=\"comment\">//用于将传入的Class进行复制       </span></span><br><span class=\"line\">        SecurityManager var4 = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), var0, var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用 getProxyClass0() 方法</span></span><br><span class=\"line\">        Class var5 = getProxyClass0(var0, var3);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), var5);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor var6 = var5.getConstructor(constructorParams);  <span class=\"comment\">//通过反射类中的Constructor获取构造函数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(var5.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    var6.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 通过Constructor返回代理类的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> var6.newInstance(var2);</span><br><span class=\"line\">        &#125; <span class=\"comment\">//catch省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>getProxyClass0()</code>源码，从缓存中获取代理类对象</p>\n<pre><code class=\"java\">    public class Proxy implements Serializable &#123;\n       //proxyClassCache对象定义\n        private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n\n        //......\n        private static Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) &#123;\n        if (var1.length &gt; 65535) &#123;\n            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);\n        &#125; else &#123;\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        &#125;\n        &#125;\n        //......\n    &#125;\n\n```java\n\n\n\n\n\n\n\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><h3 id=\"代理模式介绍\"><a href=\"#代理模式介绍\" class=\"headerlink\" title=\"代理模式介绍\"></a>代理模式介绍</h3><p>代理模式又被称为委托模式，一个代理类为另一个类提供代理；使用代理模式可以隐藏原始的类，并控制对其的访问，当我们想要使用一个可以充当接口的类时，可以使用代理模式；代理模式也被大量使用在懒加载中。</p>","more":"<p>代理模式主要由三部分组成：</p>\n<ul>\n<li>Subject：一个将方法暴露给client的接口</li>\n<li>Real Subject：实现Subject接口的类，重是方法的实现，在代理模式中需要被隐藏的类</li>\n<li>Proxy：继承Real Subject并将其进行隐藏，Client与real subject之间的调用直接通过Proxy进行。</li>\n</ul>\n<p>代理模式的结构<br><img src=\"public/img/Java/proxy-design-pattern.jpg\"></p>\n<h3 id=\"静态代理实现方式\"><a href=\"#静态代理实现方式\" class=\"headerlink\" title=\"静态代理实现方式\"></a>静态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;RealSubject 输出&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RealSubject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;proxy输出&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RealSubject proxy=<span class=\"keyword\">new</span> ProxyTest();</span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"comment\">//proxy输出</span></span><br><span class=\"line\"><span class=\"comment\">//RealSubject 输出</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"动态代理实现方式\"><a href=\"#动态代理实现方式\" class=\"headerlink\" title=\"动态代理实现方式\"></a>动态代理实现方式</h3><p>Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Real Subject</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;RealSubject 输出&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Proxy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object tar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//绑定委托对象，并返回代理类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">bind</span><span class=\"params\">(Object tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tar=tar;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>                         Proxy.newProxyInstance(tar.getClass().getClassLoader(),tar.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object o, Method method, Object[] objects)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Object result=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里可以进行所谓的AOP编程</span></span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之前，执行功能处理</span></span><br><span class=\"line\">        result=method.invoke(tar,objects);</span><br><span class=\"line\">        <span class=\"comment\">//在调用具体函数方法项之后，执行功能处理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ProxyHandler proxyHandler=<span class=\"keyword\">new</span> ProxyHandler();</span><br><span class=\"line\">    <span class=\"comment\">//绑定该类实现的所有接口</span></span><br><span class=\"line\">    Subject sub=(Subject)proxyHandler.bind(<span class=\"keyword\">new</span> RealSubject());</span><br><span class=\"line\">    sub.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态代理模式详解\"><a href=\"#动态代理模式详解\" class=\"headerlink\" title=\"动态代理模式详解\"></a>动态代理模式详解</h4><h4 id=\"InvocationHandler接口介绍\"><a href=\"#InvocationHandler接口介绍\" class=\"headerlink\" title=\"InvocationHandler接口介绍\"></a>InvocationHandler接口介绍</h4><p>InvocationHandler 源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object var1, Method var2, Object[] var3)</span> <span class=\"keyword\">throws</span>     Throwable</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>\n<p><code>invoke(Object var1, Method var2, Object[] var3)</code>方法中有三个参数：</p>\n<ul>\n<li>Object var1：指代代理的真实对象</li>\n<li>Method method：指代真实对象调用的方法</li>\n<li>Object[] args：指代真实对象调用方法时的参数</li>\n</ul>\n<h4 id=\"Proxy-类介绍\"><a href=\"#Proxy-类介绍\" class=\"headerlink\" title=\"Proxy 类介绍\"></a>Proxy 类介绍</h4><p>Proxy用来动态创建一个代理对象的类，<br><code>newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</code>方法中的参数</p>\n<ul>\n<li>ClassLoader var0：一个ClassLoader对象，即用哪个类加载器来加载这个代理类到 JVM 的方法区</li>\n<li>Class&lt;?&gt;[] var1：给代理对象提供的接口类型</li>\n<li>InvocationHandler var2：InvocationHandler的实现的实例对象,表示方法调用时会调用哪一个InvocationHandler的invoke方法</li>\n</ul>\n<p>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(var2);</span><br><span class=\"line\">        Class[] var3 = (Class[])var1.clone();                <span class=\"comment\">//用于将传入的Class进行复制       </span></span><br><span class=\"line\">        SecurityManager var4 = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkProxyAccess(Reflection.getCallerClass(), var0, var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用 getProxyClass0() 方法</span></span><br><span class=\"line\">        Class var5 = getProxyClass0(var0, var3);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var4 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                checkNewProxyPermission(Reflection.getCallerClass(), var5);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Constructor var6 = var5.getConstructor(constructorParams);  <span class=\"comment\">//通过反射类中的Constructor获取构造函数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Modifier.isPublic(var5.getModifiers())) &#123;</span><br><span class=\"line\">                AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    var6.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 通过Constructor返回代理类的实例</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> var6.newInstance(var2);</span><br><span class=\"line\">        &#125; <span class=\"comment\">//catch省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>getProxyClass0()</code>源码，从缓存中获取代理类对象</p>\n<pre><code class=\"java\">    public class Proxy implements Serializable &#123;\n       //proxyClassCache对象定义\n        private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache(new Proxy.KeyFactory(), new Proxy.ProxyClassFactory());\n\n        //......\n        private static Class&lt;?&gt; getProxyClass0(ClassLoader var0, Class&lt;?&gt;... var1) &#123;\n        if (var1.length &gt; 65535) &#123;\n            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);\n        &#125; else &#123;\n            // proxyClassCache 来做一个中间的缓存\n            return (Class)proxyClassCache.get(var0, var1);\n        &#125;\n        &#125;\n        //......\n    &#125;\n\n```java\n\n\n\n\n\n\n\n</code></pre>"},{"title":"工厂模式","description":"工厂模式","type":["Java"],"toc":true,"cover":"/cover/img110.jpg","date":"2019-08-28T16:00:00.000Z","_content":"\n## 工厂模式\n\n提供一个创建对象的功能，不需要关心其具体的实现；简单工程模式降低了模块间的耦合度\n\n工厂模式的实现：\n\n1、创建需要多次实例化的类UserInfo\n\n```java\n    public class UserInfo{\n        private String name;\n        private int age;\n\n        public UserInfo(){\n\n        }\n\n        public UserInfo( String name){\n            this.name=name;\n        }\n\n        public UserInfo( String name,int age){\n            this.name=name;\n            this.age=age;\n        }\n        //省略get和set方法\n    }\n\n```\n\n2、创建一个API接口\n\n```java\n    public interface Api{\n\n        UserInfo create();\n \n    }\n```\n\n3、实现API接口\n\n```java\n\n    public class ApiImpl implements Api{\n\n       @Override \n       public UserInfo create(){\n           UserInfo info=new UserInfo();\n           return info\n       }\n\n    }\n\n    public class ApiImpl2 implements Api{\n\n       @Override \n       public UserInfo create(String name){\n           UserInfo info=new UserInfo(name);\n           return info\n       }\n\n    }\n\n```\n\n4、创建UserInfo对象工厂\n\n```java\n\n    public class UserInfoFactory(){\n        \n        public static Api createApi(){\n            return new ApiImpl.create();\n        }\n\n        public static Api createApi(String name){\n            return new ApiImpl2.create(name);\n        }\n    }\n\n```\n\n5、工厂模式的使用\n\n```java\n\n    UserInfo userInfo =UserInfoFactory.createApi();\n    UserInfo userInfo2 =UserInfoFactory.createApi(\"Test\");\n```","source":"_posts/Java/设计模式/工厂模式.md","raw":"---\ntitle: \"工厂模式\"\ndescription: \"工厂模式\"\ntype: [Java]\ntoc: true\ncover:  /cover/img110.jpg\ncategories: Java\ndate: 2019/08/29\n---\n\n## 工厂模式\n\n提供一个创建对象的功能，不需要关心其具体的实现；简单工程模式降低了模块间的耦合度\n\n工厂模式的实现：\n\n1、创建需要多次实例化的类UserInfo\n\n```java\n    public class UserInfo{\n        private String name;\n        private int age;\n\n        public UserInfo(){\n\n        }\n\n        public UserInfo( String name){\n            this.name=name;\n        }\n\n        public UserInfo( String name,int age){\n            this.name=name;\n            this.age=age;\n        }\n        //省略get和set方法\n    }\n\n```\n\n2、创建一个API接口\n\n```java\n    public interface Api{\n\n        UserInfo create();\n \n    }\n```\n\n3、实现API接口\n\n```java\n\n    public class ApiImpl implements Api{\n\n       @Override \n       public UserInfo create(){\n           UserInfo info=new UserInfo();\n           return info\n       }\n\n    }\n\n    public class ApiImpl2 implements Api{\n\n       @Override \n       public UserInfo create(String name){\n           UserInfo info=new UserInfo(name);\n           return info\n       }\n\n    }\n\n```\n\n4、创建UserInfo对象工厂\n\n```java\n\n    public class UserInfoFactory(){\n        \n        public static Api createApi(){\n            return new ApiImpl.create();\n        }\n\n        public static Api createApi(String name){\n            return new ApiImpl2.create(name);\n        }\n    }\n\n```\n\n5、工厂模式的使用\n\n```java\n\n    UserInfo userInfo =UserInfoFactory.createApi();\n    UserInfo userInfo2 =UserInfoFactory.createApi(\"Test\");\n```","slug":"Java/设计模式/工厂模式","published":1,"updated":"2021-01-06T01:05:19.818Z","_id":"ckjju0m1y006q20ua8f4p8dye","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>提供一个创建对象的功能，不需要关心其具体的实现；简单工程模式降低了模块间的耦合度</p>\n<p>工厂模式的实现：</p>\n<p>1、创建需要多次实例化的类UserInfo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInfo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInfo</span><span class=\"params\">( String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInfo</span><span class=\"params\">( String name,<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//省略get和set方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、创建一个API接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">UserInfo <span class=\"title\">create</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、实现API接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">create</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       UserInfo info=<span class=\"keyword\">new</span> UserInfo();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> info</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiImpl2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">create</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">       UserInfo info=<span class=\"keyword\">new</span> UserInfo(name);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> info</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>4、创建UserInfo对象工厂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">UserInfoFactory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Api <span class=\"title\">createApi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiImpl.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Api <span class=\"title\">createApi</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiImpl2.create(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>5、工厂模式的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">UserInfo userInfo =UserInfoFactory.createApi();</span><br><span class=\"line\">UserInfo userInfo2 =UserInfoFactory.createApi(<span class=\"string\">&quot;Test&quot;</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>提供一个创建对象的功能，不需要关心其具体的实现；简单工程模式降低了模块间的耦合度</p>\n<p>工厂模式的实现：</p>\n<p>1、创建需要多次实例化的类UserInfo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInfo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInfo</span><span class=\"params\">( String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserInfo</span><span class=\"params\">( String name,<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//省略get和set方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、创建一个API接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">UserInfo <span class=\"title\">create</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、实现API接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">create</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       UserInfo info=<span class=\"keyword\">new</span> UserInfo();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> info</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiImpl2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Api</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> UserInfo <span class=\"title\">create</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">       UserInfo info=<span class=\"keyword\">new</span> UserInfo(name);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> info</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>4、创建UserInfo对象工厂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">UserInfoFactory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Api <span class=\"title\">createApi</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiImpl.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Api <span class=\"title\">createApi</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiImpl2.create(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>5、工厂模式的使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">UserInfo userInfo =UserInfoFactory.createApi();</span><br><span class=\"line\">UserInfo userInfo2 =UserInfoFactory.createApi(<span class=\"string\">&quot;Test&quot;</span>);</span><br></pre></td></tr></table></figure>"},{"title":"Java观察者模式","cover":"/cover/img65.jpg","toc":true,"description":"Java观察者模式","type":["Java"],"date":"2019-08-24T16:00:00.000Z","_content":"\n## 观察者模式、订阅者模式、回调函数对比\n\n在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；\n<!--more-->\n在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心\n\n在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”\n\n\n### 本篇观察者模式主要在Android中实现\n\n\n\n\n\n### 在Java提供了Observer接口和Observable类方便快速实现观察者模式\n\n","source":"_posts/Java/设计模式/观察者模式.md","raw":"---\ntitle: Java观察者模式\ncover:  /cover/img65.jpg\ntoc: true\ndescription: Java观察者模式\ncategories: Java\ntype: [Java]\ndate: 2019/08/25\n---\n\n## 观察者模式、订阅者模式、回调函数对比\n\n在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；\n<!--more-->\n在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心\n\n在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”\n\n\n### 本篇观察者模式主要在Android中实现\n\n\n\n\n\n### 在Java提供了Observer接口和Observable类方便快速实现观察者模式\n\n","slug":"Java/设计模式/观察者模式","published":1,"updated":"2021-01-06T01:07:33.333Z","_id":"ckjju0m1z006t20ua8was7o89","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"观察者模式、订阅者模式、回调函数对比\"><a href=\"#观察者模式、订阅者模式、回调函数对比\" class=\"headerlink\" title=\"观察者模式、订阅者模式、回调函数对比\"></a>观察者模式、订阅者模式、回调函数对比</h2><p>在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；</p>\n<a id=\"more\"></a>\n<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心</p>\n<p>在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”</p>\n<h3 id=\"本篇观察者模式主要在Android中实现\"><a href=\"#本篇观察者模式主要在Android中实现\" class=\"headerlink\" title=\"本篇观察者模式主要在Android中实现\"></a>本篇观察者模式主要在Android中实现</h3><h3 id=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"><a href=\"#在Java提供了Observer接口和Observable类方便快速实现观察者模式\" class=\"headerlink\" title=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"></a>在Java提供了Observer接口和Observable类方便快速实现观察者模式</h3>","site":{"data":{}},"excerpt":"<h2 id=\"观察者模式、订阅者模式、回调函数对比\"><a href=\"#观察者模式、订阅者模式、回调函数对比\" class=\"headerlink\" title=\"观察者模式、订阅者模式、回调函数对比\"></a>观察者模式、订阅者模式、回调函数对比</h2><p>在观察者模式中，观察者需要直接订阅目标事件；在目标事件发出内容改变的事件，直接接收事件，并作出响应；</p>","more":"<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以避免发布者和订阅者之间产生依赖关系；订阅模式有一个统一的调度中心</p>\n<p>在观察者模式以及回调函数中，观察者模式需要维护一个观察者列表，而在回调函数中“被观察者”只保留一个“观察者”</p>\n<h3 id=\"本篇观察者模式主要在Android中实现\"><a href=\"#本篇观察者模式主要在Android中实现\" class=\"headerlink\" title=\"本篇观察者模式主要在Android中实现\"></a>本篇观察者模式主要在Android中实现</h3><h3 id=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"><a href=\"#在Java提供了Observer接口和Observable类方便快速实现观察者模式\" class=\"headerlink\" title=\"在Java提供了Observer接口和Observable类方便快速实现观察者模式\"></a>在Java提供了Observer接口和Observable类方便快速实现观察者模式</h3>"},{"title":"将Hexo博客部署到云服务器上","cover":"/cover/img96.jpg","toc":true,"description":"将Hexo博客部署到云服务器上","type":["Other"],"date":"2020-03-24T16:00:00.000Z","_content":"\n\n## 将Hexo博客部署到云服务器上\n\n在云服务器上部署Hexo博客主要包含两个步骤，配置 nginx 和搭建git仓库，配置自动化部署；\n在本文中使用华为云的Ubuntu服务器\n\n### 安装并配置 nginx\n\nnginx是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。\n\n1、安装 ngixn\n\n```xml\n    apt-get install nginx\n```\n\n\n2、配置 ngixn\nngixn 安装完完成后的默认配置路径是 /etc/nginx/\n\n在 /etc/nginx/ 文件夹下创建新的文件夹vhost，并创建 blog.conf 文件\n即 /etc/nginx/vhost/blog.conf\n\n```xml\nmkdir vhost\nvim blog.conf\n\n```\n\n在blog.conf 文件中写入配置信息\n\nlisten表示监听的端口；root 表示博客存放的路径；server_name 表示域名或公网ip\n\n```\nserver{\n    listen  80;  \n    root /home/www/blog;\n    server_name  www.zhaohanchao.com;\n    location /{\n\n    }\n}\n\n```\n\n配置 /etc/nginx/nginx.conf 信息\n\n在其中写入 `include /etc/nginx/vhost/blog.conf`，刚刚创建的配置信息\n\n![](/public/img/other/blog1.png)\n\n创建 /home/www/blog目录，用于保存博客的源码\n\n\n3、启动 ngixn\n\n```xml\nsystemctl start nginx\nsystemctl enable nginx\n```\n\n### 配置git仓库，并设置自动部署\n\n1、安装git\n\n```xml\napt-get install git\n```\n\n2、创建gitserver用户，并切换至改用户\n\n```\nadduser gitserver\nsu git server\n\n```\n3、创建 .ssh 目录获取权限，并生成 公钥秘钥文件\n\n```xml\nmkdir .ssh && chmod 700 .ssh\ncd .ssh\nssh-keygen\n\n```\n![](/public/img/other/blog2.png)\n![](/public/img/other/blog3.png)\n\n4、创建空仓库\n\n```\ngit init --bare hexo.git\n```\n空仓库创建完成后可以在本地进行下载，查看是否配置成功，路径为`git clone gitserver@ip:/home/gitserver/hexo.git`\n\n5、配置hook进行自动化部署\n\n进入 hexo.git目录，创建post-receive文件,并进行编辑\n\n```\ncd hexo.git\nvim post-receive\n\n```\n\npost-receive文件中的内容如下，其中 `work-tree`表示最终发布的博客的目录，`git-dir`表示git仓库的目录\n\n```\n#!/bin/sh\ngit --work-tree=/home/www/blog --git-dir=/home/gitserver/hexo.git checkout -f\n\n```\n给post-receive赋予可执行权限\n\n```\nchmod +x post-receive\n```\n\n6、将本地hexo文件生成目录的git仓库添加远程仓库地址`gitserver@ip:/home/gitserver/hexo.git`进行post博客就会自动发布\n\n博客访问地址为服务器ip\n\n\n\n### 在搭建过程中遇到的问题\n\n1、云服务器ping不通，但能连接\n\n在安全组设置中添加 ICMP 入方向的规则\n\n2、访问网站显示403错误\n\n在安全组中天添加 TCP 80端口的入方向规则\n\n3、博客 post 之后，在`/home/www/blog`没有任何文件\n\n可能是git配置的hook的路径错误或者没有权限","source":"_posts/Other/Blog/云服务器搭建Hexo.md","raw":"---\ntitle: 将Hexo博客部署到云服务器上\ncover:  /cover/img96.jpg\ntoc: true\ndescription: 将Hexo博客部署到云服务器上\ntype: [Other]\ncategories: Other\ndate: 2020/03/25\n---\n\n\n## 将Hexo博客部署到云服务器上\n\n在云服务器上部署Hexo博客主要包含两个步骤，配置 nginx 和搭建git仓库，配置自动化部署；\n在本文中使用华为云的Ubuntu服务器\n\n### 安装并配置 nginx\n\nnginx是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。\n\n1、安装 ngixn\n\n```xml\n    apt-get install nginx\n```\n\n\n2、配置 ngixn\nngixn 安装完完成后的默认配置路径是 /etc/nginx/\n\n在 /etc/nginx/ 文件夹下创建新的文件夹vhost，并创建 blog.conf 文件\n即 /etc/nginx/vhost/blog.conf\n\n```xml\nmkdir vhost\nvim blog.conf\n\n```\n\n在blog.conf 文件中写入配置信息\n\nlisten表示监听的端口；root 表示博客存放的路径；server_name 表示域名或公网ip\n\n```\nserver{\n    listen  80;  \n    root /home/www/blog;\n    server_name  www.zhaohanchao.com;\n    location /{\n\n    }\n}\n\n```\n\n配置 /etc/nginx/nginx.conf 信息\n\n在其中写入 `include /etc/nginx/vhost/blog.conf`，刚刚创建的配置信息\n\n![](/public/img/other/blog1.png)\n\n创建 /home/www/blog目录，用于保存博客的源码\n\n\n3、启动 ngixn\n\n```xml\nsystemctl start nginx\nsystemctl enable nginx\n```\n\n### 配置git仓库，并设置自动部署\n\n1、安装git\n\n```xml\napt-get install git\n```\n\n2、创建gitserver用户，并切换至改用户\n\n```\nadduser gitserver\nsu git server\n\n```\n3、创建 .ssh 目录获取权限，并生成 公钥秘钥文件\n\n```xml\nmkdir .ssh && chmod 700 .ssh\ncd .ssh\nssh-keygen\n\n```\n![](/public/img/other/blog2.png)\n![](/public/img/other/blog3.png)\n\n4、创建空仓库\n\n```\ngit init --bare hexo.git\n```\n空仓库创建完成后可以在本地进行下载，查看是否配置成功，路径为`git clone gitserver@ip:/home/gitserver/hexo.git`\n\n5、配置hook进行自动化部署\n\n进入 hexo.git目录，创建post-receive文件,并进行编辑\n\n```\ncd hexo.git\nvim post-receive\n\n```\n\npost-receive文件中的内容如下，其中 `work-tree`表示最终发布的博客的目录，`git-dir`表示git仓库的目录\n\n```\n#!/bin/sh\ngit --work-tree=/home/www/blog --git-dir=/home/gitserver/hexo.git checkout -f\n\n```\n给post-receive赋予可执行权限\n\n```\nchmod +x post-receive\n```\n\n6、将本地hexo文件生成目录的git仓库添加远程仓库地址`gitserver@ip:/home/gitserver/hexo.git`进行post博客就会自动发布\n\n博客访问地址为服务器ip\n\n\n\n### 在搭建过程中遇到的问题\n\n1、云服务器ping不通，但能连接\n\n在安全组设置中添加 ICMP 入方向的规则\n\n2、访问网站显示403错误\n\n在安全组中天添加 TCP 80端口的入方向规则\n\n3、博客 post 之后，在`/home/www/blog`没有任何文件\n\n可能是git配置的hook的路径错误或者没有权限","slug":"Other/Blog/云服务器搭建Hexo","published":1,"updated":"2021-01-05T12:15:34.343Z","_id":"ckjju0m1z006w20ua55cmckue","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"将Hexo博客部署到云服务器上\"><a href=\"#将Hexo博客部署到云服务器上\" class=\"headerlink\" title=\"将Hexo博客部署到云服务器上\"></a>将Hexo博客部署到云服务器上</h2><p>在云服务器上部署Hexo博客主要包含两个步骤，配置 nginx 和搭建git仓库，配置自动化部署；<br>在本文中使用华为云的Ubuntu服务器</p>\n<h3 id=\"安装并配置-nginx\"><a href=\"#安装并配置-nginx\" class=\"headerlink\" title=\"安装并配置 nginx\"></a>安装并配置 nginx</h3><p>nginx是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。</p>\n<p>1、安装 ngixn</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install nginx</span><br></pre></td></tr></table></figure>\n\n<p>2、配置 ngixn<br>ngixn 安装完完成后的默认配置路径是 /etc/nginx/</p>\n<p>在 /etc/nginx/ 文件夹下创建新的文件夹vhost，并创建 blog.conf 文件<br>即 /etc/nginx/vhost/blog.conf</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir vhost</span><br><span class=\"line\">vim blog.conf</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在blog.conf 文件中写入配置信息</p>\n<p>listen表示监听的端口；root 表示博客存放的路径；server_name 表示域名或公网ip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">    listen  80;  </span><br><span class=\"line\">    root &#x2F;home&#x2F;www&#x2F;blog;</span><br><span class=\"line\">    server_name  www.zhaohanchao.com;</span><br><span class=\"line\">    location &#x2F;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>配置 /etc/nginx/nginx.conf 信息</p>\n<p>在其中写入 <code>include /etc/nginx/vhost/blog.conf</code>，刚刚创建的配置信息</p>\n<p><img src=\"/public/img/other/blog1.png\"></p>\n<p>创建 /home/www/blog目录，用于保存博客的源码</p>\n<p>3、启动 ngixn</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start nginx</span><br><span class=\"line\">systemctl enable nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置git仓库，并设置自动部署\"><a href=\"#配置git仓库，并设置自动部署\" class=\"headerlink\" title=\"配置git仓库，并设置自动部署\"></a>配置git仓库，并设置自动部署</h3><p>1、安装git</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure>\n<p>2、创建gitserver用户，并切换至改用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser gitserver</span><br><span class=\"line\">su git server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、创建 .ssh 目录获取权限，并生成 公钥秘钥文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class=\"line\">cd .ssh</span><br><span class=\"line\">ssh-keygen</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/public/img/other/blog2.png\"><br><img src=\"/public/img/other/blog3.png\"></p>\n<p>4、创建空仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init --bare hexo.git</span><br></pre></td></tr></table></figure>\n<p>空仓库创建完成后可以在本地进行下载，查看是否配置成功，路径为<code>git clone gitserver@ip:/home/gitserver/hexo.git</code></p>\n<p>5、配置hook进行自动化部署</p>\n<p>进入 hexo.git目录，创建post-receive文件,并进行编辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo.git</span><br><span class=\"line\">vim post-receive</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>post-receive文件中的内容如下，其中 <code>work-tree</code>表示最终发布的博客的目录，<code>git-dir</code>表示git仓库的目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;sh</span><br><span class=\"line\">git --work-tree&#x3D;&#x2F;home&#x2F;www&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;gitserver&#x2F;hexo.git checkout -f</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>给post-receive赋予可执行权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n<p>6、将本地hexo文件生成目录的git仓库添加远程仓库地址<code>gitserver@ip:/home/gitserver/hexo.git</code>进行post博客就会自动发布</p>\n<p>博客访问地址为服务器ip</p>\n<h3 id=\"在搭建过程中遇到的问题\"><a href=\"#在搭建过程中遇到的问题\" class=\"headerlink\" title=\"在搭建过程中遇到的问题\"></a>在搭建过程中遇到的问题</h3><p>1、云服务器ping不通，但能连接</p>\n<p>在安全组设置中添加 ICMP 入方向的规则</p>\n<p>2、访问网站显示403错误</p>\n<p>在安全组中天添加 TCP 80端口的入方向规则</p>\n<p>3、博客 post 之后，在<code>/home/www/blog</code>没有任何文件</p>\n<p>可能是git配置的hook的路径错误或者没有权限</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"将Hexo博客部署到云服务器上\"><a href=\"#将Hexo博客部署到云服务器上\" class=\"headerlink\" title=\"将Hexo博客部署到云服务器上\"></a>将Hexo博客部署到云服务器上</h2><p>在云服务器上部署Hexo博客主要包含两个步骤，配置 nginx 和搭建git仓库，配置自动化部署；<br>在本文中使用华为云的Ubuntu服务器</p>\n<h3 id=\"安装并配置-nginx\"><a href=\"#安装并配置-nginx\" class=\"headerlink\" title=\"安装并配置 nginx\"></a>安装并配置 nginx</h3><p>nginx是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。</p>\n<p>1、安装 ngixn</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install nginx</span><br></pre></td></tr></table></figure>\n\n<p>2、配置 ngixn<br>ngixn 安装完完成后的默认配置路径是 /etc/nginx/</p>\n<p>在 /etc/nginx/ 文件夹下创建新的文件夹vhost，并创建 blog.conf 文件<br>即 /etc/nginx/vhost/blog.conf</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir vhost</span><br><span class=\"line\">vim blog.conf</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在blog.conf 文件中写入配置信息</p>\n<p>listen表示监听的端口；root 表示博客存放的路径；server_name 表示域名或公网ip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">    listen  80;  </span><br><span class=\"line\">    root &#x2F;home&#x2F;www&#x2F;blog;</span><br><span class=\"line\">    server_name  www.zhaohanchao.com;</span><br><span class=\"line\">    location &#x2F;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>配置 /etc/nginx/nginx.conf 信息</p>\n<p>在其中写入 <code>include /etc/nginx/vhost/blog.conf</code>，刚刚创建的配置信息</p>\n<p><img src=\"/public/img/other/blog1.png\"></p>\n<p>创建 /home/www/blog目录，用于保存博客的源码</p>\n<p>3、启动 ngixn</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start nginx</span><br><span class=\"line\">systemctl enable nginx</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置git仓库，并设置自动部署\"><a href=\"#配置git仓库，并设置自动部署\" class=\"headerlink\" title=\"配置git仓库，并设置自动部署\"></a>配置git仓库，并设置自动部署</h3><p>1、安装git</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure>\n<p>2、创建gitserver用户，并切换至改用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adduser gitserver</span><br><span class=\"line\">su git server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、创建 .ssh 目录获取权限，并生成 公钥秘钥文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class=\"line\">cd .ssh</span><br><span class=\"line\">ssh-keygen</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/public/img/other/blog2.png\"><br><img src=\"/public/img/other/blog3.png\"></p>\n<p>4、创建空仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init --bare hexo.git</span><br></pre></td></tr></table></figure>\n<p>空仓库创建完成后可以在本地进行下载，查看是否配置成功，路径为<code>git clone gitserver@ip:/home/gitserver/hexo.git</code></p>\n<p>5、配置hook进行自动化部署</p>\n<p>进入 hexo.git目录，创建post-receive文件,并进行编辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo.git</span><br><span class=\"line\">vim post-receive</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>post-receive文件中的内容如下，其中 <code>work-tree</code>表示最终发布的博客的目录，<code>git-dir</code>表示git仓库的目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;sh</span><br><span class=\"line\">git --work-tree&#x3D;&#x2F;home&#x2F;www&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;gitserver&#x2F;hexo.git checkout -f</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>给post-receive赋予可执行权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n<p>6、将本地hexo文件生成目录的git仓库添加远程仓库地址<code>gitserver@ip:/home/gitserver/hexo.git</code>进行post博客就会自动发布</p>\n<p>博客访问地址为服务器ip</p>\n<h3 id=\"在搭建过程中遇到的问题\"><a href=\"#在搭建过程中遇到的问题\" class=\"headerlink\" title=\"在搭建过程中遇到的问题\"></a>在搭建过程中遇到的问题</h3><p>1、云服务器ping不通，但能连接</p>\n<p>在安全组设置中添加 ICMP 入方向的规则</p>\n<p>2、访问网站显示403错误</p>\n<p>在安全组中天添加 TCP 80端口的入方向规则</p>\n<p>3、博客 post 之后，在<code>/home/www/blog</code>没有任何文件</p>\n<p>可能是git配置的hook的路径错误或者没有权限</p>\n"},{"title":"函数式编程","description":"函数式编程","type":["函数式编程"],"toc":true,"cover":"/cover/img111.jpg","date":"2019-10-10T16:00:00.000Z","_content":"\n## 函数式编程（FP）\n\n\"函数式编程\", 又称泛函编程, 是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。\n函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","source":"_posts/Other/Computer/函数式编程.md","raw":"---\ntitle: \"函数式编程\"\ndescription: \"函数式编程\"\ntype: [函数式编程]\ntoc: true\ncover:  /cover/img111.jpg\ncategories: 编程\ndate: 2019/10/11\n---\n\n## 函数式编程（FP）\n\n\"函数式编程\", 又称泛函编程, 是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。\n函数式编程关心数据的映射，命令式编程关心解决问题的步骤；","slug":"Other/Computer/函数式编程","published":1,"updated":"2021-01-06T01:06:35.009Z","_id":"ckjju0m20006z20uacj0k60lo","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"函数式编程（FP）\"><a href=\"#函数式编程（FP）\" class=\"headerlink\" title=\"函数式编程（FP）\"></a>函数式编程（FP）</h2><p>“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。<br>函数式编程关心数据的映射，命令式编程关心解决问题的步骤；</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数式编程（FP）\"><a href=\"#函数式编程（FP）\" class=\"headerlink\" title=\"函数式编程（FP）\"></a>函数式编程（FP）</h2><p>“函数式编程”, 又称泛函编程, 是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它的基础是 λ 演算（lambda calculus）。λ演算可以接受函数当作输入（参数）和输出（返回值）。和指令式编程相比，函数式编程的思维方式更加注重函数的计算。它的主要思想是把问题的解决方案写成一系列嵌套的函数调用。<br>函数式编程关心数据的映射，命令式编程关心解决问题的步骤；</p>\n"},{"title":"常用Git操作","cover":"/cover/img68.jpg","toc":true,"type":["Git"],"description":"常用Git操作","date":"2018-06-26T16:00:00.000Z","_content":"\n\n## 常用Git操作\n\n### 一、将本地已有仓库推送到远程仓库\n\n* 1、将本地仓库与远程仓库建立关联\n```\n   git remote add github git@github.com:Lucius/GitTest.git\n```\n    查看本地仓库与远程仓库关联情况\n```\ngit remote -v\n```\n    删除与远程仓库关联 \n```\n git remote rm origin\n```\n\n* 2、设置用户名和密码\n```\ngit config -global user.name \"\"\ngit config -global user.email \"\"\n```\n* 3、设置SSH Key,\n    生成SSH Key\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n** -t 指定密钥类型，默认是 rsa ，可以省略。 **\n** -C 设置注释文字，比如邮箱。 **\n** -f 指定密钥文件存储文件名。 ** \n![](/public/img/other/GitImg1.png)\n   在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中\n![](/public/img/other/GitImg2.png)\n* 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去\n```\ngit branch --set-upstream-to=origin\n```\n![](/public/img/other/GitImg3.png)\n    当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现`fatal: refusing to merge unrelated histories`错误，需要使用下面命令：\n```\ngit pull origin master --allow-unrelated-histories\n```\n* 5、将本地仓库推送至远端\n```\n  git push -u origin master \n```\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误\n![](/public/img/other/GitImg4.png)\n推送正常\n![](/public/img/other/GitImg5.png)\n\n### 二、将本地分支提交到远程\n\n* 1、建立本地到上游（远端）仓的链接\n```\ngit branch --set-upstream-to=origin\n```\n![](/public/img/other/GitImg6.png)\n\n* 2、拉取远程分支内容\n```\ngit pull --allow-unrelated-histories\n```\n* 3、将本地分支推送至远程\n```\ngit push origin EditBranch\n```\n![](/public/img/other/GitImg7.png)\n\n\n### 三、合并多次提交\n\n```\ngit rebase -i HEAD~3\n```\n\n如果在合并的过程中出现冲突需要先解决冲突，再进行合并\n```\ngit rebase --continue  \n```\n\n如果放弃本次合并，使用\n```\ngit rebase --abort \n```\n### 四、Git多用户进行管理\n\n需要为每一个仓库设置user、email\n\n* 第一步：取消git的global用户以及邮箱\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n\n```\n\n\n* 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。\n\n```\ngit config  user.email \"xxxx@xx.com\"\ngit config  user.name \"xxxx\"\n\n```\n\n### 五、git reset --hard --soft与git revert\n\n`git reset --hard HEAD~1`修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。\n\n`git reset --soft HEAD~1`修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。\n\n#### `git revert`与`git reset`区别\n* `git reset`指向原地或者向前移动指针,直接删除commit，`git revert`创建一个逆向commit来覆盖之前commit,指针向后移动。\n*  在后续合并旧版本时，`git revert`的部分不再出现；而`git reset`在合并旧版本时，这些被回滚的提交还会再次被引入。\n\n#### 撤销 git reset\n\n`git reflog` 查看操作历史，找到之前 HEAD 的 hash 值，然后 `git reset --hard` 到那个 hash 即可\n\n\n### 六、`git cherry-pick`使用方法\n\n将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。\n\n```\ngit cherry-pick <commit id>:单独合并一个提交\ngit cherry-pick -x <commit id>：同上，不同点：保留原提交者信息。\n\ngit cherry-pick <start-commit-id>..<end-commit-id>：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支\n```\n\n\n### 七、修改git urls的路径方式\n\n#### 将urls由SSH模式修改为Https模式\n\n#### 将usrls由Https模式修改为SSH模式\n\n\n### 八、建立本地分支，并推送至远程\n\n\n### 九、更新fork的代码\n在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，\n\n### 十、将git推送到多个远程仓库\n\n通过 `git remote -v` 查看现有的远程分支\n\n![](/public/img/other/GitImg8.png)\n\n通过`git remote add blog git@ip:/hom/o.git`添加远程分支,并使用　`git remote -v` 查看结果\n\n![](/public/img/other/GitImg9.png)\n\n通过指定名称推送至指定的远程仓库　`git push -u blog`\n\n### 十一、Git Hooks\n\nGit Hooks提供多种Hook，\n\npre-commit，该Hook将会拦截git commit操作，执行pre-commit，当且仅当脚本返回值为0时，执行真正的commit\npost-receive，当服务端的bare repository接收到push 信息并完成push操作后进行执行；\n\n### Git删除分支\n\n\n\n\n\n\n\n\n","source":"_posts/Other/Git/Git.md","raw":"---\ntitle: 常用Git操作\ncover:  /cover/img68.jpg\ntoc: true\ntype: [Git]\ndescription: 常用Git操作\ncategories: Other\ndate: 2018/06/27\n---\n\n\n## 常用Git操作\n\n### 一、将本地已有仓库推送到远程仓库\n\n* 1、将本地仓库与远程仓库建立关联\n```\n   git remote add github git@github.com:Lucius/GitTest.git\n```\n    查看本地仓库与远程仓库关联情况\n```\ngit remote -v\n```\n    删除与远程仓库关联 \n```\n git remote rm origin\n```\n\n* 2、设置用户名和密码\n```\ngit config -global user.name \"\"\ngit config -global user.email \"\"\n```\n* 3、设置SSH Key,\n    生成SSH Key\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n** -t 指定密钥类型，默认是 rsa ，可以省略。 **\n** -C 设置注释文字，比如邮箱。 **\n** -f 指定密钥文件存储文件名。 ** \n![](/public/img/other/GitImg1.png)\n   在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中\n![](/public/img/other/GitImg2.png)\n* 4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去\n```\ngit branch --set-upstream-to=origin\n```\n![](/public/img/other/GitImg3.png)\n    当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现`fatal: refusing to merge unrelated histories`错误，需要使用下面命令：\n```\ngit pull origin master --allow-unrelated-histories\n```\n* 5、将本地仓库推送至远端\n```\n  git push -u origin master \n```\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误\n![](/public/img/other/GitImg4.png)\n推送正常\n![](/public/img/other/GitImg5.png)\n\n### 二、将本地分支提交到远程\n\n* 1、建立本地到上游（远端）仓的链接\n```\ngit branch --set-upstream-to=origin\n```\n![](/public/img/other/GitImg6.png)\n\n* 2、拉取远程分支内容\n```\ngit pull --allow-unrelated-histories\n```\n* 3、将本地分支推送至远程\n```\ngit push origin EditBranch\n```\n![](/public/img/other/GitImg7.png)\n\n\n### 三、合并多次提交\n\n```\ngit rebase -i HEAD~3\n```\n\n如果在合并的过程中出现冲突需要先解决冲突，再进行合并\n```\ngit rebase --continue  \n```\n\n如果放弃本次合并，使用\n```\ngit rebase --abort \n```\n### 四、Git多用户进行管理\n\n需要为每一个仓库设置user、email\n\n* 第一步：取消git的global用户以及邮箱\n\n```\ngit config --global --unset user.name\ngit config --global --unset user.email\n\n```\n\n\n* 第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。\n\n```\ngit config  user.email \"xxxx@xx.com\"\ngit config  user.name \"xxxx\"\n\n```\n\n### 五、git reset --hard --soft与git revert\n\n`git reset --hard HEAD~1`修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。\n\n`git reset --soft HEAD~1`修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。\n\n#### `git revert`与`git reset`区别\n* `git reset`指向原地或者向前移动指针,直接删除commit，`git revert`创建一个逆向commit来覆盖之前commit,指针向后移动。\n*  在后续合并旧版本时，`git revert`的部分不再出现；而`git reset`在合并旧版本时，这些被回滚的提交还会再次被引入。\n\n#### 撤销 git reset\n\n`git reflog` 查看操作历史，找到之前 HEAD 的 hash 值，然后 `git reset --hard` 到那个 hash 即可\n\n\n### 六、`git cherry-pick`使用方法\n\n将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。\n\n```\ngit cherry-pick <commit id>:单独合并一个提交\ngit cherry-pick -x <commit id>：同上，不同点：保留原提交者信息。\n\ngit cherry-pick <start-commit-id>..<end-commit-id>：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支\n```\n\n\n### 七、修改git urls的路径方式\n\n#### 将urls由SSH模式修改为Https模式\n\n#### 将usrls由Https模式修改为SSH模式\n\n\n### 八、建立本地分支，并推送至远程\n\n\n### 九、更新fork的代码\n在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，\n\n### 十、将git推送到多个远程仓库\n\n通过 `git remote -v` 查看现有的远程分支\n\n![](/public/img/other/GitImg8.png)\n\n通过`git remote add blog git@ip:/hom/o.git`添加远程分支,并使用　`git remote -v` 查看结果\n\n![](/public/img/other/GitImg9.png)\n\n通过指定名称推送至指定的远程仓库　`git push -u blog`\n\n### 十一、Git Hooks\n\nGit Hooks提供多种Hook，\n\npre-commit，该Hook将会拦截git commit操作，执行pre-commit，当且仅当脚本返回值为0时，执行真正的commit\npost-receive，当服务端的bare repository接收到push 信息并完成push操作后进行执行；\n\n### Git删除分支\n\n\n\n\n\n\n\n\n","slug":"Other/Git/Git","published":1,"updated":"2021-01-05T12:15:34.900Z","_id":"ckjju0m21007420uacl8k9rqk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"常用Git操作\"><a href=\"#常用Git操作\" class=\"headerlink\" title=\"常用Git操作\"></a>常用Git操作</h2><h3 id=\"一、将本地已有仓库推送到远程仓库\"><a href=\"#一、将本地已有仓库推送到远程仓库\" class=\"headerlink\" title=\"一、将本地已有仓库推送到远程仓库\"></a>一、将本地已有仓库推送到远程仓库</h3><ul>\n<li>1、将本地仓库与远程仓库建立关联<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:Lucius&#x2F;GitTest.git</span><br></pre></td></tr></table></figure>\n  查看本地仓库与远程仓库关联情况<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n  删除与远程仓库关联 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure></li>\n<li>2、设置用户名和密码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -global user.name &quot;&quot;</span><br><span class=\"line\">git config -global user.email &quot;&quot;</span><br></pre></td></tr></table></figure></li>\n<li>3、设置SSH Key,<br>  生成SSH Key<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li>\n<li><ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-C 设置注释文字，比如邮箱。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-f 指定密钥文件存储文件名。 **<br><img src=\"/public/img/other/GitImg1.png\"><br>在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中<br><img src=\"/public/img/other/GitImg2.png\"></li>\n</ul>\n</li>\n<li>4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<img src=\"/public/img/other/GitImg3.png\"><br>  当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现<code>fatal: refusing to merge unrelated histories</code>错误，需要使用下面命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li>5、将本地仓库推送至远端<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master </span><br></pre></td></tr></table></figure>\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误<br><img src=\"/public/img/other/GitImg4.png\"><br>推送正常<br><img src=\"/public/img/other/GitImg5.png\"></li>\n</ul>\n<h3 id=\"二、将本地分支提交到远程\"><a href=\"#二、将本地分支提交到远程\" class=\"headerlink\" title=\"二、将本地分支提交到远程\"></a>二、将本地分支提交到远程</h3><ul>\n<li><p>1、建立本地到上游（远端）仓的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/public/img/other/GitImg6.png\"></p>\n</li>\n<li><p>2、拉取远程分支内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>3、将本地分支推送至远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin EditBranch</span><br></pre></td></tr></table></figure>\n<p><img src=\"/public/img/other/GitImg7.png\"></p>\n</li>\n</ul>\n<h3 id=\"三、合并多次提交\"><a href=\"#三、合并多次提交\" class=\"headerlink\" title=\"三、合并多次提交\"></a>三、合并多次提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n<p>如果在合并的过程中出现冲突需要先解决冲突，再进行合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --continue  </span><br></pre></td></tr></table></figure>\n<p>如果放弃本次合并，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --abort </span><br></pre></td></tr></table></figure>\n<h3 id=\"四、Git多用户进行管理\"><a href=\"#四、Git多用户进行管理\" class=\"headerlink\" title=\"四、Git多用户进行管理\"></a>四、Git多用户进行管理</h3><p>需要为每一个仓库设置user、email</p>\n<ul>\n<li>第一步：取消git的global用户以及邮箱</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset user.name</span><br><span class=\"line\">git config --global --unset user.email</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config  user.email &quot;xxxx@xx.com&quot;</span><br><span class=\"line\">git config  user.name &quot;xxxx&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"五、git-reset-–hard-–soft与git-revert\"><a href=\"#五、git-reset-–hard-–soft与git-revert\" class=\"headerlink\" title=\"五、git reset –hard –soft与git revert\"></a>五、git reset –hard –soft与git revert</h3><p><code>git reset --hard HEAD~1</code>修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。</p>\n<p><code>git reset --soft HEAD~1</code>修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。</p>\n<h4 id=\"git-revert与git-reset区别\"><a href=\"#git-revert与git-reset区别\" class=\"headerlink\" title=\"git revert与git reset区别\"></a><code>git revert</code>与<code>git reset</code>区别</h4><ul>\n<li><code>git reset</code>指向原地或者向前移动指针,直接删除commit，<code>git revert</code>创建一个逆向commit来覆盖之前commit,指针向后移动。</li>\n<li> 在后续合并旧版本时，<code>git revert</code>的部分不再出现；而<code>git reset</code>在合并旧版本时，这些被回滚的提交还会再次被引入。</li>\n</ul>\n<h4 id=\"撤销-git-reset\"><a href=\"#撤销-git-reset\" class=\"headerlink\" title=\"撤销 git reset\"></a>撤销 git reset</h4><p><code>git reflog</code> 查看操作历史，找到之前 HEAD 的 hash 值，然后 <code>git reset --hard</code> 到那个 hash 即可</p>\n<h3 id=\"六、git-cherry-pick使用方法\"><a href=\"#六、git-cherry-pick使用方法\" class=\"headerlink\" title=\"六、git cherry-pick使用方法\"></a>六、<code>git cherry-pick</code>使用方法</h3><p>将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;commit id&gt;:单独合并一个提交</span><br><span class=\"line\">git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。</span><br><span class=\"line\"></span><br><span class=\"line\">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"七、修改git-urls的路径方式\"><a href=\"#七、修改git-urls的路径方式\" class=\"headerlink\" title=\"七、修改git urls的路径方式\"></a>七、修改git urls的路径方式</h3><h4 id=\"将urls由SSH模式修改为Https模式\"><a href=\"#将urls由SSH模式修改为Https模式\" class=\"headerlink\" title=\"将urls由SSH模式修改为Https模式\"></a>将urls由SSH模式修改为Https模式</h4><h4 id=\"将usrls由Https模式修改为SSH模式\"><a href=\"#将usrls由Https模式修改为SSH模式\" class=\"headerlink\" title=\"将usrls由Https模式修改为SSH模式\"></a>将usrls由Https模式修改为SSH模式</h4><h3 id=\"八、建立本地分支，并推送至远程\"><a href=\"#八、建立本地分支，并推送至远程\" class=\"headerlink\" title=\"八、建立本地分支，并推送至远程\"></a>八、建立本地分支，并推送至远程</h3><h3 id=\"九、更新fork的代码\"><a href=\"#九、更新fork的代码\" class=\"headerlink\" title=\"九、更新fork的代码\"></a>九、更新fork的代码</h3><p>在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，</p>\n<h3 id=\"十、将git推送到多个远程仓库\"><a href=\"#十、将git推送到多个远程仓库\" class=\"headerlink\" title=\"十、将git推送到多个远程仓库\"></a>十、将git推送到多个远程仓库</h3><p>通过 <code>git remote -v</code> 查看现有的远程分支</p>\n<p><img src=\"/public/img/other/GitImg8.png\"></p>\n<p>通过<code>git remote add blog git@ip:/hom/o.git</code>添加远程分支,并使用　<code>git remote -v</code> 查看结果</p>\n<p><img src=\"/public/img/other/GitImg9.png\"></p>\n<p>通过指定名称推送至指定的远程仓库　<code>git push -u blog</code></p>\n<h3 id=\"十一、Git-Hooks\"><a href=\"#十一、Git-Hooks\" class=\"headerlink\" title=\"十一、Git Hooks\"></a>十一、Git Hooks</h3><p>Git Hooks提供多种Hook，</p>\n<p>pre-commit，该Hook将会拦截git commit操作，执行pre-commit，当且仅当脚本返回值为0时，执行真正的commit<br>post-receive，当服务端的bare repository接收到push 信息并完成push操作后进行执行；</p>\n<h3 id=\"Git删除分支\"><a href=\"#Git删除分支\" class=\"headerlink\" title=\"Git删除分支\"></a>Git删除分支</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用Git操作\"><a href=\"#常用Git操作\" class=\"headerlink\" title=\"常用Git操作\"></a>常用Git操作</h2><h3 id=\"一、将本地已有仓库推送到远程仓库\"><a href=\"#一、将本地已有仓库推送到远程仓库\" class=\"headerlink\" title=\"一、将本地已有仓库推送到远程仓库\"></a>一、将本地已有仓库推送到远程仓库</h3><ul>\n<li>1、将本地仓库与远程仓库建立关联<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add github git@github.com:Lucius&#x2F;GitTest.git</span><br></pre></td></tr></table></figure>\n  查看本地仓库与远程仓库关联情况<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n  删除与远程仓库关联 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br></pre></td></tr></table></figure></li>\n<li>2、设置用户名和密码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config -global user.name &quot;&quot;</span><br><span class=\"line\">git config -global user.email &quot;&quot;</span><br></pre></td></tr></table></figure></li>\n<li>3、设置SSH Key,<br>  生成SSH Key<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li>\n<li><ul>\n<li>-t 指定密钥类型，默认是 rsa ，可以省略。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-C 设置注释文字，比如邮箱。 **</li>\n</ul>\n</li>\n<li><ul>\n<li>-f 指定密钥文件存储文件名。 **<br><img src=\"/public/img/other/GitImg1.png\"><br>在GitHub中设置SSH，即将.ssh.id_rsa.pub中的内容添加到Key中<br><img src=\"/public/img/other/GitImg2.png\"></li>\n</ul>\n</li>\n<li>4、建立本地到上游（远端）仓的链接，建立链接后代码才能提交上去<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<img src=\"/public/img/other/GitImg3.png\"><br>  当本地仓库与远程仓库没有相同的commit时，git不允许提交会出现<code>fatal: refusing to merge unrelated histories</code>错误，需要使用下面命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li>5、将本地仓库推送至远端<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master </span><br></pre></td></tr></table></figure>\n如果出现Permission denied(publickey)，则说明第3步中的公钥配置错误<br><img src=\"/public/img/other/GitImg4.png\"><br>推送正常<br><img src=\"/public/img/other/GitImg5.png\"></li>\n</ul>\n<h3 id=\"二、将本地分支提交到远程\"><a href=\"#二、将本地分支提交到远程\" class=\"headerlink\" title=\"二、将本地分支提交到远程\"></a>二、将本地分支提交到远程</h3><ul>\n<li><p>1、建立本地到上游（远端）仓的链接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream-to&#x3D;origin</span><br></pre></td></tr></table></figure>\n<p><img src=\"/public/img/other/GitImg6.png\"></p>\n</li>\n<li><p>2、拉取远程分支内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>\n<li><p>3、将本地分支推送至远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin EditBranch</span><br></pre></td></tr></table></figure>\n<p><img src=\"/public/img/other/GitImg7.png\"></p>\n</li>\n</ul>\n<h3 id=\"三、合并多次提交\"><a href=\"#三、合并多次提交\" class=\"headerlink\" title=\"三、合并多次提交\"></a>三、合并多次提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>\n<p>如果在合并的过程中出现冲突需要先解决冲突，再进行合并</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --continue  </span><br></pre></td></tr></table></figure>\n<p>如果放弃本次合并，使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --abort </span><br></pre></td></tr></table></figure>\n<h3 id=\"四、Git多用户进行管理\"><a href=\"#四、Git多用户进行管理\" class=\"headerlink\" title=\"四、Git多用户进行管理\"></a>四、Git多用户进行管理</h3><p>需要为每一个仓库设置user、email</p>\n<ul>\n<li>第一步：取消git的global用户以及邮箱</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset user.name</span><br><span class=\"line\">git config --global --unset user.email</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二步：在不同的仓库中配置不同的user、email,然后就可以愉快地使用了,第一次为仓库添加user、email在push的时候需要输入密码进行验证。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config  user.email &quot;xxxx@xx.com&quot;</span><br><span class=\"line\">git config  user.name &quot;xxxx&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"五、git-reset-–hard-–soft与git-revert\"><a href=\"#五、git-reset-–hard-–soft与git-revert\" class=\"headerlink\" title=\"五、git reset –hard –soft与git revert\"></a>五、git reset –hard –soft与git revert</h3><p><code>git reset --hard HEAD~1</code>修改版本库、修改暂存区、修改工作区；将版本库回退一个版本，但是不仅仅将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并将工作代码也回退到这个版本。</p>\n<p><code>git reset --soft HEAD~1</code>修改版本库、保留暂存区、保留工作区；将版本库回退一个版本，且将这次提交之后的所有变更都移动到暂存区。</p>\n<h4 id=\"git-revert与git-reset区别\"><a href=\"#git-revert与git-reset区别\" class=\"headerlink\" title=\"git revert与git reset区别\"></a><code>git revert</code>与<code>git reset</code>区别</h4><ul>\n<li><code>git reset</code>指向原地或者向前移动指针,直接删除commit，<code>git revert</code>创建一个逆向commit来覆盖之前commit,指针向后移动。</li>\n<li> 在后续合并旧版本时，<code>git revert</code>的部分不再出现；而<code>git reset</code>在合并旧版本时，这些被回滚的提交还会再次被引入。</li>\n</ul>\n<h4 id=\"撤销-git-reset\"><a href=\"#撤销-git-reset\" class=\"headerlink\" title=\"撤销 git reset\"></a>撤销 git reset</h4><p><code>git reflog</code> 查看操作历史，找到之前 HEAD 的 hash 值，然后 <code>git reset --hard</code> 到那个 hash 即可</p>\n<h3 id=\"六、git-cherry-pick使用方法\"><a href=\"#六、git-cherry-pick使用方法\" class=\"headerlink\" title=\"六、git cherry-pick使用方法\"></a>六、<code>git cherry-pick</code>使用方法</h3><p>将某一个分支的提交，引入到当前分支的提交上，即合并某一分支的部分提交。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;commit id&gt;:单独合并一个提交</span><br><span class=\"line\">git cherry-pick -x &lt;commit id&gt;：同上，不同点：保留原提交者信息。</span><br><span class=\"line\"></span><br><span class=\"line\">git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;：(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"七、修改git-urls的路径方式\"><a href=\"#七、修改git-urls的路径方式\" class=\"headerlink\" title=\"七、修改git urls的路径方式\"></a>七、修改git urls的路径方式</h3><h4 id=\"将urls由SSH模式修改为Https模式\"><a href=\"#将urls由SSH模式修改为Https模式\" class=\"headerlink\" title=\"将urls由SSH模式修改为Https模式\"></a>将urls由SSH模式修改为Https模式</h4><h4 id=\"将usrls由Https模式修改为SSH模式\"><a href=\"#将usrls由Https模式修改为SSH模式\" class=\"headerlink\" title=\"将usrls由Https模式修改为SSH模式\"></a>将usrls由Https模式修改为SSH模式</h4><h3 id=\"八、建立本地分支，并推送至远程\"><a href=\"#八、建立本地分支，并推送至远程\" class=\"headerlink\" title=\"八、建立本地分支，并推送至远程\"></a>八、建立本地分支，并推送至远程</h3><h3 id=\"九、更新fork的代码\"><a href=\"#九、更新fork的代码\" class=\"headerlink\" title=\"九、更新fork的代码\"></a>九、更新fork的代码</h3><p>在被下载到本地仓库中，添加源分支地址到项目远程分支列表中，</p>\n<h3 id=\"十、将git推送到多个远程仓库\"><a href=\"#十、将git推送到多个远程仓库\" class=\"headerlink\" title=\"十、将git推送到多个远程仓库\"></a>十、将git推送到多个远程仓库</h3><p>通过 <code>git remote -v</code> 查看现有的远程分支</p>\n<p><img src=\"/public/img/other/GitImg8.png\"></p>\n<p>通过<code>git remote add blog git@ip:/hom/o.git</code>添加远程分支,并使用　<code>git remote -v</code> 查看结果</p>\n<p><img src=\"/public/img/other/GitImg9.png\"></p>\n<p>通过指定名称推送至指定的远程仓库　<code>git push -u blog</code></p>\n<h3 id=\"十一、Git-Hooks\"><a href=\"#十一、Git-Hooks\" class=\"headerlink\" title=\"十一、Git Hooks\"></a>十一、Git Hooks</h3><p>Git Hooks提供多种Hook，</p>\n<p>pre-commit，该Hook将会拦截git commit操作，执行pre-commit，当且仅当脚本返回值为0时，执行真正的commit<br>post-receive，当服务端的bare repository接收到push 信息并完成push操作后进行执行；</p>\n<h3 id=\"Git删除分支\"><a href=\"#Git删除分支\" class=\"headerlink\" title=\"Git删除分支\"></a>Git删除分支</h3>"},{"title":"常用操作符","cover":"/cover/img4.jpg","toc":true,"description":"常用操作符","type":["Other"],"date":"2018-08-08T16:00:00.000Z","_content":"\n## 常用操作符介绍\n\n### 位操作符 & | ^ \n\n* & 按位与\n    相同为1，相异为0\n* | 按位或\n    一真则为真\n* ^ 按位异或\n    相同为0，相异为1\n### 逻辑运算符\n\n* && 逻辑与\n    两个操作数同时为真才为真\n* || 逻辑或\n    一真则为真，两个操作数同时为假才为假","source":"_posts/Other/Computer/操作符.md","raw":"---\ntitle: 常用操作符\ncover:  /cover/img4.jpg\ntoc: true\ndescription: 常用操作符\ntype: [Other]\ncategories: Other\ndate: 2018/08/09\n---\n\n## 常用操作符介绍\n\n### 位操作符 & | ^ \n\n* & 按位与\n    相同为1，相异为0\n* | 按位或\n    一真则为真\n* ^ 按位异或\n    相同为0，相异为1\n### 逻辑运算符\n\n* && 逻辑与\n    两个操作数同时为真才为真\n* || 逻辑或\n    一真则为真，两个操作数同时为假才为假","slug":"Other/Computer/操作符","published":1,"updated":"2021-01-05T12:15:34.649Z","_id":"ckjju0m21007720uahtw48e4m","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"常用操作符介绍\"><a href=\"#常用操作符介绍\" class=\"headerlink\" title=\"常用操作符介绍\"></a>常用操作符介绍</h2><h3 id=\"位操作符-amp\"><a href=\"#位操作符-amp\" class=\"headerlink\" title=\"位操作符 &amp; | ^\"></a>位操作符 &amp; | ^</h3><ul>\n<li><p>&amp; 按位与<br>  相同为1，相异为0</p>\n</li>\n<li><p>| 按位或<br>  一真则为真</p>\n</li>\n<li><p>^ 按位异或<br>  相同为0，相异为1</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3></li>\n<li><p>&amp;&amp; 逻辑与<br>  两个操作数同时为真才为真</p>\n</li>\n<li><p>|| 逻辑或<br>  一真则为真，两个操作数同时为假才为假</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用操作符介绍\"><a href=\"#常用操作符介绍\" class=\"headerlink\" title=\"常用操作符介绍\"></a>常用操作符介绍</h2><h3 id=\"位操作符-amp\"><a href=\"#位操作符-amp\" class=\"headerlink\" title=\"位操作符 &amp; | ^\"></a>位操作符 &amp; | ^</h3><ul>\n<li><p>&amp; 按位与<br>  相同为1，相异为0</p>\n</li>\n<li><p>| 按位或<br>  一真则为真</p>\n</li>\n<li><p>^ 按位异或<br>  相同为0，相异为1</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3></li>\n<li><p>&amp;&amp; 逻辑与<br>  两个操作数同时为真才为真</p>\n</li>\n<li><p>|| 逻辑或<br>  一真则为真，两个操作数同时为假才为假</p>\n</li>\n</ul>\n"},{"title":"Permission to LuciusCS/test.git denied to Lrici.","cover":"/cover/img67.jpg","toc":true,"type":["Git"],"description":"Permission to LuciusCS/test.git denied to Lrici.","date":"2017-07-26T16:00:00.000Z","_content":"\n\n\n\nmodified: 2017-07-27\n\n\n###　问题一：remote: Permission to LuciusCS/test.git denied to Lrici.\nfatal: unable to access 'https://github.com/LuciusCS/test.git/': The requested URL returned error: 403\n\n<!--more-->\n![](/public/img/other/Image3.png)\n\n\n没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；\n都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；\n\n方法一：修改配置文件，或者只在本仓库中设置用户名\n\ngit config –global user.name “name” \n\ngit config –global user.email “email” \n\n方法二：重新创建生成SSH KEY\n\n方法三：删除Config文件，再重建\n\n方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）\n\n方法五：按照The requested URL returned error: 403 403错误的解决方法\n\n重装大法：卸载Git，然后清除注册表（就差重装系统了）\n\n## 以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\n\n还是显示上面的错误！！！！\n\n## 终极方法：在凭证管理器中删除不需要账号的信息\n\n## 步骤：\n\n  Control Panel(控制面板)——>User Account and family Safety(用户账号和家庭安全)——>Manage Windows Credential(凭证管理)——>将跟Git有关的账号删除\n\n\n![](public/img/other/Image1.png)\n![](public/img/other/Image4.png)\n\n\n\n再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦\n\n\n![](public/img/other/Image5.png)\n![](public/img/other/Image6.png)\n\n\n\n\n### 问题二：推送错误\n\n```xml\nsign_and_send_pubkey: signing failed: agent refused operation\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n```\n\n解决方式：\n\n```\neval \"$(ssh-agent -s)\"\nssh-add\n\n```\n\n","source":"_posts/Other/Git/Git出现问题解决.md","raw":"---\ntitle:  Permission to LuciusCS/test.git denied to Lrici.\ncover:  /cover/img67.jpg\ntoc: true\ntype: [Git]\ndescription: Permission to LuciusCS/test.git denied to Lrici.\ncategories: Other\ndate: 2017/07/27\n---\n\n\n\n\nmodified: 2017-07-27\n\n\n###　问题一：remote: Permission to LuciusCS/test.git denied to Lrici.\nfatal: unable to access 'https://github.com/LuciusCS/test.git/': The requested URL returned error: 403\n\n<!--more-->\n![](/public/img/other/Image3.png)\n\n\n没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；\n都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；\n\n方法一：修改配置文件，或者只在本仓库中设置用户名\n\ngit config –global user.name “name” \n\ngit config –global user.email “email” \n\n方法二：重新创建生成SSH KEY\n\n方法三：删除Config文件，再重建\n\n方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）\n\n方法五：按照The requested URL returned error: 403 403错误的解决方法\n\n重装大法：卸载Git，然后清除注册表（就差重装系统了）\n\n## 以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\n\n还是显示上面的错误！！！！\n\n## 终极方法：在凭证管理器中删除不需要账号的信息\n\n## 步骤：\n\n  Control Panel(控制面板)——>User Account and family Safety(用户账号和家庭安全)——>Manage Windows Credential(凭证管理)——>将跟Git有关的账号删除\n\n\n![](public/img/other/Image1.png)\n![](public/img/other/Image4.png)\n\n\n\n再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦\n\n\n![](public/img/other/Image5.png)\n![](public/img/other/Image6.png)\n\n\n\n\n### 问题二：推送错误\n\n```xml\nsign_and_send_pubkey: signing failed: agent refused operation\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n```\n\n解决方式：\n\n```\neval \"$(ssh-agent -s)\"\nssh-add\n\n```\n\n","slug":"Other/Git/Git出现问题解决","published":1,"updated":"2021-01-05T12:15:35.089Z","_id":"ckjju0m22007920uaajxra2uj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>modified: 2017-07-27</p>\n<h3 id=\"问题一：remote-Permission-to-LuciusCS-test-git-denied-to-Lrici\"><a href=\"#问题一：remote-Permission-to-LuciusCS-test-git-denied-to-Lrici\" class=\"headerlink\" title=\"问题一：remote: Permission to LuciusCS/test.git denied to Lrici.\"></a>问题一：remote: Permission to LuciusCS/test.git denied to Lrici.</h3><p>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/test.git/&#39;\">https://github.com/LuciusCS/test.git/&#39;</a>: The requested URL returned error: 403</p>\n<a id=\"more\"></a>\n<p><img src=\"/public/img/other/Image3.png\"></p>\n<p>没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；<br>都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；</p>\n<p>方法一：修改配置文件，或者只在本仓库中设置用户名</p>\n<p>git config –global user.name “name” </p>\n<p>git config –global user.email “email” </p>\n<p>方法二：重新创建生成SSH KEY</p>\n<p>方法三：删除Config文件，再重建</p>\n<p>方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）</p>\n<p>方法五：按照The requested URL returned error: 403 403错误的解决方法</p>\n<p>重装大法：卸载Git，然后清除注册表（就差重装系统了）</p>\n<h2 id=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"><a href=\"#以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\" class=\"headerlink\" title=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"></a>以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！</h2><p>还是显示上面的错误！！！！</p>\n<h2 id=\"终极方法：在凭证管理器中删除不需要账号的信息\"><a href=\"#终极方法：在凭证管理器中删除不需要账号的信息\" class=\"headerlink\" title=\"终极方法：在凭证管理器中删除不需要账号的信息\"></a>终极方法：在凭证管理器中删除不需要账号的信息</h2><h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><p>  Control Panel(控制面板)——&gt;User Account and family Safety(用户账号和家庭安全)——&gt;Manage Windows Credential(凭证管理)——&gt;将跟Git有关的账号删除</p>\n<p><img src=\"public/img/other/Image1.png\"><br><img src=\"public/img/other/Image4.png\"></p>\n<p>再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦</p>\n<p><img src=\"public/img/other/Image5.png\"><br><img src=\"public/img/other/Image6.png\"></p>\n<h3 id=\"问题二：推送错误\"><a href=\"#问题二：推送错误\" class=\"headerlink\" title=\"问题二：推送错误\"></a>问题二：推送错误</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sign_and_send_pubkey: signing failed: agent refused operation</span><br><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>解决方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval &quot;$(ssh-agent -s)&quot;</span><br><span class=\"line\">ssh-add</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>modified: 2017-07-27</p>\n<h3 id=\"问题一：remote-Permission-to-LuciusCS-test-git-denied-to-Lrici\"><a href=\"#问题一：remote-Permission-to-LuciusCS-test-git-denied-to-Lrici\" class=\"headerlink\" title=\"问题一：remote: Permission to LuciusCS/test.git denied to Lrici.\"></a>问题一：remote: Permission to LuciusCS/test.git denied to Lrici.</h3><p>fatal: unable to access ‘<a href=\"https://github.com/LuciusCS/test.git/&#39;\">https://github.com/LuciusCS/test.git/&#39;</a>: The requested URL returned error: 403</p>","more":"<p><img src=\"/public/img/other/Image3.png\"></p>\n<p>没错，LuciusCS是我原来的账号的名字，Lrici是我现在的账号的名字；<br>都说谷歌大法好，本宝宝恨不得把所有的方法都尝试了；</p>\n<p>方法一：修改配置文件，或者只在本仓库中设置用户名</p>\n<p>git config –global user.name “name” </p>\n<p>git config –global user.email “email” </p>\n<p>方法二：重新创建生成SSH KEY</p>\n<p>方法三：删除Config文件，再重建</p>\n<p>方法四：在Git上配置多账号（特喵的，都不知道账号在哪里）</p>\n<p>方法五：按照The requested URL returned error: 403 403错误的解决方法</p>\n<p>重装大法：卸载Git，然后清除注册表（就差重装系统了）</p>\n<h2 id=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"><a href=\"#以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\" class=\"headerlink\" title=\"以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！\"></a>以上方法都没有用！！！，以上方法都没有用！！！以上方法都没有用！！！</h2><p>还是显示上面的错误！！！！</p>\n<h2 id=\"终极方法：在凭证管理器中删除不需要账号的信息\"><a href=\"#终极方法：在凭证管理器中删除不需要账号的信息\" class=\"headerlink\" title=\"终极方法：在凭证管理器中删除不需要账号的信息\"></a>终极方法：在凭证管理器中删除不需要账号的信息</h2><h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><p>  Control Panel(控制面板)——&gt;User Account and family Safety(用户账号和家庭安全)——&gt;Manage Windows Credential(凭证管理)——&gt;将跟Git有关的账号删除</p>\n<p><img src=\"public/img/other/Image1.png\"><br><img src=\"public/img/other/Image4.png\"></p>\n<p>再次提交的时候就会让你输入账号和密码，输入完成后就可以提交啦</p>\n<p><img src=\"public/img/other/Image5.png\"><br><img src=\"public/img/other/Image6.png\"></p>\n<h3 id=\"问题二：推送错误\"><a href=\"#问题二：推送错误\" class=\"headerlink\" title=\"问题二：推送错误\"></a>问题二：推送错误</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sign_and_send_pubkey: signing failed: agent refused operation</span><br><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>解决方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval &quot;$(ssh-agent -s)&quot;</span><br><span class=\"line\">ssh-add</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"MarkDown的使用","type":["Other"],"description":"MarkDown的使用","cover":"/cover/img95.jpg","toc":true,"date":"2018-06-29T16:00:00.000Z","_content":"\n### Markdown绘制流程图并居中\n\n```xml\n   <center/>\n    ```flow\n    st=>start: Start\n    op=>operation: Your\n    cond=>condition: Yes or No?\n    e=>end: End\n    st->op->cond\n    cond(yes)->e\n    cond(no)->op\n     ```\n    </center>\n\n```\n\n实现效果\n\n   <center/>\n```flow\n    st=>start: Start\n    op=>operation: Your\n    cond=>condition: Yes or No?\n    e=>end: End\n    st->op->cond\n    cond(yes)->e\n    cond(no)->op\n``` \n</center>\n\n\n### MarkDown使内容居中方式\n\n* 方法一：\n\n```xml\n    <center>内容居中</center>\n    <center>图片居中</center>\n\n```\n* 方法二：\n```xml\n\n     <div align=center>内容居中</div>\n\n```\n","source":"_posts/Other/Tools/MarkDown使用.md","raw":"---\ntitle: MarkDown的使用\ntype: [Other]\ndescription:  MarkDown的使用\ncover:  /cover/img95.jpg\ntoc: true\ncategories: Other\ndate: 2018/06/30\n---\n\n### Markdown绘制流程图并居中\n\n```xml\n   <center/>\n    ```flow\n    st=>start: Start\n    op=>operation: Your\n    cond=>condition: Yes or No?\n    e=>end: End\n    st->op->cond\n    cond(yes)->e\n    cond(no)->op\n     ```\n    </center>\n\n```\n\n实现效果\n\n   <center/>\n```flow\n    st=>start: Start\n    op=>operation: Your\n    cond=>condition: Yes or No?\n    e=>end: End\n    st->op->cond\n    cond(yes)->e\n    cond(no)->op\n``` \n</center>\n\n\n### MarkDown使内容居中方式\n\n* 方法一：\n\n```xml\n    <center>内容居中</center>\n    <center>图片居中</center>\n\n```\n* 方法二：\n```xml\n\n     <div align=center>内容居中</div>\n\n```\n","slug":"Other/Tools/MarkDown使用","published":1,"updated":"2021-01-05T12:15:35.351Z","_id":"ckjju0m23007e20ua279qcb38","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Markdown绘制流程图并居中\"><a href=\"#Markdown绘制流程图并居中\" class=\"headerlink\" title=\"Markdown绘制流程图并居中\"></a>Markdown绘制流程图并居中</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>/&gt;</span></span><br><span class=\"line\"> ```flow</span><br><span class=\"line\"> st=&gt;start: Start</span><br><span class=\"line\"> op=&gt;operation: Your</span><br><span class=\"line\"> cond=&gt;condition: Yes or No?</span><br><span class=\"line\"> e=&gt;end: End</span><br><span class=\"line\"> st-&gt;op-&gt;cond</span><br><span class=\"line\"> cond(yes)-&gt;e</span><br><span class=\"line\"> cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<pre><code>&lt;/center&gt;</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">实现效果</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;center&#x2F;&gt;</span><br><span class=\"line\">&#96;&#96;&#96;flow</span><br><span class=\"line\">    st&#x3D;&gt;start: Start</span><br><span class=\"line\">    op&#x3D;&gt;operation: Your</span><br><span class=\"line\">    cond&#x3D;&gt;condition: Yes or No?</span><br><span class=\"line\">    e&#x3D;&gt;end: End</span><br><span class=\"line\">    st-&gt;op-&gt;cond</span><br><span class=\"line\">    cond(yes)-&gt;e</span><br><span class=\"line\">    cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n</center>\n\n\n<h3 id=\"MarkDown使内容居中方式\"><a href=\"#MarkDown使内容居中方式\" class=\"headerlink\" title=\"MarkDown使内容居中方式\"></a>MarkDown使内容居中方式</h3><ul>\n<li>方法一：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span>内容居中<span class=\"tag\">&lt;/<span class=\"name\">center</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span>图片居中<span class=\"tag\">&lt;/<span class=\"name\">center</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法二：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">center</span>&gt;</span>内容居中<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Markdown绘制流程图并居中\"><a href=\"#Markdown绘制流程图并居中\" class=\"headerlink\" title=\"Markdown绘制流程图并居中\"></a>Markdown绘制流程图并居中</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>/&gt;</span></span><br><span class=\"line\"> ```flow</span><br><span class=\"line\"> st=&gt;start: Start</span><br><span class=\"line\"> op=&gt;operation: Your</span><br><span class=\"line\"> cond=&gt;condition: Yes or No?</span><br><span class=\"line\"> e=&gt;end: End</span><br><span class=\"line\"> st-&gt;op-&gt;cond</span><br><span class=\"line\"> cond(yes)-&gt;e</span><br><span class=\"line\"> cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<pre><code>&lt;/center&gt;</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">实现效果</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;center&#x2F;&gt;</span><br><span class=\"line\">&#96;&#96;&#96;flow</span><br><span class=\"line\">    st&#x3D;&gt;start: Start</span><br><span class=\"line\">    op&#x3D;&gt;operation: Your</span><br><span class=\"line\">    cond&#x3D;&gt;condition: Yes or No?</span><br><span class=\"line\">    e&#x3D;&gt;end: End</span><br><span class=\"line\">    st-&gt;op-&gt;cond</span><br><span class=\"line\">    cond(yes)-&gt;e</span><br><span class=\"line\">    cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n</center>\n\n\n<h3 id=\"MarkDown使内容居中方式\"><a href=\"#MarkDown使内容居中方式\" class=\"headerlink\" title=\"MarkDown使内容居中方式\"></a>MarkDown使内容居中方式</h3><ul>\n<li>方法一：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span>内容居中<span class=\"tag\">&lt;/<span class=\"name\">center</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span>图片居中<span class=\"tag\">&lt;/<span class=\"name\">center</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法二：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">center</span>&gt;</span>内容居中<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"常用工具软件","type":["Other"],"description":"常用工具软件","cover":"/cover/img94.jpg","toc":true,"date":"2018-08-14T16:00:00.000Z","_content":"\n\nWindows软件\n\n1、Shadowsocks梯子\n2、Goflyway 梯子，仅限于浏览器，需要插件\n3、v2rayN 梯子\n4、Visual Studio Code 代码编辑，博客编辑，轻量\n5、Notepad++ 代码查看编辑，轻量\n6、Postman 网络接口请求模拟\n7、cpu-z 查看处理器、缓存、内存、主板、显卡、通道数等基本信息，可替代鲁大师\n8、DB Browser数据库文件查看软件\n9、BitTorrent 种子下载\n10、UltralISO制作系统启动盘\n11、Binary Viewer 用于二进制文件查看,bin文件\n12、PotPlayer 视频软件，支持倍速\n13、Beyond Compare 文件、文件夹比较\n14、Wireshark 支持网络、串口抓包\n15、Capture 图片编辑软件、可替代PhotoShop\n16、refus 制作系统启动盘，安装Ubuntu\n17、Orcle VM VirtualBox 虚拟机软件，速度比VMware\n18、文件创建事件修改软件\n19、百度网盘加速下载软件\n20、键盘鼠标共享，可以在Ubuntu和Window系统下\n21、MultiPortDialog 串口、UDP、TCP发送接受软件\n22、Picpick 截图软件\n\nUbuntu软件\n1、Shadowsocks梯子\n2、Goflyway 梯子，仅限于浏览器，需要插件\n3、v2rayN 梯子\n4、Visual Studio Code 代码编辑，博客编辑，轻量\n5、Shutter 截图软件,可以对文件进行编辑\n6、BCompare 文件、文件夹比较\n \n\n\nAndroid软件\n1、XRecoder: 录屏软件\n2、UDP Sender/Receiver\n\n\n\n网站：\n\n1、免费的图片下载网站: \n2、文档格式转换软件: \n3、Android官方Demo: \n4、CodeLa:\n5、Google搜索: \n6、","source":"_posts/Other/Tools/常用工具软件.md","raw":"---\ntitle: 常用工具软件\ntype: [Other]\ndescription:  常用工具软件\ncover:  /cover/img94.jpg\ntoc: true\ncategories: Other\ndate: 2018/08/15\n---\n\n\nWindows软件\n\n1、Shadowsocks梯子\n2、Goflyway 梯子，仅限于浏览器，需要插件\n3、v2rayN 梯子\n4、Visual Studio Code 代码编辑，博客编辑，轻量\n5、Notepad++ 代码查看编辑，轻量\n6、Postman 网络接口请求模拟\n7、cpu-z 查看处理器、缓存、内存、主板、显卡、通道数等基本信息，可替代鲁大师\n8、DB Browser数据库文件查看软件\n9、BitTorrent 种子下载\n10、UltralISO制作系统启动盘\n11、Binary Viewer 用于二进制文件查看,bin文件\n12、PotPlayer 视频软件，支持倍速\n13、Beyond Compare 文件、文件夹比较\n14、Wireshark 支持网络、串口抓包\n15、Capture 图片编辑软件、可替代PhotoShop\n16、refus 制作系统启动盘，安装Ubuntu\n17、Orcle VM VirtualBox 虚拟机软件，速度比VMware\n18、文件创建事件修改软件\n19、百度网盘加速下载软件\n20、键盘鼠标共享，可以在Ubuntu和Window系统下\n21、MultiPortDialog 串口、UDP、TCP发送接受软件\n22、Picpick 截图软件\n\nUbuntu软件\n1、Shadowsocks梯子\n2、Goflyway 梯子，仅限于浏览器，需要插件\n3、v2rayN 梯子\n4、Visual Studio Code 代码编辑，博客编辑，轻量\n5、Shutter 截图软件,可以对文件进行编辑\n6、BCompare 文件、文件夹比较\n \n\n\nAndroid软件\n1、XRecoder: 录屏软件\n2、UDP Sender/Receiver\n\n\n\n网站：\n\n1、免费的图片下载网站: \n2、文档格式转换软件: \n3、Android官方Demo: \n4、CodeLa:\n5、Google搜索: \n6、","slug":"Other/Tools/常用工具软件","published":1,"updated":"2021-01-05T12:15:38.732Z","_id":"ckjju0m24007g20uahqwy0vmx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Windows软件</p>\n<p>1、Shadowsocks梯子<br>2、Goflyway 梯子，仅限于浏览器，需要插件<br>3、v2rayN 梯子<br>4、Visual Studio Code 代码编辑，博客编辑，轻量<br>5、Notepad++ 代码查看编辑，轻量<br>6、Postman 网络接口请求模拟<br>7、cpu-z 查看处理器、缓存、内存、主板、显卡、通道数等基本信息，可替代鲁大师<br>8、DB Browser数据库文件查看软件<br>9、BitTorrent 种子下载<br>10、UltralISO制作系统启动盘<br>11、Binary Viewer 用于二进制文件查看,bin文件<br>12、PotPlayer 视频软件，支持倍速<br>13、Beyond Compare 文件、文件夹比较<br>14、Wireshark 支持网络、串口抓包<br>15、Capture 图片编辑软件、可替代PhotoShop<br>16、refus 制作系统启动盘，安装Ubuntu<br>17、Orcle VM VirtualBox 虚拟机软件，速度比VMware<br>18、文件创建事件修改软件<br>19、百度网盘加速下载软件<br>20、键盘鼠标共享，可以在Ubuntu和Window系统下<br>21、MultiPortDialog 串口、UDP、TCP发送接受软件<br>22、Picpick 截图软件</p>\n<p>Ubuntu软件<br>1、Shadowsocks梯子<br>2、Goflyway 梯子，仅限于浏览器，需要插件<br>3、v2rayN 梯子<br>4、Visual Studio Code 代码编辑，博客编辑，轻量<br>5、Shutter 截图软件,可以对文件进行编辑<br>6、BCompare 文件、文件夹比较</p>\n<p>Android软件<br>1、XRecoder: 录屏软件<br>2、UDP Sender/Receiver</p>\n<p>网站：</p>\n<p>1、免费的图片下载网站:<br>2、文档格式转换软件:<br>3、Android官方Demo:<br>4、CodeLa:<br>5、Google搜索:<br>6、</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Windows软件</p>\n<p>1、Shadowsocks梯子<br>2、Goflyway 梯子，仅限于浏览器，需要插件<br>3、v2rayN 梯子<br>4、Visual Studio Code 代码编辑，博客编辑，轻量<br>5、Notepad++ 代码查看编辑，轻量<br>6、Postman 网络接口请求模拟<br>7、cpu-z 查看处理器、缓存、内存、主板、显卡、通道数等基本信息，可替代鲁大师<br>8、DB Browser数据库文件查看软件<br>9、BitTorrent 种子下载<br>10、UltralISO制作系统启动盘<br>11、Binary Viewer 用于二进制文件查看,bin文件<br>12、PotPlayer 视频软件，支持倍速<br>13、Beyond Compare 文件、文件夹比较<br>14、Wireshark 支持网络、串口抓包<br>15、Capture 图片编辑软件、可替代PhotoShop<br>16、refus 制作系统启动盘，安装Ubuntu<br>17、Orcle VM VirtualBox 虚拟机软件，速度比VMware<br>18、文件创建事件修改软件<br>19、百度网盘加速下载软件<br>20、键盘鼠标共享，可以在Ubuntu和Window系统下<br>21、MultiPortDialog 串口、UDP、TCP发送接受软件<br>22、Picpick 截图软件</p>\n<p>Ubuntu软件<br>1、Shadowsocks梯子<br>2、Goflyway 梯子，仅限于浏览器，需要插件<br>3、v2rayN 梯子<br>4、Visual Studio Code 代码编辑，博客编辑，轻量<br>5、Shutter 截图软件,可以对文件进行编辑<br>6、BCompare 文件、文件夹比较</p>\n<p>Android软件<br>1、XRecoder: 录屏软件<br>2、UDP Sender/Receiver</p>\n<p>网站：</p>\n<p>1、免费的图片下载网站:<br>2、文档格式转换软件:<br>3、Android官方Demo:<br>4、CodeLa:<br>5、Google搜索:<br>6、</p>\n"},{"title":"Ubuntu使用","type":["Ubuntu"],"description":"Ubuntu使用","cover":"/cover/img93.jpg","toc":true,"date":"2018-07-07T16:00:00.000Z","_content":"\n## Ubuntu 使用`apt-get update` 或者 `apt-get install`失败\n\n出现错误：\n\n\n使用的镜像被墙\n\n修改 /etc/apt/sources.list中的\n\ncn.archive.ubuntu.com换成mirrors.aliyun.com\n\n更换为\n\n```java\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main\n\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main\n\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\n\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe\n\n\n```\n\n## 给文件添加权限\n\n### 给post-receive脚本添加可执行权限\n\n```\nchmod +x post-receive\n```\n\n\n## 网路相关\n\n1、查看端口占用\n\n```\nnetstat -ntlp\n```\n\n\n\n## Ubuntu 使用win10共享文件夹\n\n1、在Windows创建共享文件夹\n\n2、在Ubuntu下安装samba-client\n\n![](public/img/other/ubuntu_file_share1.png)\n\n3、在Ubuntu下安装cifs-utils\n\n![](public/img/other/ubuntu_file_share2.png)\n\n4、在Ubuntu下新建挂载目录\n\n![](public/img/other/ubuntu_file_share3.png)\n\n5、挂载共享文件\n\n![](public/img/other/ubuntu_file_share4.png)\n\n操作完成后就可以在mnt/Shared共享文件了","source":"_posts/Other/Ubuntu 使用/Ubuntu 使用.md","raw":"---\ntitle: Ubuntu使用\ntype: [Ubuntu]\ndescription:  Ubuntu使用\ncover:  /cover/img93.jpg\ntoc: true\ncategories: Android\ndate: 2018/07/08\n---\n\n## Ubuntu 使用`apt-get update` 或者 `apt-get install`失败\n\n出现错误：\n\n\n使用的镜像被墙\n\n修改 /etc/apt/sources.list中的\n\ncn.archive.ubuntu.com换成mirrors.aliyun.com\n\n更换为\n\n```java\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main\n\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main\n\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\n\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe\n\n\n```\n\n## 给文件添加权限\n\n### 给post-receive脚本添加可执行权限\n\n```\nchmod +x post-receive\n```\n\n\n## 网路相关\n\n1、查看端口占用\n\n```\nnetstat -ntlp\n```\n\n\n\n## Ubuntu 使用win10共享文件夹\n\n1、在Windows创建共享文件夹\n\n2、在Ubuntu下安装samba-client\n\n![](public/img/other/ubuntu_file_share1.png)\n\n3、在Ubuntu下安装cifs-utils\n\n![](public/img/other/ubuntu_file_share2.png)\n\n4、在Ubuntu下新建挂载目录\n\n![](public/img/other/ubuntu_file_share3.png)\n\n5、挂载共享文件\n\n![](public/img/other/ubuntu_file_share4.png)\n\n操作完成后就可以在mnt/Shared共享文件了","slug":"Other/Ubuntu 使用/Ubuntu 使用","published":1,"updated":"2021-01-05T12:15:40.684Z","_id":"ckjju0m25007k20uadn9jb2c5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Ubuntu-使用apt-get-update-或者-apt-get-install失败\"><a href=\"#Ubuntu-使用apt-get-update-或者-apt-get-install失败\" class=\"headerlink\" title=\"Ubuntu 使用apt-get update 或者 apt-get install失败\"></a>Ubuntu 使用<code>apt-get update</code> 或者 <code>apt-get install</code>失败</h2><p>出现错误：</p>\n<p>使用的镜像被墙</p>\n<p>修改 /etc/apt/sources.list中的</p>\n<p>cn.archive.ubuntu.com换成mirrors.aliyun.com</p>\n<p>更换为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"给文件添加权限\"><a href=\"#给文件添加权限\" class=\"headerlink\" title=\"给文件添加权限\"></a>给文件添加权限</h2><h3 id=\"给post-receive脚本添加可执行权限\"><a href=\"#给post-receive脚本添加可执行权限\" class=\"headerlink\" title=\"给post-receive脚本添加可执行权限\"></a>给post-receive脚本添加可执行权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网路相关\"><a href=\"#网路相关\" class=\"headerlink\" title=\"网路相关\"></a>网路相关</h2><p>1、查看端口占用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntlp</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ubuntu-使用win10共享文件夹\"><a href=\"#Ubuntu-使用win10共享文件夹\" class=\"headerlink\" title=\"Ubuntu 使用win10共享文件夹\"></a>Ubuntu 使用win10共享文件夹</h2><p>1、在Windows创建共享文件夹</p>\n<p>2、在Ubuntu下安装samba-client</p>\n<p><img src=\"public/img/other/ubuntu_file_share1.png\"></p>\n<p>3、在Ubuntu下安装cifs-utils</p>\n<p><img src=\"public/img/other/ubuntu_file_share2.png\"></p>\n<p>4、在Ubuntu下新建挂载目录</p>\n<p><img src=\"public/img/other/ubuntu_file_share3.png\"></p>\n<p>5、挂载共享文件</p>\n<p><img src=\"public/img/other/ubuntu_file_share4.png\"></p>\n<p>操作完成后就可以在mnt/Shared共享文件了</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Ubuntu-使用apt-get-update-或者-apt-get-install失败\"><a href=\"#Ubuntu-使用apt-get-update-或者-apt-get-install失败\" class=\"headerlink\" title=\"Ubuntu 使用apt-get update 或者 apt-get install失败\"></a>Ubuntu 使用<code>apt-get update</code> 或者 <code>apt-get install</code>失败</h2><p>出现错误：</p>\n<p>使用的镜像被墙</p>\n<p>修改 /etc/apt/sources.list中的</p>\n<p>cn.archive.ubuntu.com换成mirrors.aliyun.com</p>\n<p>更换为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"给文件添加权限\"><a href=\"#给文件添加权限\" class=\"headerlink\" title=\"给文件添加权限\"></a>给文件添加权限</h2><h3 id=\"给post-receive脚本添加可执行权限\"><a href=\"#给post-receive脚本添加可执行权限\" class=\"headerlink\" title=\"给post-receive脚本添加可执行权限\"></a>给post-receive脚本添加可执行权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网路相关\"><a href=\"#网路相关\" class=\"headerlink\" title=\"网路相关\"></a>网路相关</h2><p>1、查看端口占用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntlp</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Ubuntu-使用win10共享文件夹\"><a href=\"#Ubuntu-使用win10共享文件夹\" class=\"headerlink\" title=\"Ubuntu 使用win10共享文件夹\"></a>Ubuntu 使用win10共享文件夹</h2><p>1、在Windows创建共享文件夹</p>\n<p>2、在Ubuntu下安装samba-client</p>\n<p><img src=\"public/img/other/ubuntu_file_share1.png\"></p>\n<p>3、在Ubuntu下安装cifs-utils</p>\n<p><img src=\"public/img/other/ubuntu_file_share2.png\"></p>\n<p>4、在Ubuntu下新建挂载目录</p>\n<p><img src=\"public/img/other/ubuntu_file_share3.png\"></p>\n<p>5、挂载共享文件</p>\n<p><img src=\"public/img/other/ubuntu_file_share4.png\"></p>\n<p>操作完成后就可以在mnt/Shared共享文件了</p>\n"},{"title":"Android悦跑圈模式保活","type":"Android","description":"Android悦跑圈模式保活","cover":"/cover/img84.jpg","toc":true,"date":"2020-03-19T16:00:00.000Z","_content":"\n参考资料\nhttp://www.52im.net/thread-2881-1-1.html\nhttps://www.jianshu.com/p/2e01569f8ba8","source":"_posts/Android/Advanced/Android保活/Android 悦跑圈模式保活.md","raw":"---\ntitle: Android悦跑圈模式保活\ntype: Android\ndescription: Android悦跑圈模式保活\ncover: /cover/img84.jpg\ntoc: true\ncategories: Android\ndate: 2020/03/20\n---\n\n参考资料\nhttp://www.52im.net/thread-2881-1-1.html\nhttps://www.jianshu.com/p/2e01569f8ba8","slug":"Android/Advanced/Android保活/Android 悦跑圈模式保活","published":1,"updated":"2021-01-05T12:17:43.872Z","_id":"ckjju0m26007n20ua1j3r1l1x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>参考资料<br><a href=\"http://www.52im.net/thread-2881-1-1.html\">http://www.52im.net/thread-2881-1-1.html</a><br><a href=\"https://www.jianshu.com/p/2e01569f8ba8\">https://www.jianshu.com/p/2e01569f8ba8</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考资料<br><a href=\"http://www.52im.net/thread-2881-1-1.html\">http://www.52im.net/thread-2881-1-1.html</a><br><a href=\"https://www.jianshu.com/p/2e01569f8ba8\">https://www.jianshu.com/p/2e01569f8ba8</a></p>\n"},{"title":"Android 内存性能优化","description":"Android开发过程中的性能优化","type":["Android","性能优化"],"toc":true,"cover":"/cover/img77.jpg","date":"2019-08-31T16:00:00.000Z","_content":"\n\n### 垃圾回收\n垃圾回收器负责回收程序中已经不适用，但仍然被各种对象占用的内存，Android具有垃圾回收机制，自动追踪所有的对象。\n\n<!--more-->\n### Android中的垃圾回收机制\n\n![](public/img/Android/Android_performance.png)\n\n1、 Young Generation\n * 大多数新建对象都位于Eden区\n * 当Eden被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个Servivor区\n * Survivor Space: S0、S1 有两个，存放每次垃圾回收后存活的对象\n * Minor GC 同样会检查survivor区中存活的对象，并把他们转移到另一个survivor区，这样在一段时间内，总会有一个空的survivor区。\n\n2、Old Generation\n* 存放长期存活的对象和经过多次Minor GC后依然存活下来的对象\n* 满了进行Major GC(花时间比Minor时间长)\n\n3、Permanent Generation\n* 存放方法区，方法区中有要加载的类信息、静态变量、final类型的常量、属性和方法信息。\n\n### 垃圾回收机制和FPS \n\n1、Android系统每隔16ms发出VSVNYC信号，触发对UI的渲染，那个整个过程就能保证在16ms以内就能达到一个流畅的画面。16FPS\n\n2、如果某一帧的操作超过了16ms就会让用户感觉到卡顿。\n\n3、UI渲染过程发生GC，导致某一帧绘制时间超过16ms。\n\n\n## 内存泄露\n\n1、应用程序分配了大量不能被回收的对象\n2、系统可分配的内存越来越少\n3、新对象的创建需要的内存不够\n4、GC之后再分配\n5、60fps\n\n### 常见的内存泄露\n\n1、单例造成的泄露\n\n在单例中使用Context对象，应该使用Application的Context，使用其他的容易造成内存泄露；但在某些情况下需要使用Activity的Context,如：涉及View的生命周期的Context\n\n注：静态对象在程序运行期间是不会被垃圾回收，在下方代码中会一直持有一个context引用，造成内存泄露。\n\n```java\npublic class AppManager{\n    private static AppManager instance;\n    private Context context;\n    private AppManager(Context context){\n        this.context=context;\n    }\n\n    public static AppManager getInstance(Context context){\n        if(instance!=null){\n            instance=new AppManager(context);\n        }\n        return instance;\n    }\n}\n```\n\n\n2、非静态内部类的静态实例造成的泄露\n\n`sResource`变量会间接持有MainActivity实例的引用，导致内存泄露\n\n```java\n\npublic class MainActivity extends Activity{\n    private static TestResource sResource=null;\n\n    @Override\n    protected void onCreate(Bundle saveInstanceState){\n        super.onCreate(saveInstanceState);\n        setContentView(R.layout.activity_main);\n        if(sResource==null){\n            sResource=new TestResource();\n        }\n\n        //...\n    }\n\n    class TestResource{\n        //...\n    }\n\n}\n\n```\n\n3、`Handler`造成的内存泄露\n\n通过匿名对象创建mHandler，会持有MainActivity实例的引用，Handler对象的生命周期会比MainActivity长，造成MainActivit不能被回收\n\n```java\n    public class MainActivity extends Activity{\n        private Handler mHandler=new Handler(){\n            @Override\n            public void handleMessage(Message msg){\n\n            }\n        }；\n        @Override\n        protected void onCreate(Bundle saveInstanceState){\n            super.onCreate(saveInstanceState);\n            setContentView(R.layout.activity_main);\n            loadData();\n        }\n\n        private void loadData(){\n            //... request\n            Message message=Message.obtain();\n            mHandler.sendMessage(message);\n        }\n      }\n    }\n\n```\n\n### 避免内存泄露的方法\n1、尽量不要让静态变量引用Activity\n\n2、使用WeakReference\n\n3、使用静态内部类来代替内部类\n\n4、静态内部类使用弱引用来引用外部类\n\n5、在生命周期结束时释放资源\n\n### 减少内存的使用\n\n* 使用更轻量的数据结构（比如SpareArray代替HashMap）\n* 避免在onDraw方法中创建对象，onDraw方法调用频率比较高，建议使用对象池(Message.obtain())\n* LruCache\n* Bitmap内存复用，压缩(inSampleSize,inBitmap)\n* StringBuilder代替Stirng,主要是String的拼接\n* App多次申请内存会造成内存抖动，内存碎片的问题\n* 使用复用池避免内存抖动和内存碎片\n\n\n\n## 内存抖动\n当内存频繁分配回收，导致内存不稳定，内存波动图形呈锯齿状\n\n在Dalvik虚拟机上比ART虚拟机上更为明显。\n\n出现的情况：\n\n1、字符串使用加号拼接\n* 使用StringBuilder替代\n* 初始化时设置容量，减少StringBuilder扩容\n\n2、资源复用\n* 使用全局对象池，重用频繁申请和释放的对象\n* 使用结束后，手动释放对象池中的对象\n\n3、使用SparseArray类族、ArrayMap代替HashMap\n\n## 内存溢出\n\n单个应用可用的最大值对应于 /system/build.prop 文件中的 dalvik.vm.heapgrowthlimit\n\n一次性创建大的数组或载入大的图片会导致OOM","source":"_posts/Android/Advanced/Android性能优化/Andorid内存优化.md","raw":"---\ntitle: \"Android 内存性能优化\"\ndescription: \"Android开发过程中的性能优化\"\ntype: [Android,性能优化]\ntoc: true\ncover:  /cover/img77.jpg\ncategories: Android\ndate: 2019/09/01\n---\n\n\n### 垃圾回收\n垃圾回收器负责回收程序中已经不适用，但仍然被各种对象占用的内存，Android具有垃圾回收机制，自动追踪所有的对象。\n\n<!--more-->\n### Android中的垃圾回收机制\n\n![](public/img/Android/Android_performance.png)\n\n1、 Young Generation\n * 大多数新建对象都位于Eden区\n * 当Eden被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个Servivor区\n * Survivor Space: S0、S1 有两个，存放每次垃圾回收后存活的对象\n * Minor GC 同样会检查survivor区中存活的对象，并把他们转移到另一个survivor区，这样在一段时间内，总会有一个空的survivor区。\n\n2、Old Generation\n* 存放长期存活的对象和经过多次Minor GC后依然存活下来的对象\n* 满了进行Major GC(花时间比Minor时间长)\n\n3、Permanent Generation\n* 存放方法区，方法区中有要加载的类信息、静态变量、final类型的常量、属性和方法信息。\n\n### 垃圾回收机制和FPS \n\n1、Android系统每隔16ms发出VSVNYC信号，触发对UI的渲染，那个整个过程就能保证在16ms以内就能达到一个流畅的画面。16FPS\n\n2、如果某一帧的操作超过了16ms就会让用户感觉到卡顿。\n\n3、UI渲染过程发生GC，导致某一帧绘制时间超过16ms。\n\n\n## 内存泄露\n\n1、应用程序分配了大量不能被回收的对象\n2、系统可分配的内存越来越少\n3、新对象的创建需要的内存不够\n4、GC之后再分配\n5、60fps\n\n### 常见的内存泄露\n\n1、单例造成的泄露\n\n在单例中使用Context对象，应该使用Application的Context，使用其他的容易造成内存泄露；但在某些情况下需要使用Activity的Context,如：涉及View的生命周期的Context\n\n注：静态对象在程序运行期间是不会被垃圾回收，在下方代码中会一直持有一个context引用，造成内存泄露。\n\n```java\npublic class AppManager{\n    private static AppManager instance;\n    private Context context;\n    private AppManager(Context context){\n        this.context=context;\n    }\n\n    public static AppManager getInstance(Context context){\n        if(instance!=null){\n            instance=new AppManager(context);\n        }\n        return instance;\n    }\n}\n```\n\n\n2、非静态内部类的静态实例造成的泄露\n\n`sResource`变量会间接持有MainActivity实例的引用，导致内存泄露\n\n```java\n\npublic class MainActivity extends Activity{\n    private static TestResource sResource=null;\n\n    @Override\n    protected void onCreate(Bundle saveInstanceState){\n        super.onCreate(saveInstanceState);\n        setContentView(R.layout.activity_main);\n        if(sResource==null){\n            sResource=new TestResource();\n        }\n\n        //...\n    }\n\n    class TestResource{\n        //...\n    }\n\n}\n\n```\n\n3、`Handler`造成的内存泄露\n\n通过匿名对象创建mHandler，会持有MainActivity实例的引用，Handler对象的生命周期会比MainActivity长，造成MainActivit不能被回收\n\n```java\n    public class MainActivity extends Activity{\n        private Handler mHandler=new Handler(){\n            @Override\n            public void handleMessage(Message msg){\n\n            }\n        }；\n        @Override\n        protected void onCreate(Bundle saveInstanceState){\n            super.onCreate(saveInstanceState);\n            setContentView(R.layout.activity_main);\n            loadData();\n        }\n\n        private void loadData(){\n            //... request\n            Message message=Message.obtain();\n            mHandler.sendMessage(message);\n        }\n      }\n    }\n\n```\n\n### 避免内存泄露的方法\n1、尽量不要让静态变量引用Activity\n\n2、使用WeakReference\n\n3、使用静态内部类来代替内部类\n\n4、静态内部类使用弱引用来引用外部类\n\n5、在生命周期结束时释放资源\n\n### 减少内存的使用\n\n* 使用更轻量的数据结构（比如SpareArray代替HashMap）\n* 避免在onDraw方法中创建对象，onDraw方法调用频率比较高，建议使用对象池(Message.obtain())\n* LruCache\n* Bitmap内存复用，压缩(inSampleSize,inBitmap)\n* StringBuilder代替Stirng,主要是String的拼接\n* App多次申请内存会造成内存抖动，内存碎片的问题\n* 使用复用池避免内存抖动和内存碎片\n\n\n\n## 内存抖动\n当内存频繁分配回收，导致内存不稳定，内存波动图形呈锯齿状\n\n在Dalvik虚拟机上比ART虚拟机上更为明显。\n\n出现的情况：\n\n1、字符串使用加号拼接\n* 使用StringBuilder替代\n* 初始化时设置容量，减少StringBuilder扩容\n\n2、资源复用\n* 使用全局对象池，重用频繁申请和释放的对象\n* 使用结束后，手动释放对象池中的对象\n\n3、使用SparseArray类族、ArrayMap代替HashMap\n\n## 内存溢出\n\n单个应用可用的最大值对应于 /system/build.prop 文件中的 dalvik.vm.heapgrowthlimit\n\n一次性创建大的数组或载入大的图片会导致OOM","slug":"Android/Advanced/Android性能优化/Andorid内存优化","published":1,"updated":"2021-01-05T12:13:27.633Z","_id":"ckjju0m26007r20ua6x6y9mga","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><p>垃圾回收器负责回收程序中已经不适用，但仍然被各种对象占用的内存，Android具有垃圾回收机制，自动追踪所有的对象。</p>\n<a id=\"more\"></a>\n<h3 id=\"Android中的垃圾回收机制\"><a href=\"#Android中的垃圾回收机制\" class=\"headerlink\" title=\"Android中的垃圾回收机制\"></a>Android中的垃圾回收机制</h3><p><img src=\"public/img/Android/Android_performance.png\"></p>\n<p>1、 Young Generation</p>\n<ul>\n<li>大多数新建对象都位于Eden区</li>\n<li>当Eden被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个Servivor区</li>\n<li>Survivor Space: S0、S1 有两个，存放每次垃圾回收后存活的对象</li>\n<li>Minor GC 同样会检查survivor区中存活的对象，并把他们转移到另一个survivor区，这样在一段时间内，总会有一个空的survivor区。</li>\n</ul>\n<p>2、Old Generation</p>\n<ul>\n<li>存放长期存活的对象和经过多次Minor GC后依然存活下来的对象</li>\n<li>满了进行Major GC(花时间比Minor时间长)</li>\n</ul>\n<p>3、Permanent Generation</p>\n<ul>\n<li>存放方法区，方法区中有要加载的类信息、静态变量、final类型的常量、属性和方法信息。</li>\n</ul>\n<h3 id=\"垃圾回收机制和FPS\"><a href=\"#垃圾回收机制和FPS\" class=\"headerlink\" title=\"垃圾回收机制和FPS\"></a>垃圾回收机制和FPS</h3><p>1、Android系统每隔16ms发出VSVNYC信号，触发对UI的渲染，那个整个过程就能保证在16ms以内就能达到一个流畅的画面。16FPS</p>\n<p>2、如果某一帧的操作超过了16ms就会让用户感觉到卡顿。</p>\n<p>3、UI渲染过程发生GC，导致某一帧绘制时间超过16ms。</p>\n<h2 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h2><p>1、应用程序分配了大量不能被回收的对象<br>2、系统可分配的内存越来越少<br>3、新对象的创建需要的内存不够<br>4、GC之后再分配<br>5、60fps</p>\n<h3 id=\"常见的内存泄露\"><a href=\"#常见的内存泄露\" class=\"headerlink\" title=\"常见的内存泄露\"></a>常见的内存泄露</h3><p>1、单例造成的泄露</p>\n<p>在单例中使用Context对象，应该使用Application的Context，使用其他的容易造成内存泄露；但在某些情况下需要使用Activity的Context,如：涉及View的生命周期的Context</p>\n<p>注：静态对象在程序运行期间是不会被垃圾回收，在下方代码中会一直持有一个context引用，造成内存泄露。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppManager</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AppManager instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Context context;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">AppManager</span><span class=\"params\">(Context context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.context=context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppManager <span class=\"title\">getInstance</span><span class=\"params\">(Context context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            instance=<span class=\"keyword\">new</span> AppManager(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、非静态内部类的静态实例造成的泄露</p>\n<p><code>sResource</code>变量会间接持有MainActivity实例的引用，导致内存泄露</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TestResource sResource=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle saveInstanceState)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(saveInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sResource==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            sResource=<span class=\"keyword\">new</span> TestResource();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestResource</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、<code>Handler</code>造成的内存泄露</p>\n<p>通过匿名对象创建mHandler，会持有MainActivity实例的引用，Handler对象的生命周期会比MainActivity长，造成MainActivit不能被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler mHandler=<span class=\"keyword\">new</span> Handler()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;；</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle saveInstanceState)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(saveInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        loadData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... request</span></span><br><span class=\"line\">        Message message=Message.obtain();</span><br><span class=\"line\">        mHandler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"避免内存泄露的方法\"><a href=\"#避免内存泄露的方法\" class=\"headerlink\" title=\"避免内存泄露的方法\"></a>避免内存泄露的方法</h3><p>1、尽量不要让静态变量引用Activity</p>\n<p>2、使用WeakReference</p>\n<p>3、使用静态内部类来代替内部类</p>\n<p>4、静态内部类使用弱引用来引用外部类</p>\n<p>5、在生命周期结束时释放资源</p>\n<h3 id=\"减少内存的使用\"><a href=\"#减少内存的使用\" class=\"headerlink\" title=\"减少内存的使用\"></a>减少内存的使用</h3><ul>\n<li>使用更轻量的数据结构（比如SpareArray代替HashMap）</li>\n<li>避免在onDraw方法中创建对象，onDraw方法调用频率比较高，建议使用对象池(Message.obtain())</li>\n<li>LruCache</li>\n<li>Bitmap内存复用，压缩(inSampleSize,inBitmap)</li>\n<li>StringBuilder代替Stirng,主要是String的拼接</li>\n<li>App多次申请内存会造成内存抖动，内存碎片的问题</li>\n<li>使用复用池避免内存抖动和内存碎片</li>\n</ul>\n<h2 id=\"内存抖动\"><a href=\"#内存抖动\" class=\"headerlink\" title=\"内存抖动\"></a>内存抖动</h2><p>当内存频繁分配回收，导致内存不稳定，内存波动图形呈锯齿状</p>\n<p>在Dalvik虚拟机上比ART虚拟机上更为明显。</p>\n<p>出现的情况：</p>\n<p>1、字符串使用加号拼接</p>\n<ul>\n<li>使用StringBuilder替代</li>\n<li>初始化时设置容量，减少StringBuilder扩容</li>\n</ul>\n<p>2、资源复用</p>\n<ul>\n<li>使用全局对象池，重用频繁申请和释放的对象</li>\n<li>使用结束后，手动释放对象池中的对象</li>\n</ul>\n<p>3、使用SparseArray类族、ArrayMap代替HashMap</p>\n<h2 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h2><p>单个应用可用的最大值对应于 /system/build.prop 文件中的 dalvik.vm.heapgrowthlimit</p>\n<p>一次性创建大的数组或载入大的图片会导致OOM</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><p>垃圾回收器负责回收程序中已经不适用，但仍然被各种对象占用的内存，Android具有垃圾回收机制，自动追踪所有的对象。</p>","more":"<h3 id=\"Android中的垃圾回收机制\"><a href=\"#Android中的垃圾回收机制\" class=\"headerlink\" title=\"Android中的垃圾回收机制\"></a>Android中的垃圾回收机制</h3><p><img src=\"public/img/Android/Android_performance.png\"></p>\n<p>1、 Young Generation</p>\n<ul>\n<li>大多数新建对象都位于Eden区</li>\n<li>当Eden被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个Servivor区</li>\n<li>Survivor Space: S0、S1 有两个，存放每次垃圾回收后存活的对象</li>\n<li>Minor GC 同样会检查survivor区中存活的对象，并把他们转移到另一个survivor区，这样在一段时间内，总会有一个空的survivor区。</li>\n</ul>\n<p>2、Old Generation</p>\n<ul>\n<li>存放长期存活的对象和经过多次Minor GC后依然存活下来的对象</li>\n<li>满了进行Major GC(花时间比Minor时间长)</li>\n</ul>\n<p>3、Permanent Generation</p>\n<ul>\n<li>存放方法区，方法区中有要加载的类信息、静态变量、final类型的常量、属性和方法信息。</li>\n</ul>\n<h3 id=\"垃圾回收机制和FPS\"><a href=\"#垃圾回收机制和FPS\" class=\"headerlink\" title=\"垃圾回收机制和FPS\"></a>垃圾回收机制和FPS</h3><p>1、Android系统每隔16ms发出VSVNYC信号，触发对UI的渲染，那个整个过程就能保证在16ms以内就能达到一个流畅的画面。16FPS</p>\n<p>2、如果某一帧的操作超过了16ms就会让用户感觉到卡顿。</p>\n<p>3、UI渲染过程发生GC，导致某一帧绘制时间超过16ms。</p>\n<h2 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h2><p>1、应用程序分配了大量不能被回收的对象<br>2、系统可分配的内存越来越少<br>3、新对象的创建需要的内存不够<br>4、GC之后再分配<br>5、60fps</p>\n<h3 id=\"常见的内存泄露\"><a href=\"#常见的内存泄露\" class=\"headerlink\" title=\"常见的内存泄露\"></a>常见的内存泄露</h3><p>1、单例造成的泄露</p>\n<p>在单例中使用Context对象，应该使用Application的Context，使用其他的容易造成内存泄露；但在某些情况下需要使用Activity的Context,如：涉及View的生命周期的Context</p>\n<p>注：静态对象在程序运行期间是不会被垃圾回收，在下方代码中会一直持有一个context引用，造成内存泄露。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppManager</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AppManager instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Context context;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">AppManager</span><span class=\"params\">(Context context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.context=context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AppManager <span class=\"title\">getInstance</span><span class=\"params\">(Context context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            instance=<span class=\"keyword\">new</span> AppManager(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、非静态内部类的静态实例造成的泄露</p>\n<p><code>sResource</code>变量会间接持有MainActivity实例的引用，导致内存泄露</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TestResource sResource=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle saveInstanceState)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(saveInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sResource==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            sResource=<span class=\"keyword\">new</span> TestResource();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestResource</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、<code>Handler</code>造成的内存泄露</p>\n<p>通过匿名对象创建mHandler，会持有MainActivity实例的引用，Handler对象的生命周期会比MainActivity长，造成MainActivit不能被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler mHandler=<span class=\"keyword\">new</span> Handler()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;；</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle saveInstanceState)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(saveInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        loadData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... request</span></span><br><span class=\"line\">        Message message=Message.obtain();</span><br><span class=\"line\">        mHandler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"避免内存泄露的方法\"><a href=\"#避免内存泄露的方法\" class=\"headerlink\" title=\"避免内存泄露的方法\"></a>避免内存泄露的方法</h3><p>1、尽量不要让静态变量引用Activity</p>\n<p>2、使用WeakReference</p>\n<p>3、使用静态内部类来代替内部类</p>\n<p>4、静态内部类使用弱引用来引用外部类</p>\n<p>5、在生命周期结束时释放资源</p>\n<h3 id=\"减少内存的使用\"><a href=\"#减少内存的使用\" class=\"headerlink\" title=\"减少内存的使用\"></a>减少内存的使用</h3><ul>\n<li>使用更轻量的数据结构（比如SpareArray代替HashMap）</li>\n<li>避免在onDraw方法中创建对象，onDraw方法调用频率比较高，建议使用对象池(Message.obtain())</li>\n<li>LruCache</li>\n<li>Bitmap内存复用，压缩(inSampleSize,inBitmap)</li>\n<li>StringBuilder代替Stirng,主要是String的拼接</li>\n<li>App多次申请内存会造成内存抖动，内存碎片的问题</li>\n<li>使用复用池避免内存抖动和内存碎片</li>\n</ul>\n<h2 id=\"内存抖动\"><a href=\"#内存抖动\" class=\"headerlink\" title=\"内存抖动\"></a>内存抖动</h2><p>当内存频繁分配回收，导致内存不稳定，内存波动图形呈锯齿状</p>\n<p>在Dalvik虚拟机上比ART虚拟机上更为明显。</p>\n<p>出现的情况：</p>\n<p>1、字符串使用加号拼接</p>\n<ul>\n<li>使用StringBuilder替代</li>\n<li>初始化时设置容量，减少StringBuilder扩容</li>\n</ul>\n<p>2、资源复用</p>\n<ul>\n<li>使用全局对象池，重用频繁申请和释放的对象</li>\n<li>使用结束后，手动释放对象池中的对象</li>\n</ul>\n<p>3、使用SparseArray类族、ArrayMap代替HashMap</p>\n<h2 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h2><p>单个应用可用的最大值对应于 /system/build.prop 文件中的 dalvik.vm.heapgrowthlimit</p>\n<p>一次性创建大的数组或载入大的图片会导致OOM</p>"},{"title":"Android视图优化","description":"Android视图优化","type":["Android","优化"],"toc":true,"cover":"/cover/img78.jpg","date":"2019-08-15T16:00:00.000Z","_content":"\n### 视图优化\n\n60fps，16ms，只有在60fps及以上，眼睛大脑才会感到流畅.\n\nVSYNC(刷新率)：硬件刷新频率 60Hz\n帧率：GPU一秒钟绘制的帧数 30fpd, 60fps\n\n刷新率 > 帧率 ： 屏幕在连续两次刷新的时候，会出现图像暂停或者卡顿现象。\n\n帧率 > 刷新率 ：图像会差生割裂的现象。\n<!--more-->\n施工双缓冲机制\n\nBackBuffer：GPU渲染的数据会写入BackBuffer；\nFrameBuffer：屏幕显示的数据只会从FrameBuffer中进行读取。\n\nBackBuffer和FrameBuffer会进行同步；\n\n\n### 避免UI卡顿\n\n* 避免在onDraw中创建对象，使用对象池；频繁创建对象会造成内存抖动\n* 减少View层级，每一个层级的测量绘制会花费过多时间，以及造成过度绘制。\n* 避免在UI顶层使用RelativeLayout，measure了两次\n* 自定义控件控制绘制复杂度\n\n### 优化过度绘制\n\n* 降低View的层级,使用merge标签\n* 去掉不必要的背景，去掉window的背景\n* ClipRect指定当前的绘制区域，QuickReject落在制定区域之外的像素不会被绘制\n* ViewStub，刚开始不需要显示，不会参与measure和layout过程\n* .9图用作背景","source":"_posts/Android/Advanced/Android性能优化/Android视图优化.md","raw":"---\ntitle: \"Android视图优化\"\ndescription: \"Android视图优化\"\ntype: [Android,优化]\ntoc: true\ncover:  /cover/img78.jpg\ncategories: Android\ndate: 2019/08/16\n---\n\n### 视图优化\n\n60fps，16ms，只有在60fps及以上，眼睛大脑才会感到流畅.\n\nVSYNC(刷新率)：硬件刷新频率 60Hz\n帧率：GPU一秒钟绘制的帧数 30fpd, 60fps\n\n刷新率 > 帧率 ： 屏幕在连续两次刷新的时候，会出现图像暂停或者卡顿现象。\n\n帧率 > 刷新率 ：图像会差生割裂的现象。\n<!--more-->\n施工双缓冲机制\n\nBackBuffer：GPU渲染的数据会写入BackBuffer；\nFrameBuffer：屏幕显示的数据只会从FrameBuffer中进行读取。\n\nBackBuffer和FrameBuffer会进行同步；\n\n\n### 避免UI卡顿\n\n* 避免在onDraw中创建对象，使用对象池；频繁创建对象会造成内存抖动\n* 减少View层级，每一个层级的测量绘制会花费过多时间，以及造成过度绘制。\n* 避免在UI顶层使用RelativeLayout，measure了两次\n* 自定义控件控制绘制复杂度\n\n### 优化过度绘制\n\n* 降低View的层级,使用merge标签\n* 去掉不必要的背景，去掉window的背景\n* ClipRect指定当前的绘制区域，QuickReject落在制定区域之外的像素不会被绘制\n* ViewStub，刚开始不需要显示，不会参与measure和layout过程\n* .9图用作背景","slug":"Android/Advanced/Android性能优化/Android视图优化","published":1,"updated":"2021-01-05T12:13:27.939Z","_id":"ckjju0m27007u20uadwn4ew6l","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"视图优化\"><a href=\"#视图优化\" class=\"headerlink\" title=\"视图优化\"></a>视图优化</h3><p>60fps，16ms，只有在60fps及以上，眼睛大脑才会感到流畅.</p>\n<p>VSYNC(刷新率)：硬件刷新频率 60Hz<br>帧率：GPU一秒钟绘制的帧数 30fpd, 60fps</p>\n<p>刷新率 &gt; 帧率 ： 屏幕在连续两次刷新的时候，会出现图像暂停或者卡顿现象。</p>\n<p>帧率 &gt; 刷新率 ：图像会差生割裂的现象。</p>\n<a id=\"more\"></a>\n<p>施工双缓冲机制</p>\n<p>BackBuffer：GPU渲染的数据会写入BackBuffer；<br>FrameBuffer：屏幕显示的数据只会从FrameBuffer中进行读取。</p>\n<p>BackBuffer和FrameBuffer会进行同步；</p>\n<h3 id=\"避免UI卡顿\"><a href=\"#避免UI卡顿\" class=\"headerlink\" title=\"避免UI卡顿\"></a>避免UI卡顿</h3><ul>\n<li>避免在onDraw中创建对象，使用对象池；频繁创建对象会造成内存抖动</li>\n<li>减少View层级，每一个层级的测量绘制会花费过多时间，以及造成过度绘制。</li>\n<li>避免在UI顶层使用RelativeLayout，measure了两次</li>\n<li>自定义控件控制绘制复杂度</li>\n</ul>\n<h3 id=\"优化过度绘制\"><a href=\"#优化过度绘制\" class=\"headerlink\" title=\"优化过度绘制\"></a>优化过度绘制</h3><ul>\n<li>降低View的层级,使用merge标签</li>\n<li>去掉不必要的背景，去掉window的背景</li>\n<li>ClipRect指定当前的绘制区域，QuickReject落在制定区域之外的像素不会被绘制</li>\n<li>ViewStub，刚开始不需要显示，不会参与measure和layout过程</li>\n<li>.9图用作背景</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"视图优化\"><a href=\"#视图优化\" class=\"headerlink\" title=\"视图优化\"></a>视图优化</h3><p>60fps，16ms，只有在60fps及以上，眼睛大脑才会感到流畅.</p>\n<p>VSYNC(刷新率)：硬件刷新频率 60Hz<br>帧率：GPU一秒钟绘制的帧数 30fpd, 60fps</p>\n<p>刷新率 &gt; 帧率 ： 屏幕在连续两次刷新的时候，会出现图像暂停或者卡顿现象。</p>\n<p>帧率 &gt; 刷新率 ：图像会差生割裂的现象。</p>","more":"<p>施工双缓冲机制</p>\n<p>BackBuffer：GPU渲染的数据会写入BackBuffer；<br>FrameBuffer：屏幕显示的数据只会从FrameBuffer中进行读取。</p>\n<p>BackBuffer和FrameBuffer会进行同步；</p>\n<h3 id=\"避免UI卡顿\"><a href=\"#避免UI卡顿\" class=\"headerlink\" title=\"避免UI卡顿\"></a>避免UI卡顿</h3><ul>\n<li>避免在onDraw中创建对象，使用对象池；频繁创建对象会造成内存抖动</li>\n<li>减少View层级，每一个层级的测量绘制会花费过多时间，以及造成过度绘制。</li>\n<li>避免在UI顶层使用RelativeLayout，measure了两次</li>\n<li>自定义控件控制绘制复杂度</li>\n</ul>\n<h3 id=\"优化过度绘制\"><a href=\"#优化过度绘制\" class=\"headerlink\" title=\"优化过度绘制\"></a>优化过度绘制</h3><ul>\n<li>降低View的层级,使用merge标签</li>\n<li>去掉不必要的背景，去掉window的背景</li>\n<li>ClipRect指定当前的绘制区域，QuickReject落在制定区域之外的像素不会被绘制</li>\n<li>ViewStub，刚开始不需要显示，不会参与measure和layout过程</li>\n<li>.9图用作背景</li>\n</ul>"},{"title":"Android AIDL介绍","description":"Android接口定义语言AIDL","type":["Android"],"toc":true,"cover":"/cover/img79.jpg","date":"2019-10-29T16:00:00.000Z","_content":"\n## Android接口定义语言AIDL\n\n使用AIDL可以进行进程间通信(IPC)，包含客户端与服务，\n\n注：不同通信方式适合环境;\n* 使用Binder创建接口，跨不同应用，执行并发IPC\n* 使用Messager 实现接口，执行IPC，但不需要并发IPC\n<!--more-->","source":"_posts/Android/Advanced/基础/AIDL介绍.md","raw":"---\ntitle: \"Android AIDL介绍\"\ndescription: \"Android接口定义语言AIDL\"\ntype: [Android]\ntoc: true\ncover:  /cover/img79.jpg\ncategories: Android\ndate: 2019/10/30\n---\n\n## Android接口定义语言AIDL\n\n使用AIDL可以进行进程间通信(IPC)，包含客户端与服务，\n\n注：不同通信方式适合环境;\n* 使用Binder创建接口，跨不同应用，执行并发IPC\n* 使用Messager 实现接口，执行IPC，但不需要并发IPC\n<!--more-->","slug":"Android/Advanced/基础/AIDL介绍","published":1,"updated":"2021-01-05T12:13:28.300Z","_id":"ckjju0m27007x20uaaagkalsl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android接口定义语言AIDL\"><a href=\"#Android接口定义语言AIDL\" class=\"headerlink\" title=\"Android接口定义语言AIDL\"></a>Android接口定义语言AIDL</h2><p>使用AIDL可以进行进程间通信(IPC)，包含客户端与服务，</p>\n<p>注：不同通信方式适合环境;</p>\n<ul>\n<li>使用Binder创建接口，跨不同应用，执行并发IPC</li>\n<li>使用Messager 实现接口，执行IPC，但不需要并发IPC<a id=\"more\"></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Android接口定义语言AIDL\"><a href=\"#Android接口定义语言AIDL\" class=\"headerlink\" title=\"Android接口定义语言AIDL\"></a>Android接口定义语言AIDL</h2><p>使用AIDL可以进行进程间通信(IPC)，包含客户端与服务，</p>\n<p>注：不同通信方式适合环境;</p>\n<ul>\n<li>使用Binder创建接口，跨不同应用，执行并发IPC</li>\n<li>使用Messager 实现接口，执行IPC，但不需要并发IPC","more":"</li>\n</ul>"},{"title":"Android 打包流程","description":"Android 打包流程","type":["Android"],"toc":true,"cover":"/cover/img97.jpg","date":"2020-05-29T16:00:00.000Z","_content":"\n## Android 打包流程\n\nAndroid打包签名\n\n签名三步：\n\n    1、计算摘要\n    2、对原始数据私钥非对称加密\n    3、将签名写入签名区块\n\n一个key store可以放置多个秘钥，同一个签名文件，给多个应用进行签名。\n\nV2签名在Android 7.0之后出现的。\n\n","source":"_posts/Android/Advanced/基础/Android打包流程.md","raw":"---\ntitle: \"Android 打包流程\"\ndescription: \"Android 打包流程\"\ntype: [Android]\ntoc: true\ncover:  /cover/img97.jpg\ncategories: Android\ndate: 2020/5/30\n---\n\n## Android 打包流程\n\nAndroid打包签名\n\n签名三步：\n\n    1、计算摘要\n    2、对原始数据私钥非对称加密\n    3、将签名写入签名区块\n\n一个key store可以放置多个秘钥，同一个签名文件，给多个应用进行签名。\n\nV2签名在Android 7.0之后出现的。\n\n","slug":"Android/Advanced/基础/Android打包流程","published":1,"updated":"2021-01-06T00:54:32.172Z","_id":"ckjju0m28008120ua5xbrav3v","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android-打包流程\"><a href=\"#Android-打包流程\" class=\"headerlink\" title=\"Android 打包流程\"></a>Android 打包流程</h2><p>Android打包签名</p>\n<p>签名三步：</p>\n<pre><code>1、计算摘要\n2、对原始数据私钥非对称加密\n3、将签名写入签名区块</code></pre>\n<p>一个key store可以放置多个秘钥，同一个签名文件，给多个应用进行签名。</p>\n<p>V2签名在Android 7.0之后出现的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android-打包流程\"><a href=\"#Android-打包流程\" class=\"headerlink\" title=\"Android 打包流程\"></a>Android 打包流程</h2><p>Android打包签名</p>\n<p>签名三步：</p>\n<pre><code>1、计算摘要\n2、对原始数据私钥非对称加密\n3、将签名写入签名区块</code></pre>\n<p>一个key store可以放置多个秘钥，同一个签名文件，给多个应用进行签名。</p>\n<p>V2签名在Android 7.0之后出现的。</p>\n"},{"title":"Android编译时注解处理器使用","type":["Android"],"description":"Android编译时注解处理器使用","cover":"/cover/img85.jpg","toc":true,"date":"2020-01-08T16:00:00.000Z","_content":"\n## 名词介绍\n\n### APT介绍（Annotation Processing Tool）\n\n`com.sun.mirror`包中持有的APT以及相关的API,从JDK7开始弃用，从JDK8中正式移除，使用`javax.annotation.processing`包和` javax.lang.model `来处理编译时注解；\n\nRetrofit2、 Dagger2、EventBus3都使用了APT技术\n\n\n### Java Pluggable Annotation Processor （插件化注解处理框架）\n\nAPT从JDK被移除后取而代之的是Java Pluggable Annotation Processor，它从JDK 6开始进行支持。它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个\"round\"，这样整个Annotation processing过程可以看作是一个round的序列。\nPluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类javax.annotation.processing.AbstractProcessor。注意，与运行时注解RetentionPolicy.RUNTIME不同，注解处理器只会处理编译期注解，也就是RetentionPolicy.SOURCE的注解类型，处理的阶段位于Java代码编译期间。\n\n### android-apt\n\nandroid-apt是第三方开源的注解处理框架，刚开始Android对注解处理的支持。dagger、ButterKnife等流行的注解框架，都是用的android-apt进行的注解处理。\n\n### annotationProcessor\n在Android studio Gradle插件2.2版本发布后，对Android支持的注解处理，，直接在build.gradle文件配置即可使用。\n\n\n## 在Android中编译时注解处理器\n\n在Android现有的开发中，使用的是 Java Pluggable Annotation Processor 而非 Annotation Processing Tool,因为所使用的`AbstractProcessor`位于 `javax.annotation.processing`而非`com.sun.mirror`包下；在开发的过程中需要注意环境的兼容；\n\n\n### Elements介绍\n\n* PackageElement 表示一个包程序元素，提供有关包及其成员的信息的访问；\n* ExecutableElement 表示某个类或接口的方法、构造方法或初始化程序；\n* TypeElement 表示一个类或接口程序元素，提供有关类型及其成员的信息的访问；\n* 表示一个字段、enmu常量、方法或构造方法参数、局部变量或异常参数；\n\n\n## 在Android中编译时注解处理器实现\n\n实现的功能：在User类上使用编译时注解，自动生成User_log类，可以通过User_log类输出User的属性；其中User类和生成User_log类的源码如下：\n\n```java\n@Logger\npublic class User {\n\n    String name;\n\n    String city;\n\n    public User(String name,String city){\n        this.name=name;\n        this.city=city;\n    }\n    //get和set方法省略\n}\n\n```\n\n```java\npublic final class User_log {\n  public static void log(User args) {\n    Log.d(\"User\",String.format(\"name - %scity - %s\", args .name, args .city));\n  }\n}\n\n```\n\nUser_log的调用\n\n```java\n  User user=new User(\"test\",\"bj\");\n  User_log.log(user);\n\n```\n\n\n### 创建Annotation 模块\n\n1、新建一个Moudle类型为Java Library，命名为`annotation`,创建Logger注解\n\n```java\n    @Target(ElementType.TYPE)\n    @Retention(RetentionPolicy.SOURCE)  //用于表示在编译时运行\n    public @interface Logger {\n    \n    }\n\n```\n\n2、对Annotation模块的的gradle进行配置\n\n```xml\n    apply plugin: 'java-library'\n\n    dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n    sourceCompatibility = \"7\"\n    targetCompatibility = \"7\"\n\n\n```\n\n\n\n\n\n### 创建Compile 模块\n\n新建一个Moudle类型为Java Library，命名为`compile`\n\n1、对Compile模块的gradle进行配置\n\n```xml\napply plugin: 'java-library'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation project(\":annotation\")\n\n    //通过类调用的形式来生成Java代码\n    implementation 'com.squareup:javapoet:1.7.0'\n    implementation 'com.google.guava:guava:19.0'\n    //使用AutoService注册我们的processor\n    implementation 'com.google.auto.service:auto-service:1.0-rc2'   \n    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc2'\n}\n\nsourceCompatibility = \"7\"\ntargetCompatibility = \"7\"\n\n\n```\n\n2、创建注解处理器 \n\n\n```java\n\npublic class LoggerProcessor extends AbstractProcessor {\n\n    //processor 运行在一个独立的JVM实例中，javac为我们的processor启动一个新的进程，要使我们的processor被javac检测到，\n    //需要使用ServiceLoader进行注册\n\n    //用于处理一些初始化内容，工具类等\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n    }\n\n    \n    /***\n     * 注解处理器的核心方法，用于处理具体的注解，生成Java文件\n     * @param set               使用了支持处理注解的节点集合（类上面写了注解）\n     * @param roundEnvironment  当前或是之前的运行环境，可以通过该对象查找找到的注解\n     * @return true表示后续处理器不再会处理，false则会继续进行处理\n     */\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        return false;\n    }\n\n    //用于获取支持处理的注解类  在本例中使用 @SupportedAnnotationTypes()实现\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        return super.getSupportedAnnotationTypes();\n    }\n\n    //用于设置通过某一版本进行编译，必填 在本例中使用 @SupportedSourceVersion()注解实现\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return super.getSupportedSourceVersion();\n    }\n\n    //用于获取从外部传入的属性变量 在本例中是接受调用模块的gradle 中的参数；使用 @SupportedOptions（)注解实现\n    @Override\n    public Set<String> getSupportedOptions() {\n        return super.getSupportedOptions();\n    }\n}\n\n\n\n\n```\n\n\n\n3、添加注解处理器所需的必要内容;\n\n\n```java\n//通过AutoService 注册自动生成处理的文件\n@AutoService(Processor.class)\n//允许/支持的注解类型，让注解处理器处理\n@SupportedAnnotationTypes(\"com.example.annotation.Logger\")\n//指定JDK编译版本\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\n//接受build.gradle穿过来的参数，“content”为参数名\n@SupportedOptions(\"content\")\npublic class LoggerProcessor extends AbstractProcessor {\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        return false;\n    }\n\n}\n\n```\n在`@SupportedOptions(\"content\")` 注解中，\"content\"，参数的传入必须啊在defaultConfig节点，可以在`getSupportedOptions() `方法中进行获取\n\n```xml\n      //在gradle文件中配置选项参数值（用于APT传参接收，在ARouterProcessor的参数）\n        //该配置必须卸载defaultConfig节点下  \n        javaCompileOptions{\n            annotationProcessorOptions{\n                arguments=[moduleName:project.name,packageNameForAPT:packageNameForAPT]\n            }\n\n        }\n\n```\n\n4、添加文件输出变量和日志输出\n\n```java\n    //用来输出警告，错误等日志\n    private Messager messager;\n    //文件生成器  类/资源/Filter用来创建新的类文件，class文件以及辅助文件\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n        messager=processingEnvironment.getMessager();\n        filer=processingEnvironment.getFiler();\n    }\n\n```\n\n5、在编译时对注解进行处理，并不是所有的类中都被注解标记，因此需要对类上的注解进行判断。\n\n```java\n    private boolean isValidClass(TypeElement typeElement){\n        if (typeElement.getKind()!= ElementKind.CLASS){\n            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+\"只有class可以使用log注解\");\n            return false;\n        }\n\n        if (typeElement.getModifiers().contains(Modifier.PRIVATE))\n        {\n            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+\"只有public类型的类可以使用log\");\n        }\n\n\n        return true;\n    }\n\n````\n\n\n6、添加注解处理完成后的文件输出方法\n\n```java\n\n    private void writeSourceFile(TypeElement originatingType){\n\n        //从android.util.package中获取log类\n        //可以保证Log类被正确引入我们的生成类中\n        ClassName logClassName=ClassName.get(\"android.util\",\"Log\");\n\n        //用于获取当前注解的class名称\n        TypeVariableName typeVariableName=TypeVariableName.get(originatingType.getSimpleName().toString());\n\n\n        //创建一个名称为log的静态方法\n        MethodSpec log=MethodSpec.methodBuilder(METHOD_LOG)\n                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)\n                .returns(void.class)\n                //参数变量由注解的类决定\n                .addParameter(typeVariableName,KEY_PATH_NAME)\n                //创建一个 Log.d(\"className\",String.format(class fields))\n                .addStatement(\"$T.d($S,$L)\",logClassName,originatingType.getSimpleName().toString(), generateFormat(originatingType))\n                .build();\n\n\n        //创建一个class，创建的class的名字为： 被注解的class名+_Log\n\n        TypeSpec loggerClass=TypeSpec.classBuilder(originatingType.getSimpleName().toString()+CLASS_SUFFIX)\n                .addModifiers(Modifier.PUBLIC,Modifier.FINAL)\n                //天啊及log方法\n                .addMethod(log).build();\n\n        //创建文件\n        JavaFile javaFile=JavaFile.builder(originatingType.getEnclosingElement().toString(),loggerClass).build();\n\n        try {\n            javaFile.writeTo(filer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n\n```\n7、在processor中对注解进行处理\n\n```java\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        //获取所有被Logger注解的元素\n        Collection<? extends Element>annotatedElements=roundEnvironment.getElementsAnnotatedWith(Logger.class);\n\n        //删除我们不需要的元素\n        List<TypeElement>typeElements=new ImmutableList.Builder<TypeElement>().addAll(ElementFilter.typesIn(annotatedElements)).build();\n\n\n        for (TypeElement typeElement:typeElements){\n            //interface也可能是type类型，只筛选出我们需要的class\n            if (isValidClass(typeElement)){\n                writeSourceFile(typeElement);\n            };\n\n        }\n\n        return false;\n    }\n\n\n```\n\n\n[源码地址](https://github.com/LuciusCS/AndroidProject) 所使用模块为 `Jpapmodule`、`annotation`、` \tcompiler`\n\n\n[源码进阶](https://github.com/LuciusCS/AptRouter) 模仿ARouter的模块化路由框架\n\n参考资料：\n\n1、https://www.cnblogs.com/throwable/p/9139908.html\n\n\n\n\n\n\n","source":"_posts/Android/Advanced/基础/编译时注解处理与使用.md","raw":"---\ntitle: Android编译时注解处理器使用\ntype: [Android]\ndescription: Android编译时注解处理器使用\ncover:  /cover/img85.jpg\ntoc: true\ncategories: Android\ndate: 2020/01/09\n---\n\n## 名词介绍\n\n### APT介绍（Annotation Processing Tool）\n\n`com.sun.mirror`包中持有的APT以及相关的API,从JDK7开始弃用，从JDK8中正式移除，使用`javax.annotation.processing`包和` javax.lang.model `来处理编译时注解；\n\nRetrofit2、 Dagger2、EventBus3都使用了APT技术\n\n\n### Java Pluggable Annotation Processor （插件化注解处理框架）\n\nAPT从JDK被移除后取而代之的是Java Pluggable Annotation Processor，它从JDK 6开始进行支持。它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个\"round\"，这样整个Annotation processing过程可以看作是一个round的序列。\nPluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类javax.annotation.processing.AbstractProcessor。注意，与运行时注解RetentionPolicy.RUNTIME不同，注解处理器只会处理编译期注解，也就是RetentionPolicy.SOURCE的注解类型，处理的阶段位于Java代码编译期间。\n\n### android-apt\n\nandroid-apt是第三方开源的注解处理框架，刚开始Android对注解处理的支持。dagger、ButterKnife等流行的注解框架，都是用的android-apt进行的注解处理。\n\n### annotationProcessor\n在Android studio Gradle插件2.2版本发布后，对Android支持的注解处理，，直接在build.gradle文件配置即可使用。\n\n\n## 在Android中编译时注解处理器\n\n在Android现有的开发中，使用的是 Java Pluggable Annotation Processor 而非 Annotation Processing Tool,因为所使用的`AbstractProcessor`位于 `javax.annotation.processing`而非`com.sun.mirror`包下；在开发的过程中需要注意环境的兼容；\n\n\n### Elements介绍\n\n* PackageElement 表示一个包程序元素，提供有关包及其成员的信息的访问；\n* ExecutableElement 表示某个类或接口的方法、构造方法或初始化程序；\n* TypeElement 表示一个类或接口程序元素，提供有关类型及其成员的信息的访问；\n* 表示一个字段、enmu常量、方法或构造方法参数、局部变量或异常参数；\n\n\n## 在Android中编译时注解处理器实现\n\n实现的功能：在User类上使用编译时注解，自动生成User_log类，可以通过User_log类输出User的属性；其中User类和生成User_log类的源码如下：\n\n```java\n@Logger\npublic class User {\n\n    String name;\n\n    String city;\n\n    public User(String name,String city){\n        this.name=name;\n        this.city=city;\n    }\n    //get和set方法省略\n}\n\n```\n\n```java\npublic final class User_log {\n  public static void log(User args) {\n    Log.d(\"User\",String.format(\"name - %scity - %s\", args .name, args .city));\n  }\n}\n\n```\n\nUser_log的调用\n\n```java\n  User user=new User(\"test\",\"bj\");\n  User_log.log(user);\n\n```\n\n\n### 创建Annotation 模块\n\n1、新建一个Moudle类型为Java Library，命名为`annotation`,创建Logger注解\n\n```java\n    @Target(ElementType.TYPE)\n    @Retention(RetentionPolicy.SOURCE)  //用于表示在编译时运行\n    public @interface Logger {\n    \n    }\n\n```\n\n2、对Annotation模块的的gradle进行配置\n\n```xml\n    apply plugin: 'java-library'\n\n    dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n    }\n\n    sourceCompatibility = \"7\"\n    targetCompatibility = \"7\"\n\n\n```\n\n\n\n\n\n### 创建Compile 模块\n\n新建一个Moudle类型为Java Library，命名为`compile`\n\n1、对Compile模块的gradle进行配置\n\n```xml\napply plugin: 'java-library'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation project(\":annotation\")\n\n    //通过类调用的形式来生成Java代码\n    implementation 'com.squareup:javapoet:1.7.0'\n    implementation 'com.google.guava:guava:19.0'\n    //使用AutoService注册我们的processor\n    implementation 'com.google.auto.service:auto-service:1.0-rc2'   \n    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc2'\n}\n\nsourceCompatibility = \"7\"\ntargetCompatibility = \"7\"\n\n\n```\n\n2、创建注解处理器 \n\n\n```java\n\npublic class LoggerProcessor extends AbstractProcessor {\n\n    //processor 运行在一个独立的JVM实例中，javac为我们的processor启动一个新的进程，要使我们的processor被javac检测到，\n    //需要使用ServiceLoader进行注册\n\n    //用于处理一些初始化内容，工具类等\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n    }\n\n    \n    /***\n     * 注解处理器的核心方法，用于处理具体的注解，生成Java文件\n     * @param set               使用了支持处理注解的节点集合（类上面写了注解）\n     * @param roundEnvironment  当前或是之前的运行环境，可以通过该对象查找找到的注解\n     * @return true表示后续处理器不再会处理，false则会继续进行处理\n     */\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        return false;\n    }\n\n    //用于获取支持处理的注解类  在本例中使用 @SupportedAnnotationTypes()实现\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        return super.getSupportedAnnotationTypes();\n    }\n\n    //用于设置通过某一版本进行编译，必填 在本例中使用 @SupportedSourceVersion()注解实现\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return super.getSupportedSourceVersion();\n    }\n\n    //用于获取从外部传入的属性变量 在本例中是接受调用模块的gradle 中的参数；使用 @SupportedOptions（)注解实现\n    @Override\n    public Set<String> getSupportedOptions() {\n        return super.getSupportedOptions();\n    }\n}\n\n\n\n\n```\n\n\n\n3、添加注解处理器所需的必要内容;\n\n\n```java\n//通过AutoService 注册自动生成处理的文件\n@AutoService(Processor.class)\n//允许/支持的注解类型，让注解处理器处理\n@SupportedAnnotationTypes(\"com.example.annotation.Logger\")\n//指定JDK编译版本\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\n//接受build.gradle穿过来的参数，“content”为参数名\n@SupportedOptions(\"content\")\npublic class LoggerProcessor extends AbstractProcessor {\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        return false;\n    }\n\n}\n\n```\n在`@SupportedOptions(\"content\")` 注解中，\"content\"，参数的传入必须啊在defaultConfig节点，可以在`getSupportedOptions() `方法中进行获取\n\n```xml\n      //在gradle文件中配置选项参数值（用于APT传参接收，在ARouterProcessor的参数）\n        //该配置必须卸载defaultConfig节点下  \n        javaCompileOptions{\n            annotationProcessorOptions{\n                arguments=[moduleName:project.name,packageNameForAPT:packageNameForAPT]\n            }\n\n        }\n\n```\n\n4、添加文件输出变量和日志输出\n\n```java\n    //用来输出警告，错误等日志\n    private Messager messager;\n    //文件生成器  类/资源/Filter用来创建新的类文件，class文件以及辅助文件\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n        messager=processingEnvironment.getMessager();\n        filer=processingEnvironment.getFiler();\n    }\n\n```\n\n5、在编译时对注解进行处理，并不是所有的类中都被注解标记，因此需要对类上的注解进行判断。\n\n```java\n    private boolean isValidClass(TypeElement typeElement){\n        if (typeElement.getKind()!= ElementKind.CLASS){\n            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+\"只有class可以使用log注解\");\n            return false;\n        }\n\n        if (typeElement.getModifiers().contains(Modifier.PRIVATE))\n        {\n            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+\"只有public类型的类可以使用log\");\n        }\n\n\n        return true;\n    }\n\n````\n\n\n6、添加注解处理完成后的文件输出方法\n\n```java\n\n    private void writeSourceFile(TypeElement originatingType){\n\n        //从android.util.package中获取log类\n        //可以保证Log类被正确引入我们的生成类中\n        ClassName logClassName=ClassName.get(\"android.util\",\"Log\");\n\n        //用于获取当前注解的class名称\n        TypeVariableName typeVariableName=TypeVariableName.get(originatingType.getSimpleName().toString());\n\n\n        //创建一个名称为log的静态方法\n        MethodSpec log=MethodSpec.methodBuilder(METHOD_LOG)\n                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)\n                .returns(void.class)\n                //参数变量由注解的类决定\n                .addParameter(typeVariableName,KEY_PATH_NAME)\n                //创建一个 Log.d(\"className\",String.format(class fields))\n                .addStatement(\"$T.d($S,$L)\",logClassName,originatingType.getSimpleName().toString(), generateFormat(originatingType))\n                .build();\n\n\n        //创建一个class，创建的class的名字为： 被注解的class名+_Log\n\n        TypeSpec loggerClass=TypeSpec.classBuilder(originatingType.getSimpleName().toString()+CLASS_SUFFIX)\n                .addModifiers(Modifier.PUBLIC,Modifier.FINAL)\n                //天啊及log方法\n                .addMethod(log).build();\n\n        //创建文件\n        JavaFile javaFile=JavaFile.builder(originatingType.getEnclosingElement().toString(),loggerClass).build();\n\n        try {\n            javaFile.writeTo(filer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n\n\n```\n7、在processor中对注解进行处理\n\n```java\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        //获取所有被Logger注解的元素\n        Collection<? extends Element>annotatedElements=roundEnvironment.getElementsAnnotatedWith(Logger.class);\n\n        //删除我们不需要的元素\n        List<TypeElement>typeElements=new ImmutableList.Builder<TypeElement>().addAll(ElementFilter.typesIn(annotatedElements)).build();\n\n\n        for (TypeElement typeElement:typeElements){\n            //interface也可能是type类型，只筛选出我们需要的class\n            if (isValidClass(typeElement)){\n                writeSourceFile(typeElement);\n            };\n\n        }\n\n        return false;\n    }\n\n\n```\n\n\n[源码地址](https://github.com/LuciusCS/AndroidProject) 所使用模块为 `Jpapmodule`、`annotation`、` \tcompiler`\n\n\n[源码进阶](https://github.com/LuciusCS/AptRouter) 模仿ARouter的模块化路由框架\n\n参考资料：\n\n1、https://www.cnblogs.com/throwable/p/9139908.html\n\n\n\n\n\n\n","slug":"Android/Advanced/基础/编译时注解处理与使用","published":1,"updated":"2021-01-05T12:13:34.375Z","_id":"ckjju0m29008420ua1fg0b5oj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"名词介绍\"><a href=\"#名词介绍\" class=\"headerlink\" title=\"名词介绍\"></a>名词介绍</h2><h3 id=\"APT介绍（Annotation-Processing-Tool）\"><a href=\"#APT介绍（Annotation-Processing-Tool）\" class=\"headerlink\" title=\"APT介绍（Annotation Processing Tool）\"></a>APT介绍（Annotation Processing Tool）</h3><p><code>com.sun.mirror</code>包中持有的APT以及相关的API,从JDK7开始弃用，从JDK8中正式移除，使用<code>javax.annotation.processing</code>包和<code>javax.lang.model</code>来处理编译时注解；</p>\n<p>Retrofit2、 Dagger2、EventBus3都使用了APT技术</p>\n<h3 id=\"Java-Pluggable-Annotation-Processor-（插件化注解处理框架）\"><a href=\"#Java-Pluggable-Annotation-Processor-（插件化注解处理框架）\" class=\"headerlink\" title=\"Java Pluggable Annotation Processor （插件化注解处理框架）\"></a>Java Pluggable Annotation Processor （插件化注解处理框架）</h3><p>APT从JDK被移除后取而代之的是Java Pluggable Annotation Processor，它从JDK 6开始进行支持。它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。<br>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类javax.annotation.processing.AbstractProcessor。注意，与运行时注解RetentionPolicy.RUNTIME不同，注解处理器只会处理编译期注解，也就是RetentionPolicy.SOURCE的注解类型，处理的阶段位于Java代码编译期间。</p>\n<h3 id=\"android-apt\"><a href=\"#android-apt\" class=\"headerlink\" title=\"android-apt\"></a>android-apt</h3><p>android-apt是第三方开源的注解处理框架，刚开始Android对注解处理的支持。dagger、ButterKnife等流行的注解框架，都是用的android-apt进行的注解处理。</p>\n<h3 id=\"annotationProcessor\"><a href=\"#annotationProcessor\" class=\"headerlink\" title=\"annotationProcessor\"></a>annotationProcessor</h3><p>在Android studio Gradle插件2.2版本发布后，对Android支持的注解处理，，直接在build.gradle文件配置即可使用。</p>\n<h2 id=\"在Android中编译时注解处理器\"><a href=\"#在Android中编译时注解处理器\" class=\"headerlink\" title=\"在Android中编译时注解处理器\"></a>在Android中编译时注解处理器</h2><p>在Android现有的开发中，使用的是 Java Pluggable Annotation Processor 而非 Annotation Processing Tool,因为所使用的<code>AbstractProcessor</code>位于 <code>javax.annotation.processing</code>而非<code>com.sun.mirror</code>包下；在开发的过程中需要注意环境的兼容；</p>\n<h3 id=\"Elements介绍\"><a href=\"#Elements介绍\" class=\"headerlink\" title=\"Elements介绍\"></a>Elements介绍</h3><ul>\n<li>PackageElement 表示一个包程序元素，提供有关包及其成员的信息的访问；</li>\n<li>ExecutableElement 表示某个类或接口的方法、构造方法或初始化程序；</li>\n<li>TypeElement 表示一个类或接口程序元素，提供有关类型及其成员的信息的访问；</li>\n<li>表示一个字段、enmu常量、方法或构造方法参数、局部变量或异常参数；</li>\n</ul>\n<h2 id=\"在Android中编译时注解处理器实现\"><a href=\"#在Android中编译时注解处理器实现\" class=\"headerlink\" title=\"在Android中编译时注解处理器实现\"></a>在Android中编译时注解处理器实现</h2><p>实现的功能：在User类上使用编译时注解，自动生成User_log类，可以通过User_log类输出User的属性；其中User类和生成User_log类的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Logger</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name,String city)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.city=city;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//get和set方法省略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User_log</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(User args)</span> </span>&#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;User&quot;</span>,String.format(<span class=\"string\">&quot;name - %scity - %s&quot;</span>, args .name, args .city));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>User_log的调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user=<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;bj&quot;</span>);</span><br><span class=\"line\">User_log.log(user);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建Annotation-模块\"><a href=\"#创建Annotation-模块\" class=\"headerlink\" title=\"创建Annotation 模块\"></a>创建Annotation 模块</h3><p>1、新建一个Moudle类型为Java Library，命名为<code>annotation</code>,创建Logger注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.SOURCE)</span>  <span class=\"comment\">//用于表示在编译时运行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Logger &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、对Annotation模块的的gradle进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;java-library&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = &quot;7&quot;</span><br><span class=\"line\">targetCompatibility = &quot;7&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"创建Compile-模块\"><a href=\"#创建Compile-模块\" class=\"headerlink\" title=\"创建Compile 模块\"></a>创建Compile 模块</h3><p>新建一个Moudle类型为Java Library，命名为<code>compile</code></p>\n<p>1、对Compile模块的gradle进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;java-library&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])</span><br><span class=\"line\">    implementation project(&quot;:annotation&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    //通过类调用的形式来生成Java代码</span><br><span class=\"line\">    implementation &#x27;com.squareup:javapoet:1.7.0&#x27;</span><br><span class=\"line\">    implementation &#x27;com.google.guava:guava:19.0&#x27;</span><br><span class=\"line\">    //使用AutoService注册我们的processor</span><br><span class=\"line\">    implementation &#x27;com.google.auto.service:auto-service:1.0-rc2&#x27;   </span><br><span class=\"line\">    annotationProcessor &#x27;com.google.auto.service:auto-service:1.0-rc2&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = &quot;7&quot;</span><br><span class=\"line\">targetCompatibility = &quot;7&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、创建注解处理器 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//processor 运行在一个独立的JVM实例中，javac为我们的processor启动一个新的进程，要使我们的processor被javac检测到，</span></span><br><span class=\"line\">    <span class=\"comment\">//需要使用ServiceLoader进行注册</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于处理一些初始化内容，工具类等</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">     * 注解处理器的核心方法，用于处理具体的注解，生成Java文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> set               使用了支持处理注解的节点集合（类上面写了注解）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> roundEnvironment  当前或是之前的运行环境，可以通过该对象查找找到的注解</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示后续处理器不再会处理，false则会继续进行处理</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取支持处理的注解类  在本例中使用 @SupportedAnnotationTypes()实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedAnnotationTypes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于设置通过某一版本进行编译，必填 在本例中使用 @SupportedSourceVersion()注解实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedSourceVersion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取从外部传入的属性变量 在本例中是接受调用模块的gradle 中的参数；使用 @SupportedOptions（)注解实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedOptions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedOptions();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>3、添加注解处理器所需的必要内容;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过AutoService 注册自动生成处理的文件</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor.class)</span></span><br><span class=\"line\"><span class=\"comment\">//允许/支持的注解类型，让注解处理器处理</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&quot;com.example.annotation.Logger&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//指定JDK编译版本</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span></span><br><span class=\"line\"><span class=\"comment\">//接受build.gradle穿过来的参数，“content”为参数名</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedOptions(&quot;content&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>@SupportedOptions(&quot;content&quot;)</code> 注解中，”content”，参数的传入必须啊在defaultConfig节点，可以在<code>getSupportedOptions() </code>方法中进行获取</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在gradle文件中配置选项参数值（用于APT传参接收，在ARouterProcessor的参数）</span><br><span class=\"line\">  //该配置必须卸载defaultConfig节点下  </span><br><span class=\"line\">  javaCompileOptions&#123;</span><br><span class=\"line\">      annotationProcessorOptions&#123;</span><br><span class=\"line\">          arguments=[moduleName:project.name,packageNameForAPT:packageNameForAPT]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>4、添加文件输出变量和日志输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用来输出警告，错误等日志</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\"><span class=\"comment\">//文件生成器  类/资源/Filter用来创建新的类文件，class文件以及辅助文件</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Filer filer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    messager=processingEnvironment.getMessager();</span><br><span class=\"line\">    filer=processingEnvironment.getFiler();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>5、在编译时对注解进行处理，并不是所有的类中都被注解标记，因此需要对类上的注解进行判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidClass</span><span class=\"params\">(TypeElement typeElement)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (typeElement.getKind()!= ElementKind.CLASS)&#123;</span><br><span class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+<span class=\"string\">&quot;只有class可以使用log注解&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (typeElement.getModifiers().contains(Modifier.PRIVATE))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+<span class=\"string\">&quot;只有public类型的类可以使用log&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6</span>、添加注解处理完成后的文件输出方法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeSourceFile</span><span class=\"params\">(TypeElement originatingType)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从android.util.package中获取log类</span></span><br><span class=\"line\">        <span class=\"comment\">//可以保证Log类被正确引入我们的生成类中</span></span><br><span class=\"line\">        ClassName logClassName=ClassName.get(<span class=\"string\">&quot;android.util&quot;</span>,<span class=\"string\">&quot;Log&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用于获取当前注解的class名称</span></span><br><span class=\"line\">        TypeVariableName typeVariableName=TypeVariableName.get(originatingType.getSimpleName().toString());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个名称为log的静态方法</span></span><br><span class=\"line\">        MethodSpec log=MethodSpec.methodBuilder(METHOD_LOG)</span><br><span class=\"line\">                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)</span><br><span class=\"line\">                .returns(<span class=\"keyword\">void</span>.class)</span><br><span class=\"line\">                <span class=\"comment\">//参数变量由注解的类决定</span></span><br><span class=\"line\">                .addParameter(typeVariableName,KEY_PATH_NAME)</span><br><span class=\"line\">                <span class=\"comment\">//创建一个 Log.d(&quot;className&quot;,String.format(class fields))</span></span><br><span class=\"line\">                .addStatement(<span class=\"string\">&quot;$T.d($S,$L)&quot;</span>,logClassName,originatingType.getSimpleName().toString(), generateFormat(originatingType))</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个class，创建的class的名字为： 被注解的class名+_Log</span></span><br><span class=\"line\"></span><br><span class=\"line\">        TypeSpec loggerClass=TypeSpec.classBuilder(originatingType.getSimpleName().toString()+CLASS_SUFFIX)</span><br><span class=\"line\">                .addModifiers(Modifier.PUBLIC,Modifier.FINAL)</span><br><span class=\"line\">                <span class=\"comment\">//天啊及log方法</span></span><br><span class=\"line\">                .addMethod(log).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建文件</span></span><br><span class=\"line\">        JavaFile javaFile=JavaFile.builder(originatingType.getEnclosingElement().toString(),loggerClass).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            javaFile.writeTo(filer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>7、在processor中对注解进行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取所有被Logger注解的元素</span></span><br><span class=\"line\">    Collection&lt;? extends Element&gt;annotatedElements=roundEnvironment.getElementsAnnotatedWith(Logger.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除我们不需要的元素</span></span><br><span class=\"line\">    List&lt;TypeElement&gt;typeElements=<span class=\"keyword\">new</span> ImmutableList.Builder&lt;TypeElement&gt;().addAll(ElementFilter.typesIn(annotatedElements)).build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TypeElement typeElement:typeElements)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//interface也可能是type类型，只筛选出我们需要的class</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isValidClass(typeElement))&#123;</span><br><span class=\"line\">            writeSourceFile(typeElement);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/LuciusCS/AndroidProject\">源码地址</a> 所使用模块为 <code>Jpapmodule</code>、<code>annotation</code>、<code>     compiler</code></p>\n<p><a href=\"https://github.com/LuciusCS/AptRouter\">源码进阶</a> 模仿ARouter的模块化路由框架</p>\n<p>参考资料：</p>\n<p>1、<a href=\"https://www.cnblogs.com/throwable/p/9139908.html\">https://www.cnblogs.com/throwable/p/9139908.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"名词介绍\"><a href=\"#名词介绍\" class=\"headerlink\" title=\"名词介绍\"></a>名词介绍</h2><h3 id=\"APT介绍（Annotation-Processing-Tool）\"><a href=\"#APT介绍（Annotation-Processing-Tool）\" class=\"headerlink\" title=\"APT介绍（Annotation Processing Tool）\"></a>APT介绍（Annotation Processing Tool）</h3><p><code>com.sun.mirror</code>包中持有的APT以及相关的API,从JDK7开始弃用，从JDK8中正式移除，使用<code>javax.annotation.processing</code>包和<code>javax.lang.model</code>来处理编译时注解；</p>\n<p>Retrofit2、 Dagger2、EventBus3都使用了APT技术</p>\n<h3 id=\"Java-Pluggable-Annotation-Processor-（插件化注解处理框架）\"><a href=\"#Java-Pluggable-Annotation-Processor-（插件化注解处理框架）\" class=\"headerlink\" title=\"Java Pluggable Annotation Processor （插件化注解处理框架）\"></a>Java Pluggable Annotation Processor （插件化注解处理框架）</h3><p>APT从JDK被移除后取而代之的是Java Pluggable Annotation Processor，它从JDK 6开始进行支持。它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。<br>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类javax.annotation.processing.AbstractProcessor。注意，与运行时注解RetentionPolicy.RUNTIME不同，注解处理器只会处理编译期注解，也就是RetentionPolicy.SOURCE的注解类型，处理的阶段位于Java代码编译期间。</p>\n<h3 id=\"android-apt\"><a href=\"#android-apt\" class=\"headerlink\" title=\"android-apt\"></a>android-apt</h3><p>android-apt是第三方开源的注解处理框架，刚开始Android对注解处理的支持。dagger、ButterKnife等流行的注解框架，都是用的android-apt进行的注解处理。</p>\n<h3 id=\"annotationProcessor\"><a href=\"#annotationProcessor\" class=\"headerlink\" title=\"annotationProcessor\"></a>annotationProcessor</h3><p>在Android studio Gradle插件2.2版本发布后，对Android支持的注解处理，，直接在build.gradle文件配置即可使用。</p>\n<h2 id=\"在Android中编译时注解处理器\"><a href=\"#在Android中编译时注解处理器\" class=\"headerlink\" title=\"在Android中编译时注解处理器\"></a>在Android中编译时注解处理器</h2><p>在Android现有的开发中，使用的是 Java Pluggable Annotation Processor 而非 Annotation Processing Tool,因为所使用的<code>AbstractProcessor</code>位于 <code>javax.annotation.processing</code>而非<code>com.sun.mirror</code>包下；在开发的过程中需要注意环境的兼容；</p>\n<h3 id=\"Elements介绍\"><a href=\"#Elements介绍\" class=\"headerlink\" title=\"Elements介绍\"></a>Elements介绍</h3><ul>\n<li>PackageElement 表示一个包程序元素，提供有关包及其成员的信息的访问；</li>\n<li>ExecutableElement 表示某个类或接口的方法、构造方法或初始化程序；</li>\n<li>TypeElement 表示一个类或接口程序元素，提供有关类型及其成员的信息的访问；</li>\n<li>表示一个字段、enmu常量、方法或构造方法参数、局部变量或异常参数；</li>\n</ul>\n<h2 id=\"在Android中编译时注解处理器实现\"><a href=\"#在Android中编译时注解处理器实现\" class=\"headerlink\" title=\"在Android中编译时注解处理器实现\"></a>在Android中编译时注解处理器实现</h2><p>实现的功能：在User类上使用编译时注解，自动生成User_log类，可以通过User_log类输出User的属性；其中User类和生成User_log类的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Logger</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name,String city)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.city=city;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//get和set方法省略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User_log</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(User args)</span> </span>&#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;User&quot;</span>,String.format(<span class=\"string\">&quot;name - %scity - %s&quot;</span>, args .name, args .city));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>User_log的调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user=<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;bj&quot;</span>);</span><br><span class=\"line\">User_log.log(user);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建Annotation-模块\"><a href=\"#创建Annotation-模块\" class=\"headerlink\" title=\"创建Annotation 模块\"></a>创建Annotation 模块</h3><p>1、新建一个Moudle类型为Java Library，命名为<code>annotation</code>,创建Logger注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.SOURCE)</span>  <span class=\"comment\">//用于表示在编译时运行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Logger &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、对Annotation模块的的gradle进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;java-library&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = &quot;7&quot;</span><br><span class=\"line\">targetCompatibility = &quot;7&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"创建Compile-模块\"><a href=\"#创建Compile-模块\" class=\"headerlink\" title=\"创建Compile 模块\"></a>创建Compile 模块</h3><p>新建一个Moudle类型为Java Library，命名为<code>compile</code></p>\n<p>1、对Compile模块的gradle进行配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: &#x27;java-library&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])</span><br><span class=\"line\">    implementation project(&quot;:annotation&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">    //通过类调用的形式来生成Java代码</span><br><span class=\"line\">    implementation &#x27;com.squareup:javapoet:1.7.0&#x27;</span><br><span class=\"line\">    implementation &#x27;com.google.guava:guava:19.0&#x27;</span><br><span class=\"line\">    //使用AutoService注册我们的processor</span><br><span class=\"line\">    implementation &#x27;com.google.auto.service:auto-service:1.0-rc2&#x27;   </span><br><span class=\"line\">    annotationProcessor &#x27;com.google.auto.service:auto-service:1.0-rc2&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = &quot;7&quot;</span><br><span class=\"line\">targetCompatibility = &quot;7&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、创建注解处理器 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//processor 运行在一个独立的JVM实例中，javac为我们的processor启动一个新的进程，要使我们的processor被javac检测到，</span></span><br><span class=\"line\">    <span class=\"comment\">//需要使用ServiceLoader进行注册</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于处理一些初始化内容，工具类等</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">     * 注解处理器的核心方法，用于处理具体的注解，生成Java文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> set               使用了支持处理注解的节点集合（类上面写了注解）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> roundEnvironment  当前或是之前的运行环境，可以通过该对象查找找到的注解</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true表示后续处理器不再会处理，false则会继续进行处理</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取支持处理的注解类  在本例中使用 @SupportedAnnotationTypes()实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedAnnotationTypes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于设置通过某一版本进行编译，必填 在本例中使用 @SupportedSourceVersion()注解实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedSourceVersion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取从外部传入的属性变量 在本例中是接受调用模块的gradle 中的参数；使用 @SupportedOptions（)注解实现</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedOptions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedOptions();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>3、添加注解处理器所需的必要内容;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过AutoService 注册自动生成处理的文件</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor.class)</span></span><br><span class=\"line\"><span class=\"comment\">//允许/支持的注解类型，让注解处理器处理</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&quot;com.example.annotation.Logger&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//指定JDK编译版本</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span></span><br><span class=\"line\"><span class=\"comment\">//接受build.gradle穿过来的参数，“content”为参数名</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedOptions(&quot;content&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>@SupportedOptions(&quot;content&quot;)</code> 注解中，”content”，参数的传入必须啊在defaultConfig节点，可以在<code>getSupportedOptions() </code>方法中进行获取</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在gradle文件中配置选项参数值（用于APT传参接收，在ARouterProcessor的参数）</span><br><span class=\"line\">  //该配置必须卸载defaultConfig节点下  </span><br><span class=\"line\">  javaCompileOptions&#123;</span><br><span class=\"line\">      annotationProcessorOptions&#123;</span><br><span class=\"line\">          arguments=[moduleName:project.name,packageNameForAPT:packageNameForAPT]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>4、添加文件输出变量和日志输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用来输出警告，错误等日志</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\"><span class=\"comment\">//文件生成器  类/资源/Filter用来创建新的类文件，class文件以及辅助文件</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Filer filer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    messager=processingEnvironment.getMessager();</span><br><span class=\"line\">    filer=processingEnvironment.getFiler();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>5、在编译时对注解进行处理，并不是所有的类中都被注解标记，因此需要对类上的注解进行判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidClass</span><span class=\"params\">(TypeElement typeElement)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (typeElement.getKind()!= ElementKind.CLASS)&#123;</span><br><span class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+<span class=\"string\">&quot;只有class可以使用log注解&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (typeElement.getModifiers().contains(Modifier.PRIVATE))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            messager.printMessage(Diagnostic.Kind.ERROR,typeElement.getSimpleName()+<span class=\"string\">&quot;只有public类型的类可以使用log&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">````</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6</span>、添加注解处理完成后的文件输出方法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeSourceFile</span><span class=\"params\">(TypeElement originatingType)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从android.util.package中获取log类</span></span><br><span class=\"line\">        <span class=\"comment\">//可以保证Log类被正确引入我们的生成类中</span></span><br><span class=\"line\">        ClassName logClassName=ClassName.get(<span class=\"string\">&quot;android.util&quot;</span>,<span class=\"string\">&quot;Log&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用于获取当前注解的class名称</span></span><br><span class=\"line\">        TypeVariableName typeVariableName=TypeVariableName.get(originatingType.getSimpleName().toString());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个名称为log的静态方法</span></span><br><span class=\"line\">        MethodSpec log=MethodSpec.methodBuilder(METHOD_LOG)</span><br><span class=\"line\">                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)</span><br><span class=\"line\">                .returns(<span class=\"keyword\">void</span>.class)</span><br><span class=\"line\">                <span class=\"comment\">//参数变量由注解的类决定</span></span><br><span class=\"line\">                .addParameter(typeVariableName,KEY_PATH_NAME)</span><br><span class=\"line\">                <span class=\"comment\">//创建一个 Log.d(&quot;className&quot;,String.format(class fields))</span></span><br><span class=\"line\">                .addStatement(<span class=\"string\">&quot;$T.d($S,$L)&quot;</span>,logClassName,originatingType.getSimpleName().toString(), generateFormat(originatingType))</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个class，创建的class的名字为： 被注解的class名+_Log</span></span><br><span class=\"line\"></span><br><span class=\"line\">        TypeSpec loggerClass=TypeSpec.classBuilder(originatingType.getSimpleName().toString()+CLASS_SUFFIX)</span><br><span class=\"line\">                .addModifiers(Modifier.PUBLIC,Modifier.FINAL)</span><br><span class=\"line\">                <span class=\"comment\">//天啊及log方法</span></span><br><span class=\"line\">                .addMethod(log).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建文件</span></span><br><span class=\"line\">        JavaFile javaFile=JavaFile.builder(originatingType.getEnclosingElement().toString(),loggerClass).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            javaFile.writeTo(filer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>7、在processor中对注解进行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取所有被Logger注解的元素</span></span><br><span class=\"line\">    Collection&lt;? extends Element&gt;annotatedElements=roundEnvironment.getElementsAnnotatedWith(Logger.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//删除我们不需要的元素</span></span><br><span class=\"line\">    List&lt;TypeElement&gt;typeElements=<span class=\"keyword\">new</span> ImmutableList.Builder&lt;TypeElement&gt;().addAll(ElementFilter.typesIn(annotatedElements)).build();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TypeElement typeElement:typeElements)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//interface也可能是type类型，只筛选出我们需要的class</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isValidClass(typeElement))&#123;</span><br><span class=\"line\">            writeSourceFile(typeElement);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/LuciusCS/AndroidProject\">源码地址</a> 所使用模块为 <code>Jpapmodule</code>、<code>annotation</code>、<code>     compiler</code></p>\n<p><a href=\"https://github.com/LuciusCS/AptRouter\">源码进阶</a> 模仿ARouter的模块化路由框架</p>\n<p>参考资料：</p>\n<p>1、<a href=\"https://www.cnblogs.com/throwable/p/9139908.html\">https://www.cnblogs.com/throwable/p/9139908.html</a></p>\n"},{"title":"ActivityThread源码分析","description":"ActivityThread源码分析","type":["Android"],"toc":true,"cover":"/cover/img80.jpg","date":"2019-08-09T16:00:00.000Z","_content":"\n# ActivityThread源码分析\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载) ————》 mH LAUNCH_ACTIVITY（自己处理LoadApk中的classLoader） ————》（handleLaunchActivity 类加载 Activity performLaunchActivity）\n<!--more-->\n```java\n       case LAUNCH_ACTIVITY: {\n                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\n                //跳转Activity的记录\n                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n                //如果缓存mPackages中有loadApk 就直接返回，如果没有loadApk就创建出loadApk————》宿主中的LoadAPk.ClassLoader\n\n                //如果是加载插件，从mPackages中取出插件专用的LadedApk，自定义ClassLoader \n                r.packageInfo = getPackageInfoNoCheck(\n                        r.activityInfo.applicationInfo, r.compatInfo);\n                //真正的即将 实例化Activity 然后启动\n                handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n              } break;\n\n```\n\nActivityClientRecord用于对Activity的每次跳转做一下记录\n\n\n1、public final LoadApk getPackageInfoNoCheck == 宿主的\n\n2、缓存中的final ArrayMap<String,WeakReference<LoadApk>> mPackages默认保存的是宿主的LoadedApk\n\nLoadedApk -- 宿主的 ——》 LoadedApk.ClassLoader ———— 》 宿主中的class \n\n实例化的Activity是宿主中的loadApk里面的ClassLoader去实例化的\n\n宿主中的LoadedApk.ClassLoader去加载 宿主中的class ，然后实例化\n\n\n———————— 自定义一个LoadedApk 自定义一个ClassLoader 用于专门加载插件里面的 class 然后实例化\n\n自定义一个LoadedApk 然后保存 ——》 mPackages\n\nLoadApk ————》 插件的 ————》 LoadedApk.ClassLoader ——》插件中的class \n\n3、梳理流程\n\n宿主：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出LoadedApk.ClassLoader ——实例化 Activity （只能加载宿主的）\n\n插件：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出插件专用LoadedApk.ClassLoader ——实例化插件的Activity \n\n\n绕过PMS的检查：\n\n流程： startActivity ——》 Activity ——》 Instrument ——AMS检查 ——》 ActivityThread——》\n    获取自定义的LoadedApk.ClassLoader ——》 实例化 initializeJavaContextClassLoader （PMS检查要启动的包名是否安装） ——》 生命周期方法的处理（才能真正启动加载到插件包里的Activity）\n\n\nPMS检测 插件包包名是否安装，如果没有安装则抛出异常，\n    Hook 要在getPackageInfo 执行之前给Hook拦截住，控制pi 不为null\n\n\n分析 pm.package  客户端进程 ---》 系统进程\n\n54:07 能看到代码的浏览 ","source":"_posts/Android/Advanced/插件化/ActivityThread源码分析.md","raw":"---\ntitle: \"ActivityThread源码分析\"\ndescription: \"ActivityThread源码分析\"\ntype: [Android]\ntoc: true\ncover:  /cover/img80.jpg\ncategories: Android\ndate: 2019/08/10\n---\n\n# ActivityThread源码分析\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载) ————》 mH LAUNCH_ACTIVITY（自己处理LoadApk中的classLoader） ————》（handleLaunchActivity 类加载 Activity performLaunchActivity）\n<!--more-->\n```java\n       case LAUNCH_ACTIVITY: {\n                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\n                //跳转Activity的记录\n                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n                //如果缓存mPackages中有loadApk 就直接返回，如果没有loadApk就创建出loadApk————》宿主中的LoadAPk.ClassLoader\n\n                //如果是加载插件，从mPackages中取出插件专用的LadedApk，自定义ClassLoader \n                r.packageInfo = getPackageInfoNoCheck(\n                        r.activityInfo.applicationInfo, r.compatInfo);\n                //真正的即将 实例化Activity 然后启动\n                handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n              } break;\n\n```\n\nActivityClientRecord用于对Activity的每次跳转做一下记录\n\n\n1、public final LoadApk getPackageInfoNoCheck == 宿主的\n\n2、缓存中的final ArrayMap<String,WeakReference<LoadApk>> mPackages默认保存的是宿主的LoadedApk\n\nLoadedApk -- 宿主的 ——》 LoadedApk.ClassLoader ———— 》 宿主中的class \n\n实例化的Activity是宿主中的loadApk里面的ClassLoader去实例化的\n\n宿主中的LoadedApk.ClassLoader去加载 宿主中的class ，然后实例化\n\n\n———————— 自定义一个LoadedApk 自定义一个ClassLoader 用于专门加载插件里面的 class 然后实例化\n\n自定义一个LoadedApk 然后保存 ——》 mPackages\n\nLoadApk ————》 插件的 ————》 LoadedApk.ClassLoader ——》插件中的class \n\n3、梳理流程\n\n宿主：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出LoadedApk.ClassLoader ——实例化 Activity （只能加载宿主的）\n\n插件：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出插件专用LoadedApk.ClassLoader ——实例化插件的Activity \n\n\n绕过PMS的检查：\n\n流程： startActivity ——》 Activity ——》 Instrument ——AMS检查 ——》 ActivityThread——》\n    获取自定义的LoadedApk.ClassLoader ——》 实例化 initializeJavaContextClassLoader （PMS检查要启动的包名是否安装） ——》 生命周期方法的处理（才能真正启动加载到插件包里的Activity）\n\n\nPMS检测 插件包包名是否安装，如果没有安装则抛出异常，\n    Hook 要在getPackageInfo 执行之前给Hook拦截住，控制pi 不为null\n\n\n分析 pm.package  客户端进程 ---》 系统进程\n\n54:07 能看到代码的浏览 ","slug":"Android/Advanced/插件化/ActivityThread源码分析","published":1,"updated":"2021-01-05T12:13:40.506Z","_id":"ckjju0m2a008720uacr7kfs11","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ActivityThread源码分析\"><a href=\"#ActivityThread源码分析\" class=\"headerlink\" title=\"ActivityThread源码分析\"></a>ActivityThread源码分析</h1><p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载) ————》 mH LAUNCH_ACTIVITY（自己处理LoadApk中的classLoader） ————》（handleLaunchActivity 类加载 Activity performLaunchActivity）</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class=\"line\">         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">         <span class=\"comment\">//跳转Activity的记录</span></span><br><span class=\"line\">         <span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">         <span class=\"comment\">//如果缓存mPackages中有loadApk 就直接返回，如果没有loadApk就创建出loadApk————》宿主中的LoadAPk.ClassLoader</span></span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//如果是加载插件，从mPackages中取出插件专用的LadedApk，自定义ClassLoader </span></span><br><span class=\"line\">         r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                 r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">         <span class=\"comment\">//真正的即将 实例化Activity 然后启动</span></span><br><span class=\"line\">         handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class=\"line\">         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ActivityClientRecord用于对Activity的每次跳转做一下记录</p>\n<p>1、public final LoadApk getPackageInfoNoCheck == 宿主的</p>\n<p>2、缓存中的final ArrayMap&lt;String,WeakReference<LoadApk>&gt; mPackages默认保存的是宿主的LoadedApk</p>\n<p>LoadedApk – 宿主的 ——》 LoadedApk.ClassLoader ———— 》 宿主中的class </p>\n<p>实例化的Activity是宿主中的loadApk里面的ClassLoader去实例化的</p>\n<p>宿主中的LoadedApk.ClassLoader去加载 宿主中的class ，然后实例化</p>\n<p>———————— 自定义一个LoadedApk 自定义一个ClassLoader 用于专门加载插件里面的 class 然后实例化</p>\n<p>自定义一个LoadedApk 然后保存 ——》 mPackages</p>\n<p>LoadApk ————》 插件的 ————》 LoadedApk.ClassLoader ——》插件中的class </p>\n<p>3、梳理流程</p>\n<p>宿主：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出LoadedApk.ClassLoader ——实例化 Activity （只能加载宿主的）</p>\n<p>插件：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出插件专用LoadedApk.ClassLoader ——实例化插件的Activity </p>\n<p>绕过PMS的检查：</p>\n<p>流程： startActivity ——》 Activity ——》 Instrument ——AMS检查 ——》 ActivityThread——》<br>    获取自定义的LoadedApk.ClassLoader ——》 实例化 initializeJavaContextClassLoader （PMS检查要启动的包名是否安装） ——》 生命周期方法的处理（才能真正启动加载到插件包里的Activity）</p>\n<p>PMS检测 插件包包名是否安装，如果没有安装则抛出异常，<br>    Hook 要在getPackageInfo 执行之前给Hook拦截住，控制pi 不为null</p>\n<p>分析 pm.package  客户端进程 —》 系统进程</p>\n<p>54:07 能看到代码的浏览 </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"ActivityThread源码分析\"><a href=\"#ActivityThread源码分析\" class=\"headerlink\" title=\"ActivityThread源码分析\"></a>ActivityThread源码分析</h1><p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载) ————》 mH LAUNCH_ACTIVITY（自己处理LoadApk中的classLoader） ————》（handleLaunchActivity 类加载 Activity performLaunchActivity）</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class=\"line\">         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">         <span class=\"comment\">//跳转Activity的记录</span></span><br><span class=\"line\">         <span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\">         <span class=\"comment\">//如果缓存mPackages中有loadApk 就直接返回，如果没有loadApk就创建出loadApk————》宿主中的LoadAPk.ClassLoader</span></span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//如果是加载插件，从mPackages中取出插件专用的LadedApk，自定义ClassLoader </span></span><br><span class=\"line\">         r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                 r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">         <span class=\"comment\">//真正的即将 实例化Activity 然后启动</span></span><br><span class=\"line\">         handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class=\"line\">         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ActivityClientRecord用于对Activity的每次跳转做一下记录</p>\n<p>1、public final LoadApk getPackageInfoNoCheck == 宿主的</p>\n<p>2、缓存中的final ArrayMap&lt;String,WeakReference<LoadApk>&gt; mPackages默认保存的是宿主的LoadedApk</p>\n<p>LoadedApk – 宿主的 ——》 LoadedApk.ClassLoader ———— 》 宿主中的class </p>\n<p>实例化的Activity是宿主中的loadApk里面的ClassLoader去实例化的</p>\n<p>宿主中的LoadedApk.ClassLoader去加载 宿主中的class ，然后实例化</p>\n<p>———————— 自定义一个LoadedApk 自定义一个ClassLoader 用于专门加载插件里面的 class 然后实例化</p>\n<p>自定义一个LoadedApk 然后保存 ——》 mPackages</p>\n<p>LoadApk ————》 插件的 ————》 LoadedApk.ClassLoader ——》插件中的class </p>\n<p>3、梳理流程</p>\n<p>宿主：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出LoadedApk.ClassLoader ——实例化 Activity （只能加载宿主的）</p>\n<p>插件：startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)    mPackages.value中取出插件专用LoadedApk.ClassLoader ——实例化插件的Activity </p>\n<p>绕过PMS的检查：</p>\n<p>流程： startActivity ——》 Activity ——》 Instrument ——AMS检查 ——》 ActivityThread——》<br>    获取自定义的LoadedApk.ClassLoader ——》 实例化 initializeJavaContextClassLoader （PMS检查要启动的包名是否安装） ——》 生命周期方法的处理（才能真正启动加载到插件包里的Activity）</p>\n<p>PMS检测 插件包包名是否安装，如果没有安装则抛出异常，<br>    Hook 要在getPackageInfo 执行之前给Hook拦截住，控制pi 不为null</p>\n<p>分析 pm.package  客户端进程 —》 系统进程</p>\n<p>54:07 能看到代码的浏览 </p>"},{"title":"Android 9.0 Hook插件化","cover":"/cover/img4.jpg","toc":true,"description":"Android 9.0 Hook插件化","type":["Android"],"date":"2020-03-01T16:00:00.000Z","_content":"\n### 第一步：绕过AMS对Activity的检查\n注：如果Activity没有在Manifest.xml中进行注册则会报错\n\n    1、Hook绕过AMS检查，采用代理的方式\n    2、Hook还原目标Activity\n    3、Hook方式融合宿主和插件DexElement\n<!--more-->\n### 第二步 还原ProxyActivity\n\n要在ActivityThread的  class H extends Handler {}类中的的 handleMessage(Message msg)执行之前，将ProxyActivity换成需要进行启动的Activity， 而handleMessage(Message msg)会在Handler dispatchMessage()中进行调用\n\n需要在替换之前使得mCallback部位不为空，替换之后将会调用自己定义的MyCallback.handleMessage,然后进行相应的处理\n\n```java\n   public void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n在 handleMessage()中需要拿到 mIntent进行替换\n```java\nprivate class  MyCallback implements android.os.Handler.Callback{\n\n        @Override\n        public boolean handleMessage(@NonNull Message msg) {\n        }\n}\n\n```\n\n\n## Hook式插件化框架化Android版本兼容\n\n","source":"_posts/Android/Advanced/插件化/Android 9.0 Hook插件化.md","raw":"---\ntitle: Android 9.0 Hook插件化\ncover:  /cover/img4.jpg\ntoc: true\ndescription: Android 9.0 Hook插件化\ntype: [Android]\ncategories: Android\ndate: 2020/03/02\n---\n\n### 第一步：绕过AMS对Activity的检查\n注：如果Activity没有在Manifest.xml中进行注册则会报错\n\n    1、Hook绕过AMS检查，采用代理的方式\n    2、Hook还原目标Activity\n    3、Hook方式融合宿主和插件DexElement\n<!--more-->\n### 第二步 还原ProxyActivity\n\n要在ActivityThread的  class H extends Handler {}类中的的 handleMessage(Message msg)执行之前，将ProxyActivity换成需要进行启动的Activity， 而handleMessage(Message msg)会在Handler dispatchMessage()中进行调用\n\n需要在替换之前使得mCallback部位不为空，替换之后将会调用自己定义的MyCallback.handleMessage,然后进行相应的处理\n\n```java\n   public void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n在 handleMessage()中需要拿到 mIntent进行替换\n```java\nprivate class  MyCallback implements android.os.Handler.Callback{\n\n        @Override\n        public boolean handleMessage(@NonNull Message msg) {\n        }\n}\n\n```\n\n\n## Hook式插件化框架化Android版本兼容\n\n","slug":"Android/Advanced/插件化/Android 9.0 Hook插件化","published":1,"updated":"2021-01-05T12:13:41.004Z","_id":"ckjju0m2a008a20uaa0lzd6cf","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"第一步：绕过AMS对Activity的检查\"><a href=\"#第一步：绕过AMS对Activity的检查\" class=\"headerlink\" title=\"第一步：绕过AMS对Activity的检查\"></a>第一步：绕过AMS对Activity的检查</h3><p>注：如果Activity没有在Manifest.xml中进行注册则会报错</p>\n<pre><code>1、Hook绕过AMS检查，采用代理的方式\n2、Hook还原目标Activity\n3、Hook方式融合宿主和插件DexElement</code></pre>\n<a id=\"more\"></a>\n<h3 id=\"第二步-还原ProxyActivity\"><a href=\"#第二步-还原ProxyActivity\" class=\"headerlink\" title=\"第二步 还原ProxyActivity\"></a>第二步 还原ProxyActivity</h3><p>要在ActivityThread的  class H extends Handler {}类中的的 handleMessage(Message msg)执行之前，将ProxyActivity换成需要进行启动的Activity， 而handleMessage(Message msg)会在Handler dispatchMessage()中进行调用</p>\n<p>需要在替换之前使得mCallback部位不为空，替换之后将会调用自己定义的MyCallback.handleMessage,然后进行相应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         handleCallback(msg);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         handleMessage(msg);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在 handleMessage()中需要拿到 mIntent进行替换</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">MyCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">android</span>.<span class=\"title\">os</span>.<span class=\"title\">Handler</span>.<span class=\"title\">Callback</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hook式插件化框架化Android版本兼容\"><a href=\"#Hook式插件化框架化Android版本兼容\" class=\"headerlink\" title=\"Hook式插件化框架化Android版本兼容\"></a>Hook式插件化框架化Android版本兼容</h2>","site":{"data":{}},"excerpt":"<h3 id=\"第一步：绕过AMS对Activity的检查\"><a href=\"#第一步：绕过AMS对Activity的检查\" class=\"headerlink\" title=\"第一步：绕过AMS对Activity的检查\"></a>第一步：绕过AMS对Activity的检查</h3><p>注：如果Activity没有在Manifest.xml中进行注册则会报错</p>\n<pre><code>1、Hook绕过AMS检查，采用代理的方式\n2、Hook还原目标Activity\n3、Hook方式融合宿主和插件DexElement</code></pre>","more":"<h3 id=\"第二步-还原ProxyActivity\"><a href=\"#第二步-还原ProxyActivity\" class=\"headerlink\" title=\"第二步 还原ProxyActivity\"></a>第二步 还原ProxyActivity</h3><p>要在ActivityThread的  class H extends Handler {}类中的的 handleMessage(Message msg)执行之前，将ProxyActivity换成需要进行启动的Activity， 而handleMessage(Message msg)会在Handler dispatchMessage()中进行调用</p>\n<p>需要在替换之前使得mCallback部位不为空，替换之后将会调用自己定义的MyCallback.handleMessage,然后进行相应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         handleCallback(msg);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         handleMessage(msg);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在 handleMessage()中需要拿到 mIntent进行替换</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"title\">MyCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">android</span>.<span class=\"title\">os</span>.<span class=\"title\">Handler</span>.<span class=\"title\">Callback</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hook式插件化框架化Android版本兼容\"><a href=\"#Hook式插件化框架化Android版本兼容\" class=\"headerlink\" title=\"Hook式插件化框架化Android版本兼容\"></a>Hook式插件化框架化Android版本兼容</h2>"},{"title":"Android LoadApk插件化实现","description":"Android LoadApk插件化实现","type":["Android"],"toc":true,"cover":"/cover/img81.jpg","date":"2020-02-27T16:00:00.000Z","_content":"## Android采用LoadAPK式的框架\n\n\n### Android 7.0 启动流程\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) —— 》 ActivityThread(即将加载启动Activity) —— 》 将ProxyActivity换回 TestActivity\n<!--more-->\n如果开发插件化，需要在AMS.startActivity() 之前添加Hook，换成ProxyAcivity(已经在Manifest中进行注册)\n\nActivityManagerNative.getDefault() 方法源码\n`gDefault.get()`获取的是IActivityManager的单例\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            IBinder b = ServiceManager.getService(\"activity\");\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n            }\n            IActivityManager am = asInterface(b);\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service = \" + am);\n            }\n            return am;\n        }\n    };\n\n```\n\n采用动态代理的方式在startActivity()方法之前，执行自定义的方法(把未注册的Activity替换成已经注册的Activity)\n\n\n2、AMS检查过后，需要将未注册的Activity换回去\n\n在ActivityThread中启动Activity，需要对 `case LAUNCH_ACTIVITY` 后面的代码进行Hook\n\n\n```java\n  private class H extends Handler {\n     public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\n                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n\n                    r.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\n                    handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                } break;\n\n            }\n     }\n  }\n```\n","source":"_posts/Android/Advanced/插件化/Android LoadAPK插件化.md","raw":"---\ntitle: \"Android LoadApk插件化实现\"\ndescription: \"Android LoadApk插件化实现\"\ntype: [Android]\ntoc: true\ncover:  /cover/img81.jpg\ncategories: Android\ndate: 2020/2/28\n---\n## Android采用LoadAPK式的框架\n\n\n### Android 7.0 启动流程\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) —— 》 ActivityThread(即将加载启动Activity) —— 》 将ProxyActivity换回 TestActivity\n<!--more-->\n如果开发插件化，需要在AMS.startActivity() 之前添加Hook，换成ProxyAcivity(已经在Manifest中进行注册)\n\nActivityManagerNative.getDefault() 方法源码\n`gDefault.get()`获取的是IActivityManager的单例\n\n```java\n    static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n\n\n    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n        protected IActivityManager create() {\n            IBinder b = ServiceManager.getService(\"activity\");\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service binder = \" + b);\n            }\n            IActivityManager am = asInterface(b);\n            if (false) {\n                Log.v(\"ActivityManager\", \"default service = \" + am);\n            }\n            return am;\n        }\n    };\n\n```\n\n采用动态代理的方式在startActivity()方法之前，执行自定义的方法(把未注册的Activity替换成已经注册的Activity)\n\n\n2、AMS检查过后，需要将未注册的Activity换回去\n\n在ActivityThread中启动Activity，需要对 `case LAUNCH_ACTIVITY` 后面的代码进行Hook\n\n\n```java\n  private class H extends Handler {\n     public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case LAUNCH_ACTIVITY: {\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");\n                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;\n\n                    r.packageInfo = getPackageInfoNoCheck(\n                            r.activityInfo.applicationInfo, r.compatInfo);\n                    handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                } break;\n\n            }\n     }\n  }\n```\n","slug":"Android/Advanced/插件化/Android LoadAPK插件化","published":1,"updated":"2021-01-06T00:54:47.246Z","_id":"ckjju0m2b008d20ua1nr1da8m","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android采用LoadAPK式的框架\"><a href=\"#Android采用LoadAPK式的框架\" class=\"headerlink\" title=\"Android采用LoadAPK式的框架\"></a>Android采用LoadAPK式的框架</h2><h3 id=\"Android-7-0-启动流程\"><a href=\"#Android-7-0-启动流程\" class=\"headerlink\" title=\"Android 7.0 启动流程\"></a>Android 7.0 启动流程</h3><p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) —— 》 ActivityThread(即将加载启动Activity) —— 》 将ProxyActivity换回 TestActivity</p>\n<a id=\"more\"></a>\n<p>如果开发插件化，需要在AMS.startActivity() 之前添加Hook，换成ProxyAcivity(已经在Manifest中进行注册)</p>\n<p>ActivityManagerNative.getDefault() 方法源码<br><code>gDefault.get()</code>获取的是IActivityManager的单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        IBinder b = ServiceManager.getService(<span class=\"string\">&quot;activity&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">&quot;ActivityManager&quot;</span>, <span class=\"string\">&quot;default service binder = &quot;</span> + b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        IActivityManager am = asInterface(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">&quot;ActivityManager&quot;</span>, <span class=\"string\">&quot;default service = &quot;</span> + am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> am;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>采用动态代理的方式在startActivity()方法之前，执行自定义的方法(把未注册的Activity替换成已经注册的Activity)</p>\n<p>2、AMS检查过后，需要将未注册的Activity换回去</p>\n<p>在ActivityThread中启动Activity，需要对 <code>case LAUNCH_ACTIVITY</code> 后面的代码进行Hook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class=\"line\">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\"></span><br><span class=\"line\">                  r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                          r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">                  handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class=\"line\">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Android采用LoadAPK式的框架\"><a href=\"#Android采用LoadAPK式的框架\" class=\"headerlink\" title=\"Android采用LoadAPK式的框架\"></a>Android采用LoadAPK式的框架</h2><h3 id=\"Android-7-0-启动流程\"><a href=\"#Android-7-0-启动流程\" class=\"headerlink\" title=\"Android 7.0 启动流程\"></a>Android 7.0 启动流程</h3><p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) —— 》 ActivityThread(即将加载启动Activity) —— 》 将ProxyActivity换回 TestActivity</p>","more":"<p>如果开发插件化，需要在AMS.startActivity() 之前添加Hook，换成ProxyAcivity(已经在Manifest中进行注册)</p>\n<p>ActivityManagerNative.getDefault() 方法源码<br><code>gDefault.get()</code>获取的是IActivityManager的单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        IBinder b = ServiceManager.getService(<span class=\"string\">&quot;activity&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">&quot;ActivityManager&quot;</span>, <span class=\"string\">&quot;default service binder = &quot;</span> + b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        IActivityManager am = asInterface(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">&quot;ActivityManager&quot;</span>, <span class=\"string\">&quot;default service = &quot;</span> + am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> am;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>采用动态代理的方式在startActivity()方法之前，执行自定义的方法(把未注册的Activity替换成已经注册的Activity)</p>\n<p>2、AMS检查过后，需要将未注册的Activity换回去</p>\n<p>在ActivityThread中启动Activity，需要对 <code>case LAUNCH_ACTIVITY</code> 后面的代码进行Hook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class=\"line\">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\"></span><br><span class=\"line\">                  r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                          r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">                  handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class=\"line\">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Android 插件化介绍","description":"Android 插件化介绍","type":["Android"],"toc":true,"cover":"/cover/img86.jpg","date":"2020-03-04T16:00:00.000Z","_content":"\n## 占位式插件\n插件开发，必须使用宿主中的环境\n\n<!--more-->\n## Hook式插件\n\n宿主和插件的element进行融合，插件可以使用宿主的环境\n\n缺点，插件越多，内存中的newDexElements就会越大\n\n### 在宿主中启动宿主的Activity\n\n```java\n\n    Intent intent =new Intent();\n    intent.setComponent(new ComponentName(\"com.example\",\"com.example.TestActivity\"))\n    startActivity(intent);\n\n```\n\n### 在宿主中启动插件里面的Activity\n\n```java\n\n    Intent intent =new Intent();\n    intent.setComponent(new ComponentName(\"com.example.plugin\",\"com.example.plugin.TestActivity\"))\n    startActivity(intent);\n\n```\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）\n\n\n\n\nAndroid的ClassLoader在启动的过程中在ActivityThread中有调用         \n\nAndroid中的ClassLoader =PathClassLoader\n\n\nAndroid中ClassLoader的过程：\n    1、Java中的ClassLoader 和 Android中的ClassLoader 是不一样的\n    2、ClassLoader == PathClassLoader\n    3、PathClassLoader==cl.loadClass(className).newInstance();\n\nPathClassLoader.loadClass —— 》 BaseDexClassLoader ——>ClassLoader .loadClass ——》 findClass(空方法)，让覆盖的子类实现 ——》 BaseDexClassLoader实现findClass() ——》 pathList.loadClass —— 》 遍历dexElements ——》DexFile.loadClassBinaryName（系列步骤后NDK）\n\nPathClassLoader继承自 BaseDexClassLoader \nBaseDexClassLoader 继承自 ClassLoader \n\n\nClassLoader .loadClass\n\nAndroid中的ClassLoader介绍\n1、Java中的 ClassLoader 和Android中的ClassLoader不一样:\n        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想\n2、Andorid中的ClassLoader分为两类，\n        系统提供的ClassLoader ——》 BootClassLoader、PathClassLoader、DexClassLoader        \n        自定义ClassLoader\n\n     BootClassLoader： 给系统预加载使用\n     PathClassLoader： 给系统/系统程序/应用程序\n     DexClassLoader：加载apk、zip apk文件的DexClassLoader\n\n1、内核启动\n2、init第一个进程\n3、zygote进程\n   ——》 zygoteInit ——》 BootClassLoaser.getInstance(); | handleSystemServerProcess PathClassLoaderFactory ——》 PahtClassLoader\n4、zygote 进程孵化 SystemServer\n5、SystemServer 启动系统服务 —— (AMS、PSM ...)         \n\n\n\n### Hook式插件化，宿主与插件融合\n\n    //第一步： 找到宿主的 dexElements得到此对象  PathClassLoader代表是宿主\n\n    //第二步： 找到插件的dexElements得到此对象  代表插件 DexClassLoader \n    //第三步：创建出新的dexElements[]  必须是数组对象\n    //第四步：宿主dexElements+插件dexElements = ——》新的dexElements\n    //第五步：把新的DexElements，设置到宿主中去   \n\n还需要加载插件里面的布局\n\n\n## LoadApk式，插件化\n\n在LoadApk式的插件化中，需要控制 ClassLoader\n\n该方法解决newElements在插件中过大的问题\n\nPathClassLoader —— 》 使用宿主的class\n自定义ClassLoader —— 》 插件的class\n\n\n\n","source":"_posts/Android/Advanced/插件化/Android插件化介绍.md","raw":"---\ntitle: \"Android 插件化介绍\"\ndescription: \"Android 插件化介绍\"\ntype: [Android]\ntoc: true\ncover:  /cover/img86.jpg\ncategories: Android\ndate: 2020/03/05\n---\n\n## 占位式插件\n插件开发，必须使用宿主中的环境\n\n<!--more-->\n## Hook式插件\n\n宿主和插件的element进行融合，插件可以使用宿主的环境\n\n缺点，插件越多，内存中的newDexElements就会越大\n\n### 在宿主中启动宿主的Activity\n\n```java\n\n    Intent intent =new Intent();\n    intent.setComponent(new ComponentName(\"com.example\",\"com.example.TestActivity\"))\n    startActivity(intent);\n\n```\n\n### 在宿主中启动插件里面的Activity\n\n```java\n\n    Intent intent =new Intent();\n    intent.setComponent(new ComponentName(\"com.example.plugin\",\"com.example.plugin.TestActivity\"))\n    startActivity(intent);\n\n```\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）\n\n\n\n\nAndroid的ClassLoader在启动的过程中在ActivityThread中有调用         \n\nAndroid中的ClassLoader =PathClassLoader\n\n\nAndroid中ClassLoader的过程：\n    1、Java中的ClassLoader 和 Android中的ClassLoader 是不一样的\n    2、ClassLoader == PathClassLoader\n    3、PathClassLoader==cl.loadClass(className).newInstance();\n\nPathClassLoader.loadClass —— 》 BaseDexClassLoader ——>ClassLoader .loadClass ——》 findClass(空方法)，让覆盖的子类实现 ——》 BaseDexClassLoader实现findClass() ——》 pathList.loadClass —— 》 遍历dexElements ——》DexFile.loadClassBinaryName（系列步骤后NDK）\n\nPathClassLoader继承自 BaseDexClassLoader \nBaseDexClassLoader 继承自 ClassLoader \n\n\nClassLoader .loadClass\n\nAndroid中的ClassLoader介绍\n1、Java中的 ClassLoader 和Android中的ClassLoader不一样:\n        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想\n2、Andorid中的ClassLoader分为两类，\n        系统提供的ClassLoader ——》 BootClassLoader、PathClassLoader、DexClassLoader        \n        自定义ClassLoader\n\n     BootClassLoader： 给系统预加载使用\n     PathClassLoader： 给系统/系统程序/应用程序\n     DexClassLoader：加载apk、zip apk文件的DexClassLoader\n\n1、内核启动\n2、init第一个进程\n3、zygote进程\n   ——》 zygoteInit ——》 BootClassLoaser.getInstance(); | handleSystemServerProcess PathClassLoaderFactory ——》 PahtClassLoader\n4、zygote 进程孵化 SystemServer\n5、SystemServer 启动系统服务 —— (AMS、PSM ...)         \n\n\n\n### Hook式插件化，宿主与插件融合\n\n    //第一步： 找到宿主的 dexElements得到此对象  PathClassLoader代表是宿主\n\n    //第二步： 找到插件的dexElements得到此对象  代表插件 DexClassLoader \n    //第三步：创建出新的dexElements[]  必须是数组对象\n    //第四步：宿主dexElements+插件dexElements = ——》新的dexElements\n    //第五步：把新的DexElements，设置到宿主中去   \n\n还需要加载插件里面的布局\n\n\n## LoadApk式，插件化\n\n在LoadApk式的插件化中，需要控制 ClassLoader\n\n该方法解决newElements在插件中过大的问题\n\nPathClassLoader —— 》 使用宿主的class\n自定义ClassLoader —— 》 插件的class\n\n\n\n","slug":"Android/Advanced/插件化/Android插件化介绍","published":1,"updated":"2021-01-05T12:13:41.855Z","_id":"ckjju0m2b008g20ua0rizeeo8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"占位式插件\"><a href=\"#占位式插件\" class=\"headerlink\" title=\"占位式插件\"></a>占位式插件</h2><p>插件开发，必须使用宿主中的环境</p>\n<a id=\"more\"></a>\n<h2 id=\"Hook式插件\"><a href=\"#Hook式插件\" class=\"headerlink\" title=\"Hook式插件\"></a>Hook式插件</h2><p>宿主和插件的element进行融合，插件可以使用宿主的环境</p>\n<p>缺点，插件越多，内存中的newDexElements就会越大</p>\n<h3 id=\"在宿主中启动宿主的Activity\"><a href=\"#在宿主中启动宿主的Activity\" class=\"headerlink\" title=\"在宿主中启动宿主的Activity\"></a>在宿主中启动宿主的Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Intent intent =<span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> ComponentName(<span class=\"string\">&quot;com.example&quot;</span>,<span class=\"string\">&quot;com.example.TestActivity&quot;</span>))</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"在宿主中启动插件里面的Activity\"><a href=\"#在宿主中启动插件里面的Activity\" class=\"headerlink\" title=\"在宿主中启动插件里面的Activity\"></a>在宿主中启动插件里面的Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Intent intent =<span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> ComponentName(<span class=\"string\">&quot;com.example.plugin&quot;</span>,<span class=\"string\">&quot;com.example.plugin.TestActivity&quot;</span>))</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）</p>\n<p>Android的ClassLoader在启动的过程中在ActivityThread中有调用         </p>\n<p>Android中的ClassLoader =PathClassLoader</p>\n<p>Android中ClassLoader的过程：<br>    1、Java中的ClassLoader 和 Android中的ClassLoader 是不一样的<br>    2、ClassLoader == PathClassLoader<br>    3、PathClassLoader==cl.loadClass(className).newInstance();</p>\n<p>PathClassLoader.loadClass —— 》 BaseDexClassLoader ——&gt;ClassLoader .loadClass ——》 findClass(空方法)，让覆盖的子类实现 ——》 BaseDexClassLoader实现findClass() ——》 pathList.loadClass —— 》 遍历dexElements ——》DexFile.loadClassBinaryName（系列步骤后NDK）</p>\n<p>PathClassLoader继承自 BaseDexClassLoader<br>BaseDexClassLoader 继承自 ClassLoader </p>\n<p>ClassLoader .loadClass</p>\n<p>Android中的ClassLoader介绍<br>1、Java中的 ClassLoader 和Android中的ClassLoader不一样:<br>        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想<br>2、Andorid中的ClassLoader分为两类，<br>        系统提供的ClassLoader ——》 BootClassLoader、PathClassLoader、DexClassLoader<br>        自定义ClassLoader</p>\n<pre><code> BootClassLoader： 给系统预加载使用\n PathClassLoader： 给系统/系统程序/应用程序\n DexClassLoader：加载apk、zip apk文件的DexClassLoader</code></pre>\n<p>1、内核启动<br>2、init第一个进程<br>3、zygote进程<br>   ——》 zygoteInit ——》 BootClassLoaser.getInstance(); | handleSystemServerProcess PathClassLoaderFactory ——》 PahtClassLoader<br>4、zygote 进程孵化 SystemServer<br>5、SystemServer 启动系统服务 —— (AMS、PSM …)         </p>\n<h3 id=\"Hook式插件化，宿主与插件融合\"><a href=\"#Hook式插件化，宿主与插件融合\" class=\"headerlink\" title=\"Hook式插件化，宿主与插件融合\"></a>Hook式插件化，宿主与插件融合</h3><pre><code>//第一步： 找到宿主的 dexElements得到此对象  PathClassLoader代表是宿主\n\n//第二步： 找到插件的dexElements得到此对象  代表插件 DexClassLoader \n//第三步：创建出新的dexElements[]  必须是数组对象\n//第四步：宿主dexElements+插件dexElements = ——》新的dexElements\n//第五步：把新的DexElements，设置到宿主中去   </code></pre>\n<p>还需要加载插件里面的布局</p>\n<h2 id=\"LoadApk式，插件化\"><a href=\"#LoadApk式，插件化\" class=\"headerlink\" title=\"LoadApk式，插件化\"></a>LoadApk式，插件化</h2><p>在LoadApk式的插件化中，需要控制 ClassLoader</p>\n<p>该方法解决newElements在插件中过大的问题</p>\n<p>PathClassLoader —— 》 使用宿主的class<br>自定义ClassLoader —— 》 插件的class</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"占位式插件\"><a href=\"#占位式插件\" class=\"headerlink\" title=\"占位式插件\"></a>占位式插件</h2><p>插件开发，必须使用宿主中的环境</p>","more":"<h2 id=\"Hook式插件\"><a href=\"#Hook式插件\" class=\"headerlink\" title=\"Hook式插件\"></a>Hook式插件</h2><p>宿主和插件的element进行融合，插件可以使用宿主的环境</p>\n<p>缺点，插件越多，内存中的newDexElements就会越大</p>\n<h3 id=\"在宿主中启动宿主的Activity\"><a href=\"#在宿主中启动宿主的Activity\" class=\"headerlink\" title=\"在宿主中启动宿主的Activity\"></a>在宿主中启动宿主的Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Intent intent =<span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> ComponentName(<span class=\"string\">&quot;com.example&quot;</span>,<span class=\"string\">&quot;com.example.TestActivity&quot;</span>))</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"在宿主中启动插件里面的Activity\"><a href=\"#在宿主中启动插件里面的Activity\" class=\"headerlink\" title=\"在宿主中启动插件里面的Activity\"></a>在宿主中启动插件里面的Activity</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Intent intent =<span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> ComponentName(<span class=\"string\">&quot;com.example.plugin&quot;</span>,<span class=\"string\">&quot;com.example.plugin.TestActivity&quot;</span>))</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）</p>\n<p>Android的ClassLoader在启动的过程中在ActivityThread中有调用         </p>\n<p>Android中的ClassLoader =PathClassLoader</p>\n<p>Android中ClassLoader的过程：<br>    1、Java中的ClassLoader 和 Android中的ClassLoader 是不一样的<br>    2、ClassLoader == PathClassLoader<br>    3、PathClassLoader==cl.loadClass(className).newInstance();</p>\n<p>PathClassLoader.loadClass —— 》 BaseDexClassLoader ——&gt;ClassLoader .loadClass ——》 findClass(空方法)，让覆盖的子类实现 ——》 BaseDexClassLoader实现findClass() ——》 pathList.loadClass —— 》 遍历dexElements ——》DexFile.loadClassBinaryName（系列步骤后NDK）</p>\n<p>PathClassLoader继承自 BaseDexClassLoader<br>BaseDexClassLoader 继承自 ClassLoader </p>\n<p>ClassLoader .loadClass</p>\n<p>Android中的ClassLoader介绍<br>1、Java中的 ClassLoader 和Android中的ClassLoader不一样:<br>        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想<br>2、Andorid中的ClassLoader分为两类，<br>        系统提供的ClassLoader ——》 BootClassLoader、PathClassLoader、DexClassLoader<br>        自定义ClassLoader</p>\n<pre><code> BootClassLoader： 给系统预加载使用\n PathClassLoader： 给系统/系统程序/应用程序\n DexClassLoader：加载apk、zip apk文件的DexClassLoader</code></pre>\n<p>1、内核启动<br>2、init第一个进程<br>3、zygote进程<br>   ——》 zygoteInit ——》 BootClassLoaser.getInstance(); | handleSystemServerProcess PathClassLoaderFactory ——》 PahtClassLoader<br>4、zygote 进程孵化 SystemServer<br>5、SystemServer 启动系统服务 —— (AMS、PSM …)         </p>\n<h3 id=\"Hook式插件化，宿主与插件融合\"><a href=\"#Hook式插件化，宿主与插件融合\" class=\"headerlink\" title=\"Hook式插件化，宿主与插件融合\"></a>Hook式插件化，宿主与插件融合</h3><pre><code>//第一步： 找到宿主的 dexElements得到此对象  PathClassLoader代表是宿主\n\n//第二步： 找到插件的dexElements得到此对象  代表插件 DexClassLoader \n//第三步：创建出新的dexElements[]  必须是数组对象\n//第四步：宿主dexElements+插件dexElements = ——》新的dexElements\n//第五步：把新的DexElements，设置到宿主中去   </code></pre>\n<p>还需要加载插件里面的布局</p>\n<h2 id=\"LoadApk式，插件化\"><a href=\"#LoadApk式，插件化\" class=\"headerlink\" title=\"LoadApk式，插件化\"></a>LoadApk式，插件化</h2><p>在LoadApk式的插件化中，需要控制 ClassLoader</p>\n<p>该方法解决newElements在插件中过大的问题</p>\n<p>PathClassLoader —— 》 使用宿主的class<br>自定义ClassLoader —— 》 插件的class</p>"},{"title":"Android 插桩","description":"Android 插桩介绍","type":["Android"],"toc":true,"cover":"/cover/img99.jpg","date":"2020-06-14T16:00:00.000Z","_content":"\nAOP面向切面编程\n\n\n\n### 插桩应用\n\n\n### 插桩原理\n\n\n\n### 插桩工具 AspectJ\n\n\n优点：\n\n缺点：\n\n\n\n### 插桩工具 ASM\n\n优点：\n\n缺点：\n\n\n\n","source":"_posts/Android/Advanced/插件化/Android插桩.md","raw":"---\ntitle: \"Android 插桩\"\ndescription: \"Android 插桩介绍\"\ntype: [Android]\ntoc: true\ncover:  /cover/img99.jpg\ncategories: Android\ndate: 2020/6/15\n---\n\nAOP面向切面编程\n\n\n\n### 插桩应用\n\n\n### 插桩原理\n\n\n\n### 插桩工具 AspectJ\n\n\n优点：\n\n缺点：\n\n\n\n### 插桩工具 ASM\n\n优点：\n\n缺点：\n\n\n\n","slug":"Android/Advanced/插件化/Android插桩","published":1,"updated":"2021-01-06T00:55:32.101Z","_id":"ckjju0m2c008j20uafpb5elqa","comments":1,"layout":"post","photos":[],"link":"","content":"<p>AOP面向切面编程</p>\n<h3 id=\"插桩应用\"><a href=\"#插桩应用\" class=\"headerlink\" title=\"插桩应用\"></a>插桩应用</h3><h3 id=\"插桩原理\"><a href=\"#插桩原理\" class=\"headerlink\" title=\"插桩原理\"></a>插桩原理</h3><h3 id=\"插桩工具-AspectJ\"><a href=\"#插桩工具-AspectJ\" class=\"headerlink\" title=\"插桩工具 AspectJ\"></a>插桩工具 AspectJ</h3><p>优点：</p>\n<p>缺点：</p>\n<h3 id=\"插桩工具-ASM\"><a href=\"#插桩工具-ASM\" class=\"headerlink\" title=\"插桩工具 ASM\"></a>插桩工具 ASM</h3><p>优点：</p>\n<p>缺点：</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AOP面向切面编程</p>\n<h3 id=\"插桩应用\"><a href=\"#插桩应用\" class=\"headerlink\" title=\"插桩应用\"></a>插桩应用</h3><h3 id=\"插桩原理\"><a href=\"#插桩原理\" class=\"headerlink\" title=\"插桩原理\"></a>插桩原理</h3><h3 id=\"插桩工具-AspectJ\"><a href=\"#插桩工具-AspectJ\" class=\"headerlink\" title=\"插桩工具 AspectJ\"></a>插桩工具 AspectJ</h3><p>优点：</p>\n<p>缺点：</p>\n<h3 id=\"插桩工具-ASM\"><a href=\"#插桩工具-ASM\" class=\"headerlink\" title=\"插桩工具 ASM\"></a>插桩工具 ASM</h3><p>优点：</p>\n<p>缺点：</p>\n"},{"title":"Android不同版本的差异","description":"Android不同版本之间的差异","type":["Android"],"toc":true,"cover":"/cover/img82.jpg","date":"2019-06-04T16:00:00.000Z","_content":"\n\n### Android 8.0 后台Service限制\n\n#### 前台应用和后台应用的区别\n\n前台应用：  \n* 具有可见Activity(不管该Activity已启动还是已暂停)\n* 具有前台Service\n* 另一个应用已关联到该应用\n\n后台应用:\n不满足前台应用的所有条件\n\n### Andorid 9.0(API 28)加密连接\n\n在Andorid 9.0(API 28) 之后网络请求默认需要使用加密连接，没有加密的是不可以的\n在 9.0之前   `android:usesCleartextTraffic`默认为true\n9.0 之后 `android:usesCleartextTraffic` 默认为falue，需要改为true\n<!--more-->\n```xml\n    <application\n      android:usesCleartextTraffic=\"true\">\n```\n\n\n### Android 9.0 (API 28) 对非SDK接口加以限制\n\n通过反射机制处理类时，不应方位SDK中未列出的方法或字段；非SDK接口中存在黑名单、灰名单、白名单。\n\n\n### Android 10.0 (API 29)对后台定位的限制\n\n在Android 10.0 后台定位时，需要进行两次请求，否则会会显示未获取定位权限；第一次需要获取权限`Manifest.permission.ACCESS_COARSE_LOCATION` 需要选择仅运行时允许，\n\n第二次需要获取权限`Manifest.permission.ACCESS_BACKGROUND_LOCATION` 需要选择一直允许；两次获取权限的过程需要分开获取，否则在Android 10.0 上不能正常使用。\n\n高地地图出现的异常 `查看错误码说明,错误详细信息:定位权限被禁用,请授予应用定位权限#1201`\n\n\n","source":"_posts/Android/Advanced/版本区别/不同版本区别.md","raw":"---\ntitle: \"Android不同版本的差异\"\ndescription: \"Android不同版本之间的差异\"\ntype: [Android]\ntoc: true\ncover:  /cover/img82.jpg\ncategories: Android\ndate: 2019/06/05\n---\n\n\n### Android 8.0 后台Service限制\n\n#### 前台应用和后台应用的区别\n\n前台应用：  \n* 具有可见Activity(不管该Activity已启动还是已暂停)\n* 具有前台Service\n* 另一个应用已关联到该应用\n\n后台应用:\n不满足前台应用的所有条件\n\n### Andorid 9.0(API 28)加密连接\n\n在Andorid 9.0(API 28) 之后网络请求默认需要使用加密连接，没有加密的是不可以的\n在 9.0之前   `android:usesCleartextTraffic`默认为true\n9.0 之后 `android:usesCleartextTraffic` 默认为falue，需要改为true\n<!--more-->\n```xml\n    <application\n      android:usesCleartextTraffic=\"true\">\n```\n\n\n### Android 9.0 (API 28) 对非SDK接口加以限制\n\n通过反射机制处理类时，不应方位SDK中未列出的方法或字段；非SDK接口中存在黑名单、灰名单、白名单。\n\n\n### Android 10.0 (API 29)对后台定位的限制\n\n在Android 10.0 后台定位时，需要进行两次请求，否则会会显示未获取定位权限；第一次需要获取权限`Manifest.permission.ACCESS_COARSE_LOCATION` 需要选择仅运行时允许，\n\n第二次需要获取权限`Manifest.permission.ACCESS_BACKGROUND_LOCATION` 需要选择一直允许；两次获取权限的过程需要分开获取，否则在Android 10.0 上不能正常使用。\n\n高地地图出现的异常 `查看错误码说明,错误详细信息:定位权限被禁用,请授予应用定位权限#1201`\n\n\n","slug":"Android/Advanced/版本区别/不同版本区别","published":1,"updated":"2021-01-05T12:13:42.150Z","_id":"ckjju0m2d008m20ua3kim9hs8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Android-8-0-后台Service限制\"><a href=\"#Android-8-0-后台Service限制\" class=\"headerlink\" title=\"Android 8.0 后台Service限制\"></a>Android 8.0 后台Service限制</h3><h4 id=\"前台应用和后台应用的区别\"><a href=\"#前台应用和后台应用的区别\" class=\"headerlink\" title=\"前台应用和后台应用的区别\"></a>前台应用和后台应用的区别</h4><p>前台应用：  </p>\n<ul>\n<li>具有可见Activity(不管该Activity已启动还是已暂停)</li>\n<li>具有前台Service</li>\n<li>另一个应用已关联到该应用</li>\n</ul>\n<p>后台应用:<br>不满足前台应用的所有条件</p>\n<h3 id=\"Andorid-9-0-API-28-加密连接\"><a href=\"#Andorid-9-0-API-28-加密连接\" class=\"headerlink\" title=\"Andorid 9.0(API 28)加密连接\"></a>Andorid 9.0(API 28)加密连接</h3><p>在Andorid 9.0(API 28) 之后网络请求默认需要使用加密连接，没有加密的是不可以的<br>在 9.0之前   <code>android:usesCleartextTraffic</code>默认为true<br>9.0 之后 <code>android:usesCleartextTraffic</code> 默认为falue，需要改为true</p>\n<a id=\"more\"></a>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;application</span><br><span class=\"line\">  android:usesCleartextTraffic=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Android-9-0-API-28-对非SDK接口加以限制\"><a href=\"#Android-9-0-API-28-对非SDK接口加以限制\" class=\"headerlink\" title=\"Android 9.0 (API 28) 对非SDK接口加以限制\"></a>Android 9.0 (API 28) 对非SDK接口加以限制</h3><p>通过反射机制处理类时，不应方位SDK中未列出的方法或字段；非SDK接口中存在黑名单、灰名单、白名单。</p>\n<h3 id=\"Android-10-0-API-29-对后台定位的限制\"><a href=\"#Android-10-0-API-29-对后台定位的限制\" class=\"headerlink\" title=\"Android 10.0 (API 29)对后台定位的限制\"></a>Android 10.0 (API 29)对后台定位的限制</h3><p>在Android 10.0 后台定位时，需要进行两次请求，否则会会显示未获取定位权限；第一次需要获取权限<code>Manifest.permission.ACCESS_COARSE_LOCATION</code> 需要选择仅运行时允许，</p>\n<p>第二次需要获取权限<code>Manifest.permission.ACCESS_BACKGROUND_LOCATION</code> 需要选择一直允许；两次获取权限的过程需要分开获取，否则在Android 10.0 上不能正常使用。</p>\n<p>高地地图出现的异常 <code>查看错误码说明,错误详细信息:定位权限被禁用,请授予应用定位权限#1201</code></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Android-8-0-后台Service限制\"><a href=\"#Android-8-0-后台Service限制\" class=\"headerlink\" title=\"Android 8.0 后台Service限制\"></a>Android 8.0 后台Service限制</h3><h4 id=\"前台应用和后台应用的区别\"><a href=\"#前台应用和后台应用的区别\" class=\"headerlink\" title=\"前台应用和后台应用的区别\"></a>前台应用和后台应用的区别</h4><p>前台应用：  </p>\n<ul>\n<li>具有可见Activity(不管该Activity已启动还是已暂停)</li>\n<li>具有前台Service</li>\n<li>另一个应用已关联到该应用</li>\n</ul>\n<p>后台应用:<br>不满足前台应用的所有条件</p>\n<h3 id=\"Andorid-9-0-API-28-加密连接\"><a href=\"#Andorid-9-0-API-28-加密连接\" class=\"headerlink\" title=\"Andorid 9.0(API 28)加密连接\"></a>Andorid 9.0(API 28)加密连接</h3><p>在Andorid 9.0(API 28) 之后网络请求默认需要使用加密连接，没有加密的是不可以的<br>在 9.0之前   <code>android:usesCleartextTraffic</code>默认为true<br>9.0 之后 <code>android:usesCleartextTraffic</code> 默认为falue，需要改为true</p>","more":"<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;application</span><br><span class=\"line\">  android:usesCleartextTraffic=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Android-9-0-API-28-对非SDK接口加以限制\"><a href=\"#Android-9-0-API-28-对非SDK接口加以限制\" class=\"headerlink\" title=\"Android 9.0 (API 28) 对非SDK接口加以限制\"></a>Android 9.0 (API 28) 对非SDK接口加以限制</h3><p>通过反射机制处理类时，不应方位SDK中未列出的方法或字段；非SDK接口中存在黑名单、灰名单、白名单。</p>\n<h3 id=\"Android-10-0-API-29-对后台定位的限制\"><a href=\"#Android-10-0-API-29-对后台定位的限制\" class=\"headerlink\" title=\"Android 10.0 (API 29)对后台定位的限制\"></a>Android 10.0 (API 29)对后台定位的限制</h3><p>在Android 10.0 后台定位时，需要进行两次请求，否则会会显示未获取定位权限；第一次需要获取权限<code>Manifest.permission.ACCESS_COARSE_LOCATION</code> 需要选择仅运行时允许，</p>\n<p>第二次需要获取权限<code>Manifest.permission.ACCESS_BACKGROUND_LOCATION</code> 需要选择一直允许；两次获取权限的过程需要分开获取，否则在Android 10.0 上不能正常使用。</p>\n<p>高地地图出现的异常 <code>查看错误码说明,错误详细信息:定位权限被禁用,请授予应用定位权限#1201</code></p>"},{"title":"Andoid组件化注意问题","description":"Andoid组件化注意问题","type":["Android"],"toc":true,"cover":"/cover/img83.jpg","date":"2020-01-07T16:00:00.000Z","_content":"\n## 注意问题：\n1、使用组件化化开发时需要避免循环依赖\n\n2、子模块之间的Activity调用，通过类加载的方式或通过在Common模块中设置全局Map的形式，才可以调用\n<!--more-->\n\n## 阿里云router架构源码查看缺点\n\n1、全局Map缓存多达5个之多，还有一个全局List\n\ncom.alibaba.android.arouter.core.Warehouse 路由和其他数据存储\n\n2、加载私有目录下apk中的所有dex并遍历，获取所有包名为xxx的类，并开启了线程工作\n\ncom.alibaba.android.arouter.utils.ClassUtils\n\ngetFileNameByPackageName()  80行\ntryLoadInstantRunDexFil()  173行\n\n3、ClassUtils这一个类在华为手机兼容失败\n\n4、耗时操作，就需要线程池：67行\n\n","source":"_posts/Android/Advanced/组件化/Android组件化注意问题.md","raw":"---\ntitle: \"Andoid组件化注意问题\"\ndescription: \"Andoid组件化注意问题\"\ntype: [Android]\ntoc: true\ncover:  /cover/img83.jpg\ncategories: Android\ndate: 2020/01/08\n---\n\n## 注意问题：\n1、使用组件化化开发时需要避免循环依赖\n\n2、子模块之间的Activity调用，通过类加载的方式或通过在Common模块中设置全局Map的形式，才可以调用\n<!--more-->\n\n## 阿里云router架构源码查看缺点\n\n1、全局Map缓存多达5个之多，还有一个全局List\n\ncom.alibaba.android.arouter.core.Warehouse 路由和其他数据存储\n\n2、加载私有目录下apk中的所有dex并遍历，获取所有包名为xxx的类，并开启了线程工作\n\ncom.alibaba.android.arouter.utils.ClassUtils\n\ngetFileNameByPackageName()  80行\ntryLoadInstantRunDexFil()  173行\n\n3、ClassUtils这一个类在华为手机兼容失败\n\n4、耗时操作，就需要线程池：67行\n\n","slug":"Android/Advanced/组件化/Android组件化注意问题","published":1,"updated":"2021-01-05T12:13:42.963Z","_id":"ckjju0m2d008p20ua0gs1dk9j","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"注意问题：\"><a href=\"#注意问题：\" class=\"headerlink\" title=\"注意问题：\"></a>注意问题：</h2><p>1、使用组件化化开发时需要避免循环依赖</p>\n<p>2、子模块之间的Activity调用，通过类加载的方式或通过在Common模块中设置全局Map的形式，才可以调用</p>\n<a id=\"more\"></a>\n\n<h2 id=\"阿里云router架构源码查看缺点\"><a href=\"#阿里云router架构源码查看缺点\" class=\"headerlink\" title=\"阿里云router架构源码查看缺点\"></a>阿里云router架构源码查看缺点</h2><p>1、全局Map缓存多达5个之多，还有一个全局List</p>\n<p>com.alibaba.android.arouter.core.Warehouse 路由和其他数据存储</p>\n<p>2、加载私有目录下apk中的所有dex并遍历，获取所有包名为xxx的类，并开启了线程工作</p>\n<p>com.alibaba.android.arouter.utils.ClassUtils</p>\n<p>getFileNameByPackageName()  80行<br>tryLoadInstantRunDexFil()  173行</p>\n<p>3、ClassUtils这一个类在华为手机兼容失败</p>\n<p>4、耗时操作，就需要线程池：67行</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"注意问题：\"><a href=\"#注意问题：\" class=\"headerlink\" title=\"注意问题：\"></a>注意问题：</h2><p>1、使用组件化化开发时需要避免循环依赖</p>\n<p>2、子模块之间的Activity调用，通过类加载的方式或通过在Common模块中设置全局Map的形式，才可以调用</p>","more":"<h2 id=\"阿里云router架构源码查看缺点\"><a href=\"#阿里云router架构源码查看缺点\" class=\"headerlink\" title=\"阿里云router架构源码查看缺点\"></a>阿里云router架构源码查看缺点</h2><p>1、全局Map缓存多达5个之多，还有一个全局List</p>\n<p>com.alibaba.android.arouter.core.Warehouse 路由和其他数据存储</p>\n<p>2、加载私有目录下apk中的所有dex并遍历，获取所有包名为xxx的类，并开启了线程工作</p>\n<p>com.alibaba.android.arouter.utils.ClassUtils</p>\n<p>getFileNameByPackageName()  80行<br>tryLoadInstantRunDexFil()  173行</p>\n<p>3、ClassUtils这一个类在华为手机兼容失败</p>\n<p>4、耗时操作，就需要线程池：67行</p>"},{"title":"结构化组件介绍与使用","cover":"/cover/img24.jpg","toc":true,"description":"结构化组件介绍与使用","type":["Android"],"date":"2019-08-18T16:00:00.000Z","_content":"\n# 结构化组件介绍\n\n结构化组件\\(Android Architecture Components\\)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。\n<!--more-->\n* 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。\n* 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。\n* ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁\n* Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。\n\n## 结构化组件推荐\n\n结构化组件的工作原理介绍如图所示，\n\n* Entity\\(实体\\)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。\n* SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。\n* Dao：用于获取数据的Object，将Sql语句映射为`Funcation`，通常需要在`SQLite OpenHelper`中进行定义，但使用Room持久化层，只需调用方法即可，不需要再`SQLite OpenHelper`中进行定义。\n* Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在`SQLite Openhelper`中进行处理），Room数据库使用Dao来操作SQLite Database。\n* Repository：使用Repository来操作多种数据源。\n* ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，\n* LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。`LiveData`可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，`LiveData`可以自动感知与它相关的组件的生命周期的改变。\n\n","source":"_posts/Android/框架/AAC/Android Architecture Components.md","raw":"---\ntitle: 结构化组件介绍与使用\ncover: /cover/img24.jpg\ntoc: true\ndescription: 结构化组件介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2019/08/19\n\n---\n\n# 结构化组件介绍\n\n结构化组件\\(Android Architecture Components\\)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。\n<!--more-->\n* 使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。\n* 使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。\n* ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁\n* Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。\n\n## 结构化组件推荐\n\n结构化组件的工作原理介绍如图所示，\n\n* Entity\\(实体\\)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。\n* SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。\n* Dao：用于获取数据的Object，将Sql语句映射为`Funcation`，通常需要在`SQLite OpenHelper`中进行定义，但使用Room持久化层，只需调用方法即可，不需要再`SQLite OpenHelper`中进行定义。\n* Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在`SQLite Openhelper`中进行处理），Room数据库使用Dao来操作SQLite Database。\n* Repository：使用Repository来操作多种数据源。\n* ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，\n* LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。`LiveData`可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，`LiveData`可以自动感知与它相关的组件的生命周期的改变。\n\n","slug":"Android/框架/AAC/Android Architecture Components","published":1,"updated":"2021-01-05T12:14:23.170Z","_id":"ckjju0m2e008s20ua08ck693n","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"结构化组件介绍\"><a href=\"#结构化组件介绍\" class=\"headerlink\" title=\"结构化组件介绍\"></a>结构化组件介绍</h1><p>结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。</p>\n<a id=\"more\"></a>\n<ul>\n<li>使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。</li>\n<li>使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。</li>\n<li>ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁</li>\n<li>Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。</li>\n</ul>\n<h2 id=\"结构化组件推荐\"><a href=\"#结构化组件推荐\" class=\"headerlink\" title=\"结构化组件推荐\"></a>结构化组件推荐</h2><p>结构化组件的工作原理介绍如图所示，</p>\n<ul>\n<li>Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。</li>\n<li>SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。</li>\n<li>Dao：用于获取数据的Object，将Sql语句映射为<code>Funcation</code>，通常需要在<code>SQLite OpenHelper</code>中进行定义，但使用Room持久化层，只需调用方法即可，不需要再<code>SQLite OpenHelper</code>中进行定义。</li>\n<li>Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在<code>SQLite Openhelper</code>中进行处理），Room数据库使用Dao来操作SQLite Database。</li>\n<li>Repository：使用Repository来操作多种数据源。</li>\n<li>ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，</li>\n<li>LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。<code>LiveData</code>可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，<code>LiveData</code>可以自动感知与它相关的组件的生命周期的改变。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"结构化组件介绍\"><a href=\"#结构化组件介绍\" class=\"headerlink\" title=\"结构化组件介绍\"></a>结构化组件介绍</h1><p>结构化组件(Android Architecture Components)是Android Jetpack的一部分，这些集合库可以使得开发更容易测试与维护。</p>","more":"<ul>\n<li>使用life-aware components组件可以用于管理activity以及fragment的生命周期。用于配置信息的改变、避免内存泄漏以及更加方便在UI中加载数据。</li>\n<li>使用LiveData建立数据对象，当底层数据发生改变时通知View进行刷新。</li>\n<li>ViewModel可以保存与UI相关的数据，保证用户在屏幕旋转时数据不会被销毁</li>\n<li>Room是SQLite数据库对象的映射，使用Room可以很容易将SQLite数据表转换为Java对象。Room提供了在编译过程中对SQLite声明的check，可以返回RxJava、Flowable以及LiveData的observables。</li>\n</ul>\n<h2 id=\"结构化组件推荐\"><a href=\"#结构化组件推荐\" class=\"headerlink\" title=\"结构化组件推荐\"></a>结构化组件推荐</h2><p>结构化组件的工作原理介绍如图所示，</p>\n<ul>\n<li>Entity(实体)：当使用结构化组件时，使用注解的方式表示数据库中的一张数据表。</li>\n<li>SQLite database:在手机中将数据存储在SQLite数据中，Room持久化库创建和控制这一个数据库。</li>\n<li>Dao：用于获取数据的Object，将Sql语句映射为<code>Funcation</code>，通常需要在<code>SQLite OpenHelper</code>中进行定义，但使用Room持久化层，只需调用方法即可，不需要再<code>SQLite OpenHelper</code>中进行定义。</li>\n<li>Room Database：Room数据库层是在SQLite Database的上一层，用于处理复杂的任务（之前是在<code>SQLite Openhelper</code>中进行处理），Room数据库使用Dao来操作SQLite Database。</li>\n<li>Repository：使用Repository来操作多种数据源。</li>\n<li>ViewModel：向UI界面提供数据，作为Repository与UI数据媒介，向UI隐藏数据源，</li>\n<li>LiveData：是一个数据持有类，可以被订阅（感知），持有/缓存最新的数据。当数据发生改变时，将会通知它的订阅者。<code>LiveData</code>可以感知组件的生命周期，UI组件只是订阅与之相关的生命周期，不会停止或者暂停订阅，<code>LiveData</code>可以自动感知与它相关的组件的生命周期的改变。</li>\n</ul>"},{"title":"Android生命周期感知组件详解","cover":"/cover/img25.jpg","toc":true,"description":"Android生命周期感知组件详解","type":["Android"],"date":"2018-07-07T16:00:00.000Z","_content":"\n\n## Android生命周期感知组件详解\n\n使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 `onStart()` `onStop()`中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。\n<!--more-->\n### Lifecycle类\n\n![](/public/img/Android/lifecycle.png)\n\nLifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。\n\n* Event\n\n    由framework层分发的以及`Lifecycle`类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调\n\n* State\n   \n    表示由`Lifecycle`对象跟踪的组件的当前的状态\n    \n### LifecycleOwner\n\n`LifecycleOwner`是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。\n\n源码：\n\n```java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     *\n    @NonNull\n    Lifecycle getLifecycle();\n}\n\n```\n\n一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现`LifecycleOwner`接口。\n\n\n### LifecycleObserver\n\n`LifecycleObserver`接口可以与实现`LifecycleOwner`接口的类配合使用，实现`LifecycleOwner`接口的类提供`Lifecycle`，而`LifecycleObserver`可以注册至被观察者。\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/Android Lifecycle-Aware组件详解.md","raw":"---\ntitle: Android生命周期感知组件详解\ncover: /cover/img25.jpg\ntoc: true\ndescription: Android生命周期感知组件详解\ncategories: Android\ntype: [Android]\ndate: 2018/07/08\n\n---\n\n\n## Android生命周期感知组件详解\n\n使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 `onStart()` `onStop()`中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。\n<!--more-->\n### Lifecycle类\n\n![](/public/img/Android/lifecycle.png)\n\nLifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。\n\n* Event\n\n    由framework层分发的以及`Lifecycle`类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调\n\n* State\n   \n    表示由`Lifecycle`对象跟踪的组件的当前的状态\n    \n### LifecycleOwner\n\n`LifecycleOwner`是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。\n\n源码：\n\n```java\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     *\n    @NonNull\n    Lifecycle getLifecycle();\n}\n\n```\n\n一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现`LifecycleOwner`接口。\n\n\n### LifecycleObserver\n\n`LifecycleObserver`接口可以与实现`LifecycleOwner`接口的类配合使用，实现`LifecycleOwner`接口的类提供`Lifecycle`，而`LifecycleObserver`可以注册至被观察者。\n\n\n\n\n\n","slug":"Android/框架/AAC/Android Lifecycle-Aware组件详解","published":1,"updated":"2021-01-05T12:14:23.628Z","_id":"ckjju0m2f008v20ua8kp79a9s","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Android生命周期感知组件详解\"><a href=\"#Android生命周期感知组件详解\" class=\"headerlink\" title=\"Android生命周期感知组件详解\"></a>Android生命周期感知组件详解</h2><p>使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 <code>onStart()</code> <code>onStop()</code>中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。</p>\n<a id=\"more\"></a>\n<h3 id=\"Lifecycle类\"><a href=\"#Lifecycle类\" class=\"headerlink\" title=\"Lifecycle类\"></a>Lifecycle类</h3><p><img src=\"/public/img/Android/lifecycle.png\"></p>\n<p>Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。</p>\n<ul>\n<li><p>Event</p>\n<p>  由framework层分发的以及<code>Lifecycle</code>类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调</p>\n</li>\n<li><p>State</p>\n<p>  表示由<code>Lifecycle</code>对象跟踪的组件的当前的状态</p>\n</li>\n</ul>\n<h3 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h3><p><code>LifecycleOwner</code>是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">@NonNull</span></span></span><br><span class=\"line\"><span class=\"comment\">    Lifecycle getLifecycle();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br></pre></td></tr></table></figure>\n<p>一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现<code>LifecycleOwner</code>接口。</p>\n<h3 id=\"LifecycleObserver\"><a href=\"#LifecycleObserver\" class=\"headerlink\" title=\"LifecycleObserver\"></a>LifecycleObserver</h3><p><code>LifecycleObserver</code>接口可以与实现<code>LifecycleOwner</code>接口的类配合使用，实现<code>LifecycleOwner</code>接口的类提供<code>Lifecycle</code>，而<code>LifecycleObserver</code>可以注册至被观察者。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Android生命周期感知组件详解\"><a href=\"#Android生命周期感知组件详解\" class=\"headerlink\" title=\"Android生命周期感知组件详解\"></a>Android生命周期感知组件详解</h2><p>使用Lifecycle-aware components（生命周期感知组件），可以将与Activity、Fragemnt、Service生命周期相关方法如 <code>onStart()</code> <code>onStop()</code>中的调用，放入单独的模块中,lifecycle-aware components可以自动根据生命周期进行不同的处理。</p>","more":"<h3 id=\"Lifecycle类\"><a href=\"#Lifecycle类\" class=\"headerlink\" title=\"Lifecycle类\"></a>Lifecycle类</h3><p><img src=\"/public/img/Android/lifecycle.png\"></p>\n<p>Lifecycle可以持有组件的生命周期的信息，其使用两个枚举类型来跟踪与之相关的组件的生命周期。</p>\n<ul>\n<li><p>Event</p>\n<p>  由framework层分发的以及<code>Lifecycle</code>类分发的生命周期事件，这些事件映射到Activity以及Fragemnt的回调</p>\n</li>\n<li><p>State</p>\n<p>  表示由<code>Lifecycle</code>对象跟踪的组件的当前的状态</p>\n</li>\n</ul>\n<h3 id=\"LifecycleOwner\"><a href=\"#LifecycleOwner\" class=\"headerlink\" title=\"LifecycleOwner\"></a>LifecycleOwner</h3><p><code>LifecycleOwner</code>是只有一个方法的接口，在代码编写的过程中任何一个类都可以实现该接口。</p>\n<p>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">@NonNull</span></span></span><br><span class=\"line\"><span class=\"comment\">    Lifecycle getLifecycle();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br></pre></td></tr></table></figure>\n<p>一个常用的生命周期感知用于Android组件的中回调，如果回调函数发生在组件的不合理生命周期则会造成崩溃的发生。在Support Library 26.1.0 以及更新的版本中，Fragment以及Activity已经实现<code>LifecycleOwner</code>接口。</p>\n<h3 id=\"LifecycleObserver\"><a href=\"#LifecycleObserver\" class=\"headerlink\" title=\"LifecycleObserver\"></a>LifecycleObserver</h3><p><code>LifecycleObserver</code>接口可以与实现<code>LifecycleOwner</code>接口的类配合使用，实现<code>LifecycleOwner</code>接口的类提供<code>Lifecycle</code>，而<code>LifecycleObserver</code>可以注册至被观察者。</p>"},{"title":"LiveData介绍与使用","cover":"/cover/img26.jpg","toc":true,"description":"LiveData介绍与使用","type":["Android"],"date":"2019-04-22T16:00:00.000Z","_content":"\n## LiveData介绍\n`LiveData`是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。`LiveData`是一个抽象类，其继承关系如下：\n<!--more-->\n![](/public/img/Android/livedata.png)\n\n#### LiveData的优势\n* 保证UI界面与数据相匹配\n* 无内存泄漏\n    \n    观察者绑定至`Lifecycle`，当观察者的生命周期结束后，其会自动清理\n* 不会由于Activity stop而发生崩溃\n\n    如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据\n* 合理的数据配置\n         \n    如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 \n* 数据共享\n\n    可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。\n\n### 在具有生命周期的对象中使用LiveData\n\n#### 定义被观察者\n在定义被观察者对象时通常使用`MutableLiveData`类，在Activity中定义一个被观察的对象：\n\n```java\n  \n    MutableLiveData<String> mutableLiveData=new MutableLiveData<>();\n\n```\n\n#### 注册观察者：\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mutableLiveData.observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String s) {\n                Log.i(\"输出数据：\",s);\n            }\n        });\n    }\n```\n\n被观察者`mutableLiveData`的数据修改有两种方式：`setValue(T value)`和`postValue(T value) `。当被观察者数据在UI主线程中进行修改时，使用`setValue(T value)`，当被观察者在子线程中使用时，使用`postValue(T value) `；\n\n#### 通过`setValue(T value)`修改被观察者并通知观察者\n\n```\n    mutableLiveData.setValue(\"TEST\");\n```\n\n`setValue(T value)`源码：\n```java\n    @MainThread\n    protected void setValue(T value) {\n        assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常\n        mVersion++;\n        mData = value;\n        dispatchingValue(null);  //用于数据分发通知观察者\n    }\n\n```\n在`setValue(T value)`中调用`dispatchingValue(null)`，用于通知观察者。\n\n`dispatchingValue(@Nullable ObserverWrapper initiator)`源码\n```java\n    //参数ObserverWrapper是每一个观察者的封装\n    void dispatchingValue(@Nullable ObserverWrapper initiator) {\n       \n        //...\n        do {\n            mDispatchInvalidated = false;\n                //...\n                //遍历所有的观察者，并进行通知\n                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                    //considerNotify用于通知观察者\n                    considerNotify(iterator.next().getValue());\n                    if (mDispatchInvalidated) {\n                        break;\n                    }\n            }\n        } while (mDispatchInvalidated);\n        mDispatchingValue = false;\n    }\n\n```\n\n在`dispatchingValue(@Nullable ObserverWrapper initiator)`方法中调用`considerNotify(ObserverWrapper observer)`通知观察者\n\n```java\n    private void considerNotify(ObserverWrapper observer) {\n        if (!observer.mActive) {\n            return;\n        }\n        if (!observer.shouldBeActive()) {\n            observer.activeStateChanged(false);\n            return;\n        }\n        if (observer.mLastVersion >= mVersion) {\n            return;\n        }\n        observer.mLastVersion = mVersion;\n        observer.mObserver.onChanged((T) mData);\n    }\n```\n\n\n#### 通过`postValue(T value) `修改被观察者并通知观察者\n\n```\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                mutableLiveData.postValue(\"TEST\");\n            }\n        }).start();\n\n```\n\n`postValue(T value) `源码：\n\n```java\n    protected void postValue(T value) {\n        boolean postTask;\n        synchronized (mDataLock) {\n            postTask = mPendingData == NOT_SET;\n            mPendingData = value;\n        }\n        if (!postTask) {\n            return;\n        }\n        \n        //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n```\n`mPostValueRunnable`源码：\n```java\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            //...\n            //依然是调用setValue对数据进行修改\n            setValue((T) newValue);\n        }\n    };\n\n```\n\n#### 在不具有生命周期的对象中使用LiveData\n\n```\n    public class TestLiveDataBean {\n\n        MutableLiveData<String> mutableLiveData = new MutableLiveData<>();\n        \n        Observer<String> observer;\n\n        public TestLiveDataBean() {\n            observer = new Observer<String>() {\n                @Override\n                public void onChanged(String s) {\n                    LogUtils.printInfo(s);\n                }\n            };\n            //添加观察者\n            mutableLiveData.observeForever(observer);\n        }\n\n        public void setValue() {\n            //无论setValue是否在UI主线程中，都可以用postValue\n            mutableLiveData.postValue(\"测试\");\n            //当在子线程中调用setValue报错\n            //mutableLiveData.setValue(\"测试\");\n        }\n    \n          public void removeObserver() {\n            mutableLiveData.removeObserver(observer);\n        }\n    }\n\n```\n`observeForever()`与`removeOberver()`方法需要成对进行使用，通过`observeForever()`方法添加观察者，该方法只能在主线程中调用;\n\n```java\n\n    @MainThread\n    public void observeForever(@NonNull Observer<? super T> observer) {\n        assertMainThread(\"observeForever\");\n        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        if (existing instanceof LiveData.LifecycleBoundObserver) {\n            throw new IllegalArgumentException(\"Cannot add the same observer\"\n                    + \" with different lifecycles\");\n        }\n        if (existing != null) {\n            return;\n        }\n        wrapper.activeStateChanged(true);\n    }\n\n```\n\n\n观察者使用完毕后，需要通过`removeOberver()`方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用\n\n`removeObserver(@NonNull final Observer<? super T> observer)`源码：\n```java\n\n    @MainThread\n    public void removeObserver(@NonNull final Observer<? super T> observer) {\n        assertMainThread(\"removeObserver\");\n        ObserverWrapper removed = mObservers.remove(observer);\n        if (removed == null) {\n            return;\n        }\n        removed.detachObserver();\n        removed.activeStateChanged(false);\n    }\n\n\n```\n\n### MediatorLiveData介绍\n\n`MediatorLiveData`是`LiveData`的一个子类，可以将`LiveData`的数据源合并至一起；当任一`LiveData`数据源的数据发生改变后，都会触发`MediatorLiveData`的观察者。\n\n\n### 继承LiveData进行数据共享\n\n\n","source":"_posts/Android/框架/AAC/Android Livedata详解.md","raw":"---\ntitle: LiveData介绍与使用\ncover: /cover/img26.jpg\ntoc: true\ndescription: LiveData介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2019/04/23\n\n---\n\n## LiveData介绍\n`LiveData`是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。`LiveData`是一个抽象类，其继承关系如下：\n<!--more-->\n![](/public/img/Android/livedata.png)\n\n#### LiveData的优势\n* 保证UI界面与数据相匹配\n* 无内存泄漏\n    \n    观察者绑定至`Lifecycle`，当观察者的生命周期结束后，其会自动清理\n* 不会由于Activity stop而发生崩溃\n\n    如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据\n* 合理的数据配置\n         \n    如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 \n* 数据共享\n\n    可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。\n\n### 在具有生命周期的对象中使用LiveData\n\n#### 定义被观察者\n在定义被观察者对象时通常使用`MutableLiveData`类，在Activity中定义一个被观察的对象：\n\n```java\n  \n    MutableLiveData<String> mutableLiveData=new MutableLiveData<>();\n\n```\n\n#### 注册观察者：\n\n```java\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mutableLiveData.observe(this, new Observer<String>() {\n            @Override\n            public void onChanged(String s) {\n                Log.i(\"输出数据：\",s);\n            }\n        });\n    }\n```\n\n被观察者`mutableLiveData`的数据修改有两种方式：`setValue(T value)`和`postValue(T value) `。当被观察者数据在UI主线程中进行修改时，使用`setValue(T value)`，当被观察者在子线程中使用时，使用`postValue(T value) `；\n\n#### 通过`setValue(T value)`修改被观察者并通知观察者\n\n```\n    mutableLiveData.setValue(\"TEST\");\n```\n\n`setValue(T value)`源码：\n```java\n    @MainThread\n    protected void setValue(T value) {\n        assertMainThread(\"setValue\"); //用于判断是否在主线程，否则抛出异常\n        mVersion++;\n        mData = value;\n        dispatchingValue(null);  //用于数据分发通知观察者\n    }\n\n```\n在`setValue(T value)`中调用`dispatchingValue(null)`，用于通知观察者。\n\n`dispatchingValue(@Nullable ObserverWrapper initiator)`源码\n```java\n    //参数ObserverWrapper是每一个观察者的封装\n    void dispatchingValue(@Nullable ObserverWrapper initiator) {\n       \n        //...\n        do {\n            mDispatchInvalidated = false;\n                //...\n                //遍历所有的观察者，并进行通知\n                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                    //considerNotify用于通知观察者\n                    considerNotify(iterator.next().getValue());\n                    if (mDispatchInvalidated) {\n                        break;\n                    }\n            }\n        } while (mDispatchInvalidated);\n        mDispatchingValue = false;\n    }\n\n```\n\n在`dispatchingValue(@Nullable ObserverWrapper initiator)`方法中调用`considerNotify(ObserverWrapper observer)`通知观察者\n\n```java\n    private void considerNotify(ObserverWrapper observer) {\n        if (!observer.mActive) {\n            return;\n        }\n        if (!observer.shouldBeActive()) {\n            observer.activeStateChanged(false);\n            return;\n        }\n        if (observer.mLastVersion >= mVersion) {\n            return;\n        }\n        observer.mLastVersion = mVersion;\n        observer.mObserver.onChanged((T) mData);\n    }\n```\n\n\n#### 通过`postValue(T value) `修改被观察者并通知观察者\n\n```\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                mutableLiveData.postValue(\"TEST\");\n            }\n        }).start();\n\n```\n\n`postValue(T value) `源码：\n\n```java\n    protected void postValue(T value) {\n        boolean postTask;\n        synchronized (mDataLock) {\n            postTask = mPendingData == NOT_SET;\n            mPendingData = value;\n        }\n        if (!postTask) {\n            return;\n        }\n        \n        //postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n```\n`mPostValueRunnable`源码：\n```java\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            //...\n            //依然是调用setValue对数据进行修改\n            setValue((T) newValue);\n        }\n    };\n\n```\n\n#### 在不具有生命周期的对象中使用LiveData\n\n```\n    public class TestLiveDataBean {\n\n        MutableLiveData<String> mutableLiveData = new MutableLiveData<>();\n        \n        Observer<String> observer;\n\n        public TestLiveDataBean() {\n            observer = new Observer<String>() {\n                @Override\n                public void onChanged(String s) {\n                    LogUtils.printInfo(s);\n                }\n            };\n            //添加观察者\n            mutableLiveData.observeForever(observer);\n        }\n\n        public void setValue() {\n            //无论setValue是否在UI主线程中，都可以用postValue\n            mutableLiveData.postValue(\"测试\");\n            //当在子线程中调用setValue报错\n            //mutableLiveData.setValue(\"测试\");\n        }\n    \n          public void removeObserver() {\n            mutableLiveData.removeObserver(observer);\n        }\n    }\n\n```\n`observeForever()`与`removeOberver()`方法需要成对进行使用，通过`observeForever()`方法添加观察者，该方法只能在主线程中调用;\n\n```java\n\n    @MainThread\n    public void observeForever(@NonNull Observer<? super T> observer) {\n        assertMainThread(\"observeForever\");\n        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        if (existing instanceof LiveData.LifecycleBoundObserver) {\n            throw new IllegalArgumentException(\"Cannot add the same observer\"\n                    + \" with different lifecycles\");\n        }\n        if (existing != null) {\n            return;\n        }\n        wrapper.activeStateChanged(true);\n    }\n\n```\n\n\n观察者使用完毕后，需要通过`removeOberver()`方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用\n\n`removeObserver(@NonNull final Observer<? super T> observer)`源码：\n```java\n\n    @MainThread\n    public void removeObserver(@NonNull final Observer<? super T> observer) {\n        assertMainThread(\"removeObserver\");\n        ObserverWrapper removed = mObservers.remove(observer);\n        if (removed == null) {\n            return;\n        }\n        removed.detachObserver();\n        removed.activeStateChanged(false);\n    }\n\n\n```\n\n### MediatorLiveData介绍\n\n`MediatorLiveData`是`LiveData`的一个子类，可以将`LiveData`的数据源合并至一起；当任一`LiveData`数据源的数据发生改变后，都会触发`MediatorLiveData`的观察者。\n\n\n### 继承LiveData进行数据共享\n\n\n","slug":"Android/框架/AAC/Android Livedata详解","published":1,"updated":"2021-01-05T12:14:24.370Z","_id":"ckjju0m2f008y20uahr7l9qra","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"LiveData介绍\"><a href=\"#LiveData介绍\" class=\"headerlink\" title=\"LiveData介绍\"></a>LiveData介绍</h2><p><code>LiveData</code>是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。<code>LiveData</code>是一个抽象类，其继承关系如下：</p>\n<a id=\"more\"></a>\n<p><img src=\"/public/img/Android/livedata.png\"></p>\n<h4 id=\"LiveData的优势\"><a href=\"#LiveData的优势\" class=\"headerlink\" title=\"LiveData的优势\"></a>LiveData的优势</h4><ul>\n<li><p>保证UI界面与数据相匹配</p>\n</li>\n<li><p>无内存泄漏</p>\n<p>  观察者绑定至<code>Lifecycle</code>，当观察者的生命周期结束后，其会自动清理</p>\n</li>\n<li><p>不会由于Activity stop而发生崩溃</p>\n<p>  如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据</p>\n</li>\n<li><p>合理的数据配置</p>\n<p>  如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 </p>\n</li>\n<li><p>数据共享</p>\n<p>  可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。</p>\n</li>\n</ul>\n<h3 id=\"在具有生命周期的对象中使用LiveData\"><a href=\"#在具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在具有生命周期的对象中使用LiveData\"></a>在具有生命周期的对象中使用LiveData</h3><h4 id=\"定义被观察者\"><a href=\"#定义被观察者\" class=\"headerlink\" title=\"定义被观察者\"></a>定义被观察者</h4><p>在定义被观察者对象时通常使用<code>MutableLiveData</code>类，在Activity中定义一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">MutableLiveData&lt;String&gt; mutableLiveData=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"注册观察者：\"><a href=\"#注册观察者：\" class=\"headerlink\" title=\"注册观察者：\"></a>注册观察者：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    mutableLiveData.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">            Log.i(<span class=\"string\">&quot;输出数据：&quot;</span>,s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被观察者<code>mutableLiveData</code>的数据修改有两种方式：<code>setValue(T value)</code>和<code>postValue(T value) </code>。当被观察者数据在UI主线程中进行修改时，使用<code>setValue(T value)</code>，当被观察者在子线程中使用时，使用<code>postValue(T value) </code>；</p>\n<h4 id=\"通过setValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过setValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过setValue(T value)修改被观察者并通知观察者\"></a>通过<code>setValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableLiveData.setValue(&quot;TEST&quot;);</span><br></pre></td></tr></table></figure>\n<p><code>setValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;setValue&quot;</span>); <span class=\"comment\">//用于判断是否在主线程，否则抛出异常</span></span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);  <span class=\"comment\">//用于数据分发通知观察者</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>setValue(T value)</code>中调用<code>dispatchingValue(null)</code>，用于通知观察者。</p>\n<p><code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//参数ObserverWrapper是每一个观察者的封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"comment\">//遍历所有的观察者，并进行通知</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//considerNotify用于通知观察者</span></span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>方法中调用<code>considerNotify(ObserverWrapper observer)</code>通知观察者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过postValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过postValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过postValue(T value) 修改被观察者并通知观察者\"></a>通过<code>postValue(T value) </code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;TEST&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>postValue(T value) </code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;</span><br><span class=\"line\">        mPendingData = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行</span></span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mPostValueRunnable</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//依然是调用setValue对数据进行修改</span></span><br><span class=\"line\">        setValue((T) newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在不具有生命周期的对象中使用LiveData\"><a href=\"#在不具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在不具有生命周期的对象中使用LiveData\"></a>在不具有生命周期的对象中使用LiveData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestLiveDataBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MutableLiveData&lt;String&gt; mutableLiveData &#x3D; new MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Observer&lt;String&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestLiveDataBean() &#123;</span><br><span class=\"line\">        observer &#x3D; new Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onChanged(String s) &#123;</span><br><span class=\"line\">                LogUtils.printInfo(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F;添加观察者</span><br><span class=\"line\">        mutableLiveData.observeForever(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setValue() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;无论setValue是否在UI主线程中，都可以用postValue</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;测试&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;当在子线程中调用setValue报错</span><br><span class=\"line\">        &#x2F;&#x2F;mutableLiveData.setValue(&quot;测试&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public void removeObserver() &#123;</span><br><span class=\"line\">        mutableLiveData.removeObserver(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>observeForever()</code>与<code>removeOberver()</code>方法需要成对进行使用，通过<code>observeForever()</code>方法添加观察者，该方法只能在主线程中调用;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;observeForever&quot;</span>);</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing <span class=\"keyword\">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Cannot add the same observer&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; with different lifecycles&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>观察者使用完毕后，需要通过<code>removeOberver()</code>方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用</p>\n<p><code>removeObserver(@NonNull final Observer&lt;? super T&gt; observer)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;removeObserver&quot;</span>);</span><br><span class=\"line\">    ObserverWrapper removed = mObservers.remove(observer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    removed.detachObserver();</span><br><span class=\"line\">    removed.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"MediatorLiveData介绍\"><a href=\"#MediatorLiveData介绍\" class=\"headerlink\" title=\"MediatorLiveData介绍\"></a>MediatorLiveData介绍</h3><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，可以将<code>LiveData</code>的数据源合并至一起；当任一<code>LiveData</code>数据源的数据发生改变后，都会触发<code>MediatorLiveData</code>的观察者。</p>\n<h3 id=\"继承LiveData进行数据共享\"><a href=\"#继承LiveData进行数据共享\" class=\"headerlink\" title=\"继承LiveData进行数据共享\"></a>继承LiveData进行数据共享</h3>","site":{"data":{}},"excerpt":"<h2 id=\"LiveData介绍\"><a href=\"#LiveData介绍\" class=\"headerlink\" title=\"LiveData介绍\"></a>LiveData介绍</h2><p><code>LiveData</code>是一个被观察的类，其具有生命周期感知，即只有Android组件，Activity、Fragment、Service处于活动状态时，它才会通知组件数据发生变化。<code>LiveData</code>是一个抽象类，其继承关系如下：</p>","more":"<p><img src=\"/public/img/Android/livedata.png\"></p>\n<h4 id=\"LiveData的优势\"><a href=\"#LiveData的优势\" class=\"headerlink\" title=\"LiveData的优势\"></a>LiveData的优势</h4><ul>\n<li><p>保证UI界面与数据相匹配</p>\n</li>\n<li><p>无内存泄漏</p>\n<p>  观察者绑定至<code>Lifecycle</code>，当观察者的生命周期结束后，其会自动清理</p>\n</li>\n<li><p>不会由于Activity stop而发生崩溃</p>\n<p>  如果观察者的生命周期进入inactive状态，那么其将不会收到LiveData的数据</p>\n</li>\n<li><p>合理的数据配置</p>\n<p>  如果Activity和Fragment由于屏幕旋转重建导致页面配置发生变化，则可以通过LiveData获取到最新数据 </p>\n</li>\n<li><p>数据共享</p>\n<p>  可以使用继承自Livedata的单例类，定义系统所需要的数据，并在整个App中进行共享。</p>\n</li>\n</ul>\n<h3 id=\"在具有生命周期的对象中使用LiveData\"><a href=\"#在具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在具有生命周期的对象中使用LiveData\"></a>在具有生命周期的对象中使用LiveData</h3><h4 id=\"定义被观察者\"><a href=\"#定义被观察者\" class=\"headerlink\" title=\"定义被观察者\"></a>定义被观察者</h4><p>在定义被观察者对象时通常使用<code>MutableLiveData</code>类，在Activity中定义一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">MutableLiveData&lt;String&gt; mutableLiveData=<span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"注册观察者：\"><a href=\"#注册观察者：\" class=\"headerlink\" title=\"注册观察者：\"></a>注册观察者：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    mutableLiveData.observe(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">            Log.i(<span class=\"string\">&quot;输出数据：&quot;</span>,s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>被观察者<code>mutableLiveData</code>的数据修改有两种方式：<code>setValue(T value)</code>和<code>postValue(T value) </code>。当被观察者数据在UI主线程中进行修改时，使用<code>setValue(T value)</code>，当被观察者在子线程中使用时，使用<code>postValue(T value) </code>；</p>\n<h4 id=\"通过setValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过setValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过setValue(T value)修改被观察者并通知观察者\"></a>通过<code>setValue(T value)</code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableLiveData.setValue(&quot;TEST&quot;);</span><br></pre></td></tr></table></figure>\n<p><code>setValue(T value)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;setValue&quot;</span>); <span class=\"comment\">//用于判断是否在主线程，否则抛出异常</span></span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);  <span class=\"comment\">//用于数据分发通知观察者</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>setValue(T value)</code>中调用<code>dispatchingValue(null)</code>，用于通知观察者。</p>\n<p><code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//参数ObserverWrapper是每一个观察者的封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"comment\">//遍历所有的观察者，并进行通知</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//considerNotify用于通知观察者</span></span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>dispatchingValue(@Nullable ObserverWrapper initiator)</code>方法中调用<code>considerNotify(ObserverWrapper observer)</code>通知观察者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"通过postValue-T-value-修改被观察者并通知观察者\"><a href=\"#通过postValue-T-value-修改被观察者并通知观察者\" class=\"headerlink\" title=\"通过postValue(T value) 修改被观察者并通知观察者\"></a>通过<code>postValue(T value) </code>修改被观察者并通知观察者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;TEST&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>postValue(T value) </code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</span><br><span class=\"line\">        postTask = mPendingData == NOT_SET;</span><br><span class=\"line\">        mPendingData = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//postToMainThread将任务放入主线程中进行，即mPostValueRunnable将会在主线程执行</span></span><br><span class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mPostValueRunnable</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"comment\">//依然是调用setValue对数据进行修改</span></span><br><span class=\"line\">        setValue((T) newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"在不具有生命周期的对象中使用LiveData\"><a href=\"#在不具有生命周期的对象中使用LiveData\" class=\"headerlink\" title=\"在不具有生命周期的对象中使用LiveData\"></a>在不具有生命周期的对象中使用LiveData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestLiveDataBean &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MutableLiveData&lt;String&gt; mutableLiveData &#x3D; new MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Observer&lt;String&gt; observer;</span><br><span class=\"line\"></span><br><span class=\"line\">    public TestLiveDataBean() &#123;</span><br><span class=\"line\">        observer &#x3D; new Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onChanged(String s) &#123;</span><br><span class=\"line\">                LogUtils.printInfo(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F;添加观察者</span><br><span class=\"line\">        mutableLiveData.observeForever(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setValue() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;无论setValue是否在UI主线程中，都可以用postValue</span><br><span class=\"line\">        mutableLiveData.postValue(&quot;测试&quot;);</span><br><span class=\"line\">        &#x2F;&#x2F;当在子线程中调用setValue报错</span><br><span class=\"line\">        &#x2F;&#x2F;mutableLiveData.setValue(&quot;测试&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public void removeObserver() &#123;</span><br><span class=\"line\">        mutableLiveData.removeObserver(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>observeForever()</code>与<code>removeOberver()</code>方法需要成对进行使用，通过<code>observeForever()</code>方法添加观察者，该方法只能在主线程中调用;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;observeForever&quot;</span>);</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing <span class=\"keyword\">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Cannot add the same observer&quot;</span></span><br><span class=\"line\">                + <span class=\"string\">&quot; with different lifecycles&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>观察者使用完毕后，需要通过<code>removeOberver()</code>方法，将观察者从观察者队列中移除，该方法只能在主线程中进行调用</p>\n<p><code>removeObserver(@NonNull final Observer&lt;? super T&gt; observer)</code>源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">&quot;removeObserver&quot;</span>);</span><br><span class=\"line\">    ObserverWrapper removed = mObservers.remove(observer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (removed == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    removed.detachObserver();</span><br><span class=\"line\">    removed.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"MediatorLiveData介绍\"><a href=\"#MediatorLiveData介绍\" class=\"headerlink\" title=\"MediatorLiveData介绍\"></a>MediatorLiveData介绍</h3><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，可以将<code>LiveData</code>的数据源合并至一起；当任一<code>LiveData</code>数据源的数据发生改变后，都会触发<code>MediatorLiveData</code>的观察者。</p>\n<h3 id=\"继承LiveData进行数据共享\"><a href=\"#继承LiveData进行数据共享\" class=\"headerlink\" title=\"继承LiveData进行数据共享\"></a>继承LiveData进行数据共享</h3>"},{"title":"Databinding点击事件的实现","cover":"/cover/img27.jpg","toc":true,"description":"Databinding点击事件的几种实现方式","type":["Android"],"date":"2018-04-05T16:00:00.000Z","_content":"\n## Databinding点击事件的几种实现方式\n<!--more-->\n代码片段\n\n```\n    //BaseActivity中\n    public void click(View view){\n    }\n    \n    public void click1(){\n    }\n    \n    public void click2(int id){\n    }\n    \n    //xml文件中\n    <variable\n        name=\"activity\"\n        type=\".BaseActivity\" />\n    \n    <variable\n        name=\"user\"\n        type=\".User\" />\n    \n\n```\n\n### 1、@{activity.click}\n`click`函数带有参数\n\n```\n    <TextView\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"wrap_content\"\n         android:text=\"点击事件\"\n         android:onClick=\"@{activity.click}\"\n    />\n```\n\n### 2、@{()->activity.click()}\n`click`函数无参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click1()}\"\n    />\n```\n\n### 3、@{activity::click}\n`click`带参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{activity::click}\"\n    />\n```\n\n### 4、@{()->activity.click(user.id)}\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(user.id)}\"\n    />\n```\n\n### 5、@{()->activity.click(3)}\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(3)}\"\n    />\n```\n\n### 6、自定义View中DataBinding的点击事件\n\n\n\n### 7、在RecyclerView中的item添加点击事件\n\n```\n    // 按钮点击\n            holder.getBinding.getRoot().findViewById(R.id.btn_edit)\n            .setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    // todo\n                }\n            });\n\n```\n\n## DataBinding赋值操作\n\n方法一：\n\n\n\n\n\n## Databinding特殊用法\n```\n    <CheckBox\n        android:id=\"@+id/showName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n    <TextView\n        android:text=\"@{user.firstName}\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"@{showName.checked ? View.VISIBLE :             View.GONE}\"\n        />\n\n```\n\n## 注意事项\n\n**在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误**\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/DataBinding的使用.md","raw":"---\ntitle: Databinding点击事件的实现\ncover: /cover/img27.jpg\ntoc: true\ndescription: Databinding点击事件的几种实现方式\ncategories: Android\ntype: [Android]\ndate: 2018/04/06\n\n---\n\n## Databinding点击事件的几种实现方式\n<!--more-->\n代码片段\n\n```\n    //BaseActivity中\n    public void click(View view){\n    }\n    \n    public void click1(){\n    }\n    \n    public void click2(int id){\n    }\n    \n    //xml文件中\n    <variable\n        name=\"activity\"\n        type=\".BaseActivity\" />\n    \n    <variable\n        name=\"user\"\n        type=\".User\" />\n    \n\n```\n\n### 1、@{activity.click}\n`click`函数带有参数\n\n```\n    <TextView\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"wrap_content\"\n         android:text=\"点击事件\"\n         android:onClick=\"@{activity.click}\"\n    />\n```\n\n### 2、@{()->activity.click()}\n`click`函数无参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click1()}\"\n    />\n```\n\n### 3、@{activity::click}\n`click`带参数\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{activity::click}\"\n    />\n```\n\n### 4、@{()->activity.click(user.id)}\n\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(user.id)}\"\n    />\n```\n\n### 5、@{()->activity.click(3)}\n```\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"点击事件\"\n        android:onClick=\"@{()->activity.click2(3)}\"\n    />\n```\n\n### 6、自定义View中DataBinding的点击事件\n\n\n\n### 7、在RecyclerView中的item添加点击事件\n\n```\n    // 按钮点击\n            holder.getBinding.getRoot().findViewById(R.id.btn_edit)\n            .setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    // todo\n                }\n            });\n\n```\n\n## DataBinding赋值操作\n\n方法一：\n\n\n\n\n\n## Databinding特殊用法\n```\n    <CheckBox\n        android:id=\"@+id/showName\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/>\n    <TextView\n        android:text=\"@{user.firstName}\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"@{showName.checked ? View.VISIBLE :             View.GONE}\"\n        />\n\n```\n\n## 注意事项\n\n**在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误**\n\n\n\n\n\n\n","slug":"Android/框架/AAC/DataBinding的使用","published":1,"updated":"2021-01-05T12:14:26.202Z","_id":"ckjju0m2g009120ua0ix32016","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Databinding点击事件的几种实现方式\"><a href=\"#Databinding点击事件的几种实现方式\" class=\"headerlink\" title=\"Databinding点击事件的几种实现方式\"></a>Databinding点击事件的几种实现方式</h2><a id=\"more\"></a>\n<p>代码片段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;BaseActivity中</span><br><span class=\"line\">public void click(View view)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click1()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click2(int id)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;xml文件中</span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;activity&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.BaseActivity&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;user&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.User&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1、-activity-click\"><a href=\"#1、-activity-click\" class=\"headerlink\" title=\"1、@{activity.click}\"></a>1、@{activity.click}</h3><p><code>click</code>函数带有参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">     android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">     android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">     android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">     android:onClick&#x3D;&quot;@&#123;activity.click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、-gt-activity-click\"><a href=\"#2、-gt-activity-click\" class=\"headerlink\" title=\"2、@{()-&gt;activity.click()}\"></a>2、@{()-&gt;activity.click()}</h3><p><code>click</code>函数无参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click1()&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、-activity-click\"><a href=\"#3、-activity-click\" class=\"headerlink\" title=\"3、@{activity::click}\"></a>3、@{activity::click}</h3><p><code>click</code>带参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;activity::click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、-gt-activity-click-user-id\"><a href=\"#4、-gt-activity-click-user-id\" class=\"headerlink\" title=\"4、@{()-&gt;activity.click(user.id)}\"></a>4、@{()-&gt;activity.click(user.id)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(user.id)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、-gt-activity-click-3\"><a href=\"#5、-gt-activity-click-3\" class=\"headerlink\" title=\"5、@{()-&gt;activity.click(3)}\"></a>5、@{()-&gt;activity.click(3)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(3)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、自定义View中DataBinding的点击事件\"><a href=\"#6、自定义View中DataBinding的点击事件\" class=\"headerlink\" title=\"6、自定义View中DataBinding的点击事件\"></a>6、自定义View中DataBinding的点击事件</h3><h3 id=\"7、在RecyclerView中的item添加点击事件\"><a href=\"#7、在RecyclerView中的item添加点击事件\" class=\"headerlink\" title=\"7、在RecyclerView中的item添加点击事件\"></a>7、在RecyclerView中的item添加点击事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 按钮点击</span><br><span class=\"line\">        holder.getBinding.getRoot().findViewById(R.id.btn_edit)</span><br><span class=\"line\">        .setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; todo</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"DataBinding赋值操作\"><a href=\"#DataBinding赋值操作\" class=\"headerlink\" title=\"DataBinding赋值操作\"></a>DataBinding赋值操作</h2><p>方法一：</p>\n<h2 id=\"Databinding特殊用法\"><a href=\"#Databinding特殊用法\" class=\"headerlink\" title=\"Databinding特殊用法\"></a>Databinding特殊用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CheckBox</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;showName&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility&#x3D;&quot;@&#123;showName.checked ? View.VISIBLE :             View.GONE&#125;&quot;</span><br><span class=\"line\">    &#x2F;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误</strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Databinding点击事件的几种实现方式\"><a href=\"#Databinding点击事件的几种实现方式\" class=\"headerlink\" title=\"Databinding点击事件的几种实现方式\"></a>Databinding点击事件的几种实现方式</h2>","more":"<p>代码片段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;BaseActivity中</span><br><span class=\"line\">public void click(View view)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click1()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void click2(int id)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;xml文件中</span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;activity&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.BaseActivity&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable</span><br><span class=\"line\">    name&#x3D;&quot;user&quot;</span><br><span class=\"line\">    type&#x3D;&quot;.User&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1、-activity-click\"><a href=\"#1、-activity-click\" class=\"headerlink\" title=\"1、@{activity.click}\"></a>1、@{activity.click}</h3><p><code>click</code>函数带有参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">     android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">     android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">     android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">     android:onClick&#x3D;&quot;@&#123;activity.click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、-gt-activity-click\"><a href=\"#2、-gt-activity-click\" class=\"headerlink\" title=\"2、@{()-&gt;activity.click()}\"></a>2、@{()-&gt;activity.click()}</h3><p><code>click</code>函数无参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click1()&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3、-activity-click\"><a href=\"#3、-activity-click\" class=\"headerlink\" title=\"3、@{activity::click}\"></a>3、@{activity::click}</h3><p><code>click</code>带参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;activity::click&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4、-gt-activity-click-user-id\"><a href=\"#4、-gt-activity-click-user-id\" class=\"headerlink\" title=\"4、@{()-&gt;activity.click(user.id)}\"></a>4、@{()-&gt;activity.click(user.id)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(user.id)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5、-gt-activity-click-3\"><a href=\"#5、-gt-activity-click-3\" class=\"headerlink\" title=\"5、@{()-&gt;activity.click(3)}\"></a>5、@{()-&gt;activity.click(3)}</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:text&#x3D;&quot;点击事件&quot;</span><br><span class=\"line\">    android:onClick&#x3D;&quot;@&#123;()-&gt;activity.click2(3)&#125;&quot;</span><br><span class=\"line\">&#x2F;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、自定义View中DataBinding的点击事件\"><a href=\"#6、自定义View中DataBinding的点击事件\" class=\"headerlink\" title=\"6、自定义View中DataBinding的点击事件\"></a>6、自定义View中DataBinding的点击事件</h3><h3 id=\"7、在RecyclerView中的item添加点击事件\"><a href=\"#7、在RecyclerView中的item添加点击事件\" class=\"headerlink\" title=\"7、在RecyclerView中的item添加点击事件\"></a>7、在RecyclerView中的item添加点击事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 按钮点击</span><br><span class=\"line\">        holder.getBinding.getRoot().findViewById(R.id.btn_edit)</span><br><span class=\"line\">        .setOnClickListener(new View.OnClickListener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onClick(View view) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; todo</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"DataBinding赋值操作\"><a href=\"#DataBinding赋值操作\" class=\"headerlink\" title=\"DataBinding赋值操作\"></a>DataBinding赋值操作</h2><p>方法一：</p>\n<h2 id=\"Databinding特殊用法\"><a href=\"#Databinding特殊用法\" class=\"headerlink\" title=\"Databinding特殊用法\"></a>Databinding特殊用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;CheckBox</span><br><span class=\"line\">    android:id&#x3D;&quot;@+id&#x2F;showName&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:text&#x3D;&quot;@&#123;user.firstName&#125;&quot;</span><br><span class=\"line\">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class=\"line\">    android:visibility&#x3D;&quot;@&#123;showName.checked ? View.VISIBLE :             View.GONE&#125;&quot;</span><br><span class=\"line\">    &#x2F;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>在Databinding使用的过程中，布局文件需要按照规范来写，类的报名应全部为小写，否则会报出错误</strong></p>"},{"title":"使用框架组件Room和Lifecycle来创建应用","cover":"/cover/img28.jpg","toc":true,"description":"使用框架组件Room和Lifecycle来创建应用","type":["Android"],"date":"2018-12-19T16:00:00.000Z","_content":"\n# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n<!--more-->\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","source":"_posts/Android/框架/AAC/Lifecycle和Room的使用.md","raw":"---\ntitle: 使用框架组件Room和Lifecycle来创建应用\ncover: /cover/img28.jpg\ntoc: true\ndescription: 使用框架组件Room和Lifecycle来创建应用\ncategories: Android\ntype: [Android]\ndate: 2018/12/20\n\n---\n\n# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n<!--more-->\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","slug":"Android/框架/AAC/Lifecycle和Room的使用","published":1,"updated":"2021-01-05T12:14:28.069Z","_id":"ckjju0m2h009420uacqhyejcf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity(tableName = &quot;word_table&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo(name = &quot;word&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span></span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase &#123;&#125;</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = &#123;Word.class&#125;, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图~~~</p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao = dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao = db.wordDao();</span><br><span class=\"line\">       mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao = dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity(tableName = &quot;word_table&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo(name = &quot;word&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span></span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase &#123;&#125;</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = &#123;Word.class&#125;, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图~~~</p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao = dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao = db.wordDao();</span><br><span class=\"line\">       mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao = dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>"},{"title":"Android框架组件paging+room的使用","cover":"/cover/img29.jpg","toc":true,"description":"Android框架组件paging+room的使用","type":["Android"],"date":"2018-12-04T16:00:00.000Z","_content":"\n# Android框架组件paging+room的使用\n\n## 简介：\n\n### DataSource\n\nDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，\n<!--more-->\n\n创建一个`PagedList`被观察者的对象，需要将一个`DataSource.Factory`的实例传递给`LivePagedListBuilder`对象。一个DataSource对象为单一的`PagedList`加载pages。当数据更新时，工厂类会创建一个`PagedSource`的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供`DataSource.Factory`对象，或者可以自己创建`DataSource.Factory`\n\nRoom持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：\n\n```java\n@Query(\"SELECT * FROM COUNTRIES\")\npublic abstract DataSource.Factory<Integer,Country> getCountries();\n```\n\n### PagedList\n\nPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。\n\n### PagedListAdapter\n\nPagedListAdapter是一个`RecyclerView.Adapter`用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？\n\n## 将架构组件添加到项目中\n\n在build.gradle中添加下面的依赖\n\n```markup\n    //recyclerView\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n\n    // ViewModel and LiveData\n    implementation \"android.arch.lifecycle:extensions:1.1.1\"\n    annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"\n\n   // Room\n    implementation \"android.arch.persistence.room:runtime:1.1.1\"\n    annotationProcessor \"android.arch.persistence.room:compiler:1.1.1\"\n\n    // Paging\n    implementation \"android.arch.paging:runtime:1.0.1\"\n```\n\n## 创建DataSource\n\n### 创建实体\n\n### 创建Dao层\n\nDataSource.Factory\\(在Room中实现\\)创建\n\n### 创建数据库\n\n### 创建ViewModel\n\nLivePagedListBuilder会使用\n\nLivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。\n\n创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：\n\n* setPageSize\\(int\\)：\n* setPrefetchDistance\\(int\\)：\n* setInitialLoadSizeHint\\(int\\)：设置页面中第一次显示的数量\n* setEnablePlaceholders\\(boolean\\) ：\n\n在`onCreate`方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。\n\n## 创建Adapter\n\n使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用`DiffCallback`来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：\n\n* areItemsTheSame:判断是否指向了同一个数据元素。\n* areContentsTheSame:判断\n\n","source":"_posts/Android/框架/AAC/Paging和Room使用.md","raw":"---\ntitle: Android框架组件paging+room的使用\ncover: /cover/img29.jpg\ntoc: true\ndescription: Android框架组件paging+room的使用\ncategories: Android\ntype: [Android]\ndate: 2018/12/05\n\n---\n\n# Android框架组件paging+room的使用\n\n## 简介：\n\n### DataSource\n\nDataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，\n<!--more-->\n\n创建一个`PagedList`被观察者的对象，需要将一个`DataSource.Factory`的实例传递给`LivePagedListBuilder`对象。一个DataSource对象为单一的`PagedList`加载pages。当数据更新时，工厂类会创建一个`PagedSource`的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供`DataSource.Factory`对象，或者可以自己创建`DataSource.Factory`\n\nRoom持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：\n\n```java\n@Query(\"SELECT * FROM COUNTRIES\")\npublic abstract DataSource.Factory<Integer,Country> getCountries();\n```\n\n### PagedList\n\nPagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。\n\n### PagedListAdapter\n\nPagedListAdapter是一个`RecyclerView.Adapter`用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？\n\n## 将架构组件添加到项目中\n\n在build.gradle中添加下面的依赖\n\n```markup\n    //recyclerView\n    implementation 'com.android.support:recyclerview-v7:27.1.0'\n\n    // ViewModel and LiveData\n    implementation \"android.arch.lifecycle:extensions:1.1.1\"\n    annotationProcessor \"android.arch.lifecycle:compiler:1.1.1\"\n\n   // Room\n    implementation \"android.arch.persistence.room:runtime:1.1.1\"\n    annotationProcessor \"android.arch.persistence.room:compiler:1.1.1\"\n\n    // Paging\n    implementation \"android.arch.paging:runtime:1.0.1\"\n```\n\n## 创建DataSource\n\n### 创建实体\n\n### 创建Dao层\n\nDataSource.Factory\\(在Room中实现\\)创建\n\n### 创建数据库\n\n### 创建ViewModel\n\nLivePagedListBuilder会使用\n\nLivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。\n\n创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：\n\n* setPageSize\\(int\\)：\n* setPrefetchDistance\\(int\\)：\n* setInitialLoadSizeHint\\(int\\)：设置页面中第一次显示的数量\n* setEnablePlaceholders\\(boolean\\) ：\n\n在`onCreate`方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。\n\n## 创建Adapter\n\n使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用`DiffCallback`来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：\n\n* areItemsTheSame:判断是否指向了同一个数据元素。\n* areContentsTheSame:判断\n\n","slug":"Android/框架/AAC/Paging和Room使用","published":1,"updated":"2021-01-05T12:14:28.976Z","_id":"ckjju0m2h009720uad5g67ysx","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Android框架组件paging-room的使用\"><a href=\"#Android框架组件paging-room的使用\" class=\"headerlink\" title=\"Android框架组件paging+room的使用\"></a>Android框架组件paging+room的使用</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><h3 id=\"DataSource\"><a href=\"#DataSource\" class=\"headerlink\" title=\"DataSource\"></a>DataSource</h3><p>DataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，</p>\n<a id=\"more\"></a>\n\n<p>创建一个<code>PagedList</code>被观察者的对象，需要将一个<code>DataSource.Factory</code>的实例传递给<code>LivePagedListBuilder</code>对象。一个DataSource对象为单一的<code>PagedList</code>加载pages。当数据更新时，工厂类会创建一个<code>PagedSource</code>的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供<code>DataSource.Factory</code>对象，或者可以自己创建<code>DataSource.Factory</code></p>\n<p>Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT * FROM COUNTRIES&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DataSource.<span class=\"function\">Factory&lt;Integer,Country&gt; <span class=\"title\">getCountries</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"PagedList\"><a href=\"#PagedList\" class=\"headerlink\" title=\"PagedList\"></a>PagedList</h3><p>PagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。</p>\n<h3 id=\"PagedListAdapter\"><a href=\"#PagedListAdapter\" class=\"headerlink\" title=\"PagedListAdapter\"></a>PagedListAdapter</h3><p>PagedListAdapter是一个<code>RecyclerView.Adapter</code>用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？</p>\n<h2 id=\"将架构组件添加到项目中\"><a href=\"#将架构组件添加到项目中\" class=\"headerlink\" title=\"将架构组件添加到项目中\"></a>将架构组件添加到项目中</h2><p>在build.gradle中添加下面的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;recyclerView</span><br><span class=\"line\"> implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; ViewModel and LiveData</span><br><span class=\"line\"> implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Room</span><br><span class=\"line\"> implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; Paging</span><br><span class=\"line\"> implementation &quot;android.arch.paging:runtime:1.0.1&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建DataSource\"><a href=\"#创建DataSource\" class=\"headerlink\" title=\"创建DataSource\"></a>创建DataSource</h2><h3 id=\"创建实体\"><a href=\"#创建实体\" class=\"headerlink\" title=\"创建实体\"></a>创建实体</h3><h3 id=\"创建Dao层\"><a href=\"#创建Dao层\" class=\"headerlink\" title=\"创建Dao层\"></a>创建Dao层</h3><p>DataSource.Factory(在Room中实现)创建</p>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h3 id=\"创建ViewModel\"><a href=\"#创建ViewModel\" class=\"headerlink\" title=\"创建ViewModel\"></a>创建ViewModel</h3><p>LivePagedListBuilder会使用</p>\n<p>LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。</p>\n<p>创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：</p>\n<ul>\n<li>setPageSize(int)：</li>\n<li>setPrefetchDistance(int)：</li>\n<li>setInitialLoadSizeHint(int)：设置页面中第一次显示的数量</li>\n<li>setEnablePlaceholders(boolean) ：</li>\n</ul>\n<p>在<code>onCreate</code>方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。</p>\n<h2 id=\"创建Adapter\"><a href=\"#创建Adapter\" class=\"headerlink\" title=\"创建Adapter\"></a>创建Adapter</h2><p>使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用<code>DiffCallback</code>来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：</p>\n<ul>\n<li>areItemsTheSame:判断是否指向了同一个数据元素。</li>\n<li>areContentsTheSame:判断</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android框架组件paging-room的使用\"><a href=\"#Android框架组件paging-room的使用\" class=\"headerlink\" title=\"Android框架组件paging+room的使用\"></a>Android框架组件paging+room的使用</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><h3 id=\"DataSource\"><a href=\"#DataSource\" class=\"headerlink\" title=\"DataSource\"></a>DataSource</h3><p>DataSource持有数据库的数据或者来自于网络的数据提供给PagedLists使用，PagedListed由LivePagedListBuilder产生，具有多个可以进行选择的参数。PagedList会持有DataSource的一个副本，</p>","more":"<p>创建一个<code>PagedList</code>被观察者的对象，需要将一个<code>DataSource.Factory</code>的实例传递给<code>LivePagedListBuilder</code>对象。一个DataSource对象为单一的<code>PagedList</code>加载pages。当数据更新时，工厂类会创建一个<code>PagedSource</code>的实例，如：数据库的表更新或者网络数据更新。Room持久化数据层可以提供<code>DataSource.Factory</code>对象，或者可以自己创建<code>DataSource.Factory</code></p>\n<p>Room持久化数据层提供与Paging library相关的dataSource相关的原生支持。对于通过Room从数据库中查询的数据，Room从Dao中返回一个DataSource.Factory，并将DataSource的实现类返回给用户。相应代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT * FROM COUNTRIES&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> DataSource.<span class=\"function\">Factory&lt;Integer,Country&gt; <span class=\"title\">getCountries</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"PagedList\"><a href=\"#PagedList\" class=\"headerlink\" title=\"PagedList\"></a>PagedList</h3><p>PagedList是paging库的一个重要组成类，可以使得RecyclerView从DataSource中加载大量的数据。PagedList采用异步的方式将数据加载在界面中。</p>\n<h3 id=\"PagedListAdapter\"><a href=\"#PagedListAdapter\" class=\"headerlink\" title=\"PagedListAdapter\"></a>PagedListAdapter</h3><p>PagedListAdapter是一个<code>RecyclerView.Adapter</code>用于表示来自PagedList的数据。PagedListAdapter listens to PagedList loading callbacks as pages are loaded, and uses DiffUtil to compute fine grained updates as new PagedLists are received and then display the list to user in your UI with a recyclerView. ？？？</p>\n<h2 id=\"将架构组件添加到项目中\"><a href=\"#将架构组件添加到项目中\" class=\"headerlink\" title=\"将架构组件添加到项目中\"></a>将架构组件添加到项目中</h2><p>在build.gradle中添加下面的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &#x2F;&#x2F;recyclerView</span><br><span class=\"line\"> implementation &#39;com.android.support:recyclerview-v7:27.1.0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; ViewModel and LiveData</span><br><span class=\"line\"> implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.lifecycle:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Room</span><br><span class=\"line\"> implementation &quot;android.arch.persistence.room:runtime:1.1.1&quot;</span><br><span class=\"line\"> annotationProcessor &quot;android.arch.persistence.room:compiler:1.1.1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#x2F;&#x2F; Paging</span><br><span class=\"line\"> implementation &quot;android.arch.paging:runtime:1.0.1&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建DataSource\"><a href=\"#创建DataSource\" class=\"headerlink\" title=\"创建DataSource\"></a>创建DataSource</h2><h3 id=\"创建实体\"><a href=\"#创建实体\" class=\"headerlink\" title=\"创建实体\"></a>创建实体</h3><h3 id=\"创建Dao层\"><a href=\"#创建Dao层\" class=\"headerlink\" title=\"创建Dao层\"></a>创建Dao层</h3><p>DataSource.Factory(在Room中实现)创建</p>\n<h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><h3 id=\"创建ViewModel\"><a href=\"#创建ViewModel\" class=\"headerlink\" title=\"创建ViewModel\"></a>创建ViewModel</h3><p>LivePagedListBuilder会使用</p>\n<p>LivePagedListBuilder需要创建PageList对象，当一个新的PagedList被创建出，Livedata会将新的PagedList传递到ViewModel中，相应的数据也将传送给UI，当UI观察到PagedList发生变化，会使用它的PagedListAdapter更新RecyclerView的界面，显示出PagedList中的数据。</p>\n<p>创建和配置LiveData，需要使用LivePagedBuilder以及DataSource.Factory,并对PagedList的部分属性进行设置，主要包括以下几个方法：</p>\n<ul>\n<li>setPageSize(int)：</li>\n<li>setPrefetchDistance(int)：</li>\n<li>setInitialLoadSizeHint(int)：设置页面中第一次显示的数量</li>\n<li>setEnablePlaceholders(boolean) ：</li>\n</ul>\n<p>在<code>onCreate</code>方法中，需要对ViewModel进行实例化，在ViewModel中LiveData类发送新的PagedList到ViewModel, 再相应地传递到UI中，UI观察到PagedList发生改变，会调用PagedListAdapter更新显示在RecyclerView中的数据。</p>\n<h2 id=\"创建Adapter\"><a href=\"#创建Adapter\" class=\"headerlink\" title=\"创建Adapter\"></a>创建Adapter</h2><p>使用PagedAdapter将PagedList数据与RecyclerView进行绑定，使用<code>DiffCallback</code>来帮助PagedAdapter区分不同的适配元素，在实现DiffCallback类的时候需要重写两个方法：</p>\n<ul>\n<li>areItemsTheSame:判断是否指向了同一个数据元素。</li>\n<li>areContentsTheSame:判断</li>\n</ul>"},{"title":"使用框架组件Room和Lifecycle来创建应用","cover":"/cover/img30.jpg","toc":true,"description":"使用框架组件Room和Lifecycle来创建应用","type":["Android"],"date":"2018-11-18T16:00:00.000Z","_content":"\n# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n<!--more-->\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","source":"_posts/Android/框架/AAC/Room和Lifecycle构建程序.md","raw":"---\ntitle: 使用框架组件Room和Lifecycle来创建应用\ncover: /cover/img30.jpg\ntoc: true\ndescription: 使用框架组件Room和Lifecycle来创建应用\ncategories: Android\ntype: [Android]\ndate: 2018/11/19\n\n---\n\n# 使用框架组件Room和Lifecycle来创建应用\n\n## 在build.gradle\\(Module:app\\)中添加依赖\n<!--more-->\n```markup\n//Room组件\nimplementation \"android.arch.persistence.room:runtime:$rootProject.roomVersion\"\nannotationProcessor \"android.arch.persistence.room:compiler:$rootProject.roomVersion\"\nandroidTestImplementation \"android.arch.persistence.room:testing:$rootProject.roomVersion\"\n\n//lifestyle组件\nimplementation \"android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion\"\nannotationProcessor \"android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion\"\n```\n\n## 创建一个Entity实体\n\n在应用中数据是words，每一个word都是一个实体，创建一个`Word`类，同时需要创建构造函数以及`getter`方法，只要这样Room才会实例化`Object`\n\n假装右图！！！！\n\n代码如下：\n\n```java\npublic class Word {\n\n   private String mWord;\n\n   public Word(@NonNull String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n要使得`Word`类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。\n\n* `@Entity(tableName = \"word_table\")`\n\n  每一个`@Entity`类代表数据表中的一个实体。\n\n* `@PrimaryKey`\n\n  每一个实体都需要一个主键，为了表示方便，在这里将每一个`word`自身作为其主键。\n\n* `@NonNull`\n\n  声明参数、域或者方法的返回值不为空。\n\n* `@ColumnInfo(name = \"word\")`\n\n  当需要指定与类中的成员变量不同的列名时使用。\n\n```java\n@Entity(tableName = \"word_table\")\npublic class Word {\n\n   @PrimaryKey\n   @NonNull\n   @ColumnInfo(name = \"word\")\n   private String mWord;\n\n   public Word(String word) {this.mWord = word;}\n\n   public String getWord(){return this.mWord;}\n}\n```\n\n## 创建Dao\n\n在`Dao`\\(data access object\\)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，**在默认状态下，所有的查询语句都需要在单独的线程中运行**。Room使用`Dao`可以使得代码更加简洁。\n\n* 创建一个新的接口声明为`WordDao`\n* 使用功注解`@Dao`来定义该类为Room的一个Dao类\n* 声明插入一个word的方法`void insert(Word word)`\n* 为该方法添加`@Insert`注解，**在方法中不需要提供任何sql语句**（还有`@Delete`以及`@Update`等注解）。\n* 声明一个删除所有words的方法`void deleteAll();`\n* 使用`@Query`注解，用于查询以及其他操作，`@Query(\"DELETE FROM word_table\")`。\n* 创建一个获取所有单词的方法，`getAllWords();`返回值为List,通过注解的方式为此方法添加SQL查询语句`@Query(\"SELECT * from word_table ORDER BY word ASC\")`\n\n```text\n@Dao\npublic interface WordDao {\n\n   @Insert\n   void insert(Word word);\n\n   @Query(\"DELETE FROM word_table\")\n   void deleteAll();\n\n   @Query(\"SELECT * from word_table ORDER BY word ASC\")\n   List<Word> getAllWords();\n}\n```\n\n## LiveData类的使用\n\n当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。\n\n`LiveData`是一个数据生命周期观察库\\(lifecycle\\_library\\)，为了解决上面的问题，使用`LiveData`类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新`LiveData`\n\n> 当你需要离开Room独立使用`LiveData`时，你需要更新数据，因为`LiveData`方法没有公有的方法来更新已经存储的数据。\n\n在`WordDao`中，将`getAllWords`的返回值包裹在`LiveData`中\n\n```java\n @Query(\"SELECT * from word_table ORDER BY word ASC\")\n LiveData<List<Word>> getAllWords();\n```\n\n## 添加Room数据库\n\n### Room数据库层介绍\n\nRoom是在SQLite数据库上面的数据库层，Room可以处理之前需要在`SQLiteOpenHelper`中处理的单调的工作。\n\n* Room使用Dao来查询数据库。\n* 在默认状态下，Room不可以在主线程中操作数据库，`LiveData`通过自动的方式在后台进程中实现异步查询。\n* Room在编译的时候检查数据库的Sql语句\n* Room类需要时抽象类并继承自RoomDatabase\n* Room数据库在整个App中需要以单例模式初始化。\n\n### 实现Room数据库\n\n1. 创建一个`public abstract`类继承自`RoomDatabase`，`public abstract class WordRoomDatabase extends RoomDatabase {}`\n2. 将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。`@Database(entities = {Word.class}, version = 1)`\n3. 定义与数据库操作相关的Dao，并使用抽象方法，代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n   public abstract WordDao wordDao();\n\n}\n```\n\n4.将`WordRoomDatabase`设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。\n\n代码如下：\n\n```java\nprivate static WordRoomDatabase INSTANCE;\n\npublic static WordRoomDatabase getDatabase(final Context context) {\n   if (INSTANCE == null) {\n       synchronized (WordRoomDatabase.class) {\n           if (INSTANCE == null) {\n               // Create database here\n           }\n       }\n   }\n   return INSTANCE;\n}\n```\n\n5.添加获取到数据库的代码\n\n代码如下：\n\n```java\nINSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n       WordRoomDatabase.class, \"word_database\")\n       .build();\n```\n\n完整代码如下：\n\n```java\n@Database(entities = {Word.class}, version = 1)\npublic abstract class WordRoomDatabase extends RoomDatabase {\n\n   public abstract WordDao wordDao();\n\n   private static WordRoomDatabase INSTANCE;\n\n\n   static WordRoomDatabase getDatabase(final Context context) {\n       if (INSTANCE == null) {\n           synchronized (WordRoomDatabase.class) {\n               if (INSTANCE == null) {\n                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                           WordRoomDatabase.class, \"word_database\")\n                           .build();                \n\n               }\n           }\n       }\n       return INSTANCE;\n   }\n\n}\n```\n\n## 创建一个Repository\n\n### Repository介绍\n\nRepository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，`Repository`类用于操作数据。\n\n假装有图~~~\n\nRepository用于管理查询\\(query\\)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。\n\n### 实现Repository\n\n1.创建一个名为`WordRepository`的公有类\n\n2.创建Dao类型的成员变量以及word列表\n\n```java\nprivate WordDao mWordDao;\nprivate LiveData<List<Word>> mAllWords;\n```\n\n3.添加构造函数，获得数据库的控制并初始化成员变量\n\n```java\nWordRepository(Application application) {\n    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n    mWordDao = db.wordDao();\n    mAllWords = mWordDao.getAllWords();\n}\n```\n\n4.添加`getAllWords()`方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的`LiveData`将会通知订阅者。\n\n```java\nLiveData<List<Word>> getAllWords() {\n   return mAllWords;\n}\n```\n\n5.封装`insert()`方法，`insert()`方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。\n\n```java\npublic void insert (Word word) {\n    new insertAsyncTask(mWordDao).execute(word);\n}\n```\n\n6.`insertAsyncTask`方法\n\n```text\nprivate static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n    private WordDao mAsyncTaskDao;\n\n    insertAsyncTask(WordDao dao) {\n        mAsyncTaskDao = dao;\n    }\n\n    @Override\n    protected Void doInBackground(final Word... params) {\n        mAsyncTaskDao.insert(params[0]);\n        return null;\n    }\n}\n```\n\n完整代码：\n\n```text\npublic class WordRepository {\n\n   private WordDao mWordDao;\n   private LiveData<List<Word>> mAllWords;\n\n   WordRepository(Application application) {\n       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);\n       mWordDao = db.wordDao();\n       mAllWords = mWordDao.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() {\n       return mAllWords;\n   }\n\n\n   public void insert (Word word) {\n       new insertAsyncTask(mWordDao).execute(word);\n   }\n\n   private static class insertAsyncTask extends AsyncTask<Word, Void, Void> {\n\n       private WordDao mAsyncTaskDao;\n\n       insertAsyncTask(WordDao dao) {\n           mAsyncTaskDao = dao;\n       }\n\n       @Override\n       protected Void doInBackground(final Word... params) {\n           mAsyncTaskDao.insert(params[0]);\n           return null;\n       }\n   }\n}\n```\n\n## 创建一个ViewModel\n\n`ViewModel`是用于向UI提供数据以及服务信息配置改变，`ViewModel`起着Repository与UI之间的交流中心的作用。可以使用`ViewModel`在fragment之间共享数据。`ViewModel`也是lifecycle library的一部分。\n\n`ViewModel`使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：`Activity`以及`Fragment`的主要作用是在屏幕中绘制UI，而`ViewModel`的作用是控制操作UI需要的所有的数据。\n\n在`ViewModel`中使用`LiveData`来表示那些UI显示过程中会发生改变的数据，使用`LiveData`主要有以下的优点：\n\n* 可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。\n* Repository以及UI通过`ViewModel`彻底分离开来，在`ViewModel`中不会调用数据库中的内容。\n\n### 实现ViewModel\n\n* 创建`WordViewModel`类，继承自`AndroidViewModel`\n\n```java\npublic class WordViewModel extends AndroidViewModel {}\n```\n\n* 创建Repository的成员变量\n\n  \\`\\`\\`java\n\n  private WordRepository mRepository;\n\n```text\n* 创建LiveData成员变量用于缓存word列表\n\n```java\n\n  private LiveData<List<Word>> mAllWords;\n```\n\n* 创建构造函数\n\n```java\n     public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n```\n\n* 创建`getter`方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。\n\n```text\n LiveData<List<Word>> getAllWords() { return mAllWords; }\n```\n\n* 创建`insert()`方法，用于调用Repostory中的`insert()`方法，这样随UI可以完全隐藏`insert()`方法的实现。\n\n`WordViewModel`类的完整实现方法如下：\n\n```java\npublic class WordViewModel extends AndroidViewModel {\n\n   private WordRepository mRepository;\n\n   private LiveData<List<Word>> mAllWords;\n\n   public WordViewModel (Application application) {\n       super(application);\n       mRepository = new WordRepository(application);\n       mAllWords = mRepository.getAllWords();\n   }\n\n   LiveData<List<Word>> getAllWords() { return mAllWords; }\n\n   public void insert(Word word) { mRepository.insert(word); }\n}\n```\n\n**注：不可以向**`ViewModel`**实例中传递**`Context`**参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。**\n\n**Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在**`ViewModel`**中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。**\n\n","slug":"Android/框架/AAC/Room和Lifecycle构建程序","published":1,"updated":"2021-01-05T12:14:29.526Z","_id":"ckjju0m2i009a20uahx9o1f4k","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity(tableName = &quot;word_table&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo(name = &quot;word&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span></span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase &#123;&#125;</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = &#123;Word.class&#125;, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图~~~</p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao = dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao = db.wordDao();</span><br><span class=\"line\">       mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao = dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用框架组件Room和Lifecycle来创建应用\"><a href=\"#使用框架组件Room和Lifecycle来创建应用\" class=\"headerlink\" title=\"使用框架组件Room和Lifecycle来创建应用\"></a>使用框架组件Room和Lifecycle来创建应用</h1><h2 id=\"在build-gradle-Module-app-中添加依赖\"><a href=\"#在build-gradle-Module-app-中添加依赖\" class=\"headerlink\" title=\"在build.gradle(Module:app)中添加依赖\"></a>在build.gradle(Module:app)中添加依赖</h2>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Room组件</span><br><span class=\"line\">implementation &quot;android.arch.persistence.room:runtime:$rootProject.roomVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.persistence.room:compiler:$rootProject.roomVersion&quot;</span><br><span class=\"line\">androidTestImplementation &quot;android.arch.persistence.room:testing:$rootProject.roomVersion&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;lifestyle组件</span><br><span class=\"line\">implementation &quot;android.arch.lifecycle:extensions:$rootProject.archLifecycleVersion&quot;</span><br><span class=\"line\">annotationProcessor &quot;android.arch.lifecycle:compiler:$rootProject.archLifecycleVersion&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Entity实体\"><a href=\"#创建一个Entity实体\" class=\"headerlink\" title=\"创建一个Entity实体\"></a>创建一个Entity实体</h2><p>在应用中数据是words，每一个word都是一个实体，创建一个<code>Word</code>类，同时需要创建构造函数以及<code>getter</code>方法，只要这样Room才会实例化<code>Object</code></p>\n<p>假装右图！！！！</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要使得<code>Word</code>类对Room数据库有意义，需要为其添加注解。注解定义了该类的每一部分与数据库中的实体的关系，Room通过注解的信息生成相应代码。</p>\n<ul>\n<li><p><code>@Entity(tableName = &quot;word_table&quot;)</code></p>\n<p>每一个<code>@Entity</code>类代表数据表中的一个实体。</p>\n</li>\n<li><p><code>@PrimaryKey</code></p>\n<p>每一个实体都需要一个主键，为了表示方便，在这里将每一个<code>word</code>自身作为其主键。</p>\n</li>\n<li><p><code>@NonNull</code></p>\n<p>声明参数、域或者方法的返回值不为空。</p>\n</li>\n<li><p><code>@ColumnInfo(name = &quot;word&quot;)</code></p>\n<p>当需要指定与类中的成员变量不同的列名时使用。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity(tableName = &quot;word_table&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Word</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PrimaryKey</span></span><br><span class=\"line\">   <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">   <span class=\"meta\">@ColumnInfo(name = &quot;word&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> String mWord;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Word</span><span class=\"params\">(String word)</span> </span>&#123;<span class=\"keyword\">this</span>.mWord = word;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWord</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mWord;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建Dao\"><a href=\"#创建Dao\" class=\"headerlink\" title=\"创建Dao\"></a>创建Dao</h2><p>在<code>Dao</code>(data access object)中，指定sql查询语句并将其与调用方法相联结。Dao需要为接口或者抽象类，<strong>在默认状态下，所有的查询语句都需要在单独的线程中运行</strong>。Room使用<code>Dao</code>可以使得代码更加简洁。</p>\n<ul>\n<li>创建一个新的接口声明为<code>WordDao</code></li>\n<li>使用功注解<code>@Dao</code>来定义该类为Room的一个Dao类</li>\n<li>声明插入一个word的方法<code>void insert(Word word)</code></li>\n<li>为该方法添加<code>@Insert</code>注解，<strong>在方法中不需要提供任何sql语句</strong>（还有<code>@Delete</code>以及<code>@Update</code>等注解）。</li>\n<li>声明一个删除所有words的方法<code>void deleteAll();</code></li>\n<li>使用<code>@Query</code>注解，用于查询以及其他操作，<code>@Query(&quot;DELETE FROM word_table&quot;)</code>。</li>\n<li>创建一个获取所有单词的方法，<code>getAllWords();</code>返回值为List,通过注解的方式为此方法添加SQL查询语句<code>@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</code></li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface WordDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   @Insert</span><br><span class=\"line\">   void insert(Word word);</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class=\"line\">   void deleteAll();</span><br><span class=\"line\"></span><br><span class=\"line\">   @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class=\"line\">   List&lt;Word&gt; getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LiveData类的使用\"><a href=\"#LiveData类的使用\" class=\"headerlink\" title=\"LiveData类的使用\"></a>LiveData类的使用</h2><p>当数据发生改变时，通常需要进行更新UI或者显示UI的操作，需要观察到数据的改变。通过复杂的组件观察到数据改变会很麻烦，在组件之间会有各种依赖关系的产生。</p>\n<p><code>LiveData</code>是一个数据生命周期观察库(lifecycle_library)，为了解决上面的问题，使用<code>LiveData</code>类型的数据返回值，当数据库更新时，Room会生成所有必要的代码来更新<code>LiveData</code></p>\n<blockquote>\n<p>当你需要离开Room独立使用<code>LiveData</code>时，你需要更新数据，因为<code>LiveData</code>方法没有公有的方法来更新已经存储的数据。</p>\n</blockquote>\n<p>在<code>WordDao</code>中，将<code>getAllWords</code>的返回值包裹在<code>LiveData</code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span></span><br><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords();</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加Room数据库\"><a href=\"#添加Room数据库\" class=\"headerlink\" title=\"添加Room数据库\"></a>添加Room数据库</h2><h3 id=\"Room数据库层介绍\"><a href=\"#Room数据库层介绍\" class=\"headerlink\" title=\"Room数据库层介绍\"></a>Room数据库层介绍</h3><p>Room是在SQLite数据库上面的数据库层，Room可以处理之前需要在<code>SQLiteOpenHelper</code>中处理的单调的工作。</p>\n<ul>\n<li>Room使用Dao来查询数据库。</li>\n<li>在默认状态下，Room不可以在主线程中操作数据库，<code>LiveData</code>通过自动的方式在后台进程中实现异步查询。</li>\n<li>Room在编译的时候检查数据库的Sql语句</li>\n<li>Room类需要时抽象类并继承自RoomDatabase</li>\n<li>Room数据库在整个App中需要以单例模式初始化。</li>\n</ul>\n<h3 id=\"实现Room数据库\"><a href=\"#实现Room数据库\" class=\"headerlink\" title=\"实现Room数据库\"></a>实现Room数据库</h3><ol>\n<li>创建一个<code>public abstract</code>类继承自<code>RoomDatabase</code>，<code>public abstract class WordRoomDatabase extends RoomDatabase &#123;&#125;</code></li>\n<li>将类使用注解为Room数据库，声明属于数据库的实体类并设置版本号，列出的实体类将在数据库中创建出相应的数据表。<code>@Database(entities = &#123;Word.class&#125;, version = 1)</code></li>\n<li>定义与数据库操作相关的Dao，并使用抽象方法，代码如下：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.将<code>WordRoomDatabase</code>设置为单例模式，防止多次实例化数据库同时出现同时打开的问题。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Create database here</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.添加获取到数据库的代码</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">       WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Database(entities = &#123;Word.class&#125;, version = 1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordRoomDatabase</span> <span class=\"keyword\">extends</span> <span class=\"title\">RoomDatabase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> WordDao <span class=\"title\">wordDao</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> WordRoomDatabase INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">static</span> WordRoomDatabase <span class=\"title\">getDatabase</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class=\"line\">                           WordRoomDatabase.class, <span class=\"string\">&quot;word_database&quot;</span>)</span><br><span class=\"line\">                           .build();                </span><br><span class=\"line\"></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个Repository\"><a href=\"#创建一个Repository\" class=\"headerlink\" title=\"创建一个Repository\"></a>创建一个Repository</h2><h3 id=\"Repository介绍\"><a href=\"#Repository介绍\" class=\"headerlink\" title=\"Repository介绍\"></a>Repository介绍</h3><p>Repository是一个抽象类用于获取到多种数据源中的数据，Repository不属于结构化组件库，推荐使用它，用于将代码组件分离，<code>Repository</code>类用于操作数据。</p>\n<p>假装有图~~~</p>\n<p>Repository用于管理查询(query)线程，可以使用多个后台线程。在大多数情况下，Repository实现的逻辑用于决定从网络中获取数据还是从本地缓存中获取。</p>\n<h3 id=\"实现Repository\"><a href=\"#实现Repository\" class=\"headerlink\" title=\"实现Repository\"></a>实现Repository</h3><p>1.创建一个名为<code>WordRepository</code>的公有类</p>\n<p>2.创建Dao类型的成员变量以及word列表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> WordDao mWordDao;</span><br><span class=\"line\"><span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<p>3.添加构造函数，获得数据库的控制并初始化成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WordRepository(Application application) &#123;</span><br><span class=\"line\">    WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">    mWordDao = db.wordDao();</span><br><span class=\"line\">    mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.添加<code>getAllWords()</code>方法，并使用进行封装，Room将所有的查询放置在独立的线程，当数据发生改变时，已经被订阅的<code>LiveData</code>将会通知订阅者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> mAllWords;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.封装<code>insert()</code>方法，<code>insert()</code>方法的调用需要在独立的非UI线程中进行，Room可以保证不会在主线程中进行耗时操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(Word word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6.<code>insertAsyncTask</code>方法</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">        mAsyncTaskDao = dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">        mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WordRepository &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   private WordDao mWordDao;</span><br><span class=\"line\">   private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   WordRepository(Application application) &#123;</span><br><span class=\"line\">       WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class=\"line\">       mWordDao = db.wordDao();</span><br><span class=\"line\">       mAllWords = mWordDao.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class=\"line\">       return mAllWords;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   public void insert (Word word) &#123;</span><br><span class=\"line\">       new insertAsyncTask(mWordDao).execute(word);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   private static class insertAsyncTask extends AsyncTask&lt;Word, Void, Void&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       private WordDao mAsyncTaskDao;</span><br><span class=\"line\"></span><br><span class=\"line\">       insertAsyncTask(WordDao dao) &#123;</span><br><span class=\"line\">           mAsyncTaskDao = dao;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       @Override</span><br><span class=\"line\">       protected Void doInBackground(final Word... params) &#123;</span><br><span class=\"line\">           mAsyncTaskDao.insert(params[0]);</span><br><span class=\"line\">           return null;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建一个ViewModel\"><a href=\"#创建一个ViewModel\" class=\"headerlink\" title=\"创建一个ViewModel\"></a>创建一个ViewModel</h2><p><code>ViewModel</code>是用于向UI提供数据以及服务信息配置改变，<code>ViewModel</code>起着Repository与UI之间的交流中心的作用。可以使用<code>ViewModel</code>在fragment之间共享数据。<code>ViewModel</code>也是lifecycle library的一部分。</p>\n<p><code>ViewModel</code>使用的是life-conscious的方式操作APP的UI数据，将UI从Activity以及Fragment类中分离出来，使得编码的过程更加符合以下原则：<code>Activity</code>以及<code>Fragment</code>的主要作用是在屏幕中绘制UI，而<code>ViewModel</code>的作用是控制操作UI需要的所有的数据。</p>\n<p>在<code>ViewModel</code>中使用<code>LiveData</code>来表示那些UI显示过程中会发生改变的数据，使用<code>LiveData</code>主要有以下的优点：</p>\n<ul>\n<li>可以使用为数据添加一个观察者（而不是轮询的方式），只有当数据确实发生改变的时候才更新UI。</li>\n<li>Repository以及UI通过<code>ViewModel</code>彻底分离开来，在<code>ViewModel</code>中不会调用数据库中的内容。</li>\n</ul>\n<h3 id=\"实现ViewModel\"><a href=\"#实现ViewModel\" class=\"headerlink\" title=\"实现ViewModel\"></a>实现ViewModel</h3><ul>\n<li>创建<code>WordViewModel</code>类，继承自<code>AndroidViewModel</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>创建Repository的成员变量</p>\n<p>```java</p>\n<p>private WordRepository mRepository;</p>\n</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 创建LiveData成员变量用于缓存word列表</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\">  private LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">    mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">    mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>getter</code>方法获取所有的word，对于UI来说数据的获取已经被完全隐藏。</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; return mAllWords; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建<code>insert()</code>方法，用于调用Repostory中的<code>insert()</code>方法，这样随UI可以完全隐藏<code>insert()</code>方法的实现。</li>\n</ul>\n<p><code>WordViewModel</code>类的完整实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">AndroidViewModel</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> WordRepository mRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordViewModel</span> <span class=\"params\">(Application application)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(application);</span><br><span class=\"line\">       mRepository = <span class=\"keyword\">new</span> WordRepository(application);</span><br><span class=\"line\">       mAllWords = mRepository.getAllWords();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123; <span class=\"keyword\">return</span> mAllWords; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Word word)</span> </span>&#123; mRepository.insert(word); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注：不可以向</strong><code>ViewModel</code><strong>实例中传递</strong><code>Context</code><strong>参数，也不可以在其实实例化Activity、Fragment或者View以及他们的context。</strong></p>\n<p><strong>Activity在设备进行旋转的时候，在ViewModel的生命周期中，它有可能会被创建或者被销毁多次。如果你在</strong><code>ViewModel</code><strong>中引用了Activity，当Activity被销毁的时候，你将会指向一个空的引用，会造成内存泄漏。</strong></p>"},{"title":"Room数据库","cover":"/cover/img31.jpg","toc":true,"description":"Room数据库","type":["Android"],"date":"2018-11-04T16:00:00.000Z","_content":"\n### 1、数据库在表中可以指定多个主键\n<!--more-->\n```java\n\n    @Entity(primaryKeys = {\"firstName\", \"lastName\"})\n    public class User{\n         \n         public String firstName;\n         public String lastName;\n         \n         \n         //使用Ignore使得该变量不生成表段名\n         \n         @Ignore\n         Bitmap bitmap;\n    }\n\n```\n如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns\n\n```\n    public class RemotePerson extends Person {\n        @PrimaryKey\n        public int id;\n\n        public boolean hasVpn;\n    }\n\n```\n\n### 2、Entity进行嵌套\n\n如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded\n\n```\n    public class Address {\n        public String street;\n        public String state;\n        public String city;\n    \n        @ColumnInfo(name = \"post_code\")\n        public int postCode;\n    }    \n\n    @Entity\n    public class Person{\n        @PrimaryKey\n        public int id;\n\n        public String firstName;\n\n        @Embedded\n        public Address address;\n    }\n\n```\n\n这样在Person表中有id,firstName,street,state,city,post_code等字段\n\n### 3、插入数据产生冲突时操作\n\n```\n    @Dao\n    public interface UserDao{\n        //插入如果冲突则替换    \n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        public void insertUser(User ... users);\n    \n    }\n\n```\n\n### 用于对数据表中某一列进行更新\n\n```\n     @Query(\"UPDATE item SET quantity = quantity + 1 WHERE id = :id\")\n     void updateQuantity(int id)\n     //item为表名\n\n```\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/Room数据库.md","raw":"---\ntitle: Room数据库\ncover: /cover/img31.jpg\ntoc: true\ndescription: Room数据库\ncategories: Android\ntype: [Android]\ndate: 2018/11/05\n\n---\n\n### 1、数据库在表中可以指定多个主键\n<!--more-->\n```java\n\n    @Entity(primaryKeys = {\"firstName\", \"lastName\"})\n    public class User{\n         \n         public String firstName;\n         public String lastName;\n         \n         \n         //使用Ignore使得该变量不生成表段名\n         \n         @Ignore\n         Bitmap bitmap;\n    }\n\n```\n如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns\n\n```\n    public class RemotePerson extends Person {\n        @PrimaryKey\n        public int id;\n\n        public boolean hasVpn;\n    }\n\n```\n\n### 2、Entity进行嵌套\n\n如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded\n\n```\n    public class Address {\n        public String street;\n        public String state;\n        public String city;\n    \n        @ColumnInfo(name = \"post_code\")\n        public int postCode;\n    }    \n\n    @Entity\n    public class Person{\n        @PrimaryKey\n        public int id;\n\n        public String firstName;\n\n        @Embedded\n        public Address address;\n    }\n\n```\n\n这样在Person表中有id,firstName,street,state,city,post_code等字段\n\n### 3、插入数据产生冲突时操作\n\n```\n    @Dao\n    public interface UserDao{\n        //插入如果冲突则替换    \n        @Insert(onConflict = OnConflictStrategy.REPLACE)\n        public void insertUser(User ... users);\n    \n    }\n\n```\n\n### 用于对数据表中某一列进行更新\n\n```\n     @Query(\"UPDATE item SET quantity = quantity + 1 WHERE id = :id\")\n     void updateQuantity(int id)\n     //item为表名\n\n```\n\n\n\n\n\n\n","slug":"Android/框架/AAC/Room数据库","published":1,"updated":"2021-01-05T12:14:30.058Z","_id":"ckjju0m2i009d20uady8v3jib","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1、数据库在表中可以指定多个主键\"><a href=\"#1、数据库在表中可以指定多个主键\" class=\"headerlink\" title=\"1、数据库在表中可以指定多个主键\"></a>1、数据库在表中可以指定多个主键</h3><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity(primaryKeys = &#123;&quot;firstName&quot;, &quot;lastName&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> String firstName;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> String lastName;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//使用Ignore使得该变量不生成表段名</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"meta\">@Ignore</span></span><br><span class=\"line\">     Bitmap bitmap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RemotePerson extends Person &#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean hasVpn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、Entity进行嵌套\"><a href=\"#2、Entity进行嵌套\" class=\"headerlink\" title=\"2、Entity进行嵌套\"></a>2、Entity进行嵌套</h3><p>如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Address &#123;</span><br><span class=\"line\">    public String street;</span><br><span class=\"line\">    public String state;</span><br><span class=\"line\">    public String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ColumnInfo(name &#x3D; &quot;post_code&quot;)</span><br><span class=\"line\">    public int postCode;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    public Address address;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样在Person表中有id,firstName,street,state,city,post_code等字段</p>\n<h3 id=\"3、插入数据产生冲突时操作\"><a href=\"#3、插入数据产生冲突时操作\" class=\"headerlink\" title=\"3、插入数据产生冲突时操作\"></a>3、插入数据产生冲突时操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface UserDao&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;插入如果冲突则替换    </span><br><span class=\"line\">    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)</span><br><span class=\"line\">    public void insertUser(User ... users);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"用于对数据表中某一列进行更新\"><a href=\"#用于对数据表中某一列进行更新\" class=\"headerlink\" title=\"用于对数据表中某一列进行更新\"></a>用于对数据表中某一列进行更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Query(&quot;UPDATE item SET quantity &#x3D; quantity + 1 WHERE id &#x3D; :id&quot;)</span><br><span class=\"line\">void updateQuantity(int id)</span><br><span class=\"line\">&#x2F;&#x2F;item为表名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h3 id=\"1、数据库在表中可以指定多个主键\"><a href=\"#1、数据库在表中可以指定多个主键\" class=\"headerlink\" title=\"1、数据库在表中可以指定多个主键\"></a>1、数据库在表中可以指定多个主键</h3>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Entity(primaryKeys = &#123;&quot;firstName&quot;, &quot;lastName&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> String firstName;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> String lastName;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//使用Ignore使得该变量不生成表段名</span></span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"meta\">@Ignore</span></span><br><span class=\"line\">     Bitmap bitmap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果有类继承自上述Person类，但不想bitmap生成数据表中的列，可以使用ignoredColumns</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RemotePerson extends Person &#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean hasVpn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2、Entity进行嵌套\"><a href=\"#2、Entity进行嵌套\" class=\"headerlink\" title=\"2、Entity进行嵌套\"></a>2、Entity进行嵌套</h3><p>如果定义的Entity类中有某一对象，并且在表列字段生成该对象的变量，使用@Embedded</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Address &#123;</span><br><span class=\"line\">    public String street;</span><br><span class=\"line\">    public String state;</span><br><span class=\"line\">    public String city;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ColumnInfo(name &#x3D; &quot;post_code&quot;)</span><br><span class=\"line\">    public int postCode;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">@Entity</span><br><span class=\"line\">public class Person&#123;</span><br><span class=\"line\">    @PrimaryKey</span><br><span class=\"line\">    public int id;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Embedded</span><br><span class=\"line\">    public Address address;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样在Person表中有id,firstName,street,state,city,post_code等字段</p>\n<h3 id=\"3、插入数据产生冲突时操作\"><a href=\"#3、插入数据产生冲突时操作\" class=\"headerlink\" title=\"3、插入数据产生冲突时操作\"></a>3、插入数据产生冲突时操作</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Dao</span><br><span class=\"line\">public interface UserDao&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;插入如果冲突则替换    </span><br><span class=\"line\">    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)</span><br><span class=\"line\">    public void insertUser(User ... users);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"用于对数据表中某一列进行更新\"><a href=\"#用于对数据表中某一列进行更新\" class=\"headerlink\" title=\"用于对数据表中某一列进行更新\"></a>用于对数据表中某一列进行更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Query(&quot;UPDATE item SET quantity &#x3D; quantity + 1 WHERE id &#x3D; :id&quot;)</span><br><span class=\"line\">void updateQuantity(int id)</span><br><span class=\"line\">&#x2F;&#x2F;item为表名</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"WorkManager介绍与使用","cover":"/cover/img32.jpg","toc":true,"description":"WorkManager介绍与使用","type":["Android"],"date":"2018-12-19T16:00:00.000Z","_content":"\nWorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。\n\n在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。\n<!--more-->\n当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。\n\nWorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service\n\nWorkManager可以执行两种类型的任务\n\n* 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中\n\n```java\n    WorkManager workManager=workManager.getInstance();\n    workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build());\n    \n```\n\n因为没有加其他的限制条件，所以上述任务只会执行一次；\n\n* 多次任务，如：每天将应用数据同步至服务器；\n\n创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中\n\n```\n    new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);\n    \n    PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();\n    WorkManager.getInstance().enqueue(dataCheckWork);\n    \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/框架/AAC/WorkManager介绍.md","raw":"---\ntitle: WorkManager介绍与使用\ncover: /cover/img32.jpg\ntoc: true\ndescription: WorkManager介绍与使用\ncategories: Android\ntype: [Android]\ndate: 2018/12/20\n\n---\n\nWorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。\n\n在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。\n<!--more-->\n当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。\n\nWorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service\n\nWorkManager可以执行两种类型的任务\n\n* 只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中\n\n```java\n    WorkManager workManager=workManager.getInstance();\n    workManager.enqueue(new OneTimeWorkRequest.Builder(MyWork.class).build());\n    \n```\n\n因为没有加其他的限制条件，所以上述任务只会执行一次；\n\n* 多次任务，如：每天将应用数据同步至服务器；\n\n创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中\n\n```\n    new PeriodicWorkRequest.Builder dataCheckBuilder=new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);\n    \n    PeriodicWorkRequest dataCheckWork=dataCheckBuilder.build();\n    WorkManager.getInstance().enqueue(dataCheckWork);\n    \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/框架/AAC/WorkManager介绍","published":1,"updated":"2021-01-05T12:14:30.488Z","_id":"ckjju0m2j009g20uah9wu5o71","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。</p>\n<p>在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。</p>\n<a id=\"more\"></a>\n<p>当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。</p>\n<p>WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service</p>\n<p>WorkManager可以执行两种类型的任务</p>\n<ul>\n<li>只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkManager workManager=workManager.getInstance();</span><br><span class=\"line\">workManager.enqueue(<span class=\"keyword\">new</span> OneTimeWorkRequest.Builder(MyWork.class).build());</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为没有加其他的限制条件，所以上述任务只会执行一次；</p>\n<ul>\n<li>多次任务，如：每天将应用数据同步至服务器；</li>\n</ul>\n<p>创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PeriodicWorkRequest.Builder dataCheckBuilder&#x3D;new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);</span><br><span class=\"line\"></span><br><span class=\"line\">PeriodicWorkRequest dataCheckWork&#x3D;dataCheckBuilder.build();</span><br><span class=\"line\">WorkManager.getInstance().enqueue(dataCheckWork);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>WorkManager是一个Job分发服务，用来管理任务,一旦任务进入管理队里，无论是退出当前应用或重启设备，WorkManager都会保证任务的进行。</p>\n<p>在默认请状态下WorkManager会立即运行任务，但可以指定在手机在某一特殊状态下运行，如：网络状态、电池状态、或者是内存状态。</p>","more":"<p>当程序运行时，运行WorkManager,WorkManager会在一个新的后台子线程中进行；如果程序没有运行，WorkManager将会根据设备的API以及是否可以使用Google服务来选择合适的方式运行。当API在23及以上，WorkManager会使用功JobScheduler来运行，在API14-22将会使用Firebase JobDispatcher，如果JobDispatcher不能使用则会调用一个自定义AlarmManager以及BroadcastReceiver来实现后台运行任务。</p>\n<p>WorkManager不是为了执行所有不在主线程中的任务，如果任务不需要保证执行，则应该使用intent service或者foreground service</p>\n<p>WorkManager可以执行两种类型的任务</p>\n<ul>\n<li>只执行一次的任务，需要创建一个OneTimeWorkRequest对象，然后加入到任务队列中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkManager workManager=workManager.getInstance();</span><br><span class=\"line\">workManager.enqueue(<span class=\"keyword\">new</span> OneTimeWorkRequest.Builder(MyWork.class).build());</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为没有加其他的限制条件，所以上述任务只会执行一次；</p>\n<ul>\n<li>多次任务，如：每天将应用数据同步至服务器；</li>\n</ul>\n<p>创建多次任务时，需要使用PeriodicWorkRequest.Bulder创建一个PeriodicWorkRequest对象，指定两次任务之间的时间间隔，然后将PeriodWorkRequest加入到执行队列中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PeriodicWorkRequest.Builder dataCheckBuilder&#x3D;new PeriodicWorkRequest.Builder(DataCheckWorker.class,12,TimeUnit.HOURS);</span><br><span class=\"line\"></span><br><span class=\"line\">PeriodicWorkRequest dataCheckWork&#x3D;dataCheckBuilder.build();</span><br><span class=\"line\">WorkManager.getInstance().enqueue(dataCheckWork);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Retrofit使用HTTPS请求","description":"Retrofit使用HTTPS请求","type":["Android"],"toc":true,"cover":"/cover/img104.jpg","date":"2020-07-05T16:00:00.000Z","_content":"## Retrofit使用HTTPS请求","source":"_posts/Android/框架/Retrofit/Retrofit 使用HTTPS请求.md","raw":"---\ntitle: \"Retrofit使用HTTPS请求\"\ndescription: \"Retrofit使用HTTPS请求\"\ntype: [Android]\ntoc: true\ncover:  /cover/img104.jpg\ncategories: Android\ndate: 2020/7/6\n---\n## Retrofit使用HTTPS请求","slug":"Android/框架/Retrofit/Retrofit 使用HTTPS请求","published":1,"updated":"2021-01-06T01:00:03.279Z","_id":"ckjju0m2l009q20ua92x5az5b","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Retrofit使用HTTPS请求\"><a href=\"#Retrofit使用HTTPS请求\" class=\"headerlink\" title=\"Retrofit使用HTTPS请求\"></a>Retrofit使用HTTPS请求</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Retrofit使用HTTPS请求\"><a href=\"#Retrofit使用HTTPS请求\" class=\"headerlink\" title=\"Retrofit使用HTTPS请求\"></a>Retrofit使用HTTPS请求</h2>"},{"title":"Retrofit基础","description":"Retrofit使用基础","type":["Android"],"toc":true,"cover":"/cover/img105.jpg","date":"2019-05-11T16:00:00.000Z","_content":"\n\n\n## Retrofit注解\n### Http请求方法注解\n\nHttp请求方法包含`@GET`、`@POST`、`@DELETE`、`@PUT`、`@HEAD`、`@PATCH`、`@TRACE`、`@OPTIONS`、`@HTTP`共8中，除了get外，其他6种都是基于post方法衍生的(需要证实)\n\n\n* get和post请求的区别在于get没有请求体，而post有请求体\n\n\n注：（需要证实）\n\n* baseUrl(\"\")中的url必须要用 '/' 进行结尾，否则会报异常\n\n\n1、`@HTTP`注解可以替换以上七种，对HTTP请求进行拓展\n\n```java\n    /**\n      * method 表示请的方法，不区分大小写\n      * path表示路径\n     * hasBody表示是否有请求体\n    */\n    @HTTP(method = \"get\", path = \"user\", hasBody = false)\n    LiveData<ApiResponse<User>> getUser();\n\n```\n\n### 标记类注解\n\nRetrofit支持的标记类注解，包括：`@FormUrlEncoded`、`@Multipart`、`@Streaming`\n\n1、`@FormUrlEncoded` 请求体是一个Form表单，`Content-Type=application/x-www-form-urlencoded`，需要和参数类注解@Field，@FieldMap搭配使用\n```java\n@FormUrlEncoded\n@POST(\"login\")\nFlowable<HttpResult<UserInfoData>> login(@FieldMap Map<String, String> map);\n\n@FormUrlEncoded\n@POST(\"public\")\nCall<BaseResult> addUser(@Field(\"userName\") String userName);\n\n```\n\n2、`@Multipart` 支持文件上传的表单From表单`Content-Type=multipart/form-data`，需要和参数类注解@Part，@PartMap搭配使用\n\n使用@Multipart注解方法，并用@Part注解方法参数，类型是List< okhttp3.MultipartBody.Part>\n不使用@Multipart注解方法，直接使用@Body注解方法参数，类型是okhttp3.MultipartBody\n\n\n```java\n@Multipart\n@POST(\"public\")\nCall<BaseResult> uploadFile(@Part MultipartBody.Part file);\n\n @Multipart\n@POST(\"users/image\")\nCall<BaseResponse<String>> uploadFilesWithParts(@Part() List<MultipartBody.Part> parts);\n\n @POST(\"users/image\")\nCall<BaseResponse<String>> uploadFileWithRequestBody(@Body  MultipartBody multipartBody);\n```\n\n\n3、`@Streaming` 响应体的数据以流的形式返回，如果不使用，默认会把所有的数据全部加载到内存中，下载文件时，需要使用此注解\n\n```java\n@Streaming\n@GET(\"download\")\nCall<ResponseBody> downloadFile();\n```\n\n\n### 参数类注解\n\nRetrofit支持的参数类注解，包括：`@Headers`、`@Header`、`@Body`、`@Url`、`@Path`、`@Field`、`@FieldMap`、`@Part`、`@PartMap`、`@Query`、`@QueryMap`、`@Body`\n\n1、`@Headers`用于添加请求头，作用于方法\n\n```java\n@Headers({\n\"Cache-Control: max-age=640000\"\n\"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser();\n\n```\n\n2、`@Header`用于动态添加头部，作用于方法参数\n```java\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser(@Header(\"Token\") String token);\n\n```\n\n3、`@Body`用于非表单请求体，作用与方法参数\n\n```java\n@POST(\"user\")\n  Call<BaseResult<String>> addUser(@Body User user);\n\n\n```\n```java\n@POST(\"{api}\")\nObservable<String> request(@Path(\"api\") @NonNull String api,\n                           @Body  Map<String, Object> para);\n\n```\n\n4、`@Url`用于动态改变Url，作用于方法参数\n\n请求时url会替换掉public\n\n```java\n\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser(@Url String url);\n```\n\n5、`@Path` 用于替换请求地址，作用于方法参数\n\n请求url时会替换掉public\n\n```java\n\n@GET(\"{public}\")\nCall<BaseResult<List<User>>> getUser(@Path(\"public\") String path);\n```\n\n6、`@Field` 用于表单字段参数，需要配合`@FormUrlEncoded`使用，作用于方法参数\n\n```java\n@FormUrlEncoded\n@POST(\"public\")\nCall<BaseResult> addUser(@Field(\"userName\") String userName);\n\n```\n\n7、`@FieldMap`用于表单字段参数，接收MAP实现多个参数，需要配合`@FormUrlEncoded`使用\n\n```java\n@FormUrlEncoded\n@POST(\"public\")\nCall<BaseResult> addUser(@FieldMap Map<String,String> fieldMap);\n```\n\n8、`@Part` 用于表单字段参数，适用于文件上传，需要配合`@Multipart`一起使用，作用于方法参数\n\n```java\n@Multipart\n@POST(\"public\")\nCall<BaseResult> uploadFile(@Part MultipartBody.Part file);\n\n```\n\n9、`@PartMap` 用于表单字段参数，适用于文件上传，需要配合`@Multipart`一起使用，作用于方法参数\n\n```java\n@Multipart\n@POST(\"public\")\nCall<BaseResult> uploadFile(@PartMap Map<String,RequestBody> RequestBodyMap);\n```\n10、`@Query` 用于条件字段参数，作用于方法参数，主要在GET中使用\n\n```java\n    @GET(\"public\")\n    Call<BaseResult<List<User>>> getUser(@Query(\"userId\") String userId);\n```\n\n\n11、`@QueryMap` 用于条件字段参数，作用于方法参数，主要在GET中使用\n```java\n\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser(@QueryMap Map<String,String> map);\n```\n\n12、`@Body` 作用于方法参数\n\n```java\n @POST(\"public\")\n Call<BaseResult<List<User>>> getUser(@Body( User user);\n\n```\n\n\n注：\n使用Post请求方式（数据都是被放在请求体中上传到服务器）：\n1、表单提交：建议使用Field或FieldMap+FormUrlEncoded，以键值对上传到服务器；\n2、JSON提交：建议使用@Body，大部分都是实体类，最后将实体类转换为JSON，上传服务器；\n\n使用GET请求（将参数拼接在url后面的）\n1、建议使用Query或QueryMap都是将参数拼接在url后面的；","source":"_posts/Android/框架/Retrofit/Retrofit 基础.md","raw":"---\ntitle: \"Retrofit基础\"\ndescription: \"Retrofit使用基础\"\ntype: [Android]\ntoc: true\ncover:  /cover/img105.jpg\ncategories: Android\ndate: 2019/5/12\n---\n\n\n\n## Retrofit注解\n### Http请求方法注解\n\nHttp请求方法包含`@GET`、`@POST`、`@DELETE`、`@PUT`、`@HEAD`、`@PATCH`、`@TRACE`、`@OPTIONS`、`@HTTP`共8中，除了get外，其他6种都是基于post方法衍生的(需要证实)\n\n\n* get和post请求的区别在于get没有请求体，而post有请求体\n\n\n注：（需要证实）\n\n* baseUrl(\"\")中的url必须要用 '/' 进行结尾，否则会报异常\n\n\n1、`@HTTP`注解可以替换以上七种，对HTTP请求进行拓展\n\n```java\n    /**\n      * method 表示请的方法，不区分大小写\n      * path表示路径\n     * hasBody表示是否有请求体\n    */\n    @HTTP(method = \"get\", path = \"user\", hasBody = false)\n    LiveData<ApiResponse<User>> getUser();\n\n```\n\n### 标记类注解\n\nRetrofit支持的标记类注解，包括：`@FormUrlEncoded`、`@Multipart`、`@Streaming`\n\n1、`@FormUrlEncoded` 请求体是一个Form表单，`Content-Type=application/x-www-form-urlencoded`，需要和参数类注解@Field，@FieldMap搭配使用\n```java\n@FormUrlEncoded\n@POST(\"login\")\nFlowable<HttpResult<UserInfoData>> login(@FieldMap Map<String, String> map);\n\n@FormUrlEncoded\n@POST(\"public\")\nCall<BaseResult> addUser(@Field(\"userName\") String userName);\n\n```\n\n2、`@Multipart` 支持文件上传的表单From表单`Content-Type=multipart/form-data`，需要和参数类注解@Part，@PartMap搭配使用\n\n使用@Multipart注解方法，并用@Part注解方法参数，类型是List< okhttp3.MultipartBody.Part>\n不使用@Multipart注解方法，直接使用@Body注解方法参数，类型是okhttp3.MultipartBody\n\n\n```java\n@Multipart\n@POST(\"public\")\nCall<BaseResult> uploadFile(@Part MultipartBody.Part file);\n\n @Multipart\n@POST(\"users/image\")\nCall<BaseResponse<String>> uploadFilesWithParts(@Part() List<MultipartBody.Part> parts);\n\n @POST(\"users/image\")\nCall<BaseResponse<String>> uploadFileWithRequestBody(@Body  MultipartBody multipartBody);\n```\n\n\n3、`@Streaming` 响应体的数据以流的形式返回，如果不使用，默认会把所有的数据全部加载到内存中，下载文件时，需要使用此注解\n\n```java\n@Streaming\n@GET(\"download\")\nCall<ResponseBody> downloadFile();\n```\n\n\n### 参数类注解\n\nRetrofit支持的参数类注解，包括：`@Headers`、`@Header`、`@Body`、`@Url`、`@Path`、`@Field`、`@FieldMap`、`@Part`、`@PartMap`、`@Query`、`@QueryMap`、`@Body`\n\n1、`@Headers`用于添加请求头，作用于方法\n\n```java\n@Headers({\n\"Cache-Control: max-age=640000\"\n\"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser();\n\n```\n\n2、`@Header`用于动态添加头部，作用于方法参数\n```java\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser(@Header(\"Token\") String token);\n\n```\n\n3、`@Body`用于非表单请求体，作用与方法参数\n\n```java\n@POST(\"user\")\n  Call<BaseResult<String>> addUser(@Body User user);\n\n\n```\n```java\n@POST(\"{api}\")\nObservable<String> request(@Path(\"api\") @NonNull String api,\n                           @Body  Map<String, Object> para);\n\n```\n\n4、`@Url`用于动态改变Url，作用于方法参数\n\n请求时url会替换掉public\n\n```java\n\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser(@Url String url);\n```\n\n5、`@Path` 用于替换请求地址，作用于方法参数\n\n请求url时会替换掉public\n\n```java\n\n@GET(\"{public}\")\nCall<BaseResult<List<User>>> getUser(@Path(\"public\") String path);\n```\n\n6、`@Field` 用于表单字段参数，需要配合`@FormUrlEncoded`使用，作用于方法参数\n\n```java\n@FormUrlEncoded\n@POST(\"public\")\nCall<BaseResult> addUser(@Field(\"userName\") String userName);\n\n```\n\n7、`@FieldMap`用于表单字段参数，接收MAP实现多个参数，需要配合`@FormUrlEncoded`使用\n\n```java\n@FormUrlEncoded\n@POST(\"public\")\nCall<BaseResult> addUser(@FieldMap Map<String,String> fieldMap);\n```\n\n8、`@Part` 用于表单字段参数，适用于文件上传，需要配合`@Multipart`一起使用，作用于方法参数\n\n```java\n@Multipart\n@POST(\"public\")\nCall<BaseResult> uploadFile(@Part MultipartBody.Part file);\n\n```\n\n9、`@PartMap` 用于表单字段参数，适用于文件上传，需要配合`@Multipart`一起使用，作用于方法参数\n\n```java\n@Multipart\n@POST(\"public\")\nCall<BaseResult> uploadFile(@PartMap Map<String,RequestBody> RequestBodyMap);\n```\n10、`@Query` 用于条件字段参数，作用于方法参数，主要在GET中使用\n\n```java\n    @GET(\"public\")\n    Call<BaseResult<List<User>>> getUser(@Query(\"userId\") String userId);\n```\n\n\n11、`@QueryMap` 用于条件字段参数，作用于方法参数，主要在GET中使用\n```java\n\n@GET(\"public\")\nCall<BaseResult<List<User>>> getUser(@QueryMap Map<String,String> map);\n```\n\n12、`@Body` 作用于方法参数\n\n```java\n @POST(\"public\")\n Call<BaseResult<List<User>>> getUser(@Body( User user);\n\n```\n\n\n注：\n使用Post请求方式（数据都是被放在请求体中上传到服务器）：\n1、表单提交：建议使用Field或FieldMap+FormUrlEncoded，以键值对上传到服务器；\n2、JSON提交：建议使用@Body，大部分都是实体类，最后将实体类转换为JSON，上传服务器；\n\n使用GET请求（将参数拼接在url后面的）\n1、建议使用Query或QueryMap都是将参数拼接在url后面的；","slug":"Android/框架/Retrofit/Retrofit 基础","published":1,"updated":"2021-01-06T01:01:06.518Z","_id":"ckjju0m2l009r20uaael80rd4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Retrofit注解\"><a href=\"#Retrofit注解\" class=\"headerlink\" title=\"Retrofit注解\"></a>Retrofit注解</h2><h3 id=\"Http请求方法注解\"><a href=\"#Http请求方法注解\" class=\"headerlink\" title=\"Http请求方法注解\"></a>Http请求方法注解</h3><p>Http请求方法包含<code>@GET</code>、<code>@POST</code>、<code>@DELETE</code>、<code>@PUT</code>、<code>@HEAD</code>、<code>@PATCH</code>、<code>@TRACE</code>、<code>@OPTIONS</code>、<code>@HTTP</code>共8中，除了get外，其他6种都是基于post方法衍生的(需要证实)</p>\n<ul>\n<li>get和post请求的区别在于get没有请求体，而post有请求体</li>\n</ul>\n<p>注：（需要证实）</p>\n<ul>\n<li>baseUrl(“”)中的url必须要用 ‘/‘ 进行结尾，否则会报异常</li>\n</ul>\n<p>1、<code>@HTTP</code>注解可以替换以上七种，对HTTP请求进行拓展</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * method 表示请的方法，不区分大小写</span></span><br><span class=\"line\"><span class=\"comment\">  * path表示路径</span></span><br><span class=\"line\"><span class=\"comment\"> * hasBody表示是否有请求体</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@HTTP(method = &quot;get&quot;, path = &quot;user&quot;, hasBody = false)</span></span><br><span class=\"line\">LiveData&lt;ApiResponse&lt;User&gt;&gt; getUser();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"标记类注解\"><a href=\"#标记类注解\" class=\"headerlink\" title=\"标记类注解\"></a>标记类注解</h3><p>Retrofit支持的标记类注解，包括：<code>@FormUrlEncoded</code>、<code>@Multipart</code>、<code>@Streaming</code></p>\n<p>1、<code>@FormUrlEncoded</code> 请求体是一个Form表单，<code>Content-Type=application/x-www-form-urlencoded</code>，需要和参数类注解@Field，@FieldMap搭配使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;login&quot;)</span></span><br><span class=\"line\">Flowable&lt;HttpResult&lt;UserInfoData&gt;&gt; login(<span class=\"meta\">@FieldMap</span> Map&lt;String, String&gt; map);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">addUser</span><span class=\"params\">(<span class=\"meta\">@Field(&quot;userName&quot;)</span> String userName)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、<code>@Multipart</code> 支持文件上传的表单From表单<code>Content-Type=multipart/form-data</code>，需要和参数类注解@Part，@PartMap搭配使用</p>\n<p>使用@Multipart注解方法，并用@Part注解方法参数，类型是List&lt; okhttp3.MultipartBody.Part&gt;<br>不使用@Multipart注解方法，直接使用@Body注解方法参数，类型是okhttp3.MultipartBody</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">uploadFile</span><span class=\"params\">(<span class=\"meta\">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;users/image&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResponse&lt;String&gt;&gt; uploadFilesWithParts(<span class=\"meta\">@Part()</span> List&lt;MultipartBody.Part&gt; parts);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@POST(&quot;users/image&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResponse&lt;String&gt;&gt; uploadFileWithRequestBody(<span class=\"meta\">@Body</span>  MultipartBody multipartBody);</span><br></pre></td></tr></table></figure>\n\n<p>3、<code>@Streaming</code> 响应体的数据以流的形式返回，如果不使用，默认会把所有的数据全部加载到内存中，下载文件时，需要使用此注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Streaming</span></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;download&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;ResponseBody&gt; <span class=\"title\">downloadFile</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数类注解\"><a href=\"#参数类注解\" class=\"headerlink\" title=\"参数类注解\"></a>参数类注解</h3><p>Retrofit支持的参数类注解，包括：<code>@Headers</code>、<code>@Header</code>、<code>@Body</code>、<code>@Url</code>、<code>@Path</code>、<code>@Field</code>、<code>@FieldMap</code>、<code>@Part</code>、<code>@PartMap</code>、<code>@Query</code>、<code>@QueryMap</code>、<code>@Body</code></p>\n<p>1、<code>@Headers</code>用于添加请求头，作用于方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Headers(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">&quot;Cache-Control: max-age=640000&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&quot;User-Agent: Retrofit-Sample-App&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、<code>@Header</code>用于动态添加头部，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Header(&quot;Token&quot;)</span> String token);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、<code>@Body</code>用于非表单请求体，作用与方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@POST(&quot;user&quot;)</span></span><br><span class=\"line\">  Call&lt;BaseResult&lt;String&gt;&gt; addUser(<span class=\"meta\">@Body</span> User user);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@POST(&quot;&#123;api&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Observable&lt;String&gt; <span class=\"title\">request</span><span class=\"params\">(<span class=\"meta\">@Path(&quot;api&quot;)</span> <span class=\"meta\">@NonNull</span> String api,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"meta\">@Body</span>  Map&lt;String, Object&gt; para)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>4、<code>@Url</code>用于动态改变Url，作用于方法参数</p>\n<p>请求时url会替换掉public</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Url</span> String url);</span><br></pre></td></tr></table></figure>\n<p>5、<code>@Path</code> 用于替换请求地址，作用于方法参数</p>\n<p>请求url时会替换掉public</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;&#123;public&#125;&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Path(&quot;public&quot;)</span> String path);</span><br></pre></td></tr></table></figure>\n<p>6、<code>@Field</code> 用于表单字段参数，需要配合<code>@FormUrlEncoded</code>使用，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">addUser</span><span class=\"params\">(<span class=\"meta\">@Field(&quot;userName&quot;)</span> String userName)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>7、<code>@FieldMap</code>用于表单字段参数，接收MAP实现多个参数，需要配合<code>@FormUrlEncoded</code>使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">addUser</span><span class=\"params\">(<span class=\"meta\">@FieldMap</span> Map&lt;String,String&gt; fieldMap)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>8、<code>@Part</code> 用于表单字段参数，适用于文件上传，需要配合<code>@Multipart</code>一起使用，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">uploadFile</span><span class=\"params\">(<span class=\"meta\">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>9、<code>@PartMap</code> 用于表单字段参数，适用于文件上传，需要配合<code>@Multipart</code>一起使用，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">uploadFile</span><span class=\"params\">(<span class=\"meta\">@PartMap</span> Map&lt;String,RequestBody&gt; RequestBodyMap)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>10、<code>@Query</code> 用于条件字段参数，作用于方法参数，主要在GET中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Query(&quot;userId&quot;)</span> String userId);</span><br></pre></td></tr></table></figure>\n\n<p>11、<code>@QueryMap</code> 用于条件字段参数，作用于方法参数，主要在GET中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@QueryMap</span> Map&lt;String,String&gt; map);</span><br></pre></td></tr></table></figure>\n<p>12、<code>@Body</code> 作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Body( User user)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>注：<br>使用Post请求方式（数据都是被放在请求体中上传到服务器）：<br>1、表单提交：建议使用Field或FieldMap+FormUrlEncoded，以键值对上传到服务器；<br>2、JSON提交：建议使用@Body，大部分都是实体类，最后将实体类转换为JSON，上传服务器；</p>\n<p>使用GET请求（将参数拼接在url后面的）<br>1、建议使用Query或QueryMap都是将参数拼接在url后面的；</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Retrofit注解\"><a href=\"#Retrofit注解\" class=\"headerlink\" title=\"Retrofit注解\"></a>Retrofit注解</h2><h3 id=\"Http请求方法注解\"><a href=\"#Http请求方法注解\" class=\"headerlink\" title=\"Http请求方法注解\"></a>Http请求方法注解</h3><p>Http请求方法包含<code>@GET</code>、<code>@POST</code>、<code>@DELETE</code>、<code>@PUT</code>、<code>@HEAD</code>、<code>@PATCH</code>、<code>@TRACE</code>、<code>@OPTIONS</code>、<code>@HTTP</code>共8中，除了get外，其他6种都是基于post方法衍生的(需要证实)</p>\n<ul>\n<li>get和post请求的区别在于get没有请求体，而post有请求体</li>\n</ul>\n<p>注：（需要证实）</p>\n<ul>\n<li>baseUrl(“”)中的url必须要用 ‘/‘ 进行结尾，否则会报异常</li>\n</ul>\n<p>1、<code>@HTTP</code>注解可以替换以上七种，对HTTP请求进行拓展</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * method 表示请的方法，不区分大小写</span></span><br><span class=\"line\"><span class=\"comment\">  * path表示路径</span></span><br><span class=\"line\"><span class=\"comment\"> * hasBody表示是否有请求体</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@HTTP(method = &quot;get&quot;, path = &quot;user&quot;, hasBody = false)</span></span><br><span class=\"line\">LiveData&lt;ApiResponse&lt;User&gt;&gt; getUser();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"标记类注解\"><a href=\"#标记类注解\" class=\"headerlink\" title=\"标记类注解\"></a>标记类注解</h3><p>Retrofit支持的标记类注解，包括：<code>@FormUrlEncoded</code>、<code>@Multipart</code>、<code>@Streaming</code></p>\n<p>1、<code>@FormUrlEncoded</code> 请求体是一个Form表单，<code>Content-Type=application/x-www-form-urlencoded</code>，需要和参数类注解@Field，@FieldMap搭配使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;login&quot;)</span></span><br><span class=\"line\">Flowable&lt;HttpResult&lt;UserInfoData&gt;&gt; login(<span class=\"meta\">@FieldMap</span> Map&lt;String, String&gt; map);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">addUser</span><span class=\"params\">(<span class=\"meta\">@Field(&quot;userName&quot;)</span> String userName)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、<code>@Multipart</code> 支持文件上传的表单From表单<code>Content-Type=multipart/form-data</code>，需要和参数类注解@Part，@PartMap搭配使用</p>\n<p>使用@Multipart注解方法，并用@Part注解方法参数，类型是List&lt; okhttp3.MultipartBody.Part&gt;<br>不使用@Multipart注解方法，直接使用@Body注解方法参数，类型是okhttp3.MultipartBody</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">uploadFile</span><span class=\"params\">(<span class=\"meta\">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;users/image&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResponse&lt;String&gt;&gt; uploadFilesWithParts(<span class=\"meta\">@Part()</span> List&lt;MultipartBody.Part&gt; parts);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@POST(&quot;users/image&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResponse&lt;String&gt;&gt; uploadFileWithRequestBody(<span class=\"meta\">@Body</span>  MultipartBody multipartBody);</span><br></pre></td></tr></table></figure>\n\n<p>3、<code>@Streaming</code> 响应体的数据以流的形式返回，如果不使用，默认会把所有的数据全部加载到内存中，下载文件时，需要使用此注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Streaming</span></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;download&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;ResponseBody&gt; <span class=\"title\">downloadFile</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数类注解\"><a href=\"#参数类注解\" class=\"headerlink\" title=\"参数类注解\"></a>参数类注解</h3><p>Retrofit支持的参数类注解，包括：<code>@Headers</code>、<code>@Header</code>、<code>@Body</code>、<code>@Url</code>、<code>@Path</code>、<code>@Field</code>、<code>@FieldMap</code>、<code>@Part</code>、<code>@PartMap</code>、<code>@Query</code>、<code>@QueryMap</code>、<code>@Body</code></p>\n<p>1、<code>@Headers</code>用于添加请求头，作用于方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Headers(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">&quot;Cache-Control: max-age=640000&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&quot;User-Agent: Retrofit-Sample-App&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、<code>@Header</code>用于动态添加头部，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Header(&quot;Token&quot;)</span> String token);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、<code>@Body</code>用于非表单请求体，作用与方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@POST(&quot;user&quot;)</span></span><br><span class=\"line\">  Call&lt;BaseResult&lt;String&gt;&gt; addUser(<span class=\"meta\">@Body</span> User user);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@POST(&quot;&#123;api&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Observable&lt;String&gt; <span class=\"title\">request</span><span class=\"params\">(<span class=\"meta\">@Path(&quot;api&quot;)</span> <span class=\"meta\">@NonNull</span> String api,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           <span class=\"meta\">@Body</span>  Map&lt;String, Object&gt; para)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>4、<code>@Url</code>用于动态改变Url，作用于方法参数</p>\n<p>请求时url会替换掉public</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Url</span> String url);</span><br></pre></td></tr></table></figure>\n<p>5、<code>@Path</code> 用于替换请求地址，作用于方法参数</p>\n<p>请求url时会替换掉public</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;&#123;public&#125;&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Path(&quot;public&quot;)</span> String path);</span><br></pre></td></tr></table></figure>\n<p>6、<code>@Field</code> 用于表单字段参数，需要配合<code>@FormUrlEncoded</code>使用，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">addUser</span><span class=\"params\">(<span class=\"meta\">@Field(&quot;userName&quot;)</span> String userName)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>7、<code>@FieldMap</code>用于表单字段参数，接收MAP实现多个参数，需要配合<code>@FormUrlEncoded</code>使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FormUrlEncoded</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">addUser</span><span class=\"params\">(<span class=\"meta\">@FieldMap</span> Map&lt;String,String&gt; fieldMap)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>8、<code>@Part</code> 用于表单字段参数，适用于文件上传，需要配合<code>@Multipart</code>一起使用，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">uploadFile</span><span class=\"params\">(<span class=\"meta\">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>9、<code>@PartMap</code> 用于表单字段参数，适用于文件上传，需要配合<code>@Multipart</code>一起使用，作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Multipart</span></span><br><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\"><span class=\"function\">Call&lt;BaseResult&gt; <span class=\"title\">uploadFile</span><span class=\"params\">(<span class=\"meta\">@PartMap</span> Map&lt;String,RequestBody&gt; RequestBodyMap)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>10、<code>@Query</code> 用于条件字段参数，作用于方法参数，主要在GET中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Query(&quot;userId&quot;)</span> String userId);</span><br></pre></td></tr></table></figure>\n\n<p>11、<code>@QueryMap</code> 用于条件字段参数，作用于方法参数，主要在GET中使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@GET(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@QueryMap</span> Map&lt;String,String&gt; map);</span><br></pre></td></tr></table></figure>\n<p>12、<code>@Body</code> 作用于方法参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@POST(&quot;public&quot;)</span></span><br><span class=\"line\">Call&lt;BaseResult&lt;List&lt;User&gt;&gt;&gt; getUser(<span class=\"meta\">@Body( User user)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>注：<br>使用Post请求方式（数据都是被放在请求体中上传到服务器）：<br>1、表单提交：建议使用Field或FieldMap+FormUrlEncoded，以键值对上传到服务器；<br>2、JSON提交：建议使用@Body，大部分都是实体类，最后将实体类转换为JSON，上传服务器；</p>\n<p>使用GET请求（将参数拼接在url后面的）<br>1、建议使用Query或QueryMap都是将参数拼接在url后面的；</p>\n"},{"title":"Android应用启动流程","cover":"/cover/img1.jpg","toc":true,"description":"Android应用启动流程","type":["Android"],"date":"2019-09-29T16:00:00.000Z","_content":"\n1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。\n2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。\n3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。\n4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。\n5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。\n6、AMS通知淘宝绑定Application并启动MainActivity。\n7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。\n\n<!--more-->\n## Linux 系统加载流程\n\nLinux 内核加载 ——》init 进程（守护进程） ——》 系统服务 ——》Android Runtime(虚拟机) \n\n### Linux 内核加载\n\n### init 进程（守护进程）\n    定义：是Linux内核启动的第一个用户级进程，init进程主要任务为启动Android关键服务，守护关键服务进程，确保其不会被杀死；\n    Init与Android之间的关系：当Linux内核启动后，通过启动用户级程序init来完成引导Android Framework的建立，因此init总是第一个进程（其进程号PID总是1,其父进程PID为0）。\n    在init进程中启动关键服务：\n         多媒体服务、网络服务、音量服务、蓝牙服务、USB服务、日志服务、电话服务、事件服务、Zygote服务\n         关键服务在内存不足的时候不会被kill掉，如果被kill掉，会被init进程拉起来。关键服务不对下面的进程负责，即下面的进程kill掉后，不会被重新拉起。\n\n注：Andorid模拟器打开后在根目录下会有init文件(Nexus_5x中)，它是可执行文件由init.cpp文件编译出来的，删掉后重启会再次生成。\n    init.cpp在源码中的system/core/init路径下，在该文件中有main函数\n    inti.cpp解析了一个根目录 \"/init.rc\"文件（模拟器根目录下有，但修改这一个文件没有用），在配置文件中可以定制化启动服务，只能在Android系统编译前进行清理\n    源码中的system/文件夹下的都是系统服务 ，自定义服务需要写在system/extras文件下，服务中都有Android.mk, .ccp文件 .h文件\n\n 定制化Android系统服务：\n    目的：自定义服务可以做到开机启动到自己的App界面，完整定制化Android系统；\n    需求：适合定制开发，如：车载设备、智能家居设备，手表，手机厂商\n    缺点：1、只适合针对机型定制化，需要编译Android和刷盘\n         2、只能启动c文件可执行文件（含有main函数），然后通过c反射执行Java代码  \n    过程：系统源码下 —— 》写入C文件 —— 》 写入Android.mk文件 —— 》 在init.rc 中添加服务 —— 》 编译Andoid系统 —— 》刷盘     \n    在init.rc添加的服务通常具有root权限\n\nAndroid源码编译方式  https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098582 \n\n#### Android init进程守护过程\n    init守护进程时，通过socket与被守护服务建立长连接，如果read阻塞，则重启服务\n\n```xml\n    <!-- 查看进程号码 -->\n    adb shell\n    ps\n    <!-- 杀死进程 -->\n     kill -9 进程号\n\n```\n\n\n## Android应用启动从Zygote到Activity.onCreate\n\n开机 —— 》 init进程启动 —— 》 解析init.rc —— 》 启动 Zygote 服务 —— 》 启动SystemSevice进程 —— 》 进入Home应用\n\nZygote进程在启动时，会扫描所有安装到手机的应用，使用PSM 对data/app文件进行扫描，通过PackageParse解析，AndoridManifest.xml，对每一个组件进行保存，会将扫描的内容缓存到缓存中心（Packages），启动一个应用的只会给包名，通过包名找到PSM缓存的类，进行加载。\n\n注：\n    *  使用AndroidManifest.xml文件会加快Android的启动的速度\n    *  PMS进程是在Zygote进程启动的时候进行启动的，运行在单独进程\n    *  AndroidManifest.xml文件通过PackageParser进行解析\n    *  PMS启动的扫描过程会消耗大量的时间\n\n本文从点击Android应用图标开始介绍Android应用的启动过程\n\n### Android应用有两个方面的特点\n\n**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。\n\n**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;\n\n\n任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。\n\n在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 \n\n\n### Zygote：创建新的进程\n\nAndroid操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。\n\n**init进程会启动Zygote进程**\n\n**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。\n\n**在Zygote之后，init启动运行时的进程？**\n\n紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**\n\n### 用户点击图标通过Launcher启动应用的过程\n\n点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。\n\n* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。\n* 2、目标信心会被存储至intent对象中，避免重复第一步工作；\n* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；\n* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；\n* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。\n\n\n### 在该应用启动流程中有三个不同的阶段\n* 1、进程创建\n* 2、绑定应用\n* 3、启动Activity/Service/调用intent receiver\n\n#### 进程创建\n\nActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id\n\n在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。\n\n#### 应用绑定\n\n下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。\n\n\n## 启动APP 流程\n用手机点击屏幕图标 —— 》startActivity —— 》 ActivityManagerService —— 》 根据启动的类名信息从缓存中心找到组件存档—— 》 通过反射( Class.forName()方式)找到Activity对象 ——》 所有被加载的Activity 的对象会被缓存到ActivityThread中\n\n注：AMS的缓存中心在 ActivityThread中，缓存活动Activity对象；\n   PMS 缓存中心，用于缓存从AndroidManifest.xml解析的Android组件；\n\n\nApp分为冷启动和热启动：热启动速度快一些\n\n\n### PMS源码解析\n\n1、 在其中有main函数，是由SystemServer进行启动,手机开机，还没有进入Home界面时启动（Android logo在闪的时候）\n添加PackageManager main函数源码图片\n\n\n\n\n将当前的PMS服务添加到ServicaManger中，\n\n\n构造方法 扫描文件，data为我们的安装目录，把当前目录全部扫描一遍\n\n\n2、\n\n\n注： ART和DVM在启动应用的时候没有区别，在安装的时候有区别。\nAndroid 5.0 之前虚拟机以 class 字节码加载到内存，JAVA虚拟机转为本地指令，CPU执行本地指令\nAndroid 5.0 之后ART 虚拟机，在安装的时候对class字节码转换为本地指令\n\nART虚拟机：加载速度快，打包文件偏大，安装速度慢，以空间换时间\nDVM虚拟机：加载速度慢，安装快\n\n### AMS缓存中心详解\n\nActivityManager继承自ActivityManagerNative\n\nActivityThread最终启动Activity，会经过一个进程间通信\n\n## Activity 在不同版本下的启动流程\n\n### Android 9.0应用启动流程\n\n1、从`startActivity()`开始会一直调用到  `startActivityForResult(intent, -1, options)`中，其源码如下：\n\n```java\n  public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n            @Nullable Bundle options) {\n        if (mParent == null) {\n            options = transferSpringboardActivityOptions(options);\n            Instrumentation.ActivityResult ar =\n                mInstrumentation.execStartActivity(\n                    this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n            if (ar != null) {\n                mMainThread.sendActivityResult(\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n                    ar.getResultData());\n            }\n            if (requestCode >= 0) {\n                // If this start is requesting a result, we can avoid making\n                // the activity visible until the result is received.  Setting\n                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n                // activity hidden during this time, to avoid flickering.\n                // This can only be done when a result is requested because\n                // that guarantees we will get information back when the\n                // activity is finished, no matter what happens to it.\n                mStartedActivity = true;\n            }\n\n            cancelInputsAndStartExitTransition(options);\n            // TODO Consider clearing/flushing other event sources and events for child windows.\n        } else {\n            if (options != null) {\n                mParent.startActivityFromChild(this, intent, requestCode, options);\n            } else {\n                // Note we want to go through this method for compatibility with\n                // existing applications that may have overridden it.\n                mParent.startActivityFromChild(this, intent, requestCode);\n            }\n        }\n    }\n\n\n```\n\n在startActivityForResult()中会调用Instrumentation中的 mInstrumentation.execStartActivity()方法，\n\nInstrumentation.execStartActivity()方法源码\n\n```java\n    public ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, String target,\n        Intent intent, int requestCode, Bundle options) {\n        IApplicationThread whoThread = (IApplicationThread) contextThread;\n        if (mActivityMonitors != null) {\n            synchronized (mSync) {\n                final int N = mActivityMonitors.size();\n                for (int i=0; i<N; i++) {\n                    final ActivityMonitor am = mActivityMonitors.get(i);\n                    ActivityResult result = null;\n                    if (am.ignoreMatchingSpecificIntents()) {\n                        result = am.onStartActivity(intent);\n                    }\n                    if (result != null) {\n                        am.mHits++;\n                        return result;\n                    } else if (am.match(who, null, intent)) {\n                        am.mHits++;\n                        if (am.isBlocking()) {\n                            return requestCode >= 0 ? am.getResult() : null;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        try {\n            intent.migrateExtraStreamToClipData();\n            intent.prepareToLeaveProcess(who);\n            int result = ActivityTaskManager.getService()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolvetypeIfNeeded(who.getContentResolver()),\n                        token, target, requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failure from system\", e);\n        }\n        return null;\n    }\n\n\n```\n\n\n获取IActivityManger，IActivityManger.getService()\n\n//.startActivity\nIActivityManger.startActivity(); (应用所在进程) ————》 Binder机制 ——》 AMS(系统进程)\n\n\n\n### Android 7.0 启动流程\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）\n\n分析 ClassLoader Java中的 ClassLoader 和Android中的ClassLoader不一样:\n        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想\n\n\nAndroid的ClassLoader在启动的过程中在ActivityThread中有调用         \n\nAndroid中的ClassLoader =PathClassLoader\n\n\nAndroid中ClassLoader的过程：\n    1、Java中的ClassLo\n     \n\n//如果开发插件化，需要在AMS.startActivity() 之前添加Hook\n\n\n类继承关系  `ActivityManagerService extends ActivityManagerNative`\n          ` ActivityManagerNative extends Binder implements IActivityManager`\n\n\n#### 从startActivity开始\n\n启动Activity时，会从`startActivity()`方法一直调用到`Activity`中的`startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) `方法\n其源码如下：\n\n```java\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n            @Nullable Bundle options) {\n        if (mParent == null) {\n            Instrumentation.ActivityResult ar =\n                mInstrumentation.execStartActivity(\n                    this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n            if (ar != null) {\n                mMainThread.sendActivityResult(\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n                    ar.getResultData());\n            }\n            if (requestCode >= 0) {\n                // If this start is requesting a result, we can avoid making\n                // the activity visible until the result is received.  Setting\n                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n                // activity hidden during this time, to avoid flickering.\n                // This can only be done when a result is requested because\n                // that guarantees we will get information back when the\n                // activity is finished, no matter what happens to it.\n                mStartedActivity = true;\n            }\n\n            cancelInputsAndStartExitTransition(options);\n            // TODO Consider clearing/flushing other event sources and events for child windows.\n        } else {\n            if (options != null) {\n                mParent.startActivityFromChild(this, intent, requestCode, options);\n            } else {\n                // Note we want to go through this method for compatibility with\n                // existing applications that may have overridden it.\n                mParent.startActivityFromChild(this, intent, requestCode);\n            }\n        }\n    }\n\n\n```\n\n在startActivityForResult()方法中会调用`Instrumentation`中的`execStartActivity()`方法，其源码如下：\n\n```java\n  public ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, String target,\n        Intent intent, int requestCode, Bundle options) {\n        IApplicationThread whoThread = (IApplicationThread) contextThread;\n        if (mActivityMonitors != null) {\n            synchronized (mSync) {\n                final int N = mActivityMonitors.size();\n                for (int i=0; i<N; i++) {\n                    final ActivityMonitor am = mActivityMonitors.get(i);\n                    if (am.match(who, null, intent)) {\n                        am.mHits++;\n                        if (am.isBlocking()) {\n                            return requestCode >= 0 ? am.getResult() : null;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        try {\n            intent.migrateExtraStreamToClipData();\n            intent.prepareToLeaveProcess(who);\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolvetypeIfNeeded(who.getContentResolver()),\n                        token, target, requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failure from system\", e);\n        }\n        return null;\n    }\n\n```\n\n在`Instrumentation`中的`execStartActivity()`方法中会调用 ` ActivityManagerNative.getDefault().startActivity()`启动Activity\n\n\n`ActivityManagerNative.getDefault()`方法获取的是一个接口，该接口是用于域AMS进行通信的接口，返回`IActivityManager`，其源码如下\n\n```java\n\n  static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n\n```\n IActivityManager实现了一个AIDL的接口，\n\n```java\npublic interface IActivityManager extends IInterface {\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedtype, IBinder resultTo, String resultWho, int requestCode, int flags,\n            ProfilerInfo profilerInfo, Bundle options) throws RemoteException;\n}\n\n```\n\n```java\npublic interface IInterface\n{\n    /**\n     * Retrieve the Binder object associated with this interface.\n     * You must use this instead of a plain cast, so that proxy objects\n     * can return the correct result.\n     */\n    public IBinder asBinder();\n}\n\n\n```\n\nIActivityManager 类中调用startActivity最终会调用 ActivityManagerService中的 ` startActivity()`方法，\n","source":"_posts/Android/Advanced/基础/应用启动流程.md","raw":"---\ntitle: Android应用启动流程\ncover:  /cover/img1.jpg\ntoc: true\ndescription: Android应用启动流程\ntype: [Android]\ncategories: Android\ndate: 2019/09/30\n---\n\n1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。\n2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。\n3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。\n4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。\n5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。\n6、AMS通知淘宝绑定Application并启动MainActivity。\n7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。\n\n<!--more-->\n## Linux 系统加载流程\n\nLinux 内核加载 ——》init 进程（守护进程） ——》 系统服务 ——》Android Runtime(虚拟机) \n\n### Linux 内核加载\n\n### init 进程（守护进程）\n    定义：是Linux内核启动的第一个用户级进程，init进程主要任务为启动Android关键服务，守护关键服务进程，确保其不会被杀死；\n    Init与Android之间的关系：当Linux内核启动后，通过启动用户级程序init来完成引导Android Framework的建立，因此init总是第一个进程（其进程号PID总是1,其父进程PID为0）。\n    在init进程中启动关键服务：\n         多媒体服务、网络服务、音量服务、蓝牙服务、USB服务、日志服务、电话服务、事件服务、Zygote服务\n         关键服务在内存不足的时候不会被kill掉，如果被kill掉，会被init进程拉起来。关键服务不对下面的进程负责，即下面的进程kill掉后，不会被重新拉起。\n\n注：Andorid模拟器打开后在根目录下会有init文件(Nexus_5x中)，它是可执行文件由init.cpp文件编译出来的，删掉后重启会再次生成。\n    init.cpp在源码中的system/core/init路径下，在该文件中有main函数\n    inti.cpp解析了一个根目录 \"/init.rc\"文件（模拟器根目录下有，但修改这一个文件没有用），在配置文件中可以定制化启动服务，只能在Android系统编译前进行清理\n    源码中的system/文件夹下的都是系统服务 ，自定义服务需要写在system/extras文件下，服务中都有Android.mk, .ccp文件 .h文件\n\n 定制化Android系统服务：\n    目的：自定义服务可以做到开机启动到自己的App界面，完整定制化Android系统；\n    需求：适合定制开发，如：车载设备、智能家居设备，手表，手机厂商\n    缺点：1、只适合针对机型定制化，需要编译Android和刷盘\n         2、只能启动c文件可执行文件（含有main函数），然后通过c反射执行Java代码  \n    过程：系统源码下 —— 》写入C文件 —— 》 写入Android.mk文件 —— 》 在init.rc 中添加服务 —— 》 编译Andoid系统 —— 》刷盘     \n    在init.rc添加的服务通常具有root权限\n\nAndroid源码编译方式  https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098582 \n\n#### Android init进程守护过程\n    init守护进程时，通过socket与被守护服务建立长连接，如果read阻塞，则重启服务\n\n```xml\n    <!-- 查看进程号码 -->\n    adb shell\n    ps\n    <!-- 杀死进程 -->\n     kill -9 进程号\n\n```\n\n\n## Android应用启动从Zygote到Activity.onCreate\n\n开机 —— 》 init进程启动 —— 》 解析init.rc —— 》 启动 Zygote 服务 —— 》 启动SystemSevice进程 —— 》 进入Home应用\n\nZygote进程在启动时，会扫描所有安装到手机的应用，使用PSM 对data/app文件进行扫描，通过PackageParse解析，AndoridManifest.xml，对每一个组件进行保存，会将扫描的内容缓存到缓存中心（Packages），启动一个应用的只会给包名，通过包名找到PSM缓存的类，进行加载。\n\n注：\n    *  使用AndroidManifest.xml文件会加快Android的启动的速度\n    *  PMS进程是在Zygote进程启动的时候进行启动的，运行在单独进程\n    *  AndroidManifest.xml文件通过PackageParser进行解析\n    *  PMS启动的扫描过程会消耗大量的时间\n\n本文从点击Android应用图标开始介绍Android应用的启动过程\n\n### Android应用有两个方面的特点\n\n**特点一：**具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。\n\n**特点二：**自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;\n\n\n任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。\n\n在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 \n\n\n### Zygote：创建新的进程\n\nAndroid操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。\n\n**init进程会启动Zygote进程**\n\n**Zygote**进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。\n\n**在Zygote之后，init启动运行时的进程？**\n\n紧接着Zygote fork并启动一个称为system server的进程，**system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。**\n\n### 用户点击图标通过Launcher启动应用的过程\n\n点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。\n\n* 1、收集intent的目标的信息，通过调用`PackageManager`对象中的`resolveIntent()`方法，默认使用`PackageManager.MATCH_DEFAULT_ONLY` 和     `PackageManager.GET_SHARED_LIBRARY_FILES`标志。\n* 2、目标信心会被存储至intent对象中，避免重复第一步工作；\n* 3、判断用户是否有权限调用intent中的组件，通过`grantUriPermissionLocked()`方法执行；\n* 4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：`FLAG_ACTIVITY_NEW_TASK` 或者其他flags`FLAG_ACTIVITY_CLEAR_TOP`；\n* 5、检查进程的`ProcessRecord`是否已经存在，如果`ProcessRecord`为空，ActivityManager需要创建一个新的进程来实例化目标组件。\n\n\n### 在该应用启动流程中有三个不同的阶段\n* 1、进程创建\n* 2、绑定应用\n* 3、启动Activity/Service/调用intent receiver\n\n#### 进程创建\n\nActivityManagerService通过调用`startProcessLocked()`方法来创建一个新的进程，`startProcessLocked`方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用`ZygoteInit.main()`方法，该方法会创建一个ActivityThread对象，并返回新建进程的id\n\n在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用`Looper.loop()`方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用`Looper.prepareLoop()`再掉用`Looper.loop()`方法启动message loop。\n\n#### 应用绑定\n\n下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的`bindApplication()`方法来实现。该方法将`BIND_APPLICATION`信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——`handleBindApplication()`，该方法调用`makeApplication()`方法，`makeApplication()`方法将应用中特定的类加载到内存中执行。\n\n\n## 启动APP 流程\n用手机点击屏幕图标 —— 》startActivity —— 》 ActivityManagerService —— 》 根据启动的类名信息从缓存中心找到组件存档—— 》 通过反射( Class.forName()方式)找到Activity对象 ——》 所有被加载的Activity 的对象会被缓存到ActivityThread中\n\n注：AMS的缓存中心在 ActivityThread中，缓存活动Activity对象；\n   PMS 缓存中心，用于缓存从AndroidManifest.xml解析的Android组件；\n\n\nApp分为冷启动和热启动：热启动速度快一些\n\n\n### PMS源码解析\n\n1、 在其中有main函数，是由SystemServer进行启动,手机开机，还没有进入Home界面时启动（Android logo在闪的时候）\n添加PackageManager main函数源码图片\n\n\n\n\n将当前的PMS服务添加到ServicaManger中，\n\n\n构造方法 扫描文件，data为我们的安装目录，把当前目录全部扫描一遍\n\n\n2、\n\n\n注： ART和DVM在启动应用的时候没有区别，在安装的时候有区别。\nAndroid 5.0 之前虚拟机以 class 字节码加载到内存，JAVA虚拟机转为本地指令，CPU执行本地指令\nAndroid 5.0 之后ART 虚拟机，在安装的时候对class字节码转换为本地指令\n\nART虚拟机：加载速度快，打包文件偏大，安装速度慢，以空间换时间\nDVM虚拟机：加载速度慢，安装快\n\n### AMS缓存中心详解\n\nActivityManager继承自ActivityManagerNative\n\nActivityThread最终启动Activity，会经过一个进程间通信\n\n## Activity 在不同版本下的启动流程\n\n### Android 9.0应用启动流程\n\n1、从`startActivity()`开始会一直调用到  `startActivityForResult(intent, -1, options)`中，其源码如下：\n\n```java\n  public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n            @Nullable Bundle options) {\n        if (mParent == null) {\n            options = transferSpringboardActivityOptions(options);\n            Instrumentation.ActivityResult ar =\n                mInstrumentation.execStartActivity(\n                    this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n            if (ar != null) {\n                mMainThread.sendActivityResult(\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n                    ar.getResultData());\n            }\n            if (requestCode >= 0) {\n                // If this start is requesting a result, we can avoid making\n                // the activity visible until the result is received.  Setting\n                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n                // activity hidden during this time, to avoid flickering.\n                // This can only be done when a result is requested because\n                // that guarantees we will get information back when the\n                // activity is finished, no matter what happens to it.\n                mStartedActivity = true;\n            }\n\n            cancelInputsAndStartExitTransition(options);\n            // TODO Consider clearing/flushing other event sources and events for child windows.\n        } else {\n            if (options != null) {\n                mParent.startActivityFromChild(this, intent, requestCode, options);\n            } else {\n                // Note we want to go through this method for compatibility with\n                // existing applications that may have overridden it.\n                mParent.startActivityFromChild(this, intent, requestCode);\n            }\n        }\n    }\n\n\n```\n\n在startActivityForResult()中会调用Instrumentation中的 mInstrumentation.execStartActivity()方法，\n\nInstrumentation.execStartActivity()方法源码\n\n```java\n    public ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, String target,\n        Intent intent, int requestCode, Bundle options) {\n        IApplicationThread whoThread = (IApplicationThread) contextThread;\n        if (mActivityMonitors != null) {\n            synchronized (mSync) {\n                final int N = mActivityMonitors.size();\n                for (int i=0; i<N; i++) {\n                    final ActivityMonitor am = mActivityMonitors.get(i);\n                    ActivityResult result = null;\n                    if (am.ignoreMatchingSpecificIntents()) {\n                        result = am.onStartActivity(intent);\n                    }\n                    if (result != null) {\n                        am.mHits++;\n                        return result;\n                    } else if (am.match(who, null, intent)) {\n                        am.mHits++;\n                        if (am.isBlocking()) {\n                            return requestCode >= 0 ? am.getResult() : null;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        try {\n            intent.migrateExtraStreamToClipData();\n            intent.prepareToLeaveProcess(who);\n            int result = ActivityTaskManager.getService()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolvetypeIfNeeded(who.getContentResolver()),\n                        token, target, requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failure from system\", e);\n        }\n        return null;\n    }\n\n\n```\n\n\n获取IActivityManger，IActivityManger.getService()\n\n//.startActivity\nIActivityManger.startActivity(); (应用所在进程) ————》 Binder机制 ——》 AMS(系统进程)\n\n\n\n### Android 7.0 启动流程\n\nstartActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）\n\n分析 ClassLoader Java中的 ClassLoader 和Android中的ClassLoader不一样:\n        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想\n\n\nAndroid的ClassLoader在启动的过程中在ActivityThread中有调用         \n\nAndroid中的ClassLoader =PathClassLoader\n\n\nAndroid中ClassLoader的过程：\n    1、Java中的ClassLo\n     \n\n//如果开发插件化，需要在AMS.startActivity() 之前添加Hook\n\n\n类继承关系  `ActivityManagerService extends ActivityManagerNative`\n          ` ActivityManagerNative extends Binder implements IActivityManager`\n\n\n#### 从startActivity开始\n\n启动Activity时，会从`startActivity()`方法一直调用到`Activity`中的`startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) `方法\n其源码如下：\n\n```java\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n            @Nullable Bundle options) {\n        if (mParent == null) {\n            Instrumentation.ActivityResult ar =\n                mInstrumentation.execStartActivity(\n                    this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n            if (ar != null) {\n                mMainThread.sendActivityResult(\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n                    ar.getResultData());\n            }\n            if (requestCode >= 0) {\n                // If this start is requesting a result, we can avoid making\n                // the activity visible until the result is received.  Setting\n                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n                // activity hidden during this time, to avoid flickering.\n                // This can only be done when a result is requested because\n                // that guarantees we will get information back when the\n                // activity is finished, no matter what happens to it.\n                mStartedActivity = true;\n            }\n\n            cancelInputsAndStartExitTransition(options);\n            // TODO Consider clearing/flushing other event sources and events for child windows.\n        } else {\n            if (options != null) {\n                mParent.startActivityFromChild(this, intent, requestCode, options);\n            } else {\n                // Note we want to go through this method for compatibility with\n                // existing applications that may have overridden it.\n                mParent.startActivityFromChild(this, intent, requestCode);\n            }\n        }\n    }\n\n\n```\n\n在startActivityForResult()方法中会调用`Instrumentation`中的`execStartActivity()`方法，其源码如下：\n\n```java\n  public ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, String target,\n        Intent intent, int requestCode, Bundle options) {\n        IApplicationThread whoThread = (IApplicationThread) contextThread;\n        if (mActivityMonitors != null) {\n            synchronized (mSync) {\n                final int N = mActivityMonitors.size();\n                for (int i=0; i<N; i++) {\n                    final ActivityMonitor am = mActivityMonitors.get(i);\n                    if (am.match(who, null, intent)) {\n                        am.mHits++;\n                        if (am.isBlocking()) {\n                            return requestCode >= 0 ? am.getResult() : null;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        try {\n            intent.migrateExtraStreamToClipData();\n            intent.prepareToLeaveProcess(who);\n            int result = ActivityManagerNative.getDefault()\n                .startActivity(whoThread, who.getBasePackageName(), intent,\n                        intent.resolvetypeIfNeeded(who.getContentResolver()),\n                        token, target, requestCode, 0, null, options);\n            checkStartActivityResult(result, intent);\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Failure from system\", e);\n        }\n        return null;\n    }\n\n```\n\n在`Instrumentation`中的`execStartActivity()`方法中会调用 ` ActivityManagerNative.getDefault().startActivity()`启动Activity\n\n\n`ActivityManagerNative.getDefault()`方法获取的是一个接口，该接口是用于域AMS进行通信的接口，返回`IActivityManager`，其源码如下\n\n```java\n\n  static public IActivityManager getDefault() {\n        return gDefault.get();\n    }\n\n```\n IActivityManager实现了一个AIDL的接口，\n\n```java\npublic interface IActivityManager extends IInterface {\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedtype, IBinder resultTo, String resultWho, int requestCode, int flags,\n            ProfilerInfo profilerInfo, Bundle options) throws RemoteException;\n}\n\n```\n\n```java\npublic interface IInterface\n{\n    /**\n     * Retrieve the Binder object associated with this interface.\n     * You must use this instead of a plain cast, so that proxy objects\n     * can return the correct result.\n     */\n    public IBinder asBinder();\n}\n\n\n```\n\nIActivityManager 类中调用startActivity最终会调用 ActivityManagerService中的 ` startActivity()`方法，\n","slug":"Android/Advanced/基础/应用启动流程","published":1,"updated":"2021-01-05T12:13:28.602Z","_id":"ckjju0m2m009s20uaakev7n08","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。<br>2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br>3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。<br>4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。<br>5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。<br>6、AMS通知淘宝绑定Application并启动MainActivity。<br>7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"Linux-系统加载流程\"><a href=\"#Linux-系统加载流程\" class=\"headerlink\" title=\"Linux 系统加载流程\"></a>Linux 系统加载流程</h2><p>Linux 内核加载 ——》init 进程（守护进程） ——》 系统服务 ——》Android Runtime(虚拟机) </p>\n<h3 id=\"Linux-内核加载\"><a href=\"#Linux-内核加载\" class=\"headerlink\" title=\"Linux 内核加载\"></a>Linux 内核加载</h3><h3 id=\"init-进程（守护进程）\"><a href=\"#init-进程（守护进程）\" class=\"headerlink\" title=\"init 进程（守护进程）\"></a>init 进程（守护进程）</h3><pre><code>定义：是Linux内核启动的第一个用户级进程，init进程主要任务为启动Android关键服务，守护关键服务进程，确保其不会被杀死；\nInit与Android之间的关系：当Linux内核启动后，通过启动用户级程序init来完成引导Android Framework的建立，因此init总是第一个进程（其进程号PID总是1,其父进程PID为0）。\n在init进程中启动关键服务：\n     多媒体服务、网络服务、音量服务、蓝牙服务、USB服务、日志服务、电话服务、事件服务、Zygote服务\n     关键服务在内存不足的时候不会被kill掉，如果被kill掉，会被init进程拉起来。关键服务不对下面的进程负责，即下面的进程kill掉后，不会被重新拉起。</code></pre>\n<p>注：Andorid模拟器打开后在根目录下会有init文件(Nexus_5x中)，它是可执行文件由init.cpp文件编译出来的，删掉后重启会再次生成。<br>    init.cpp在源码中的system/core/init路径下，在该文件中有main函数<br>    inti.cpp解析了一个根目录 “/init.rc”文件（模拟器根目录下有，但修改这一个文件没有用），在配置文件中可以定制化启动服务，只能在Android系统编译前进行清理<br>    源码中的system/文件夹下的都是系统服务 ，自定义服务需要写在system/extras文件下，服务中都有Android.mk, .ccp文件 .h文件</p>\n<p> 定制化Android系统服务：<br>    目的：自定义服务可以做到开机启动到自己的App界面，完整定制化Android系统；<br>    需求：适合定制开发，如：车载设备、智能家居设备，手表，手机厂商<br>    缺点：1、只适合针对机型定制化，需要编译Android和刷盘<br>         2、只能启动c文件可执行文件（含有main函数），然后通过c反射执行Java代码<br>    过程：系统源码下 —— 》写入C文件 —— 》 写入Android.mk文件 —— 》 在init.rc 中添加服务 —— 》 编译Andoid系统 —— 》刷盘<br>    在init.rc添加的服务通常具有root权限</p>\n<p>Android源码编译方式  <a href=\"https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098582\">https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098582</a> </p>\n<h4 id=\"Android-init进程守护过程\"><a href=\"#Android-init进程守护过程\" class=\"headerlink\" title=\"Android init进程守护过程\"></a>Android init进程守护过程</h4><pre><code>init守护进程时，通过socket与被守护服务建立长连接，如果read阻塞，则重启服务</code></pre>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 查看进程号码 --&gt;</span></span><br><span class=\"line\">adb shell</span><br><span class=\"line\">ps</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 杀死进程 --&gt;</span></span><br><span class=\"line\"> kill -9 进程号</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Android应用启动从Zygote到Activity-onCreate\"><a href=\"#Android应用启动从Zygote到Activity-onCreate\" class=\"headerlink\" title=\"Android应用启动从Zygote到Activity.onCreate\"></a>Android应用启动从Zygote到Activity.onCreate</h2><p>开机 —— 》 init进程启动 —— 》 解析init.rc —— 》 启动 Zygote 服务 —— 》 启动SystemSevice进程 —— 》 进入Home应用</p>\n<p>Zygote进程在启动时，会扫描所有安装到手机的应用，使用PSM 对data/app文件进行扫描，通过PackageParse解析，AndoridManifest.xml，对每一个组件进行保存，会将扫描的内容缓存到缓存中心（Packages），启动一个应用的只会给包名，通过包名找到PSM缓存的类，进行加载。</p>\n<p>注：<br>    *  使用AndroidManifest.xml文件会加快Android的启动的速度<br>    *  PMS进程是在Zygote进程启动的时候进行启动的，运行在单独进程<br>    *  AndroidManifest.xml文件通过PackageParser进行解析<br>    *  PMS启动的扫描过程会消耗大量的时间</p>\n<p>本文从点击Android应用图标开始介绍Android应用的启动过程</p>\n<h3 id=\"Android应用有两个方面的特点\"><a href=\"#Android应用有两个方面的特点\" class=\"headerlink\" title=\"Android应用有两个方面的特点\"></a>Android应用有两个方面的特点</h3><p><strong>特点一：</strong>具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。</p>\n<p><strong>特点二：</strong>自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;</p>\n<p>任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。</p>\n<p>在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 </p>\n<h3 id=\"Zygote：创建新的进程\"><a href=\"#Zygote：创建新的进程\" class=\"headerlink\" title=\"Zygote：创建新的进程\"></a>Zygote：创建新的进程</h3><p>Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。</p>\n<p><strong>init进程会启动Zygote进程</strong></p>\n<p><strong>Zygote</strong>进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。</p>\n<p><strong>在Zygote之后，init启动运行时的进程？</strong></p>\n<p>紧接着Zygote fork并启动一个称为system server的进程，<strong>system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。</strong></p>\n<h3 id=\"用户点击图标通过Launcher启动应用的过程\"><a href=\"#用户点击图标通过Launcher启动应用的过程\" class=\"headerlink\" title=\"用户点击图标通过Launcher启动应用的过程\"></a>用户点击图标通过Launcher启动应用的过程</h3><p>点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。</p>\n<ul>\n<li>1、收集intent的目标的信息，通过调用<code>PackageManager</code>对象中的<code>resolveIntent()</code>方法，默认使用<code>PackageManager.MATCH_DEFAULT_ONLY</code> 和     <code>PackageManager.GET_SHARED_LIBRARY_FILES</code>标志。</li>\n<li>2、目标信心会被存储至intent对象中，避免重复第一步工作；</li>\n<li>3、判断用户是否有权限调用intent中的组件，通过<code>grantUriPermissionLocked()</code>方法执行；</li>\n<li>4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：<code>FLAG_ACTIVITY_NEW_TASK</code> 或者其他flags<code>FLAG_ACTIVITY_CLEAR_TOP</code>；</li>\n<li>5、检查进程的<code>ProcessRecord</code>是否已经存在，如果<code>ProcessRecord</code>为空，ActivityManager需要创建一个新的进程来实例化目标组件。</li>\n</ul>\n<h3 id=\"在该应用启动流程中有三个不同的阶段\"><a href=\"#在该应用启动流程中有三个不同的阶段\" class=\"headerlink\" title=\"在该应用启动流程中有三个不同的阶段\"></a>在该应用启动流程中有三个不同的阶段</h3><ul>\n<li>1、进程创建</li>\n<li>2、绑定应用</li>\n<li>3、启动Activity/Service/调用intent receiver</li>\n</ul>\n<h4 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h4><p>ActivityManagerService通过调用<code>startProcessLocked()</code>方法来创建一个新的进程，<code>startProcessLocked</code>方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用<code>ZygoteInit.main()</code>方法，该方法会创建一个ActivityThread对象，并返回新建进程的id</p>\n<p>在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用<code>Looper.loop()</code>方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用<code>Looper.prepareLoop()</code>再掉用<code>Looper.loop()</code>方法启动message loop。</p>\n<h4 id=\"应用绑定\"><a href=\"#应用绑定\" class=\"headerlink\" title=\"应用绑定\"></a>应用绑定</h4><p>下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的<code>bindApplication()</code>方法来实现。该方法将<code>BIND_APPLICATION</code>信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——<code>handleBindApplication()</code>，该方法调用<code>makeApplication()</code>方法，<code>makeApplication()</code>方法将应用中特定的类加载到内存中执行。</p>\n<h2 id=\"启动APP-流程\"><a href=\"#启动APP-流程\" class=\"headerlink\" title=\"启动APP 流程\"></a>启动APP 流程</h2><p>用手机点击屏幕图标 —— 》startActivity —— 》 ActivityManagerService —— 》 根据启动的类名信息从缓存中心找到组件存档—— 》 通过反射( Class.forName()方式)找到Activity对象 ——》 所有被加载的Activity 的对象会被缓存到ActivityThread中</p>\n<p>注：AMS的缓存中心在 ActivityThread中，缓存活动Activity对象；<br>   PMS 缓存中心，用于缓存从AndroidManifest.xml解析的Android组件；</p>\n<p>App分为冷启动和热启动：热启动速度快一些</p>\n<h3 id=\"PMS源码解析\"><a href=\"#PMS源码解析\" class=\"headerlink\" title=\"PMS源码解析\"></a>PMS源码解析</h3><p>1、 在其中有main函数，是由SystemServer进行启动,手机开机，还没有进入Home界面时启动（Android logo在闪的时候）<br>添加PackageManager main函数源码图片</p>\n<p>将当前的PMS服务添加到ServicaManger中，</p>\n<p>构造方法 扫描文件，data为我们的安装目录，把当前目录全部扫描一遍</p>\n<p>2、</p>\n<p>注： ART和DVM在启动应用的时候没有区别，在安装的时候有区别。<br>Android 5.0 之前虚拟机以 class 字节码加载到内存，JAVA虚拟机转为本地指令，CPU执行本地指令<br>Android 5.0 之后ART 虚拟机，在安装的时候对class字节码转换为本地指令</p>\n<p>ART虚拟机：加载速度快，打包文件偏大，安装速度慢，以空间换时间<br>DVM虚拟机：加载速度慢，安装快</p>\n<h3 id=\"AMS缓存中心详解\"><a href=\"#AMS缓存中心详解\" class=\"headerlink\" title=\"AMS缓存中心详解\"></a>AMS缓存中心详解</h3><p>ActivityManager继承自ActivityManagerNative</p>\n<p>ActivityThread最终启动Activity，会经过一个进程间通信</p>\n<h2 id=\"Activity-在不同版本下的启动流程\"><a href=\"#Activity-在不同版本下的启动流程\" class=\"headerlink\" title=\"Activity 在不同版本下的启动流程\"></a>Activity 在不同版本下的启动流程</h2><h3 id=\"Android-9-0应用启动流程\"><a href=\"#Android-9-0应用启动流程\" class=\"headerlink\" title=\"Android 9.0应用启动流程\"></a>Android 9.0应用启动流程</h3><p>1、从<code>startActivity()</code>开始会一直调用到  <code>startActivityForResult(intent, -1, options)</code>中，其源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(<span class=\"meta\">@RequiresPermission</span> Intent intent, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          <span class=\"meta\">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          options = transferSpringboardActivityOptions(options);</span><br><span class=\"line\">          Instrumentation.ActivityResult ar =</span><br><span class=\"line\">              mInstrumentation.execStartActivity(</span><br><span class=\"line\">                  <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                  intent, requestCode, options);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              mMainThread.sendActivityResult(</span><br><span class=\"line\">                  mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class=\"line\">                  ar.getResultData());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// If this start is requesting a result, we can avoid making</span></span><br><span class=\"line\">              <span class=\"comment\">// the activity visible until the result is received.  Setting</span></span><br><span class=\"line\">              <span class=\"comment\">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class=\"line\">              <span class=\"comment\">// activity hidden during this time, to avoid flickering.</span></span><br><span class=\"line\">              <span class=\"comment\">// This can only be done when a result is requested because</span></span><br><span class=\"line\">              <span class=\"comment\">// that guarantees we will get information back when the</span></span><br><span class=\"line\">              <span class=\"comment\">// activity is finished, no matter what happens to it.</span></span><br><span class=\"line\">              mStartedActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          cancelInputsAndStartExitTransition(options);</span><br><span class=\"line\">          <span class=\"comment\">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode, options);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// Note we want to go through this method for compatibility with</span></span><br><span class=\"line\">              <span class=\"comment\">// existing applications that may have overridden it.</span></span><br><span class=\"line\">              mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在startActivityForResult()中会调用Instrumentation中的 mInstrumentation.execStartActivity()方法，</p>\n<p>Instrumentation.execStartActivity()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Context who, IBinder contextThread, IBinder token, String target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Intent intent, <span class=\"keyword\">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    result = am.onStartActivity(intent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    am.mHits++;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    am.mHits++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        intent.migrateExtraStreamToClipData();</span><br><span class=\"line\">        intent.prepareToLeaveProcess(who);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityTaskManager.getService()</span><br><span class=\"line\">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class=\"line\">                    intent.resolvetypeIfNeeded(who.getContentResolver()),</span><br><span class=\"line\">                    token, target, requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</span><br><span class=\"line\">        checkStartActivityResult(result, intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failure from system&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>获取IActivityManger，IActivityManger.getService()</p>\n<p>//.startActivity<br>IActivityManger.startActivity(); (应用所在进程) ————》 Binder机制 ——》 AMS(系统进程)</p>\n<h3 id=\"Android-7-0-启动流程\"><a href=\"#Android-7-0-启动流程\" class=\"headerlink\" title=\"Android 7.0 启动流程\"></a>Android 7.0 启动流程</h3><p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）</p>\n<p>分析 ClassLoader Java中的 ClassLoader 和Android中的ClassLoader不一样:<br>        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想</p>\n<p>Android的ClassLoader在启动的过程中在ActivityThread中有调用         </p>\n<p>Android中的ClassLoader =PathClassLoader</p>\n<p>Android中ClassLoader的过程：<br>    1、Java中的ClassLo</p>\n<p>//如果开发插件化，需要在AMS.startActivity() 之前添加Hook</p>\n<p>类继承关系  <code>ActivityManagerService extends ActivityManagerNative</code><br>          <code> ActivityManagerNative extends Binder implements IActivityManager</code></p>\n<h4 id=\"从startActivity开始\"><a href=\"#从startActivity开始\" class=\"headerlink\" title=\"从startActivity开始\"></a>从startActivity开始</h4><p>启动Activity时，会从<code>startActivity()</code>方法一直调用到<code>Activity</code>中的<code>startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) </code>方法<br>其源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(<span class=\"meta\">@RequiresPermission</span> Intent intent, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Instrumentation.ActivityResult ar =</span><br><span class=\"line\">            mInstrumentation.execStartActivity(</span><br><span class=\"line\">                <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                intent, requestCode, options);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mMainThread.sendActivityResult(</span><br><span class=\"line\">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class=\"line\">                ar.getResultData());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If this start is requesting a result, we can avoid making</span></span><br><span class=\"line\">            <span class=\"comment\">// the activity visible until the result is received.  Setting</span></span><br><span class=\"line\">            <span class=\"comment\">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity hidden during this time, to avoid flickering.</span></span><br><span class=\"line\">            <span class=\"comment\">// This can only be done when a result is requested because</span></span><br><span class=\"line\">            <span class=\"comment\">// that guarantees we will get information back when the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity is finished, no matter what happens to it.</span></span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cancelInputsAndStartExitTransition(options);</span><br><span class=\"line\">        <span class=\"comment\">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode, options);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Note we want to go through this method for compatibility with</span></span><br><span class=\"line\">            <span class=\"comment\">// existing applications that may have overridden it.</span></span><br><span class=\"line\">            mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在startActivityForResult()方法中会调用<code>Instrumentation</code>中的<code>execStartActivity()</code>方法，其源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Context who, IBinder contextThread, IBinder token, String target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Intent intent, <span class=\"keyword\">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">      IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                      am.mHits++;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                          <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          intent.migrateExtraStreamToClipData();</span><br><span class=\"line\">          intent.prepareToLeaveProcess(who);</span><br><span class=\"line\">          <span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</span><br><span class=\"line\">              .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class=\"line\">                      intent.resolvetypeIfNeeded(who.getContentResolver()),</span><br><span class=\"line\">                      token, target, requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</span><br><span class=\"line\">          checkStartActivityResult(result, intent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failure from system&quot;</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>Instrumentation</code>中的<code>execStartActivity()</code>方法中会调用 <code> ActivityManagerNative.getDefault().startActivity()</code>启动Activity</p>\n<p><code>ActivityManagerNative.getDefault()</code>方法获取的是一个接口，该接口是用于域AMS进行通信的接口，返回<code>IActivityManager</code>，其源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> gDefault.get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p> IActivityManager实现了一个AIDL的接口，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IActivityManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">IInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String resolvedtype, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProfilerInfo profilerInfo, Bundle options)</span> <span class=\"keyword\">throws</span> RemoteException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Retrieve the Binder object associated with this interface.</span></span><br><span class=\"line\"><span class=\"comment\">     * You must use this instead of a plain cast, so that proxy objects</span></span><br><span class=\"line\"><span class=\"comment\">     * can return the correct result.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">asBinder</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>IActivityManager 类中调用startActivity最终会调用 ActivityManagerService中的 <code> startActivity()</code>方法，</p>\n","site":{"data":{}},"excerpt":"<p>1、Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。<br>2、AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br>3、Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。<br>4、淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。<br>5、淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。<br>6、AMS通知淘宝绑定Application并启动MainActivity。<br>7、淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</p>","more":"<h2 id=\"Linux-系统加载流程\"><a href=\"#Linux-系统加载流程\" class=\"headerlink\" title=\"Linux 系统加载流程\"></a>Linux 系统加载流程</h2><p>Linux 内核加载 ——》init 进程（守护进程） ——》 系统服务 ——》Android Runtime(虚拟机) </p>\n<h3 id=\"Linux-内核加载\"><a href=\"#Linux-内核加载\" class=\"headerlink\" title=\"Linux 内核加载\"></a>Linux 内核加载</h3><h3 id=\"init-进程（守护进程）\"><a href=\"#init-进程（守护进程）\" class=\"headerlink\" title=\"init 进程（守护进程）\"></a>init 进程（守护进程）</h3><pre><code>定义：是Linux内核启动的第一个用户级进程，init进程主要任务为启动Android关键服务，守护关键服务进程，确保其不会被杀死；\nInit与Android之间的关系：当Linux内核启动后，通过启动用户级程序init来完成引导Android Framework的建立，因此init总是第一个进程（其进程号PID总是1,其父进程PID为0）。\n在init进程中启动关键服务：\n     多媒体服务、网络服务、音量服务、蓝牙服务、USB服务、日志服务、电话服务、事件服务、Zygote服务\n     关键服务在内存不足的时候不会被kill掉，如果被kill掉，会被init进程拉起来。关键服务不对下面的进程负责，即下面的进程kill掉后，不会被重新拉起。</code></pre>\n<p>注：Andorid模拟器打开后在根目录下会有init文件(Nexus_5x中)，它是可执行文件由init.cpp文件编译出来的，删掉后重启会再次生成。<br>    init.cpp在源码中的system/core/init路径下，在该文件中有main函数<br>    inti.cpp解析了一个根目录 “/init.rc”文件（模拟器根目录下有，但修改这一个文件没有用），在配置文件中可以定制化启动服务，只能在Android系统编译前进行清理<br>    源码中的system/文件夹下的都是系统服务 ，自定义服务需要写在system/extras文件下，服务中都有Android.mk, .ccp文件 .h文件</p>\n<p> 定制化Android系统服务：<br>    目的：自定义服务可以做到开机启动到自己的App界面，完整定制化Android系统；<br>    需求：适合定制开发，如：车载设备、智能家居设备，手表，手机厂商<br>    缺点：1、只适合针对机型定制化，需要编译Android和刷盘<br>         2、只能启动c文件可执行文件（含有main函数），然后通过c反射执行Java代码<br>    过程：系统源码下 —— 》写入C文件 —— 》 写入Android.mk文件 —— 》 在init.rc 中添加服务 —— 》 编译Andoid系统 —— 》刷盘<br>    在init.rc添加的服务通常具有root权限</p>\n<p>Android源码编译方式  <a href=\"https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098582\">https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098582</a> </p>\n<h4 id=\"Android-init进程守护过程\"><a href=\"#Android-init进程守护过程\" class=\"headerlink\" title=\"Android init进程守护过程\"></a>Android init进程守护过程</h4><pre><code>init守护进程时，通过socket与被守护服务建立长连接，如果read阻塞，则重启服务</code></pre>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 查看进程号码 --&gt;</span></span><br><span class=\"line\">adb shell</span><br><span class=\"line\">ps</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 杀死进程 --&gt;</span></span><br><span class=\"line\"> kill -9 进程号</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Android应用启动从Zygote到Activity-onCreate\"><a href=\"#Android应用启动从Zygote到Activity-onCreate\" class=\"headerlink\" title=\"Android应用启动从Zygote到Activity.onCreate\"></a>Android应用启动从Zygote到Activity.onCreate</h2><p>开机 —— 》 init进程启动 —— 》 解析init.rc —— 》 启动 Zygote 服务 —— 》 启动SystemSevice进程 —— 》 进入Home应用</p>\n<p>Zygote进程在启动时，会扫描所有安装到手机的应用，使用PSM 对data/app文件进行扫描，通过PackageParse解析，AndoridManifest.xml，对每一个组件进行保存，会将扫描的内容缓存到缓存中心（Packages），启动一个应用的只会给包名，通过包名找到PSM缓存的类，进行加载。</p>\n<p>注：<br>    *  使用AndroidManifest.xml文件会加快Android的启动的速度<br>    *  PMS进程是在Zygote进程启动的时候进行启动的，运行在单独进程<br>    *  AndroidManifest.xml文件通过PackageParser进行解析<br>    *  PMS启动的扫描过程会消耗大量的时间</p>\n<p>本文从点击Android应用图标开始介绍Android应用的启动过程</p>\n<h3 id=\"Android应用有两个方面的特点\"><a href=\"#Android应用有两个方面的特点\" class=\"headerlink\" title=\"Android应用有两个方面的特点\"></a>Android应用有两个方面的特点</h3><p><strong>特点一：</strong>具有多个入口，Android应用由多个组件组成，而且他们可以调用其他应用的组件。组件可以成为应用的多个入口，因此Android应用不像传统的应用只有类似于main()函数的启动入口。</p>\n<p><strong>特点二：</strong>自己的运行空间，每个Android应用都运行在独立的进程中，具有自己的Dalvik虚拟机实例，并且被指定了唯一的userId;</p>\n<p>任何用户或者其他的组件请求你的应用组件（service、activitry）执行，如果你的App没有在运行，操作系统会为App启动一个新的进程。</p>\n<p>在默认的情况下，每一个Android应用都运行在自己的进程中，即一个Linux进程，改Linux进程拥有一个可以启动的线程。 </p>\n<h3 id=\"Zygote：创建新的进程\"><a href=\"#Zygote：创建新的进程\" class=\"headerlink\" title=\"Zygote：创建新的进程\"></a>Zygote：创建新的进程</h3><p>Android操作系统在启动的过程：Boot加载系统内核，并启动init进程，init进程再创建Linux中低等级的守护进程（daemons）,例如：debug daemons、USB daemons，这些守护进程用于控制低级的硬件接口。</p>\n<p><strong>init进程会启动Zygote进程</strong></p>\n<p><strong>Zygote</strong>进程可以初始化第一个Dalvik虚拟机实例，同时也提前加载Android层通用的类和系统中不同的应用。会在套接字接口上监听创建新的虚拟机的请求，以及管理新的应用进程。一旦获取创建虚拟机的请求，Zygote会将自己fork创建一个新的进程，并提前初始化虚拟机的实例。</p>\n<p><strong>在Zygote之后，init启动运行时的进程？</strong></p>\n<p>紧接着Zygote fork并启动一个称为system server的进程，<strong>system server会启动所有的核心服务包括：activity manager service、hardware services在其自己的context中。</strong></p>\n<h3 id=\"用户点击图标通过Launcher启动应用的过程\"><a href=\"#用户点击图标通过Launcher启动应用的过程\" class=\"headerlink\" title=\"用户点击图标通过Launcher启动应用的过程\"></a>用户点击图标通过Launcher启动应用的过程</h3><p>点击事件会被转换为startActivity(intent)并通过Binder IPC将事件转换到ActivityManagerService，在ActivityManagerService中执行很多操作步骤。</p>\n<ul>\n<li>1、收集intent的目标的信息，通过调用<code>PackageManager</code>对象中的<code>resolveIntent()</code>方法，默认使用<code>PackageManager.MATCH_DEFAULT_ONLY</code> 和     <code>PackageManager.GET_SHARED_LIBRARY_FILES</code>标志。</li>\n<li>2、目标信心会被存储至intent对象中，避免重复第一步工作；</li>\n<li>3、判断用户是否有权限调用intent中的组件，通过<code>grantUriPermissionLocked()</code>方法执行；</li>\n<li>4、如果用户有足够的权限，ActivityManagerService会去检查目标activity是否需要在新的task中进行启动。task的创建依赖于intent的标志(flags)如：<code>FLAG_ACTIVITY_NEW_TASK</code> 或者其他flags<code>FLAG_ACTIVITY_CLEAR_TOP</code>；</li>\n<li>5、检查进程的<code>ProcessRecord</code>是否已经存在，如果<code>ProcessRecord</code>为空，ActivityManager需要创建一个新的进程来实例化目标组件。</li>\n</ul>\n<h3 id=\"在该应用启动流程中有三个不同的阶段\"><a href=\"#在该应用启动流程中有三个不同的阶段\" class=\"headerlink\" title=\"在该应用启动流程中有三个不同的阶段\"></a>在该应用启动流程中有三个不同的阶段</h3><ul>\n<li>1、进程创建</li>\n<li>2、绑定应用</li>\n<li>3、启动Activity/Service/调用intent receiver</li>\n</ul>\n<h4 id=\"进程创建\"><a href=\"#进程创建\" class=\"headerlink\" title=\"进程创建\"></a>进程创建</h4><p>ActivityManagerService通过调用<code>startProcessLocked()</code>方法来创建一个新的进程，<code>startProcessLocked</code>方法通过socket连接将参数传递给Zygote进程。Zygote将自己fork，然后调用<code>ZygoteInit.main()</code>方法，该方法会创建一个ActivityThread对象，并返回新建进程的id</p>\n<p>在默认情况先每一个进程都会获取一个线程，在主线程中有一个Looper实例通过调用<code>Looper.loop()</code>方法处理从message queue中的message，在Looper每一次运行run()方法时。Looper的作用是从message queue中取出相应message并调用相应的方法来处理它们。ActivityThread通过调用<code>Looper.prepareLoop()</code>再掉用<code>Looper.loop()</code>方法启动message loop。</p>\n<h4 id=\"应用绑定\"><a href=\"#应用绑定\" class=\"headerlink\" title=\"应用绑定\"></a>应用绑定</h4><p>下一步是将新创建的进程绑定至特定的应用上，通过调用线程中的<code>bindApplication()</code>方法来实现。该方法将<code>BIND_APPLICATION</code>信息发送至message queue，该Message通过Handler对象检索，然后调用handlerMessage()方法来触发该message具有的特殊方法——<code>handleBindApplication()</code>，该方法调用<code>makeApplication()</code>方法，<code>makeApplication()</code>方法将应用中特定的类加载到内存中执行。</p>\n<h2 id=\"启动APP-流程\"><a href=\"#启动APP-流程\" class=\"headerlink\" title=\"启动APP 流程\"></a>启动APP 流程</h2><p>用手机点击屏幕图标 —— 》startActivity —— 》 ActivityManagerService —— 》 根据启动的类名信息从缓存中心找到组件存档—— 》 通过反射( Class.forName()方式)找到Activity对象 ——》 所有被加载的Activity 的对象会被缓存到ActivityThread中</p>\n<p>注：AMS的缓存中心在 ActivityThread中，缓存活动Activity对象；<br>   PMS 缓存中心，用于缓存从AndroidManifest.xml解析的Android组件；</p>\n<p>App分为冷启动和热启动：热启动速度快一些</p>\n<h3 id=\"PMS源码解析\"><a href=\"#PMS源码解析\" class=\"headerlink\" title=\"PMS源码解析\"></a>PMS源码解析</h3><p>1、 在其中有main函数，是由SystemServer进行启动,手机开机，还没有进入Home界面时启动（Android logo在闪的时候）<br>添加PackageManager main函数源码图片</p>\n<p>将当前的PMS服务添加到ServicaManger中，</p>\n<p>构造方法 扫描文件，data为我们的安装目录，把当前目录全部扫描一遍</p>\n<p>2、</p>\n<p>注： ART和DVM在启动应用的时候没有区别，在安装的时候有区别。<br>Android 5.0 之前虚拟机以 class 字节码加载到内存，JAVA虚拟机转为本地指令，CPU执行本地指令<br>Android 5.0 之后ART 虚拟机，在安装的时候对class字节码转换为本地指令</p>\n<p>ART虚拟机：加载速度快，打包文件偏大，安装速度慢，以空间换时间<br>DVM虚拟机：加载速度慢，安装快</p>\n<h3 id=\"AMS缓存中心详解\"><a href=\"#AMS缓存中心详解\" class=\"headerlink\" title=\"AMS缓存中心详解\"></a>AMS缓存中心详解</h3><p>ActivityManager继承自ActivityManagerNative</p>\n<p>ActivityThread最终启动Activity，会经过一个进程间通信</p>\n<h2 id=\"Activity-在不同版本下的启动流程\"><a href=\"#Activity-在不同版本下的启动流程\" class=\"headerlink\" title=\"Activity 在不同版本下的启动流程\"></a>Activity 在不同版本下的启动流程</h2><h3 id=\"Android-9-0应用启动流程\"><a href=\"#Android-9-0应用启动流程\" class=\"headerlink\" title=\"Android 9.0应用启动流程\"></a>Android 9.0应用启动流程</h3><p>1、从<code>startActivity()</code>开始会一直调用到  <code>startActivityForResult(intent, -1, options)</code>中，其源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(<span class=\"meta\">@RequiresPermission</span> Intent intent, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          <span class=\"meta\">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          options = transferSpringboardActivityOptions(options);</span><br><span class=\"line\">          Instrumentation.ActivityResult ar =</span><br><span class=\"line\">              mInstrumentation.execStartActivity(</span><br><span class=\"line\">                  <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                  intent, requestCode, options);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              mMainThread.sendActivityResult(</span><br><span class=\"line\">                  mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class=\"line\">                  ar.getResultData());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// If this start is requesting a result, we can avoid making</span></span><br><span class=\"line\">              <span class=\"comment\">// the activity visible until the result is received.  Setting</span></span><br><span class=\"line\">              <span class=\"comment\">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class=\"line\">              <span class=\"comment\">// activity hidden during this time, to avoid flickering.</span></span><br><span class=\"line\">              <span class=\"comment\">// This can only be done when a result is requested because</span></span><br><span class=\"line\">              <span class=\"comment\">// that guarantees we will get information back when the</span></span><br><span class=\"line\">              <span class=\"comment\">// activity is finished, no matter what happens to it.</span></span><br><span class=\"line\">              mStartedActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          cancelInputsAndStartExitTransition(options);</span><br><span class=\"line\">          <span class=\"comment\">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode, options);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// Note we want to go through this method for compatibility with</span></span><br><span class=\"line\">              <span class=\"comment\">// existing applications that may have overridden it.</span></span><br><span class=\"line\">              mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在startActivityForResult()中会调用Instrumentation中的 mInstrumentation.execStartActivity()方法，</p>\n<p>Instrumentation.execStartActivity()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Context who, IBinder contextThread, IBinder token, String target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Intent intent, <span class=\"keyword\">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class=\"line\">                ActivityResult result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class=\"line\">                    result = am.onStartActivity(intent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    am.mHits++;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                    am.mHits++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        intent.migrateExtraStreamToClipData();</span><br><span class=\"line\">        intent.prepareToLeaveProcess(who);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityTaskManager.getService()</span><br><span class=\"line\">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class=\"line\">                    intent.resolvetypeIfNeeded(who.getContentResolver()),</span><br><span class=\"line\">                    token, target, requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</span><br><span class=\"line\">        checkStartActivityResult(result, intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failure from system&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>获取IActivityManger，IActivityManger.getService()</p>\n<p>//.startActivity<br>IActivityManger.startActivity(); (应用所在进程) ————》 Binder机制 ——》 AMS(系统进程)</p>\n<h3 id=\"Android-7-0-启动流程\"><a href=\"#Android-7-0-启动流程\" class=\"headerlink\" title=\"Android 7.0 启动流程\"></a>Android 7.0 启动流程</h3><p>startActivity ———》 Activity ———》 mInstrumentation.execStartActivity() ————》 ActivityManagerNative.getDefault().startActivity() ——》 AMS.startActivity(检测，当前要启动的Activity是都注册) ———》 ActivityThread(即将加载)————》（handleLaunchActivity 类加载 Activity performLaunchActivity）</p>\n<p>分析 ClassLoader Java中的 ClassLoader 和Android中的ClassLoader不一样:<br>        Java中的ClassLoader以Jar包为中心思想，而Android中以dex文件为中心思想</p>\n<p>Android的ClassLoader在启动的过程中在ActivityThread中有调用         </p>\n<p>Android中的ClassLoader =PathClassLoader</p>\n<p>Android中ClassLoader的过程：<br>    1、Java中的ClassLo</p>\n<p>//如果开发插件化，需要在AMS.startActivity() 之前添加Hook</p>\n<p>类继承关系  <code>ActivityManagerService extends ActivityManagerNative</code><br>          <code> ActivityManagerNative extends Binder implements IActivityManager</code></p>\n<h4 id=\"从startActivity开始\"><a href=\"#从startActivity开始\" class=\"headerlink\" title=\"从startActivity开始\"></a>从startActivity开始</h4><p>启动Activity时，会从<code>startActivity()</code>方法一直调用到<code>Activity</code>中的<code>startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) </code>方法<br>其源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(<span class=\"meta\">@RequiresPermission</span> Intent intent, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Instrumentation.ActivityResult ar =</span><br><span class=\"line\">            mInstrumentation.execStartActivity(</span><br><span class=\"line\">                <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                intent, requestCode, options);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mMainThread.sendActivityResult(</span><br><span class=\"line\">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class=\"line\">                ar.getResultData());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If this start is requesting a result, we can avoid making</span></span><br><span class=\"line\">            <span class=\"comment\">// the activity visible until the result is received.  Setting</span></span><br><span class=\"line\">            <span class=\"comment\">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity hidden during this time, to avoid flickering.</span></span><br><span class=\"line\">            <span class=\"comment\">// This can only be done when a result is requested because</span></span><br><span class=\"line\">            <span class=\"comment\">// that guarantees we will get information back when the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity is finished, no matter what happens to it.</span></span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cancelInputsAndStartExitTransition(options);</span><br><span class=\"line\">        <span class=\"comment\">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode, options);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Note we want to go through this method for compatibility with</span></span><br><span class=\"line\">            <span class=\"comment\">// existing applications that may have overridden it.</span></span><br><span class=\"line\">            mParent.startActivityFromChild(<span class=\"keyword\">this</span>, intent, requestCode);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在startActivityForResult()方法中会调用<code>Instrumentation</code>中的<code>execStartActivity()</code>方法，其源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Context who, IBinder contextThread, IBinder token, String target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Intent intent, <span class=\"keyword\">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">      IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mActivityMonitors != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = mActivityMonitors.size();</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (am.match(who, <span class=\"keyword\">null</span>, intent)) &#123;</span><br><span class=\"line\">                      am.mHits++;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (am.isBlocking()) &#123;</span><br><span class=\"line\">                          <span class=\"keyword\">return</span> requestCode &gt;= <span class=\"number\">0</span> ? am.getResult() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          intent.migrateExtraStreamToClipData();</span><br><span class=\"line\">          intent.prepareToLeaveProcess(who);</span><br><span class=\"line\">          <span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</span><br><span class=\"line\">              .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class=\"line\">                      intent.resolvetypeIfNeeded(who.getContentResolver()),</span><br><span class=\"line\">                      token, target, requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</span><br><span class=\"line\">          checkStartActivityResult(result, intent);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Failure from system&quot;</span>, e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在<code>Instrumentation</code>中的<code>execStartActivity()</code>方法中会调用 <code> ActivityManagerNative.getDefault().startActivity()</code>启动Activity</p>\n<p><code>ActivityManagerNative.getDefault()</code>方法获取的是一个接口，该接口是用于域AMS进行通信的接口，返回<code>IActivityManager</code>，其源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> gDefault.get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p> IActivityManager实现了一个AIDL的接口，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IActivityManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">IInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String resolvedtype, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProfilerInfo profilerInfo, Bundle options)</span> <span class=\"keyword\">throws</span> RemoteException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Retrieve the Binder object associated with this interface.</span></span><br><span class=\"line\"><span class=\"comment\">     * You must use this instead of a plain cast, so that proxy objects</span></span><br><span class=\"line\"><span class=\"comment\">     * can return the correct result.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">asBinder</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>IActivityManager 类中调用startActivity最终会调用 ActivityManagerService中的 <code> startActivity()</code>方法，</p>"},{"title":"Glide手写框架实现","type":["Android"],"description":"Glide手写框架实现","cover":"/cover/img92.jpg","toc":true,"date":"2019-05-07T16:00:00.000Z","_content":"\n# Glide手写框架实现\n\n## 实现步骤\n\nGlide框架实现主要有以下步骤\n\n图片下载后，先缓存至活动缓存；在获取缓存中通过弱引用监控bitMap的回收，如果活动缓存中bitMap的弱引用被回收，那么会将活动缓存中的bitMap，缓存至内存缓存；当图片被再次使用会从内存缓存中移除，添加到活动缓存中；\n\n\n* 活动缓存的实现\n\n* 内存缓存的实现\n\n* 磁盘缓存的实现\n\n* 声明周期的管理\n\n### 实现前的准备\n\n1、在图片加载的过程中，采用<Key,BitMap>的形式获取图片对象；在使用的过程中，需要对图片文件的名称和路径进行加密，定义一个专门的类对名称和路径进行加密和解密，这样可以避免图片路径过长的问题。\n\n```java\npublic class Path {\n\n    private String key;  //例如  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311\n\n    /**\n     * 加密前 sha256 (https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90cm01Vk1lRnA5blVESWdHaWJkVnlFSnk3MmlieVdXOElDWGlhamZDNlliNTc3YnVRTUdtYmUxR1hxSmhwVjNvUzhyWktENTIzODNVZDFpYkh6VTJDakxrUUEvNjQw?x-oss-process=image/format,png)\n     * 加密后  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311\n     * @param key\n     */\n    public Path(String key) {\n        this.key = Tool.getSHA256StrJava( key);\n    }\n\n    //添加getter和setter方法。\n}\n\n```\n\n2、在使用的过程中，需要对BitMap的使用状态以及回收状态进行处理，设置一个专门的类进行管理。在对BitMap进行管理的过程中，需要对BitMap的引用次数进行标记，当引用次数等于零时，回收BitMap的空间；BitMap回收采用回调的方式由外部进行回收\n\n回调接口\n\n```java\npublic interface ValueCallback {\n\n    //活动缓存监听的方法（BitMap不再使用了）\n    public void valueNonUseAction(String path, BitMapValue bitMapValue);\n}\n\n```\n\n在BitMap中 `bitmap`变量用于持有正在使用的图片对象，`count`变量用于对该对象的引用进行计数，会进行加一或者减一操作，`path`变量用于标记图片的路路径，`valueCallback`用于引用次数为零时的回调；\n\n```java\n\npublic class BitMapValue {\n\n    private BitMapValue(){}\n\n    //采用单利模式\n    private static BitMapValue bitMapValue;\n    \n    public static BitMapValue getInstance(){\n        //.....\n        //省略单例实现\n        return bitMapValue;\n    }\n\n    private Bitmap bitmap;\n\n    private int count;\n\n    //互动缓存监听\n    private ValueCallback valueCallback;\n\n    private String path;\n\n    public void useAction(){\n        if (bitmap.isRecycled()){   //已经被回收\n            return;\n        }\n        count++;\n\n    }\n\n    public void nonUseAction(){\n        count--;\n        if (count<=0){\n            valueCallback.valueNonUseAction(path,this);\n            recycleBitmap();\n        };\n    }\n\n    //释放bitmap\n    public void recycleBitmap(){\n    \n        bitmap.recycle();\n\n        bitMapValue =null;\n\n        System.gc();\n    }\n    //添加getter和setter方法\n}\n\n\n```\n\n### 活动缓存的实现\n活动缓存用于存储应用中正在使用的图片资源，采用弱引用的方式便于系统及时回收；在活动缓存中采用<Path,Bitmap>的方式表示的正在使用的图片信息;\n\n在活动缓存中需要对被回收的对象的引用进行监听，当对象被回收后，需要将其加入到内存缓存中。\n\n变量`Map<String, WeakReference<BitMapValue>>mapList`用于持有缓存对象的弱引用，`mapList`的`value`是一个弱引用，会被自动回收，需要对该弱引用的回收做监听，处理弱引用回收后的操作，因此需要创建一个`CustomWeakReference`内部类；\n\n变量`Map<String, Bitmap>mapValueList`用于持有缓存对象的引用，其中保存的对象与`mapList`中的对象一致，`mapList`中的弱引用被回收后，需要通过获取`mapValueList`中的Bitmap对象，将其缓存至内存缓存中；\n\n变量`ReferenceQueue<BitMapValue>queue` 将`BitMapValue`的弱引用添加到该队列中，通过调用`remove`这一阻塞方法监听弱引用是否被回收。\n\n变量`boolean isCloseThread` 用于监听是否将弱引用回收监听的线程进行停止；\n\n变量`Thread thread` 用于表示弱引用回收监听线程\n\n\n\n方法` put(String path, BitMapValue bitMapValue)`用于添加活动缓存；\n方法`get(String key)`用于获取活动缓存；\n方法` closeActiveCache()`用于关闭活动缓存\n\n内部类 `class CustomWeakReference `用于在弱引用被回收后，获取该 BitMapValue 的 path和bitmap\n\n\n\n```java\n\npublic class ActiveCache {\n\n\n    private Map<String, WeakReference<BitMapValue>>mapList=new HashMap<>();\n\n    private Map<String, Bitmap>mapValueList=new HashMap<>();\n\n    private ReferenceQueue<BitMapValue>queue;    //目的：为了监听弱引用是否被回收\n\n    private boolean isCloseThread;\n\n    private Thread thread;\n\n\n    private ValueCallback valueCallback;\n\n    public ActiveCache(ValueCallback valueCallback){\n        this.valueCallback=valueCallback;\n    }\n\n    /**\n     * TODO 添加活动缓存\n     * @param path\n     * @param bitMapValue\n     */\n    public void put(String path, BitMapValue bitMapValue){\n\n        Tool.checkNotEmpty(path);\n\n        //绑定Value的监听，Value没有被使用了，就会发起这个监听，给外界业务需要来使用)\n        bitMapValue.setValueCallback(valueCallback);\n\n        mapList.put(path,new CustomWeakReference(bitMapValue,getQueue(),path));\n\n        mapValueList.put(path,bitMapValue.getBitmap());\n    }\n\n\n    /**\n     * TODO 给外界获取value\n     * @param path\n     * @return\n     */\n    public BitMapValue get(String path){\n        WeakReference<BitMapValue>valueWeakReference=mapList.get(path);\n        if (null!=valueWeakReference){\n            BitMapValue value=valueWeakReference.get();   //返回value\n            value.setBitmap(mapValueList.get(path));\n            value.setPath(path);\n            return value;   //返回value\n        }\n        return null;\n\n    }\n\n    //主动释放内存缓存，并将线程进行关闭\n    public void closeActiveCache(){\n        isCloseThread=true;\n        mapList.clear();;\n        System.gc();\n    }\n\n\n    //监听弱引用，成为弱引用的子类，为了监听弱引用是否被回收，并获取弱引用回收后的 path和 BitMapValue\n    public class CustomWeakReference extends WeakReference<BitMapValue>{\n\n        private String path;\n        private BitMapValue value;\n\n        public CustomWeakReference(BitMapValue referent, ReferenceQueue<? super BitMapValue> q,String path) {\n            super(referent, q);\n            this.path =path;\n            this.value=referent;\n        }\n\n    }\n\n\n    //创建弱引用队列，并对弱引用的回收进行监听\n    private ReferenceQueue<BitMapValue>getQueue(){\n        if (queue==null){\n            queue=new ReferenceQueue<>();\n            thread= new Thread(){\n                @Override\n                public void run() {\n                    super.run();\n                    while (!isCloseThread){\n                        try {\n                            //阻塞式方法 如果有引用被回收，则会执行该方法，并返回被回收的对象\n                            Reference<? extends BitMapValue> remove = queue.remove(); \n                            CustomWeakReference weakReference = (CustomWeakReference) remove;\n\n                             //将引用移除容器\n                            if (mapList != null && !mapList.isEmpty()) {\n                                    mapList.remove(weakReference.path);\n                                    mapValueList.remove(weakReference.path);\n                            }\n\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        } } }\n            };\n            thread.start();\n        }\n        return queue;\n    }\n}\n\n\n\n```\n\n### 内存缓存的实现\n\n内存缓存将使用的图片资源缓存至内存中，采用LRU算法进行回收,继承`LruCache<K, V>`接口，并在初始化的时候设置图片缓存的最大值。内存缓存的图片在每一次调用之后，都会进行移除后再次加入到活动缓存中；\n\n与活动缓存一样，内存缓存在缓存中的BitMapValue被移除后，需要进行回调，内存缓存回调接口如下：\n\n```\npublic interface MemoryCacheCallback {\n\n    /**\n     * 内存缓存中移除的path\n     * @param path\n     * @param oldBitMapValue\n     */\n    public void entryRemoveMemoryCache(String path,@NonNull BitMapValue oldBitMapValue);\n}\n\n```\n内存缓存的源码如下：\n\n```java\npublic class MemoryCache extends LruCache <String, BitMapValue>{\n\n    private boolean manualRemove;\n\n    //TODO 手动移除 Manual\n    public BitMapValue manualRemove(String path){\n        manualRemove=true;\n       BitMapValue bitMapValue =remove(path);\n        manualRemove=false;\n       return bitMapValue;\n    }\n\n\n    private MemoryCacheCallback memoryCacheCallback;\n\n    public void setMemoryCacheCallback(MemoryCacheCallback memoryCacheCallback) {\n        this.memoryCacheCallback = memoryCacheCallback;\n    }\n\n    // 传入元素最大值给 LruCache\n    public MemoryCache(int maxSize) {\n        super(maxSize);\n    }\n\n    @Override\n    protected int sizeOf(@NonNull String key, @NonNull BitMapValue bitMapValue) {\n//        return super.sizeOf(key, value);\n        Bitmap bitmap= bitMapValue.getBitmap();\n\n        //最开始的的时候\n//        int result=bitmap.getRowBytes()*bitmap.getHeight();\n        //API 12  3.0\n//        int result=bitmap.getByteCount();  //bitmap内存复用上有区别(所属的)\n        //API 19 4.4\n//        int result=bitmap.getAllocationByteCount();//bitmap内存复用上有区别(整个的)\n        int sdkInt= Build.VERSION.SDK_INT;\n        if (sdkInt>=Build.VERSION_CODES.KITKAT){\n            return bitmap.getAllocationByteCount();\n        }\n\n        return bitmap.getByteCount();\n\n    }\n\n    /**\n     * 1. 重复的key\n     * 2. 最少使用的元素会被移除\n     * @param evicted\n     * @param key\n     * @param oldBitMapValue\n     * @param newBitMapValue\n     */\n\n    @Override\n    protected void entryRemoved(boolean evicted, @NonNull String key, @NonNull BitMapValue oldBitMapValue, @Nullable BitMapValue newBitMapValue) {\n        super.entryRemoved(evicted, key, oldBitMapValue, newBitMapValue);\n        if (memoryCacheCallback!=null&&!manualRemove){  //被动删除\n            memoryCacheCallback.entryRemoveMemoryCache(key, oldBitMapValue);\n        }\n    }\n}\n\n\n```\n\n### 磁盘缓存的实现\n\n以文件的形式保存至本地磁盘，文件名称需要通过`Path`类进行设置，在磁盘缓存中借助于 https://github.com/JakeWharton/DiskLruCache 中的  `DiskLruCache.java` `StrictLineReader.java` `Util.java ` 并对DiskLruCache进行封装。在封装的过程中，需要指定磁盘缓存的路径、缓存文件的最大值，以及put和get方法\n\n```java\npublic class DiskLruCacheImpl {\n\n    //SD/disk_lru_cache_dir/ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311\n    private final String DISKLRU_CACHE_DIR=\"disk_lru_cache_dir\";  //磁盘缓存的目录\n\n    private final int APP_VERSION=1;   //我们的版本号，一旦修改这个版本号，之前的缓存失效\n\n    private final int VALUE_COUNT=1;  //通常情况下是1\n\n    private final long MAX_SIZE=1024*1024*10l; //指定缓存文件最大值\n\n    private DiskLruCache diskLruCache;\n\n    public DiskLruCacheImpl() {\n\n        File file=new File(Environment.getExternalStorageDirectory()+File.separator+DISKLRU_CACHE_DIR);\n\n\n        try {\n            diskLruCache= DiskLruCache.open(file,APP_VERSION,VALUE_COUNT,MAX_SIZE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    //TODO put\n    public void put(String path){\n\n        DiskLruCache.Editor editor=null;\n\n        OutputStream outputStream=null;\n\n        try {\n            editor=diskLruCache.edit(path);\n\n           outputStream=editor.newOutputStream(0);  //index不能大于 VALUE_COUNT\n\n            Bitmap bitmap= bitMapValue.getBitmap();\n\n            bitmap.compress(Bitmap.CompressFormat.PNG,100,outputStream);  //吧把BitMap 写入outputStream\n\n            outputStream.flush();\n\n        } catch (IOException e) {\n            //....省略\n        }\n\n        //....省略提交，流输出、关闭\n\n    }\n\n    public BitMapValue get(String path, BitmapPool bitmapPool){\n\n        InputStream inputStream=null;\n        try {\n            DiskLruCache.Snapshot snapshot=diskLruCache.get(key);\n            //判断快照不为null的情况下，再去读操作\n            if (null!=snapshot){\n                BitMapValue bitMapValue = BitMapValue.getInstance();\n                inputStream=snapshot.getInputStream(0); \n\n                int w=1092;\n                int h=1080;\n                BitmapFactory.Options options2 = new BitmapFactory.Options();\n                options2.inMutable=true;\n                options2.inPreferredConfig=Bitmap.Config.RGB_565;\n                options2.inJustDecodeBounds=false;\n                //inSampleSize是采样率，当inSampleSize为2时，一个2000 1000的图片，将被缩小至 1000 500\n                options2.inSampleSize= Tool.sampleBitmapSize(options2,w,h);\n                final Bitmap bitmap = BitmapFactory.decodeStream(inputStream,null,options2);\n                bitMapValue.setBitmap(bitmap);\n                //保存key唯一标识\n                bitMapValue.setPath(path);\n                return bitMapValue;\n            }\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //....省略提交、流输出、关闭\n\n        return null;\n    }\n\n}\n\n\n```\n\n### 复用池的实现\n\n复用池的作用是将已经不需要使用的数据空间重新拿来使用，可以避免频繁申请内存，减少内存的抖动；在未使用复用池的情况下，每张图片都需要一块内存，在使用复用池的情况下，如果存在能被复用的图片就会重复使用改图片的内存。\n\n`inMutable`是bitmapFactory的一个参数，表示该bitmap是可变的，支持复用的，在复用Bitmap之前需要设置`inMutable`为true\n`inBitmap`设置想要存储的bitmap\n\n复用池接口\n\n```java\npublic interface BitmapPool {\n    /**\n     * 存入到Bitmap\n     * @param bitmap\n     */\n    void put(Bitmap bitmap);\n\n    /**\n     * 获取匹配 可用复用 Bitmap\n     * @param w\n     * @param h\n     * @return\n     */\n    Bitmap get(int w,int h,Bitmap.Config config);\n}\n\n```\n\n在复用池接口实现的过程中，继承`LruCache` 类，实现LRU算法；在复用池中通过Treemap对图片的内存空间进行排序，并通过TreeMap的`ceilingKey()`方法获取到合适的Bitmap内存；当Bitmap从内存缓存中移除后，会将其内存空间添加到复用池中；当Bitmap从磁盘中取出后，会先去查找复用池中是否有合适的空间，如果有则直接使用，否则开辟新的内存空间；\n\n我觉得应该先去看bitmap的内存申请\n\n```java\npublic class BitmapPoolImpl extends LruCache<Integer,Bitmap> implements BitmapPool {\n\n\n    //为了筛选出合适的 Bitmap 容器\n    private TreeMap<Integer,String>treeMap=new TreeMap<>();\n\n    /**\n     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n     *                the maximum number of entries in the cache. For all other caches,\n     *                this is the maximum sum of the sizes of the entries in this cache.\n     */\n    public BitmapPoolImpl(int maxSize) {\n        super(maxSize);\n    }\n\n    @Override\n    public void put(Bitmap bitmap) {\n        //存入复用池\n        bitmap.isMutable();\n        //todo 条件一 bitmap.isMutable()==true;\n        if (!bitmap.isMutable())\n        {\n            if (bitmap.isRecycled()==false){\n                bitmap.recycle();\n            }\n            return;\n        }\n\n        //todo 条件二 就计算bitmap的大小,\n        int bitmapSize = getBitmapSize(bitmap);\n        if (bitmapSize>maxSize()){\n            if (bitmap.isRecycled()==false){\n                bitmap.recycle();\n            }\n            return;\n        }\n        //todo bitmap存入 LruCache\n        put(bitmapSize,bitmap);\n        //存入筛选容器\n        treeMap.put(bitmapSize,null);\n    }\n\n    //获取可以复用Bitmap\n   \n    @Override\n    public Bitmap get(int w, int h, Bitmap.Config config) {\n\n        /**\n         * ALPHA_8 理论上 实际上Android自动做处理的  只有透明度 8 位，一个字节\n         * w*h*1\n         *\n         * RGB_565 理论上 实际上Android自动处理的  R 5位 G 6位 B 5位 没有透明度 两个字节\n         * w*h*2\n         *\n         * ARGB_4444  理论上 实际上Android自动处理的 A 4位 R 4位 G 4位 B 4位  两个字节\n         *\n         *\n         * 质量最高：\n         * ARGB_8888  Android默认使用  A 8位 R 8位 G 8位 B 8位  四个字节\n         *\n         *\n         * 常用的 ARGB_8888 RGB_565\n         *\n         */\n\n        int getSize=w*h*(config==Bitmap.Config.ARGB_8888?4:2);  //只考虑两种，Glide所有的都考虑了\n\n        Integer key = treeMap.ceilingKey(getSize);//可以查找到容器里面 和 getSize一样大的，也可以比getSize还要大的\n\n        //如果treeMap还没有put,那么一定是null\n        if (key==null){\n            return null;   //没有找到合适的可复用的key\n        }\n\n        //查找容器取出来的key ,必须小于计算出来的 (getSize*2)\n        if (key<=(getSize*2)){\n            Bitmap remove=remove(key);  //复用池如果要取出来，肯定要取出来，不给其他地方用\n            Log.e(TAG,\"从复用池中取出复用元素 bitmap\");\n            return remove;\n        }\n        return null;\n    }\n\n\n    /**\n     * 计算Bitmap的大小\n     * @param bitmap\n     * @return\n     */\n    private int getBitmapSize(Bitmap  bitmap){\n        int sdkInt= Build.VERSION.SDK_INT;\n        if (sdkInt>=Build.VERSION_CODES.KITKAT){\n            return bitmap.getAllocationByteCount();\n        }\n\n        return bitmap.getByteCount();\n\n    }\n\n    //元素的大小\n    @Override\n    protected int sizeOf(@NonNull Integer key, @NonNull Bitmap value) {\n//        return super.sizeOf(key, value);\n        return getBitmapSize(value);\n    }\n\n    @Override\n    protected void entryRemoved(boolean evicted, @NonNull Integer key, @NonNull Bitmap oldValue, @Nullable Bitmap newValue) {\n        super.entryRemoved(evicted, key, oldValue, newValue);\n        //吧TreeMap里面的给移除\n    }\n}\n\n\n```\n\n[源码地址](https://github.com/LuciusCS/AndroidProject) 在`glidemodule`模块中进行实现","source":"_posts/Android/框架/Glide/Glide框架手写实现.md","raw":"---\ntitle: Glide手写框架实现\ntype: [Android]\ndescription:  Glide手写框架实现\ncover: /cover/img92.jpg\ntoc: true\ncategories: Android\ndate: 2019/05/08\n---\n\n# Glide手写框架实现\n\n## 实现步骤\n\nGlide框架实现主要有以下步骤\n\n图片下载后，先缓存至活动缓存；在获取缓存中通过弱引用监控bitMap的回收，如果活动缓存中bitMap的弱引用被回收，那么会将活动缓存中的bitMap，缓存至内存缓存；当图片被再次使用会从内存缓存中移除，添加到活动缓存中；\n\n\n* 活动缓存的实现\n\n* 内存缓存的实现\n\n* 磁盘缓存的实现\n\n* 声明周期的管理\n\n### 实现前的准备\n\n1、在图片加载的过程中，采用<Key,BitMap>的形式获取图片对象；在使用的过程中，需要对图片文件的名称和路径进行加密，定义一个专门的类对名称和路径进行加密和解密，这样可以避免图片路径过长的问题。\n\n```java\npublic class Path {\n\n    private String key;  //例如  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311\n\n    /**\n     * 加密前 sha256 (https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90cm01Vk1lRnA5blVESWdHaWJkVnlFSnk3MmlieVdXOElDWGlhamZDNlliNTc3YnVRTUdtYmUxR1hxSmhwVjNvUzhyWktENTIzODNVZDFpYkh6VTJDakxrUUEvNjQw?x-oss-process=image/format,png)\n     * 加密后  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311\n     * @param key\n     */\n    public Path(String key) {\n        this.key = Tool.getSHA256StrJava( key);\n    }\n\n    //添加getter和setter方法。\n}\n\n```\n\n2、在使用的过程中，需要对BitMap的使用状态以及回收状态进行处理，设置一个专门的类进行管理。在对BitMap进行管理的过程中，需要对BitMap的引用次数进行标记，当引用次数等于零时，回收BitMap的空间；BitMap回收采用回调的方式由外部进行回收\n\n回调接口\n\n```java\npublic interface ValueCallback {\n\n    //活动缓存监听的方法（BitMap不再使用了）\n    public void valueNonUseAction(String path, BitMapValue bitMapValue);\n}\n\n```\n\n在BitMap中 `bitmap`变量用于持有正在使用的图片对象，`count`变量用于对该对象的引用进行计数，会进行加一或者减一操作，`path`变量用于标记图片的路路径，`valueCallback`用于引用次数为零时的回调；\n\n```java\n\npublic class BitMapValue {\n\n    private BitMapValue(){}\n\n    //采用单利模式\n    private static BitMapValue bitMapValue;\n    \n    public static BitMapValue getInstance(){\n        //.....\n        //省略单例实现\n        return bitMapValue;\n    }\n\n    private Bitmap bitmap;\n\n    private int count;\n\n    //互动缓存监听\n    private ValueCallback valueCallback;\n\n    private String path;\n\n    public void useAction(){\n        if (bitmap.isRecycled()){   //已经被回收\n            return;\n        }\n        count++;\n\n    }\n\n    public void nonUseAction(){\n        count--;\n        if (count<=0){\n            valueCallback.valueNonUseAction(path,this);\n            recycleBitmap();\n        };\n    }\n\n    //释放bitmap\n    public void recycleBitmap(){\n    \n        bitmap.recycle();\n\n        bitMapValue =null;\n\n        System.gc();\n    }\n    //添加getter和setter方法\n}\n\n\n```\n\n### 活动缓存的实现\n活动缓存用于存储应用中正在使用的图片资源，采用弱引用的方式便于系统及时回收；在活动缓存中采用<Path,Bitmap>的方式表示的正在使用的图片信息;\n\n在活动缓存中需要对被回收的对象的引用进行监听，当对象被回收后，需要将其加入到内存缓存中。\n\n变量`Map<String, WeakReference<BitMapValue>>mapList`用于持有缓存对象的弱引用，`mapList`的`value`是一个弱引用，会被自动回收，需要对该弱引用的回收做监听，处理弱引用回收后的操作，因此需要创建一个`CustomWeakReference`内部类；\n\n变量`Map<String, Bitmap>mapValueList`用于持有缓存对象的引用，其中保存的对象与`mapList`中的对象一致，`mapList`中的弱引用被回收后，需要通过获取`mapValueList`中的Bitmap对象，将其缓存至内存缓存中；\n\n变量`ReferenceQueue<BitMapValue>queue` 将`BitMapValue`的弱引用添加到该队列中，通过调用`remove`这一阻塞方法监听弱引用是否被回收。\n\n变量`boolean isCloseThread` 用于监听是否将弱引用回收监听的线程进行停止；\n\n变量`Thread thread` 用于表示弱引用回收监听线程\n\n\n\n方法` put(String path, BitMapValue bitMapValue)`用于添加活动缓存；\n方法`get(String key)`用于获取活动缓存；\n方法` closeActiveCache()`用于关闭活动缓存\n\n内部类 `class CustomWeakReference `用于在弱引用被回收后，获取该 BitMapValue 的 path和bitmap\n\n\n\n```java\n\npublic class ActiveCache {\n\n\n    private Map<String, WeakReference<BitMapValue>>mapList=new HashMap<>();\n\n    private Map<String, Bitmap>mapValueList=new HashMap<>();\n\n    private ReferenceQueue<BitMapValue>queue;    //目的：为了监听弱引用是否被回收\n\n    private boolean isCloseThread;\n\n    private Thread thread;\n\n\n    private ValueCallback valueCallback;\n\n    public ActiveCache(ValueCallback valueCallback){\n        this.valueCallback=valueCallback;\n    }\n\n    /**\n     * TODO 添加活动缓存\n     * @param path\n     * @param bitMapValue\n     */\n    public void put(String path, BitMapValue bitMapValue){\n\n        Tool.checkNotEmpty(path);\n\n        //绑定Value的监听，Value没有被使用了，就会发起这个监听，给外界业务需要来使用)\n        bitMapValue.setValueCallback(valueCallback);\n\n        mapList.put(path,new CustomWeakReference(bitMapValue,getQueue(),path));\n\n        mapValueList.put(path,bitMapValue.getBitmap());\n    }\n\n\n    /**\n     * TODO 给外界获取value\n     * @param path\n     * @return\n     */\n    public BitMapValue get(String path){\n        WeakReference<BitMapValue>valueWeakReference=mapList.get(path);\n        if (null!=valueWeakReference){\n            BitMapValue value=valueWeakReference.get();   //返回value\n            value.setBitmap(mapValueList.get(path));\n            value.setPath(path);\n            return value;   //返回value\n        }\n        return null;\n\n    }\n\n    //主动释放内存缓存，并将线程进行关闭\n    public void closeActiveCache(){\n        isCloseThread=true;\n        mapList.clear();;\n        System.gc();\n    }\n\n\n    //监听弱引用，成为弱引用的子类，为了监听弱引用是否被回收，并获取弱引用回收后的 path和 BitMapValue\n    public class CustomWeakReference extends WeakReference<BitMapValue>{\n\n        private String path;\n        private BitMapValue value;\n\n        public CustomWeakReference(BitMapValue referent, ReferenceQueue<? super BitMapValue> q,String path) {\n            super(referent, q);\n            this.path =path;\n            this.value=referent;\n        }\n\n    }\n\n\n    //创建弱引用队列，并对弱引用的回收进行监听\n    private ReferenceQueue<BitMapValue>getQueue(){\n        if (queue==null){\n            queue=new ReferenceQueue<>();\n            thread= new Thread(){\n                @Override\n                public void run() {\n                    super.run();\n                    while (!isCloseThread){\n                        try {\n                            //阻塞式方法 如果有引用被回收，则会执行该方法，并返回被回收的对象\n                            Reference<? extends BitMapValue> remove = queue.remove(); \n                            CustomWeakReference weakReference = (CustomWeakReference) remove;\n\n                             //将引用移除容器\n                            if (mapList != null && !mapList.isEmpty()) {\n                                    mapList.remove(weakReference.path);\n                                    mapValueList.remove(weakReference.path);\n                            }\n\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        } } }\n            };\n            thread.start();\n        }\n        return queue;\n    }\n}\n\n\n\n```\n\n### 内存缓存的实现\n\n内存缓存将使用的图片资源缓存至内存中，采用LRU算法进行回收,继承`LruCache<K, V>`接口，并在初始化的时候设置图片缓存的最大值。内存缓存的图片在每一次调用之后，都会进行移除后再次加入到活动缓存中；\n\n与活动缓存一样，内存缓存在缓存中的BitMapValue被移除后，需要进行回调，内存缓存回调接口如下：\n\n```\npublic interface MemoryCacheCallback {\n\n    /**\n     * 内存缓存中移除的path\n     * @param path\n     * @param oldBitMapValue\n     */\n    public void entryRemoveMemoryCache(String path,@NonNull BitMapValue oldBitMapValue);\n}\n\n```\n内存缓存的源码如下：\n\n```java\npublic class MemoryCache extends LruCache <String, BitMapValue>{\n\n    private boolean manualRemove;\n\n    //TODO 手动移除 Manual\n    public BitMapValue manualRemove(String path){\n        manualRemove=true;\n       BitMapValue bitMapValue =remove(path);\n        manualRemove=false;\n       return bitMapValue;\n    }\n\n\n    private MemoryCacheCallback memoryCacheCallback;\n\n    public void setMemoryCacheCallback(MemoryCacheCallback memoryCacheCallback) {\n        this.memoryCacheCallback = memoryCacheCallback;\n    }\n\n    // 传入元素最大值给 LruCache\n    public MemoryCache(int maxSize) {\n        super(maxSize);\n    }\n\n    @Override\n    protected int sizeOf(@NonNull String key, @NonNull BitMapValue bitMapValue) {\n//        return super.sizeOf(key, value);\n        Bitmap bitmap= bitMapValue.getBitmap();\n\n        //最开始的的时候\n//        int result=bitmap.getRowBytes()*bitmap.getHeight();\n        //API 12  3.0\n//        int result=bitmap.getByteCount();  //bitmap内存复用上有区别(所属的)\n        //API 19 4.4\n//        int result=bitmap.getAllocationByteCount();//bitmap内存复用上有区别(整个的)\n        int sdkInt= Build.VERSION.SDK_INT;\n        if (sdkInt>=Build.VERSION_CODES.KITKAT){\n            return bitmap.getAllocationByteCount();\n        }\n\n        return bitmap.getByteCount();\n\n    }\n\n    /**\n     * 1. 重复的key\n     * 2. 最少使用的元素会被移除\n     * @param evicted\n     * @param key\n     * @param oldBitMapValue\n     * @param newBitMapValue\n     */\n\n    @Override\n    protected void entryRemoved(boolean evicted, @NonNull String key, @NonNull BitMapValue oldBitMapValue, @Nullable BitMapValue newBitMapValue) {\n        super.entryRemoved(evicted, key, oldBitMapValue, newBitMapValue);\n        if (memoryCacheCallback!=null&&!manualRemove){  //被动删除\n            memoryCacheCallback.entryRemoveMemoryCache(key, oldBitMapValue);\n        }\n    }\n}\n\n\n```\n\n### 磁盘缓存的实现\n\n以文件的形式保存至本地磁盘，文件名称需要通过`Path`类进行设置，在磁盘缓存中借助于 https://github.com/JakeWharton/DiskLruCache 中的  `DiskLruCache.java` `StrictLineReader.java` `Util.java ` 并对DiskLruCache进行封装。在封装的过程中，需要指定磁盘缓存的路径、缓存文件的最大值，以及put和get方法\n\n```java\npublic class DiskLruCacheImpl {\n\n    //SD/disk_lru_cache_dir/ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311\n    private final String DISKLRU_CACHE_DIR=\"disk_lru_cache_dir\";  //磁盘缓存的目录\n\n    private final int APP_VERSION=1;   //我们的版本号，一旦修改这个版本号，之前的缓存失效\n\n    private final int VALUE_COUNT=1;  //通常情况下是1\n\n    private final long MAX_SIZE=1024*1024*10l; //指定缓存文件最大值\n\n    private DiskLruCache diskLruCache;\n\n    public DiskLruCacheImpl() {\n\n        File file=new File(Environment.getExternalStorageDirectory()+File.separator+DISKLRU_CACHE_DIR);\n\n\n        try {\n            diskLruCache= DiskLruCache.open(file,APP_VERSION,VALUE_COUNT,MAX_SIZE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    //TODO put\n    public void put(String path){\n\n        DiskLruCache.Editor editor=null;\n\n        OutputStream outputStream=null;\n\n        try {\n            editor=diskLruCache.edit(path);\n\n           outputStream=editor.newOutputStream(0);  //index不能大于 VALUE_COUNT\n\n            Bitmap bitmap= bitMapValue.getBitmap();\n\n            bitmap.compress(Bitmap.CompressFormat.PNG,100,outputStream);  //吧把BitMap 写入outputStream\n\n            outputStream.flush();\n\n        } catch (IOException e) {\n            //....省略\n        }\n\n        //....省略提交，流输出、关闭\n\n    }\n\n    public BitMapValue get(String path, BitmapPool bitmapPool){\n\n        InputStream inputStream=null;\n        try {\n            DiskLruCache.Snapshot snapshot=diskLruCache.get(key);\n            //判断快照不为null的情况下，再去读操作\n            if (null!=snapshot){\n                BitMapValue bitMapValue = BitMapValue.getInstance();\n                inputStream=snapshot.getInputStream(0); \n\n                int w=1092;\n                int h=1080;\n                BitmapFactory.Options options2 = new BitmapFactory.Options();\n                options2.inMutable=true;\n                options2.inPreferredConfig=Bitmap.Config.RGB_565;\n                options2.inJustDecodeBounds=false;\n                //inSampleSize是采样率，当inSampleSize为2时，一个2000 1000的图片，将被缩小至 1000 500\n                options2.inSampleSize= Tool.sampleBitmapSize(options2,w,h);\n                final Bitmap bitmap = BitmapFactory.decodeStream(inputStream,null,options2);\n                bitMapValue.setBitmap(bitmap);\n                //保存key唯一标识\n                bitMapValue.setPath(path);\n                return bitMapValue;\n            }\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        //....省略提交、流输出、关闭\n\n        return null;\n    }\n\n}\n\n\n```\n\n### 复用池的实现\n\n复用池的作用是将已经不需要使用的数据空间重新拿来使用，可以避免频繁申请内存，减少内存的抖动；在未使用复用池的情况下，每张图片都需要一块内存，在使用复用池的情况下，如果存在能被复用的图片就会重复使用改图片的内存。\n\n`inMutable`是bitmapFactory的一个参数，表示该bitmap是可变的，支持复用的，在复用Bitmap之前需要设置`inMutable`为true\n`inBitmap`设置想要存储的bitmap\n\n复用池接口\n\n```java\npublic interface BitmapPool {\n    /**\n     * 存入到Bitmap\n     * @param bitmap\n     */\n    void put(Bitmap bitmap);\n\n    /**\n     * 获取匹配 可用复用 Bitmap\n     * @param w\n     * @param h\n     * @return\n     */\n    Bitmap get(int w,int h,Bitmap.Config config);\n}\n\n```\n\n在复用池接口实现的过程中，继承`LruCache` 类，实现LRU算法；在复用池中通过Treemap对图片的内存空间进行排序，并通过TreeMap的`ceilingKey()`方法获取到合适的Bitmap内存；当Bitmap从内存缓存中移除后，会将其内存空间添加到复用池中；当Bitmap从磁盘中取出后，会先去查找复用池中是否有合适的空间，如果有则直接使用，否则开辟新的内存空间；\n\n我觉得应该先去看bitmap的内存申请\n\n```java\npublic class BitmapPoolImpl extends LruCache<Integer,Bitmap> implements BitmapPool {\n\n\n    //为了筛选出合适的 Bitmap 容器\n    private TreeMap<Integer,String>treeMap=new TreeMap<>();\n\n    /**\n     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n     *                the maximum number of entries in the cache. For all other caches,\n     *                this is the maximum sum of the sizes of the entries in this cache.\n     */\n    public BitmapPoolImpl(int maxSize) {\n        super(maxSize);\n    }\n\n    @Override\n    public void put(Bitmap bitmap) {\n        //存入复用池\n        bitmap.isMutable();\n        //todo 条件一 bitmap.isMutable()==true;\n        if (!bitmap.isMutable())\n        {\n            if (bitmap.isRecycled()==false){\n                bitmap.recycle();\n            }\n            return;\n        }\n\n        //todo 条件二 就计算bitmap的大小,\n        int bitmapSize = getBitmapSize(bitmap);\n        if (bitmapSize>maxSize()){\n            if (bitmap.isRecycled()==false){\n                bitmap.recycle();\n            }\n            return;\n        }\n        //todo bitmap存入 LruCache\n        put(bitmapSize,bitmap);\n        //存入筛选容器\n        treeMap.put(bitmapSize,null);\n    }\n\n    //获取可以复用Bitmap\n   \n    @Override\n    public Bitmap get(int w, int h, Bitmap.Config config) {\n\n        /**\n         * ALPHA_8 理论上 实际上Android自动做处理的  只有透明度 8 位，一个字节\n         * w*h*1\n         *\n         * RGB_565 理论上 实际上Android自动处理的  R 5位 G 6位 B 5位 没有透明度 两个字节\n         * w*h*2\n         *\n         * ARGB_4444  理论上 实际上Android自动处理的 A 4位 R 4位 G 4位 B 4位  两个字节\n         *\n         *\n         * 质量最高：\n         * ARGB_8888  Android默认使用  A 8位 R 8位 G 8位 B 8位  四个字节\n         *\n         *\n         * 常用的 ARGB_8888 RGB_565\n         *\n         */\n\n        int getSize=w*h*(config==Bitmap.Config.ARGB_8888?4:2);  //只考虑两种，Glide所有的都考虑了\n\n        Integer key = treeMap.ceilingKey(getSize);//可以查找到容器里面 和 getSize一样大的，也可以比getSize还要大的\n\n        //如果treeMap还没有put,那么一定是null\n        if (key==null){\n            return null;   //没有找到合适的可复用的key\n        }\n\n        //查找容器取出来的key ,必须小于计算出来的 (getSize*2)\n        if (key<=(getSize*2)){\n            Bitmap remove=remove(key);  //复用池如果要取出来，肯定要取出来，不给其他地方用\n            Log.e(TAG,\"从复用池中取出复用元素 bitmap\");\n            return remove;\n        }\n        return null;\n    }\n\n\n    /**\n     * 计算Bitmap的大小\n     * @param bitmap\n     * @return\n     */\n    private int getBitmapSize(Bitmap  bitmap){\n        int sdkInt= Build.VERSION.SDK_INT;\n        if (sdkInt>=Build.VERSION_CODES.KITKAT){\n            return bitmap.getAllocationByteCount();\n        }\n\n        return bitmap.getByteCount();\n\n    }\n\n    //元素的大小\n    @Override\n    protected int sizeOf(@NonNull Integer key, @NonNull Bitmap value) {\n//        return super.sizeOf(key, value);\n        return getBitmapSize(value);\n    }\n\n    @Override\n    protected void entryRemoved(boolean evicted, @NonNull Integer key, @NonNull Bitmap oldValue, @Nullable Bitmap newValue) {\n        super.entryRemoved(evicted, key, oldValue, newValue);\n        //吧TreeMap里面的给移除\n    }\n}\n\n\n```\n\n[源码地址](https://github.com/LuciusCS/AndroidProject) 在`glidemodule`模块中进行实现","slug":"Android/框架/Glide/Glide框架手写实现","published":1,"updated":"2021-01-05T12:14:31.488Z","_id":"ckjju0m2m009t20uabhvxh8sd","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Glide手写框架实现\"><a href=\"#Glide手写框架实现\" class=\"headerlink\" title=\"Glide手写框架实现\"></a>Glide手写框架实现</h1><h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>Glide框架实现主要有以下步骤</p>\n<p>图片下载后，先缓存至活动缓存；在获取缓存中通过弱引用监控bitMap的回收，如果活动缓存中bitMap的弱引用被回收，那么会将活动缓存中的bitMap，缓存至内存缓存；当图片被再次使用会从内存缓存中移除，添加到活动缓存中；</p>\n<ul>\n<li><p>活动缓存的实现</p>\n</li>\n<li><p>内存缓存的实现</p>\n</li>\n<li><p>磁盘缓存的实现</p>\n</li>\n<li><p>声明周期的管理</p>\n</li>\n</ul>\n<h3 id=\"实现前的准备\"><a href=\"#实现前的准备\" class=\"headerlink\" title=\"实现前的准备\"></a>实现前的准备</h3><p>1、在图片加载的过程中，采用&lt;Key,BitMap&gt;的形式获取图片对象；在使用的过程中，需要对图片文件的名称和路径进行加密，定义一个专门的类对名称和路径进行加密和解密，这样可以避免图片路径过长的问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Path</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String key;  <span class=\"comment\">//例如  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加密前 sha256 (https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90cm01Vk1lRnA5blVESWdHaWJkVnlFSnk3MmlieVdXOElDWGlhamZDNlliNTc3YnVRTUdtYmUxR1hxSmhwVjNvUzhyWktENTIzODNVZDFpYkh6VTJDakxrUUEvNjQw?x-oss-process=image/format,png)</span></span><br><span class=\"line\"><span class=\"comment\">     * 加密后  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Path</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = Tool.getSHA256StrJava( key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//添加getter和setter方法。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、在使用的过程中，需要对BitMap的使用状态以及回收状态进行处理，设置一个专门的类进行管理。在对BitMap进行管理的过程中，需要对BitMap的引用次数进行标记，当引用次数等于零时，回收BitMap的空间；BitMap回收采用回调的方式由外部进行回收</p>\n<p>回调接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ValueCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//活动缓存监听的方法（BitMap不再使用了）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">valueNonUseAction</span><span class=\"params\">(String path, BitMapValue bitMapValue)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在BitMap中 <code>bitmap</code>变量用于持有正在使用的图片对象，<code>count</code>变量用于对该对象的引用进行计数，会进行加一或者减一操作，<code>path</code>变量用于标记图片的路路径，<code>valueCallback</code>用于引用次数为零时的回调；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitMapValue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">BitMapValue</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//采用单利模式</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BitMapValue bitMapValue;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitMapValue <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//.....</span></span><br><span class=\"line\">        <span class=\"comment\">//省略单例实现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bitMapValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Bitmap bitmap;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//互动缓存监听</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueCallback valueCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">useAction</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitmap.isRecycled())&#123;   <span class=\"comment\">//已经被回收</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">nonUseAction</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            valueCallback.valueNonUseAction(path,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            recycleBitmap();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//释放bitmap</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recycleBitmap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        bitmap.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">        bitMapValue =<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加getter和setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"活动缓存的实现\"><a href=\"#活动缓存的实现\" class=\"headerlink\" title=\"活动缓存的实现\"></a>活动缓存的实现</h3><p>活动缓存用于存储应用中正在使用的图片资源，采用弱引用的方式便于系统及时回收；在活动缓存中采用&lt;Path,Bitmap&gt;的方式表示的正在使用的图片信息;</p>\n<p>在活动缓存中需要对被回收的对象的引用进行监听，当对象被回收后，需要将其加入到内存缓存中。</p>\n<p>变量<code>Map&lt;String, WeakReference&lt;BitMapValue&gt;&gt;mapList</code>用于持有缓存对象的弱引用，<code>mapList</code>的<code>value</code>是一个弱引用，会被自动回收，需要对该弱引用的回收做监听，处理弱引用回收后的操作，因此需要创建一个<code>CustomWeakReference</code>内部类；</p>\n<p>变量<code>Map&lt;String, Bitmap&gt;mapValueList</code>用于持有缓存对象的引用，其中保存的对象与<code>mapList</code>中的对象一致，<code>mapList</code>中的弱引用被回收后，需要通过获取<code>mapValueList</code>中的Bitmap对象，将其缓存至内存缓存中；</p>\n<p>变量<code>ReferenceQueue&lt;BitMapValue&gt;queue</code> 将<code>BitMapValue</code>的弱引用添加到该队列中，通过调用<code>remove</code>这一阻塞方法监听弱引用是否被回收。</p>\n<p>变量<code>boolean isCloseThread</code> 用于监听是否将弱引用回收监听的线程进行停止；</p>\n<p>变量<code>Thread thread</code> 用于表示弱引用回收监听线程</p>\n<p>方法<code> put(String path, BitMapValue bitMapValue)</code>用于添加活动缓存；<br>方法<code>get(String key)</code>用于获取活动缓存；<br>方法<code> closeActiveCache()</code>用于关闭活动缓存</p>\n<p>内部类 <code>class CustomWeakReference </code>用于在弱引用被回收后，获取该 BitMapValue 的 path和bitmap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActiveCache</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, WeakReference&lt;BitMapValue&gt;&gt;mapList=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Bitmap&gt;mapValueList=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReferenceQueue&lt;BitMapValue&gt;queue;    <span class=\"comment\">//目的：为了监听弱引用是否被回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isCloseThread;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueCallback valueCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ActiveCache</span><span class=\"params\">(ValueCallback valueCallback)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.valueCallback=valueCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * TODO 添加活动缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bitMapValue</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String path, BitMapValue bitMapValue)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Tool.checkNotEmpty(path);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//绑定Value的监听，Value没有被使用了，就会发起这个监听，给外界业务需要来使用)</span></span><br><span class=\"line\">        bitMapValue.setValueCallback(valueCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">        mapList.put(path,<span class=\"keyword\">new</span> CustomWeakReference(bitMapValue,getQueue(),path));</span><br><span class=\"line\"></span><br><span class=\"line\">        mapValueList.put(path,bitMapValue.getBitmap());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * TODO 给外界获取value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BitMapValue <span class=\"title\">get</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        WeakReference&lt;BitMapValue&gt;valueWeakReference=mapList.get(path);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=valueWeakReference)&#123;</span><br><span class=\"line\">            BitMapValue value=valueWeakReference.get();   <span class=\"comment\">//返回value</span></span><br><span class=\"line\">            value.setBitmap(mapValueList.get(path));</span><br><span class=\"line\">            value.setPath(path);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;   <span class=\"comment\">//返回value</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//主动释放内存缓存，并将线程进行关闭</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">closeActiveCache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        isCloseThread=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mapList.clear();;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//监听弱引用，成为弱引用的子类，为了监听弱引用是否被回收，并获取弱引用回收后的 path和 BitMapValue</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomWeakReference</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">BitMapValue</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> BitMapValue value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomWeakReference</span><span class=\"params\">(BitMapValue referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> BitMapValue&gt; q,String path)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.path =path;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value=referent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建弱引用队列，并对弱引用的回收进行监听</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReferenceQueue&lt;BitMapValue&gt;getQueue()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            queue=<span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">            thread= <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (!isCloseThread)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//阻塞式方法 如果有引用被回收，则会执行该方法，并返回被回收的对象</span></span><br><span class=\"line\">                            Reference&lt;? extends BitMapValue&gt; remove = queue.remove(); </span><br><span class=\"line\">                            CustomWeakReference weakReference = (CustomWeakReference) remove;</span><br><span class=\"line\"></span><br><span class=\"line\">                             <span class=\"comment\">//将引用移除容器</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mapList != <span class=\"keyword\">null</span> &amp;&amp; !mapList.isEmpty()) &#123;</span><br><span class=\"line\">                                    mapList.remove(weakReference.path);</span><br><span class=\"line\">                                    mapValueList.remove(weakReference.path);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125; &#125; &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"内存缓存的实现\"><a href=\"#内存缓存的实现\" class=\"headerlink\" title=\"内存缓存的实现\"></a>内存缓存的实现</h3><p>内存缓存将使用的图片资源缓存至内存中，采用LRU算法进行回收,继承<code>LruCache&lt;K, V&gt;</code>接口，并在初始化的时候设置图片缓存的最大值。内存缓存的图片在每一次调用之后，都会进行移除后再次加入到活动缓存中；</p>\n<p>与活动缓存一样，内存缓存在缓存中的BitMapValue被移除后，需要进行回调，内存缓存回调接口如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface MemoryCacheCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 内存缓存中移除的path</span><br><span class=\"line\">     * @param path</span><br><span class=\"line\">     * @param oldBitMapValue</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public void entryRemoveMemoryCache(String path,@NonNull BitMapValue oldBitMapValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>内存缓存的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemoryCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LruCache</span> &lt;<span class=\"title\">String</span>, <span class=\"title\">BitMapValue</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> manualRemove;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO 手动移除 Manual</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BitMapValue <span class=\"title\">manualRemove</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        manualRemove=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">       BitMapValue bitMapValue =remove(path);</span><br><span class=\"line\">        manualRemove=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> bitMapValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MemoryCacheCallback memoryCacheCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemoryCacheCallback</span><span class=\"params\">(MemoryCacheCallback memoryCacheCallback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.memoryCacheCallback = memoryCacheCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 传入元素最大值给 LruCache</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MemoryCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(maxSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> BitMapValue bitMapValue)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        return super.sizeOf(key, value);</span></span><br><span class=\"line\">        Bitmap bitmap= bitMapValue.getBitmap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//最开始的的时候</span></span><br><span class=\"line\"><span class=\"comment\">//        int result=bitmap.getRowBytes()*bitmap.getHeight();</span></span><br><span class=\"line\">        <span class=\"comment\">//API 12  3.0</span></span><br><span class=\"line\"><span class=\"comment\">//        int result=bitmap.getByteCount();  //bitmap内存复用上有区别(所属的)</span></span><br><span class=\"line\">        <span class=\"comment\">//API 19 4.4</span></span><br><span class=\"line\"><span class=\"comment\">//        int result=bitmap.getAllocationByteCount();//bitmap内存复用上有区别(整个的)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sdkInt= Build.VERSION.SDK_INT;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sdkInt&gt;=Build.VERSION_CODES.KITKAT)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bitmap.getAllocationByteCount();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bitmap.getByteCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 重复的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 最少使用的元素会被移除</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evicted</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> oldBitMapValue</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> newBitMapValue</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, <span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> BitMapValue oldBitMapValue, <span class=\"meta\">@Nullable</span> BitMapValue newBitMapValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.entryRemoved(evicted, key, oldBitMapValue, newBitMapValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (memoryCacheCallback!=<span class=\"keyword\">null</span>&amp;&amp;!manualRemove)&#123;  <span class=\"comment\">//被动删除</span></span><br><span class=\"line\">            memoryCacheCallback.entryRemoveMemoryCache(key, oldBitMapValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘缓存的实现\"><a href=\"#磁盘缓存的实现\" class=\"headerlink\" title=\"磁盘缓存的实现\"></a>磁盘缓存的实现</h3><p>以文件的形式保存至本地磁盘，文件名称需要通过<code>Path</code>类进行设置，在磁盘缓存中借助于 <a href=\"https://github.com/JakeWharton/DiskLruCache\">https://github.com/JakeWharton/DiskLruCache</a> 中的  <code>DiskLruCache.java</code> <code>StrictLineReader.java</code> <code>Util.java </code> 并对DiskLruCache进行封装。在封装的过程中，需要指定磁盘缓存的路径、缓存文件的最大值，以及put和get方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiskLruCacheImpl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//SD/disk_lru_cache_dir/ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String DISKLRU_CACHE_DIR=<span class=\"string\">&quot;disk_lru_cache_dir&quot;</span>;  <span class=\"comment\">//磁盘缓存的目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> APP_VERSION=<span class=\"number\">1</span>;   <span class=\"comment\">//我们的版本号，一旦修改这个版本号，之前的缓存失效</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> VALUE_COUNT=<span class=\"number\">1</span>;  <span class=\"comment\">//通常情况下是1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> MAX_SIZE=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>*<span class=\"number\">10l</span>; <span class=\"comment\">//指定缓存文件最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiskLruCache diskLruCache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiskLruCacheImpl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        File file=<span class=\"keyword\">new</span> File(Environment.getExternalStorageDirectory()+File.separator+DISKLRU_CACHE_DIR);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            diskLruCache= DiskLruCache.open(file,APP_VERSION,VALUE_COUNT,MAX_SIZE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO put</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        DiskLruCache.Editor editor=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        OutputStream outputStream=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            editor=diskLruCache.edit(path);</span><br><span class=\"line\"></span><br><span class=\"line\">           outputStream=editor.newOutputStream(<span class=\"number\">0</span>);  <span class=\"comment\">//index不能大于 VALUE_COUNT</span></span><br><span class=\"line\"></span><br><span class=\"line\">            Bitmap bitmap= bitMapValue.getBitmap();</span><br><span class=\"line\"></span><br><span class=\"line\">            bitmap.compress(Bitmap.CompressFormat.PNG,<span class=\"number\">100</span>,outputStream);  <span class=\"comment\">//吧把BitMap 写入outputStream</span></span><br><span class=\"line\"></span><br><span class=\"line\">            outputStream.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//....省略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//....省略提交，流输出、关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BitMapValue <span class=\"title\">get</span><span class=\"params\">(String path, BitmapPool bitmapPool)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        InputStream inputStream=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            DiskLruCache.Snapshot snapshot=diskLruCache.get(key);</span><br><span class=\"line\">            <span class=\"comment\">//判断快照不为null的情况下，再去读操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=snapshot)&#123;</span><br><span class=\"line\">                BitMapValue bitMapValue = BitMapValue.getInstance();</span><br><span class=\"line\">                inputStream=snapshot.getInputStream(<span class=\"number\">0</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> w=<span class=\"number\">1092</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h=<span class=\"number\">1080</span>;</span><br><span class=\"line\">                BitmapFactory.Options options2 = <span class=\"keyword\">new</span> BitmapFactory.Options();</span><br><span class=\"line\">                options2.inMutable=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">                options2.inPreferredConfig=Bitmap.Config.RGB_565;</span><br><span class=\"line\">                options2.inJustDecodeBounds=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">//inSampleSize是采样率，当inSampleSize为2时，一个2000 1000的图片，将被缩小至 1000 500</span></span><br><span class=\"line\">                options2.inSampleSize= Tool.sampleBitmapSize(options2,w,h);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Bitmap bitmap = BitmapFactory.decodeStream(inputStream,<span class=\"keyword\">null</span>,options2);</span><br><span class=\"line\">                bitMapValue.setBitmap(bitmap);</span><br><span class=\"line\">                <span class=\"comment\">//保存key唯一标识</span></span><br><span class=\"line\">                bitMapValue.setPath(path);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bitMapValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//....省略提交、流输出、关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"复用池的实现\"><a href=\"#复用池的实现\" class=\"headerlink\" title=\"复用池的实现\"></a>复用池的实现</h3><p>复用池的作用是将已经不需要使用的数据空间重新拿来使用，可以避免频繁申请内存，减少内存的抖动；在未使用复用池的情况下，每张图片都需要一块内存，在使用复用池的情况下，如果存在能被复用的图片就会重复使用改图片的内存。</p>\n<p><code>inMutable</code>是bitmapFactory的一个参数，表示该bitmap是可变的，支持复用的，在复用Bitmap之前需要设置<code>inMutable</code>为true<br><code>inBitmap</code>设置想要存储的bitmap</p>\n<p>复用池接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BitmapPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存入到Bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Bitmap bitmap)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取匹配 可用复用 Bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> w</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> h</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Bitmap <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> w,<span class=\"keyword\">int</span> h,Bitmap.Config config)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在复用池接口实现的过程中，继承<code>LruCache</code> 类，实现LRU算法；在复用池中通过Treemap对图片的内存空间进行排序，并通过TreeMap的<code>ceilingKey()</code>方法获取到合适的Bitmap内存；当Bitmap从内存缓存中移除后，会将其内存空间添加到复用池中；当Bitmap从磁盘中取出后，会先去查找复用池中是否有合适的空间，如果有则直接使用，否则开辟新的内存空间；</p>\n<p>我觉得应该先去看bitmap的内存申请</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitmapPoolImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">LruCache</span>&lt;<span class=\"title\">Integer</span>,<span class=\"title\">Bitmap</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">BitmapPool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为了筛选出合适的 Bitmap 容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMap&lt;Integer,String&gt;treeMap=<span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxSize for caches that do not override &#123;<span class=\"doctag\">@link</span> #sizeOf&#125;, this is</span></span><br><span class=\"line\"><span class=\"comment\">     *                the maximum number of entries in the cache. For all other caches,</span></span><br><span class=\"line\"><span class=\"comment\">     *                this is the maximum sum of the sizes of the entries in this cache.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitmapPoolImpl</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(maxSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//存入复用池</span></span><br><span class=\"line\">        bitmap.isMutable();</span><br><span class=\"line\">        <span class=\"comment\">//todo 条件一 bitmap.isMutable()==true;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!bitmap.isMutable())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bitmap.isRecycled()==<span class=\"keyword\">false</span>)&#123;</span><br><span class=\"line\">                bitmap.recycle();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//todo 条件二 就计算bitmap的大小,</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> bitmapSize = getBitmapSize(bitmap);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitmapSize&gt;maxSize())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bitmap.isRecycled()==<span class=\"keyword\">false</span>)&#123;</span><br><span class=\"line\">                bitmap.recycle();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//todo bitmap存入 LruCache</span></span><br><span class=\"line\">        put(bitmapSize,bitmap);</span><br><span class=\"line\">        <span class=\"comment\">//存入筛选容器</span></span><br><span class=\"line\">        treeMap.put(bitmapSize,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取可以复用Bitmap</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> h, Bitmap.Config config)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * ALPHA_8 理论上 实际上Android自动做处理的  只有透明度 8 位，一个字节</span></span><br><span class=\"line\"><span class=\"comment\">         * w*h*1</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * RGB_565 理论上 实际上Android自动处理的  R 5位 G 6位 B 5位 没有透明度 两个字节</span></span><br><span class=\"line\"><span class=\"comment\">         * w*h*2</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * ARGB_4444  理论上 实际上Android自动处理的 A 4位 R 4位 G 4位 B 4位  两个字节</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 质量最高：</span></span><br><span class=\"line\"><span class=\"comment\">         * ARGB_8888  Android默认使用  A 8位 R 8位 G 8位 B 8位  四个字节</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 常用的 ARGB_8888 RGB_565</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> getSize=w*h*(config==Bitmap.Config.ARGB_8888?<span class=\"number\">4</span>:<span class=\"number\">2</span>);  <span class=\"comment\">//只考虑两种，Glide所有的都考虑了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Integer key = treeMap.ceilingKey(getSize);<span class=\"comment\">//可以查找到容器里面 和 getSize一样大的，也可以比getSize还要大的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果treeMap还没有put,那么一定是null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;   <span class=\"comment\">//没有找到合适的可复用的key</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//查找容器取出来的key ,必须小于计算出来的 (getSize*2)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key&lt;=(getSize*<span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            Bitmap remove=remove(key);  <span class=\"comment\">//复用池如果要取出来，肯定要取出来，不给其他地方用</span></span><br><span class=\"line\">            Log.e(TAG,<span class=\"string\">&quot;从复用池中取出复用元素 bitmap&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> remove;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 计算Bitmap的大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getBitmapSize</span><span class=\"params\">(Bitmap  bitmap)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sdkInt= Build.VERSION.SDK_INT;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sdkInt&gt;=Build.VERSION_CODES.KITKAT)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bitmap.getAllocationByteCount();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bitmap.getByteCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//元素的大小</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Integer key, <span class=\"meta\">@NonNull</span> Bitmap value)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        return super.sizeOf(key, value);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBitmapSize(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, <span class=\"meta\">@NonNull</span> Integer key, <span class=\"meta\">@NonNull</span> Bitmap oldValue, <span class=\"meta\">@Nullable</span> Bitmap newValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.entryRemoved(evicted, key, oldValue, newValue);</span><br><span class=\"line\">        <span class=\"comment\">//吧TreeMap里面的给移除</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/LuciusCS/AndroidProject\">源码地址</a> 在<code>glidemodule</code>模块中进行实现</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Glide手写框架实现\"><a href=\"#Glide手写框架实现\" class=\"headerlink\" title=\"Glide手写框架实现\"></a>Glide手写框架实现</h1><h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><p>Glide框架实现主要有以下步骤</p>\n<p>图片下载后，先缓存至活动缓存；在获取缓存中通过弱引用监控bitMap的回收，如果活动缓存中bitMap的弱引用被回收，那么会将活动缓存中的bitMap，缓存至内存缓存；当图片被再次使用会从内存缓存中移除，添加到活动缓存中；</p>\n<ul>\n<li><p>活动缓存的实现</p>\n</li>\n<li><p>内存缓存的实现</p>\n</li>\n<li><p>磁盘缓存的实现</p>\n</li>\n<li><p>声明周期的管理</p>\n</li>\n</ul>\n<h3 id=\"实现前的准备\"><a href=\"#实现前的准备\" class=\"headerlink\" title=\"实现前的准备\"></a>实现前的准备</h3><p>1、在图片加载的过程中，采用&lt;Key,BitMap&gt;的形式获取图片对象；在使用的过程中，需要对图片文件的名称和路径进行加密，定义一个专门的类对名称和路径进行加密和解密，这样可以避免图片路径过长的问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Path</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String key;  <span class=\"comment\">//例如  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加密前 sha256 (https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy90cm01Vk1lRnA5blVESWdHaWJkVnlFSnk3MmlieVdXOElDWGlhamZDNlliNTc3YnVRTUdtYmUxR1hxSmhwVjNvUzhyWktENTIzODNVZDFpYkh6VTJDakxrUUEvNjQw?x-oss-process=image/format,png)</span></span><br><span class=\"line\"><span class=\"comment\">     * 加密后  ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Path</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = Tool.getSHA256StrJava( key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//添加getter和setter方法。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、在使用的过程中，需要对BitMap的使用状态以及回收状态进行处理，设置一个专门的类进行管理。在对BitMap进行管理的过程中，需要对BitMap的引用次数进行标记，当引用次数等于零时，回收BitMap的空间；BitMap回收采用回调的方式由外部进行回收</p>\n<p>回调接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ValueCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//活动缓存监听的方法（BitMap不再使用了）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">valueNonUseAction</span><span class=\"params\">(String path, BitMapValue bitMapValue)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在BitMap中 <code>bitmap</code>变量用于持有正在使用的图片对象，<code>count</code>变量用于对该对象的引用进行计数，会进行加一或者减一操作，<code>path</code>变量用于标记图片的路路径，<code>valueCallback</code>用于引用次数为零时的回调；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitMapValue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">BitMapValue</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//采用单利模式</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BitMapValue bitMapValue;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> BitMapValue <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//.....</span></span><br><span class=\"line\">        <span class=\"comment\">//省略单例实现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bitMapValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Bitmap bitmap;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//互动缓存监听</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueCallback valueCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">useAction</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitmap.isRecycled())&#123;   <span class=\"comment\">//已经被回收</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">nonUseAction</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            valueCallback.valueNonUseAction(path,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            recycleBitmap();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//释放bitmap</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recycleBitmap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        bitmap.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">        bitMapValue =<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加getter和setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"活动缓存的实现\"><a href=\"#活动缓存的实现\" class=\"headerlink\" title=\"活动缓存的实现\"></a>活动缓存的实现</h3><p>活动缓存用于存储应用中正在使用的图片资源，采用弱引用的方式便于系统及时回收；在活动缓存中采用&lt;Path,Bitmap&gt;的方式表示的正在使用的图片信息;</p>\n<p>在活动缓存中需要对被回收的对象的引用进行监听，当对象被回收后，需要将其加入到内存缓存中。</p>\n<p>变量<code>Map&lt;String, WeakReference&lt;BitMapValue&gt;&gt;mapList</code>用于持有缓存对象的弱引用，<code>mapList</code>的<code>value</code>是一个弱引用，会被自动回收，需要对该弱引用的回收做监听，处理弱引用回收后的操作，因此需要创建一个<code>CustomWeakReference</code>内部类；</p>\n<p>变量<code>Map&lt;String, Bitmap&gt;mapValueList</code>用于持有缓存对象的引用，其中保存的对象与<code>mapList</code>中的对象一致，<code>mapList</code>中的弱引用被回收后，需要通过获取<code>mapValueList</code>中的Bitmap对象，将其缓存至内存缓存中；</p>\n<p>变量<code>ReferenceQueue&lt;BitMapValue&gt;queue</code> 将<code>BitMapValue</code>的弱引用添加到该队列中，通过调用<code>remove</code>这一阻塞方法监听弱引用是否被回收。</p>\n<p>变量<code>boolean isCloseThread</code> 用于监听是否将弱引用回收监听的线程进行停止；</p>\n<p>变量<code>Thread thread</code> 用于表示弱引用回收监听线程</p>\n<p>方法<code> put(String path, BitMapValue bitMapValue)</code>用于添加活动缓存；<br>方法<code>get(String key)</code>用于获取活动缓存；<br>方法<code> closeActiveCache()</code>用于关闭活动缓存</p>\n<p>内部类 <code>class CustomWeakReference </code>用于在弱引用被回收后，获取该 BitMapValue 的 path和bitmap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActiveCache</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, WeakReference&lt;BitMapValue&gt;&gt;mapList=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Bitmap&gt;mapValueList=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReferenceQueue&lt;BitMapValue&gt;queue;    <span class=\"comment\">//目的：为了监听弱引用是否被回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isCloseThread;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueCallback valueCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ActiveCache</span><span class=\"params\">(ValueCallback valueCallback)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.valueCallback=valueCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * TODO 添加活动缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bitMapValue</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String path, BitMapValue bitMapValue)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Tool.checkNotEmpty(path);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//绑定Value的监听，Value没有被使用了，就会发起这个监听，给外界业务需要来使用)</span></span><br><span class=\"line\">        bitMapValue.setValueCallback(valueCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">        mapList.put(path,<span class=\"keyword\">new</span> CustomWeakReference(bitMapValue,getQueue(),path));</span><br><span class=\"line\"></span><br><span class=\"line\">        mapValueList.put(path,bitMapValue.getBitmap());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * TODO 给外界获取value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BitMapValue <span class=\"title\">get</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        WeakReference&lt;BitMapValue&gt;valueWeakReference=mapList.get(path);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=valueWeakReference)&#123;</span><br><span class=\"line\">            BitMapValue value=valueWeakReference.get();   <span class=\"comment\">//返回value</span></span><br><span class=\"line\">            value.setBitmap(mapValueList.get(path));</span><br><span class=\"line\">            value.setPath(path);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;   <span class=\"comment\">//返回value</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//主动释放内存缓存，并将线程进行关闭</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">closeActiveCache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        isCloseThread=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mapList.clear();;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//监听弱引用，成为弱引用的子类，为了监听弱引用是否被回收，并获取弱引用回收后的 path和 BitMapValue</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomWeakReference</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">BitMapValue</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> BitMapValue value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomWeakReference</span><span class=\"params\">(BitMapValue referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> BitMapValue&gt; q,String path)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.path =path;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value=referent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建弱引用队列，并对弱引用的回收进行监听</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReferenceQueue&lt;BitMapValue&gt;getQueue()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            queue=<span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">            thread= <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (!isCloseThread)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//阻塞式方法 如果有引用被回收，则会执行该方法，并返回被回收的对象</span></span><br><span class=\"line\">                            Reference&lt;? extends BitMapValue&gt; remove = queue.remove(); </span><br><span class=\"line\">                            CustomWeakReference weakReference = (CustomWeakReference) remove;</span><br><span class=\"line\"></span><br><span class=\"line\">                             <span class=\"comment\">//将引用移除容器</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (mapList != <span class=\"keyword\">null</span> &amp;&amp; !mapList.isEmpty()) &#123;</span><br><span class=\"line\">                                    mapList.remove(weakReference.path);</span><br><span class=\"line\">                                    mapValueList.remove(weakReference.path);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125; &#125; &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"内存缓存的实现\"><a href=\"#内存缓存的实现\" class=\"headerlink\" title=\"内存缓存的实现\"></a>内存缓存的实现</h3><p>内存缓存将使用的图片资源缓存至内存中，采用LRU算法进行回收,继承<code>LruCache&lt;K, V&gt;</code>接口，并在初始化的时候设置图片缓存的最大值。内存缓存的图片在每一次调用之后，都会进行移除后再次加入到活动缓存中；</p>\n<p>与活动缓存一样，内存缓存在缓存中的BitMapValue被移除后，需要进行回调，内存缓存回调接口如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface MemoryCacheCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 内存缓存中移除的path</span><br><span class=\"line\">     * @param path</span><br><span class=\"line\">     * @param oldBitMapValue</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    public void entryRemoveMemoryCache(String path,@NonNull BitMapValue oldBitMapValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>内存缓存的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemoryCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LruCache</span> &lt;<span class=\"title\">String</span>, <span class=\"title\">BitMapValue</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> manualRemove;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO 手动移除 Manual</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BitMapValue <span class=\"title\">manualRemove</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\">        manualRemove=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">       BitMapValue bitMapValue =remove(path);</span><br><span class=\"line\">        manualRemove=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> bitMapValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MemoryCacheCallback memoryCacheCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemoryCacheCallback</span><span class=\"params\">(MemoryCacheCallback memoryCacheCallback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.memoryCacheCallback = memoryCacheCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 传入元素最大值给 LruCache</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MemoryCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(maxSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> BitMapValue bitMapValue)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        return super.sizeOf(key, value);</span></span><br><span class=\"line\">        Bitmap bitmap= bitMapValue.getBitmap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//最开始的的时候</span></span><br><span class=\"line\"><span class=\"comment\">//        int result=bitmap.getRowBytes()*bitmap.getHeight();</span></span><br><span class=\"line\">        <span class=\"comment\">//API 12  3.0</span></span><br><span class=\"line\"><span class=\"comment\">//        int result=bitmap.getByteCount();  //bitmap内存复用上有区别(所属的)</span></span><br><span class=\"line\">        <span class=\"comment\">//API 19 4.4</span></span><br><span class=\"line\"><span class=\"comment\">//        int result=bitmap.getAllocationByteCount();//bitmap内存复用上有区别(整个的)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sdkInt= Build.VERSION.SDK_INT;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sdkInt&gt;=Build.VERSION_CODES.KITKAT)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bitmap.getAllocationByteCount();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bitmap.getByteCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 重复的key</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 最少使用的元素会被移除</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evicted</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> oldBitMapValue</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> newBitMapValue</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, <span class=\"meta\">@NonNull</span> String key, <span class=\"meta\">@NonNull</span> BitMapValue oldBitMapValue, <span class=\"meta\">@Nullable</span> BitMapValue newBitMapValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.entryRemoved(evicted, key, oldBitMapValue, newBitMapValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (memoryCacheCallback!=<span class=\"keyword\">null</span>&amp;&amp;!manualRemove)&#123;  <span class=\"comment\">//被动删除</span></span><br><span class=\"line\">            memoryCacheCallback.entryRemoveMemoryCache(key, oldBitMapValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘缓存的实现\"><a href=\"#磁盘缓存的实现\" class=\"headerlink\" title=\"磁盘缓存的实现\"></a>磁盘缓存的实现</h3><p>以文件的形式保存至本地磁盘，文件名称需要通过<code>Path</code>类进行设置，在磁盘缓存中借助于 <a href=\"https://github.com/JakeWharton/DiskLruCache\">https://github.com/JakeWharton/DiskLruCache</a> 中的  <code>DiskLruCache.java</code> <code>StrictLineReader.java</code> <code>Util.java </code> 并对DiskLruCache进行封装。在封装的过程中，需要指定磁盘缓存的路径、缓存文件的最大值，以及put和get方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiskLruCacheImpl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//SD/disk_lru_cache_dir/ac43474d52403e60fe21894520a67d6f417a6868994c145eeb26712472a78311</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String DISKLRU_CACHE_DIR=<span class=\"string\">&quot;disk_lru_cache_dir&quot;</span>;  <span class=\"comment\">//磁盘缓存的目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> APP_VERSION=<span class=\"number\">1</span>;   <span class=\"comment\">//我们的版本号，一旦修改这个版本号，之前的缓存失效</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> VALUE_COUNT=<span class=\"number\">1</span>;  <span class=\"comment\">//通常情况下是1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> MAX_SIZE=<span class=\"number\">1024</span>*<span class=\"number\">1024</span>*<span class=\"number\">10l</span>; <span class=\"comment\">//指定缓存文件最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiskLruCache diskLruCache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiskLruCacheImpl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        File file=<span class=\"keyword\">new</span> File(Environment.getExternalStorageDirectory()+File.separator+DISKLRU_CACHE_DIR);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            diskLruCache= DiskLruCache.open(file,APP_VERSION,VALUE_COUNT,MAX_SIZE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//TODO put</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String path)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        DiskLruCache.Editor editor=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        OutputStream outputStream=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            editor=diskLruCache.edit(path);</span><br><span class=\"line\"></span><br><span class=\"line\">           outputStream=editor.newOutputStream(<span class=\"number\">0</span>);  <span class=\"comment\">//index不能大于 VALUE_COUNT</span></span><br><span class=\"line\"></span><br><span class=\"line\">            Bitmap bitmap= bitMapValue.getBitmap();</span><br><span class=\"line\"></span><br><span class=\"line\">            bitmap.compress(Bitmap.CompressFormat.PNG,<span class=\"number\">100</span>,outputStream);  <span class=\"comment\">//吧把BitMap 写入outputStream</span></span><br><span class=\"line\"></span><br><span class=\"line\">            outputStream.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//....省略</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//....省略提交，流输出、关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BitMapValue <span class=\"title\">get</span><span class=\"params\">(String path, BitmapPool bitmapPool)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        InputStream inputStream=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            DiskLruCache.Snapshot snapshot=diskLruCache.get(key);</span><br><span class=\"line\">            <span class=\"comment\">//判断快照不为null的情况下，再去读操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span>!=snapshot)&#123;</span><br><span class=\"line\">                BitMapValue bitMapValue = BitMapValue.getInstance();</span><br><span class=\"line\">                inputStream=snapshot.getInputStream(<span class=\"number\">0</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">int</span> w=<span class=\"number\">1092</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> h=<span class=\"number\">1080</span>;</span><br><span class=\"line\">                BitmapFactory.Options options2 = <span class=\"keyword\">new</span> BitmapFactory.Options();</span><br><span class=\"line\">                options2.inMutable=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">                options2.inPreferredConfig=Bitmap.Config.RGB_565;</span><br><span class=\"line\">                options2.inJustDecodeBounds=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">//inSampleSize是采样率，当inSampleSize为2时，一个2000 1000的图片，将被缩小至 1000 500</span></span><br><span class=\"line\">                options2.inSampleSize= Tool.sampleBitmapSize(options2,w,h);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Bitmap bitmap = BitmapFactory.decodeStream(inputStream,<span class=\"keyword\">null</span>,options2);</span><br><span class=\"line\">                bitMapValue.setBitmap(bitmap);</span><br><span class=\"line\">                <span class=\"comment\">//保存key唯一标识</span></span><br><span class=\"line\">                bitMapValue.setPath(path);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bitMapValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//....省略提交、流输出、关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"复用池的实现\"><a href=\"#复用池的实现\" class=\"headerlink\" title=\"复用池的实现\"></a>复用池的实现</h3><p>复用池的作用是将已经不需要使用的数据空间重新拿来使用，可以避免频繁申请内存，减少内存的抖动；在未使用复用池的情况下，每张图片都需要一块内存，在使用复用池的情况下，如果存在能被复用的图片就会重复使用改图片的内存。</p>\n<p><code>inMutable</code>是bitmapFactory的一个参数，表示该bitmap是可变的，支持复用的，在复用Bitmap之前需要设置<code>inMutable</code>为true<br><code>inBitmap</code>设置想要存储的bitmap</p>\n<p>复用池接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BitmapPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存入到Bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Bitmap bitmap)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取匹配 可用复用 Bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> w</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> h</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Bitmap <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> w,<span class=\"keyword\">int</span> h,Bitmap.Config config)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在复用池接口实现的过程中，继承<code>LruCache</code> 类，实现LRU算法；在复用池中通过Treemap对图片的内存空间进行排序，并通过TreeMap的<code>ceilingKey()</code>方法获取到合适的Bitmap内存；当Bitmap从内存缓存中移除后，会将其内存空间添加到复用池中；当Bitmap从磁盘中取出后，会先去查找复用池中是否有合适的空间，如果有则直接使用，否则开辟新的内存空间；</p>\n<p>我觉得应该先去看bitmap的内存申请</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitmapPoolImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">LruCache</span>&lt;<span class=\"title\">Integer</span>,<span class=\"title\">Bitmap</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">BitmapPool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为了筛选出合适的 Bitmap 容器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMap&lt;Integer,String&gt;treeMap=<span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxSize for caches that do not override &#123;<span class=\"doctag\">@link</span> #sizeOf&#125;, this is</span></span><br><span class=\"line\"><span class=\"comment\">     *                the maximum number of entries in the cache. For all other caches,</span></span><br><span class=\"line\"><span class=\"comment\">     *                this is the maximum sum of the sizes of the entries in this cache.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitmapPoolImpl</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(maxSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//存入复用池</span></span><br><span class=\"line\">        bitmap.isMutable();</span><br><span class=\"line\">        <span class=\"comment\">//todo 条件一 bitmap.isMutable()==true;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!bitmap.isMutable())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bitmap.isRecycled()==<span class=\"keyword\">false</span>)&#123;</span><br><span class=\"line\">                bitmap.recycle();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//todo 条件二 就计算bitmap的大小,</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> bitmapSize = getBitmapSize(bitmap);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitmapSize&gt;maxSize())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bitmap.isRecycled()==<span class=\"keyword\">false</span>)&#123;</span><br><span class=\"line\">                bitmap.recycle();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//todo bitmap存入 LruCache</span></span><br><span class=\"line\">        put(bitmapSize,bitmap);</span><br><span class=\"line\">        <span class=\"comment\">//存入筛选容器</span></span><br><span class=\"line\">        treeMap.put(bitmapSize,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取可以复用Bitmap</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> h, Bitmap.Config config)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * ALPHA_8 理论上 实际上Android自动做处理的  只有透明度 8 位，一个字节</span></span><br><span class=\"line\"><span class=\"comment\">         * w*h*1</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * RGB_565 理论上 实际上Android自动处理的  R 5位 G 6位 B 5位 没有透明度 两个字节</span></span><br><span class=\"line\"><span class=\"comment\">         * w*h*2</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * ARGB_4444  理论上 实际上Android自动处理的 A 4位 R 4位 G 4位 B 4位  两个字节</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 质量最高：</span></span><br><span class=\"line\"><span class=\"comment\">         * ARGB_8888  Android默认使用  A 8位 R 8位 G 8位 B 8位  四个字节</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 常用的 ARGB_8888 RGB_565</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> getSize=w*h*(config==Bitmap.Config.ARGB_8888?<span class=\"number\">4</span>:<span class=\"number\">2</span>);  <span class=\"comment\">//只考虑两种，Glide所有的都考虑了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Integer key = treeMap.ceilingKey(getSize);<span class=\"comment\">//可以查找到容器里面 和 getSize一样大的，也可以比getSize还要大的</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果treeMap还没有put,那么一定是null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;   <span class=\"comment\">//没有找到合适的可复用的key</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//查找容器取出来的key ,必须小于计算出来的 (getSize*2)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key&lt;=(getSize*<span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">            Bitmap remove=remove(key);  <span class=\"comment\">//复用池如果要取出来，肯定要取出来，不给其他地方用</span></span><br><span class=\"line\">            Log.e(TAG,<span class=\"string\">&quot;从复用池中取出复用元素 bitmap&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> remove;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 计算Bitmap的大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> bitmap</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getBitmapSize</span><span class=\"params\">(Bitmap  bitmap)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sdkInt= Build.VERSION.SDK_INT;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sdkInt&gt;=Build.VERSION_CODES.KITKAT)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> bitmap.getAllocationByteCount();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> bitmap.getByteCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//元素的大小</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Integer key, <span class=\"meta\">@NonNull</span> Bitmap value)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        return super.sizeOf(key, value);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBitmapSize(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, <span class=\"meta\">@NonNull</span> Integer key, <span class=\"meta\">@NonNull</span> Bitmap oldValue, <span class=\"meta\">@Nullable</span> Bitmap newValue)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.entryRemoved(evicted, key, oldValue, newValue);</span><br><span class=\"line\">        <span class=\"comment\">//吧TreeMap里面的给移除</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/LuciusCS/AndroidProject\">源码地址</a> 在<code>glidemodule</code>模块中进行实现</p>\n"},{"title":"Retrofit 框架介绍与使用","cover":"/cover/img35.jpg","toc":true,"description":"Retrofit 框架介绍与使用","type":["Android"],"date":"2019-12-19T16:00:00.000Z","_content":"\n\n## Retrofit 框架使用\n\n\n#### 请求内容与返回值\n\n使用PostMan进行请求测试\n请求：`https://api.github.com/search/repositories?q=android`\n\n<!--more-->\n返回值：\n\nHeader:\n![](/public/img/Android/Retrofit.png)\n\n\nBody:\n```json\n{\n    \"total_count\": 943593,\n    \"incomplete_results\": false,\n    \"items\": [\n        {\n            \"id\": 82128465,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\",\n            \"name\": \"Android\",\n            \"full_name\": \"open-android/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"open-android\",\n                \"id\": 23095877,\n                \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\",\n                \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\",\n                //……\n            },\n            \"html_url\": \"https://github.com/open-android/Android\",\n            \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\",\n            \"fork\": false,\n            \"url\": \"https://api.github.com/repos/open-android/Android\",\n            //……\n        },\n        {\n            \"id\": 12544093,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\",\n            \"name\": \"Android\",\n            \"full_name\": \"hmkcode/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"hmkcode\",\n                \"id\": 3790597,\n                //……\n            },\n            //……\n        }\n    ]\n}\n```\n#### 引入Retrofit依赖\n\n```java\n    implementation 'com.squareup.retrofit2:retrofit:2.5.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'\n```\n#### 根据返回的请求结果定义Repository Bean类\n返回的报文采用google.gson进行处理，金处理必要的值\n\n```java\npublic class RepoBean {\n\n    //用于表示Repo id\n    private int id;\n    //用于表示RepoName\n    private String name;\n\n    //用于表示完整名称\n    //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注\n    @SerializedName(\"full_name\")\n    private String fullName;\n    \n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 根据返回的请求结果定义一次查询结果\n\n```java\npublic class SearchRepoBean {\n\n    //用于表示仓库数量\n    @SerializedName(\"total_count\")\n    private int totalCount;\n    //用于表示是否为完整结果\n    private boolean incompleteResults;\n    //用于表示持有的所有的仓库类\n    private List<RepoBean>items;\n\n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 定义网络请求API接口\n\n```java\n    public interface GithubService {\n        \n        //@Get注解，表示以Get方法发送网络请求\n        //返回类型为Call<SearchRepoBean>，SearchRepoBean是接收数据的类，可以自定义\n        @GET(\"search/repositories\")\n        Call<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n\n```\n\n#### 初始化Retrofit实例，生成接口实现类\n\n```java\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")                   //设置网络请求的URL地址           \n                .addConverterFactory(GsonConverterFactory.create())   //设置数据解析器 \n                .build();\n\n        githubService = retrofit.create(GithubService.class);\n\n```\n\n#### 进行网络请求\n\n```java\n\n    Call<SearchRepoBean> call = githubService.getRepoInfo(\"Android\");\n        //同步请求方式\n        //call.request();\n        //异步请求方式\n        call.enqueue(new Callback<SearchRepoBean>() {\n            @Override\n            public void onResponse(Call<SearchRepoBean> call, Response<SearchRepoBean> response) {\n              //输出请求结果 \n              //  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());\n               // List<RepoBean>repoBeans=new ArrayList<>();\n               // repoBeans.addAll(response.body().getItems());\n               // for (int i=repoBeans.size()-1;i>=0;i--){\n               //  LogUtils.printInfo(repoBeans.get(i).getFullName());\n               // }\n              }\n\n            @Override\n            public void onFailure(Call<SearchRepoBean> call, Throwable t) {\n                }\n            });\n```\n\n#### 将请求值的返回设为LiveData\n\n将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现\n\n```java\n    public interface GithubService {\n         @GET(\"search/repositories\")\n         LiveData<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n```\n自定义LiveDataCallAdapterFactory \n\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n\n        //用于获取泛型的参数\n        Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n        Class<?> rawObserverType = getRawType(observerType);\n\n\n        LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType);\n\n        return liveDataCallAdapter;\n        }\n    }\n\n\n```\n自定义 LiveDataCallAdapter\n```java\n\n    public class LiveDataCallAdapter<R> implements CallAdapter<R, LiveData<SearchRepoBean>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<SearchRepoBean> adapt(final Call<R> call) {\n\n             LiveData<SearchRepoBean>searchRepoBeanLiveData=new LiveData<SearchRepoBean>() {\n\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n    \n                    @Override\n                    public void onResponse(Call<R> call, Response<R> response) {\n                        postValue((SearchRepoBean) response.body());\n                    }\n\n                    @Override\n                    public void onFailure(Call<R> call, Throwable t) {\n                        LogUtils.printInfo(\"error\");\n                    }\n                });\n            }\n        };\n        //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值\n       return searchRepoBeanLiveData;\n    }\n    }\n\n```\n为Retrofit实例添加CallAdapterFactory\n\n```java\n      Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(new LiveDataCallAdapterFactory())\n                .build();\n\n```\n调用方法\n```java\n\n            repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n            repoBeanLiveData.observe(GithubApiActivity.this, new Observer<SearchRepoBean>() {\n                @Override\n                public void onChanged(SearchRepoBean searchRepoBean) {                            \n                     //输出结果\n                    }\n                });\n\n```\n\n\n#### 添加通用的响应实体\n\n通过`LiveDataCallAdapter` 和`LiveDataCallAdapterFactory` 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为`SearchRepoBean`类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。\n\n定义一个通用的响应实体\n\n```java\n    public class ApiResponse<T> {\n\n    public ApiResponseSuccess<T> create(Response<T> response) {\n        if (response.isSuccessful()) {\n            return new ApiResponseSuccess<T>(response.body());\n        } else {\n            return null;\n        }\n    }\n\n    //用于表示返回成功的值\n    public static class ApiResponseSuccess<T> extends ApiResponse<T> {\n        /用于表示请求返回成功的内容，在本代码中是SearchRepoBean\n        private T body;\n\n        public ApiResponseSuccess(T body) {\n            this.body = body;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n  }\n\n```\n修改LiveDataCallAdapterFactory\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n            //用于获取泛型的参数\n            //return type为LiveData<ApiResponse<SearchRepoBean>> \n            //observerType为ApiResponse<SearchRepoBean>\n            Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n            //bodyType为SearchRepoBean\n            Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType);\n            LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType);\n\n            return liveDataCallAdapter;\n        }\n    }\n\n```\n修改LiveDataCallAdapter\n\n```java\n    public class LiveDataCallAdapter<R> implements CallAdapter<R,LiveData<ApiResponse<R>>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<ApiResponse<R>> adapt(final Call<R> call) {\n            LiveData<ApiResponse<R>> result=new LiveData<ApiResponse<R>>() {\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n                        @Override\n                        public void onResponse(Call<R> call, Response<R> response) {\n                       postValue(new ApiResponse<R>().create(response));\n                    }\n\n                        @Override\n                        public void onFailure(Call<R> call, Throwable t) {\n                          //  LogUtils.printInfo(\"+++++!2312qwqweww31\");\n                        }\n                    });\n                }\n            };\n        return result;\n    }\n}\n```\n\n修改调用方法\n```java\n    repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n    repoBeanLiveData.observe(GithubApiActivity.this, new Observer<ApiResponse<SearchRepoBean>>() {\n        @Override\n        public void onChanged(ApiResponse<SearchRepoBean> searchRepoBeanApiResponse) {\n            SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();\n           //输出结果\n        }\n    });\n\n```\n\n## 源码详解\n\n##### Retrofit构建中的`.baseUrl(\"https://api.github.com/\")`介绍\nRetrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型\n```java\n\n    public final class Retrofit {\n\n      public static final class Builder {\n             public Builder baseUrl(String baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  return baseUrl(HttpUrl.get(baseUrl));\n                }\n                \n            public Builder baseUrl(HttpUrl baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  List<String> pathSegments = baseUrl.pathSegments();\n                  if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n                    throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n                  }\n              this.baseUrl = baseUrl;\n              return this;\n            }\n          }\n        }\n\n```\n\n##### Retrofit构建中的`.addConverterFactory(GsonConverterFactory.create())`\n通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory\n\n```java\n    public Builder addConverterFactory(Converter.Factory factory) {\n      converterFactories.add(checkNotNull(factory, \"factory == null\"));\n      return this;\n    }\n\n```\nConverter接口源码，核心是`T convert(F value)`,将F类型的数据转换为T类型\n\n```java\n\npublic interface Converter<F, T> {\n  //将F类型的数据转换为T类型\n  @Nullable T convert(F value) throws IOException;\n\n  //根据数据类型创建Converter创建 Converter\n  abstract class Factory {\n    //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。\n    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,\n        Annotation[] annotations, Retrofit retrofit) {\n      return null;\n    }\n\n       //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody\n    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,\n        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n      return null;\n    }\n        //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String\n    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n      return null;\n    }\n\n    protected static Type getParameterUpperBound(int index, ParameterizedType type) {\n      return Utils.getParameterUpperBound(index, type);\n    }\n\n    protected static Class<?> getRawType(Type type) {\n      return Utils.getRawType(type);\n    }\n  }\n}\n\n```\n\n\n##### Retrofit构建中的`.addCallAdapterFactory(new LiveDataCallAdapterFactory())`\n用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用\n\n```java\npublic final class Retrofit {\n      final List<CallAdapter.Factory> callAdapterFactories;\n      \n      //…………\n      public Builder addCallAdapterFactory(CallAdapter.Factory factory) {\n          callAdapterFactories.add(checkNotNull(factory, \"factory == null\"));\n          return this;\n        }\n      //…………\n}\n\n```\n\n##### 最终用来创建Service的代码`retrofit.create(GithubService.class)`\ncreate()采用代理的方式进行创建，\n\n```java\npublic final class Retrofit {\n  //……\n  public <T> T create(final Class<T> service) {\n    //判断定义的接口服务是否可用\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // 如果是Object本身的方法，正常调用后返回\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            //如果是platform默认的方法，正常调用后返回\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            //解析我们定义的网络请求的方法\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n  //……\n}\n```\n`loadServiceMethod(Method method)`源码解析,其实际上是HttpServiceMethod对象\n\n```java\n\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    //从解析的缓存中获取\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        \n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n\n```\n` static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method)`源码\n\n```java\nabstract class ServiceMethod<T> {\n      static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n      //RequestFactory负责解析接口并且生成Request\n        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n       //…………\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract T invoke(Object[] args);\n}\n\n\n```\n\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)`源码\n\n```java\n\n//将一个接口方法转变为一个Http请求\nfinal class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {\n\n  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n      //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码\n    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);\n \n    //……\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    okhttp3.Call.Factory callFactory = retrofit.callFactory;\n    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);\n  }\n\n  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(\n      Retrofit retrofit, Method method) {\n    Type returnType = method.getGenericReturnType();\n    Annotation[] annotations = method.getAnnotations();\n    try {\n      //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter\n      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);\n    } catch (RuntimeException e) { // Wide exception range because factories are user code.\n      throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n    }\n  }\n\n //…………\n\n  private final RequestFactory requestFactory;\n  private final okhttp3.Call.Factory callFactory;\n  private final CallAdapter<ResponseT, ReturnT> callAdapter;\n  private final Converter<ResponseBody, ResponseT> responseConverter;\n\n  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n      CallAdapter<ResponseT, ReturnT> callAdapter,\n      Converter<ResponseBody, ResponseT> responseConverter) {\n    this.requestFactory = requestFactory;\n    this.callFactory = callFactory;\n    this.callAdapter = callAdapter;\n    this.responseConverter = responseConverter;\n  }\n\n  //代理调用的invoke最终会调用下面invoke方法\n  @Override ReturnT invoke(Object[] args) {\n    return callAdapter.adapt(\n        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));\n  }\n}\n\n\n`call.enqueue(new Callback<SearchRepoBean>() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})`\n\n```java\n\nfinal class OkHttpCall<T> implements Call<T> {\n\n    //……\n   @Override public void enqueue(final Callback<T> callback) {\n\n    //……\n    call.enqueue(new okhttp3.Callback() {\n      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        //……\n        try {\n          callback.onResponse(OkHttpCall.this, response);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n    });\n   }\n    //……\n}\n\n```\n\n\n\n\n\n\n\n","source":"_posts/Android/框架/Retrofit/Retrofit 2.5 框架使用与源码分析.md","raw":"---\ntitle: Retrofit 框架介绍与使用\ncover: /cover/img35.jpg\ntoc: true\ncategories: Android\ndescription: Retrofit 框架介绍与使用\ntype: [Android]\ndate: 2019/12/20\n---\n\n\n## Retrofit 框架使用\n\n\n#### 请求内容与返回值\n\n使用PostMan进行请求测试\n请求：`https://api.github.com/search/repositories?q=android`\n\n<!--more-->\n返回值：\n\nHeader:\n![](/public/img/Android/Retrofit.png)\n\n\nBody:\n```json\n{\n    \"total_count\": 943593,\n    \"incomplete_results\": false,\n    \"items\": [\n        {\n            \"id\": 82128465,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==\",\n            \"name\": \"Android\",\n            \"full_name\": \"open-android/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"open-android\",\n                \"id\": 23095877,\n                \"node_id\": \"MDQ6VXNlcjIzMDk1ODc3\",\n                \"avatar_url\": \"https://avatars2.githubusercontent.com/u/23095877?v=4\",\n                //……\n            },\n            \"html_url\": \"https://github.com/open-android/Android\",\n            \"description\": \"GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频\",\n            \"fork\": false,\n            \"url\": \"https://api.github.com/repos/open-android/Android\",\n            //……\n        },\n        {\n            \"id\": 12544093,\n            \"node_id\": \"MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==\",\n            \"name\": \"Android\",\n            \"full_name\": \"hmkcode/Android\",\n            \"private\": false,\n            \"owner\": {\n                \"login\": \"hmkcode\",\n                \"id\": 3790597,\n                //……\n            },\n            //……\n        }\n    ]\n}\n```\n#### 引入Retrofit依赖\n\n```java\n    implementation 'com.squareup.retrofit2:retrofit:2.5.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.5.0'\n```\n#### 根据返回的请求结果定义Repository Bean类\n返回的报文采用google.gson进行处理，金处理必要的值\n\n```java\npublic class RepoBean {\n\n    //用于表示Repo id\n    private int id;\n    //用于表示RepoName\n    private String name;\n\n    //用于表示完整名称\n    //Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注\n    @SerializedName(\"full_name\")\n    private String fullName;\n    \n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 根据返回的请求结果定义一次查询结果\n\n```java\npublic class SearchRepoBean {\n\n    //用于表示仓库数量\n    @SerializedName(\"total_count\")\n    private int totalCount;\n    //用于表示是否为完整结果\n    private boolean incompleteResults;\n    //用于表示持有的所有的仓库类\n    private List<RepoBean>items;\n\n    //省略getter和setter\n    //……\n}\n\n```\n\n#### 定义网络请求API接口\n\n```java\n    public interface GithubService {\n        \n        //@Get注解，表示以Get方法发送网络请求\n        //返回类型为Call<SearchRepoBean>，SearchRepoBean是接收数据的类，可以自定义\n        @GET(\"search/repositories\")\n        Call<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n\n```\n\n#### 初始化Retrofit实例，生成接口实现类\n\n```java\n\n        Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")                   //设置网络请求的URL地址           \n                .addConverterFactory(GsonConverterFactory.create())   //设置数据解析器 \n                .build();\n\n        githubService = retrofit.create(GithubService.class);\n\n```\n\n#### 进行网络请求\n\n```java\n\n    Call<SearchRepoBean> call = githubService.getRepoInfo(\"Android\");\n        //同步请求方式\n        //call.request();\n        //异步请求方式\n        call.enqueue(new Callback<SearchRepoBean>() {\n            @Override\n            public void onResponse(Call<SearchRepoBean> call, Response<SearchRepoBean> response) {\n              //输出请求结果 \n              //  LogUtils.printInfo(\"搜索到的仓库的数量：\" + response.body().getItems().size());\n               // List<RepoBean>repoBeans=new ArrayList<>();\n               // repoBeans.addAll(response.body().getItems());\n               // for (int i=repoBeans.size()-1;i>=0;i--){\n               //  LogUtils.printInfo(repoBeans.get(i).getFullName());\n               // }\n              }\n\n            @Override\n            public void onFailure(Call<SearchRepoBean> call, Throwable t) {\n                }\n            });\n```\n\n#### 将请求值的返回设为LiveData\n\n将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现\n\n```java\n    public interface GithubService {\n         @GET(\"search/repositories\")\n         LiveData<SearchRepoBean> getRepoInfo(@Query(\"q\") String query);\n    }\n```\n自定义LiveDataCallAdapterFactory \n\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n\n        //用于获取泛型的参数\n        Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n        Class<?> rawObserverType = getRawType(observerType);\n\n\n        LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(rawObserverType);\n\n        return liveDataCallAdapter;\n        }\n    }\n\n\n```\n自定义 LiveDataCallAdapter\n```java\n\n    public class LiveDataCallAdapter<R> implements CallAdapter<R, LiveData<SearchRepoBean>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<SearchRepoBean> adapt(final Call<R> call) {\n\n             LiveData<SearchRepoBean>searchRepoBeanLiveData=new LiveData<SearchRepoBean>() {\n\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n    \n                    @Override\n                    public void onResponse(Call<R> call, Response<R> response) {\n                        postValue((SearchRepoBean) response.body());\n                    }\n\n                    @Override\n                    public void onFailure(Call<R> call, Throwable t) {\n                        LogUtils.printInfo(\"error\");\n                    }\n                });\n            }\n        };\n        //这里的return 即为下文中githubService.getRepoInfo(\"Android\")调用的返回值\n       return searchRepoBeanLiveData;\n    }\n    }\n\n```\n为Retrofit实例添加CallAdapterFactory\n\n```java\n      Retrofit retrofit = new Retrofit.Builder()\n                .baseUrl(\"https://api.github.com/\")\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(new LiveDataCallAdapterFactory())\n                .build();\n\n```\n调用方法\n```java\n\n            repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n            repoBeanLiveData.observe(GithubApiActivity.this, new Observer<SearchRepoBean>() {\n                @Override\n                public void onChanged(SearchRepoBean searchRepoBean) {                            \n                     //输出结果\n                    }\n                });\n\n```\n\n\n#### 添加通用的响应实体\n\n通过`LiveDataCallAdapter` 和`LiveDataCallAdapterFactory` 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为`SearchRepoBean`类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。\n\n定义一个通用的响应实体\n\n```java\n    public class ApiResponse<T> {\n\n    public ApiResponseSuccess<T> create(Response<T> response) {\n        if (response.isSuccessful()) {\n            return new ApiResponseSuccess<T>(response.body());\n        } else {\n            return null;\n        }\n    }\n\n    //用于表示返回成功的值\n    public static class ApiResponseSuccess<T> extends ApiResponse<T> {\n        /用于表示请求返回成功的内容，在本代码中是SearchRepoBean\n        private T body;\n\n        public ApiResponseSuccess(T body) {\n            this.body = body;\n        }\n\n        public T getBody() {\n            return body;\n        }\n    }\n  }\n\n```\n修改LiveDataCallAdapterFactory\n```java\n    public class LiveDataCallAdapterFactory extends CallAdapter.Factory {\n\n        @Override\n        public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {\n            //用于获取泛型的参数\n            //return type为LiveData<ApiResponse<SearchRepoBean>> \n            //observerType为ApiResponse<SearchRepoBean>\n            Type observerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n            //bodyType为SearchRepoBean\n            Type bodyType = getParameterUpperBound(0, (ParameterizedType) observerType);\n            LiveDataCallAdapter<Object> liveDataCallAdapter = new LiveDataCallAdapter<>(bodyType);\n\n            return liveDataCallAdapter;\n        }\n    }\n\n```\n修改LiveDataCallAdapter\n\n```java\n    public class LiveDataCallAdapter<R> implements CallAdapter<R,LiveData<ApiResponse<R>>> {\n\n        private Type responseType;\n\n        public LiveDataCallAdapter(Type responseType){\n            this.responseType=responseType;\n        }\n\n        @Override\n        public Type responseType() {\n            return responseType;\n        }\n\n        @Override\n        public LiveData<ApiResponse<R>> adapt(final Call<R> call) {\n            LiveData<ApiResponse<R>> result=new LiveData<ApiResponse<R>>() {\n                @Override\n                protected void onActive() {\n                    super.onActive();\n                    call.enqueue(new Callback<R>() {\n                        @Override\n                        public void onResponse(Call<R> call, Response<R> response) {\n                       postValue(new ApiResponse<R>().create(response));\n                    }\n\n                        @Override\n                        public void onFailure(Call<R> call, Throwable t) {\n                          //  LogUtils.printInfo(\"+++++!2312qwqweww31\");\n                        }\n                    });\n                }\n            };\n        return result;\n    }\n}\n```\n\n修改调用方法\n```java\n    repoBeanLiveData = githubService.getRepoInfo(\"Android\");\n    repoBeanLiveData.observe(GithubApiActivity.this, new Observer<ApiResponse<SearchRepoBean>>() {\n        @Override\n        public void onChanged(ApiResponse<SearchRepoBean> searchRepoBeanApiResponse) {\n            SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();\n           //输出结果\n        }\n    });\n\n```\n\n## 源码详解\n\n##### Retrofit构建中的`.baseUrl(\"https://api.github.com/\")`介绍\nRetrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型\n```java\n\n    public final class Retrofit {\n\n      public static final class Builder {\n             public Builder baseUrl(String baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  return baseUrl(HttpUrl.get(baseUrl));\n                }\n                \n            public Builder baseUrl(HttpUrl baseUrl) {\n                  checkNotNull(baseUrl, \"baseUrl == null\");\n                  List<String> pathSegments = baseUrl.pathSegments();\n                  if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) {\n                    throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl);\n                  }\n              this.baseUrl = baseUrl;\n              return this;\n            }\n          }\n        }\n\n```\n\n##### Retrofit构建中的`.addConverterFactory(GsonConverterFactory.create())`\n通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory\n\n```java\n    public Builder addConverterFactory(Converter.Factory factory) {\n      converterFactories.add(checkNotNull(factory, \"factory == null\"));\n      return this;\n    }\n\n```\nConverter接口源码，核心是`T convert(F value)`,将F类型的数据转换为T类型\n\n```java\n\npublic interface Converter<F, T> {\n  //将F类型的数据转换为T类型\n  @Nullable T convert(F value) throws IOException;\n\n  //根据数据类型创建Converter创建 Converter\n  abstract class Factory {\n    //将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。\n    public @Nullable Converter<ResponseBody, ?> responseBodyConverter(Type type,\n        Annotation[] annotations, Retrofit retrofit) {\n      return null;\n    }\n\n       //将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody\n    public @Nullable Converter<?, RequestBody> requestBodyConverter(Type type,\n        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {\n      return null;\n    }\n        //将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String\n    public @Nullable Converter<?, String> stringConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n      return null;\n    }\n\n    protected static Type getParameterUpperBound(int index, ParameterizedType type) {\n      return Utils.getParameterUpperBound(index, type);\n    }\n\n    protected static Class<?> getRawType(Type type) {\n      return Utils.getRawType(type);\n    }\n  }\n}\n\n```\n\n\n##### Retrofit构建中的`.addCallAdapterFactory(new LiveDataCallAdapterFactory())`\n用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用\n\n```java\npublic final class Retrofit {\n      final List<CallAdapter.Factory> callAdapterFactories;\n      \n      //…………\n      public Builder addCallAdapterFactory(CallAdapter.Factory factory) {\n          callAdapterFactories.add(checkNotNull(factory, \"factory == null\"));\n          return this;\n        }\n      //…………\n}\n\n```\n\n##### 最终用来创建Service的代码`retrofit.create(GithubService.class)`\ncreate()采用代理的方式进行创建，\n\n```java\npublic final class Retrofit {\n  //……\n  public <T> T create(final Class<T> service) {\n    //判断定义的接口服务是否可用\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // 如果是Object本身的方法，正常调用后返回\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            //如果是platform默认的方法，正常调用后返回\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            //解析我们定义的网络请求的方法\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n  //……\n}\n```\n`loadServiceMethod(Method method)`源码解析,其实际上是HttpServiceMethod对象\n\n```java\n\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    //从解析的缓存中获取\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        \n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n\n```\n` static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method)`源码\n\n```java\nabstract class ServiceMethod<T> {\n      static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n      //RequestFactory负责解析接口并且生成Request\n        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n       //…………\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract T invoke(Object[] args);\n}\n\n\n```\n\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)`源码\n\n```java\n\n//将一个接口方法转变为一个Http请求\nfinal class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<ReturnT> {\n\n  static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n      //创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码\n    CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method);\n \n    //……\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    okhttp3.Call.Factory callFactory = retrofit.callFactory;\n    return new HttpServiceMethod<>(requestFactory, callFactory, callAdapter, responseConverter);\n  }\n\n  private static <ResponseT, ReturnT> CallAdapter<ResponseT, ReturnT> createCallAdapter(\n      Retrofit retrofit, Method method) {\n    Type returnType = method.getGenericReturnType();\n    Annotation[] annotations = method.getAnnotations();\n    try {\n      //retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter\n      return (CallAdapter<ResponseT, ReturnT>) retrofit.callAdapter(returnType, annotations);\n    } catch (RuntimeException e) { // Wide exception range because factories are user code.\n      throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n    }\n  }\n\n //…………\n\n  private final RequestFactory requestFactory;\n  private final okhttp3.Call.Factory callFactory;\n  private final CallAdapter<ResponseT, ReturnT> callAdapter;\n  private final Converter<ResponseBody, ResponseT> responseConverter;\n\n  private HttpServiceMethod(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,\n      CallAdapter<ResponseT, ReturnT> callAdapter,\n      Converter<ResponseBody, ResponseT> responseConverter) {\n    this.requestFactory = requestFactory;\n    this.callFactory = callFactory;\n    this.callAdapter = callAdapter;\n    this.responseConverter = responseConverter;\n  }\n\n  //代理调用的invoke最终会调用下面invoke方法\n  @Override ReturnT invoke(Object[] args) {\n    return callAdapter.adapt(\n        new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));\n  }\n}\n\n\n`call.enqueue(new Callback<SearchRepoBean>() {})`最终调用的方法是OkhttpCall中的`call.enqueue(new okhttp3.Callback() {})`\n\n```java\n\nfinal class OkHttpCall<T> implements Call<T> {\n\n    //……\n   @Override public void enqueue(final Callback<T> callback) {\n\n    //……\n    call.enqueue(new okhttp3.Callback() {\n      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        //……\n        try {\n          callback.onResponse(OkHttpCall.this, response);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n    });\n   }\n    //……\n}\n\n```\n\n\n\n\n\n\n\n","slug":"Android/框架/Retrofit/Retrofit 2.5 框架使用与源码分析","published":1,"updated":"2021-01-05T12:14:32.958Z","_id":"ckjju0m2n009v20uafqdk8a70","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Retrofit-框架使用\"><a href=\"#Retrofit-框架使用\" class=\"headerlink\" title=\"Retrofit 框架使用\"></a>Retrofit 框架使用</h2><h4 id=\"请求内容与返回值\"><a href=\"#请求内容与返回值\" class=\"headerlink\" title=\"请求内容与返回值\"></a>请求内容与返回值</h4><p>使用PostMan进行请求测试<br>请求：<code>https://api.github.com/search/repositories?q=android</code></p>\n<a id=\"more\"></a>\n<p>返回值：</p>\n<p>Header:<br><img src=\"/public/img/Android/Retrofit.png\"></p>\n<p>Body:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;total_count&quot;</span>: <span class=\"number\">943593</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;incomplete_results&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;items&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">82128465</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;node_id&quot;</span>: <span class=\"string\">&quot;MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;full_name&quot;</span>: <span class=\"string\">&quot;open-android/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;private&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;owner&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">&quot;login&quot;</span>: <span class=\"string\">&quot;open-android&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">23095877</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;node_id&quot;</span>: <span class=\"string\">&quot;MDQ6VXNlcjIzMDk1ODc3&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;avatar_url&quot;</span>: <span class=\"string\">&quot;https://avatars2.githubusercontent.com/u/23095877?v=4&quot;</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">&quot;html_url&quot;</span>: <span class=\"string\">&quot;https://github.com/open-android/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;fork&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://api.github.com/repos/open-android/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">12544093</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;node_id&quot;</span>: <span class=\"string\">&quot;MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;full_name&quot;</span>: <span class=\"string\">&quot;hmkcode/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;private&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;owner&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">&quot;login&quot;</span>: <span class=\"string\">&quot;hmkcode&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">3790597</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引入Retrofit依赖\"><a href=\"#引入Retrofit依赖\" class=\"headerlink\" title=\"引入Retrofit依赖\"></a>引入Retrofit依赖</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.squareup.retrofit2:retrofit:2.5.0&#x27;</span></span><br><span class=\"line\">implementation <span class=\"string\">&#x27;com.squareup.retrofit2:converter-gson:2.5.0&#x27;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义Repository-Bean类\"><a href=\"#根据返回的请求结果定义Repository-Bean类\" class=\"headerlink\" title=\"根据返回的请求结果定义Repository Bean类\"></a>根据返回的请求结果定义Repository Bean类</h4><p>返回的报文采用google.gson进行处理，金处理必要的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示Repo id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示RepoName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示完整名称</span></span><br><span class=\"line\">    <span class=\"comment\">//Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName(&quot;full_name&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fullName;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义一次查询结果\"><a href=\"#根据返回的请求结果定义一次查询结果\" class=\"headerlink\" title=\"根据返回的请求结果定义一次查询结果\"></a>根据返回的请求结果定义一次查询结果</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SearchRepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示仓库数量</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName(&quot;total_count&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示是否为完整结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> incompleteResults;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示持有的所有的仓库类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RepoBean&gt;items;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"定义网络请求API接口\"><a href=\"#定义网络请求API接口\" class=\"headerlink\" title=\"定义网络请求API接口\"></a>定义网络请求API接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//@Get注解，表示以Get方法发送网络请求</span></span><br><span class=\"line\">    <span class=\"comment\">//返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义</span></span><br><span class=\"line\">    <span class=\"meta\">@GET(&quot;search/repositories&quot;)</span></span><br><span class=\"line\">    <span class=\"function\">Call&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(<span class=\"meta\">@Query(&quot;q&quot;)</span> String query)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化Retrofit实例，生成接口实现类\"><a href=\"#初始化Retrofit实例，生成接口实现类\" class=\"headerlink\" title=\"初始化Retrofit实例，生成接口实现类\"></a>初始化Retrofit实例，生成接口实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">&quot;https://api.github.com/&quot;</span>)                   <span class=\"comment\">//设置网络请求的URL地址           </span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())   <span class=\"comment\">//设置数据解析器 </span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">githubService = retrofit.create(GithubService.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(<span class=\"string\">&quot;Android&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//同步请求方式</span></span><br><span class=\"line\">    <span class=\"comment\">//call.request();</span></span><br><span class=\"line\">    <span class=\"comment\">//异步请求方式</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//输出请求结果 </span></span><br><span class=\"line\">          <span class=\"comment\">//  LogUtils.printInfo(&quot;搜索到的仓库的数量：&quot; + response.body().getItems().size());</span></span><br><span class=\"line\">           <span class=\"comment\">// List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"comment\">// repoBeans.addAll(response.body().getItems());</span></span><br><span class=\"line\">           <span class=\"comment\">// for (int i=repoBeans.size()-1;i&gt;=0;i--)&#123;</span></span><br><span class=\"line\">           <span class=\"comment\">//  LogUtils.printInfo(repoBeans.get(i).getFullName());</span></span><br><span class=\"line\">           <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将请求值的返回设为LiveData\"><a href=\"#将请求值的返回设为LiveData\" class=\"headerlink\" title=\"将请求值的返回设为LiveData\"></a>将请求值的返回设为LiveData</h4><p>将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@GET(&quot;search/repositories&quot;)</span></span><br><span class=\"line\">     <span class=\"function\">LiveData&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(<span class=\"meta\">@Query(&quot;q&quot;)</span> String query)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义LiveDataCallAdapterFactory </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">    Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; rawObserverType = getRawType(observerType);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(rawObserverType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>自定义 LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">LiveData</span>&lt;<span class=\"title\">SearchRepoBean</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;SearchRepoBean&gt; <span class=\"title\">adapt</span><span class=\"params\">(<span class=\"keyword\">final</span> Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=<span class=\"keyword\">new</span> LiveData&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                    postValue((SearchRepoBean) response.body());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                    LogUtils.printInfo(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//这里的return 即为下文中githubService.getRepoInfo(&quot;Android&quot;)调用的返回值</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> searchRepoBeanLiveData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>为Retrofit实例添加CallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">          .baseUrl(<span class=\"string\">&quot;https://api.github.com/&quot;</span>)</span><br><span class=\"line\">          .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">          .addCallAdapterFactory(<span class=\"keyword\">new</span> LiveDataCallAdapterFactory())</span><br><span class=\"line\">          .build();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">&quot;Android&quot;</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(SearchRepoBean searchRepoBean)</span> </span>&#123;                            </span><br><span class=\"line\">         <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加通用的响应实体\"><a href=\"#添加通用的响应实体\" class=\"headerlink\" title=\"添加通用的响应实体\"></a>添加通用的响应实体</h4><p>通过<code>LiveDataCallAdapter</code> 和<code>LiveDataCallAdapterFactory</code> 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为<code>SearchRepoBean</code>类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。</p>\n<p>定义一个通用的响应实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ApiResponseSuccess&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.isSuccessful()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiResponseSuccess&lt;T&gt;(response.body());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用于表示返回成功的值</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponseSuccess</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      /用于表示请求返回成功的内容，在本代码中是SearchRepoBean</span><br><span class=\"line\">      <span class=\"keyword\">private</span> T body;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiResponseSuccess</span><span class=\"params\">(T body)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getBody</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">        <span class=\"comment\">//return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//observerType为ApiResponse&lt;SearchRepoBean&gt;</span></span><br><span class=\"line\">        Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\">        <span class=\"comment\">//bodyType为SearchRepoBean</span></span><br><span class=\"line\">        Type bodyType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) observerType);</span><br><span class=\"line\">        LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(bodyType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>,<span class=\"title\">LiveData</span>&lt;<span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">R</span>&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(<span class=\"keyword\">final</span> Call&lt;R&gt; call) &#123;</span><br><span class=\"line\">            LiveData&lt;ApiResponse&lt;R&gt;&gt; result=<span class=\"keyword\">new</span> LiveData&lt;ApiResponse&lt;R&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                       postValue(<span class=\"keyword\">new</span> ApiResponse&lt;R&gt;().create(response));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                          <span class=\"comment\">//  LogUtils.printInfo(&quot;+++++!2312qwqweww31&quot;);</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">&quot;Android&quot;</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse)</span> </span>&#123;</span><br><span class=\"line\">        SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();</span><br><span class=\"line\">       <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h5 id=\"Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\"><a href=\"#Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\" class=\"headerlink\" title=\"Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍\"></a>Retrofit构建中的<code>.baseUrl(&quot;https://api.github.com/&quot;)</code>介绍</h5><p>Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(String baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">&quot;baseUrl == null&quot;</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">&quot;baseUrl == null&quot;</span>);</span><br><span class=\"line\">              List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;&quot;</span>.equals(pathSegments.get(pathSegments.size() - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;baseUrl must end in /: &quot;</span> + baseUrl);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.baseUrl = baseUrl;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\"><a href=\"#Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\" class=\"headerlink\" title=\"Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())\"></a>Retrofit构建中的<code>.addConverterFactory(GsonConverterFactory.create())</code></h5><p>通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addConverterFactory</span><span class=\"params\">(Converter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">  converterFactories.add(checkNotNull(factory, <span class=\"string\">&quot;factory == null&quot;</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Converter接口源码，核心是<code>T convert(F value)</code>,将F类型的数据转换为T类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">F</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将F类型的数据转换为T类型</span></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">convert</span><span class=\"params\">(F value)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据数据类型创建Converter创建 Converter</span></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Type <span class=\"title\">getParameterUpperBound</span><span class=\"params\">(<span class=\"keyword\">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getRawType(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\"><a href=\"#Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\" class=\"headerlink\" title=\"Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())\"></a>Retrofit构建中的<code>.addCallAdapterFactory(new LiveDataCallAdapterFactory())</code></h5><p>用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addCallAdapterFactory</span><span class=\"params\">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">          callAdapterFactories.add(checkNotNull(factory, <span class=\"string\">&quot;factory == null&quot;</span>));</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"最终用来创建Service的代码retrofit-create-GithubService-class\"><a href=\"#最终用来创建Service的代码retrofit-create-GithubService-class\" class=\"headerlink\" title=\"最终用来创建Service的代码retrofit.create(GithubService.class)\"></a>最终用来创建Service的代码<code>retrofit.create(GithubService.class)</code></h5><p>create()采用代理的方式进行创建，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断定义的接口服务是否可用</span></span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是Object本身的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是platform默认的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解析我们定义的网络请求的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loadServiceMethod(Method method)</code>源码解析,其实际上是HttpServiceMethod对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//从解析的缓存中获取</span></span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code> static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//RequestFactory负责解析接口并且生成Request</span></span><br><span class=\"line\">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//…………</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将一个接口方法转变为一个Http请求</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServiceMethod</span>&lt;<span class=\"title\">ResponseT</span>, <span class=\"title\">ReturnT</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">ReturnT</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">CallAdapter&lt;ResponseT, ReturnT&gt; <span class=\"title\">createCallAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123; <span class=\"comment\">// Wide exception range because factories are user code.</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> methodError(method, e, <span class=\"string\">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//…………</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestFactory requestFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> okhttp3.Call.Factory callFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;ResponseBody, ResponseT&gt; responseConverter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HttpServiceMethod</span><span class=\"params\">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.requestFactory = requestFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callFactory = callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callAdapter = callAdapter;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.responseConverter = responseConverter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//代理调用的invoke最终会调用下面invoke方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callAdapter.adapt(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;&#125;)`最终调用的方法是OkhttpCall中的`call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkHttpCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">        Response&lt;T&gt; response;</span><br><span class=\"line\">        <span class=\"comment\">//……</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">          t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"Retrofit-框架使用\"><a href=\"#Retrofit-框架使用\" class=\"headerlink\" title=\"Retrofit 框架使用\"></a>Retrofit 框架使用</h2><h4 id=\"请求内容与返回值\"><a href=\"#请求内容与返回值\" class=\"headerlink\" title=\"请求内容与返回值\"></a>请求内容与返回值</h4><p>使用PostMan进行请求测试<br>请求：<code>https://api.github.com/search/repositories?q=android</code></p>","more":"<p>返回值：</p>\n<p>Header:<br><img src=\"/public/img/Android/Retrofit.png\"></p>\n<p>Body:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;total_count&quot;</span>: <span class=\"number\">943593</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;incomplete_results&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;items&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">82128465</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;node_id&quot;</span>: <span class=\"string\">&quot;MDEwOlJlcG9zaXRvcnk4MjEyODQ2NQ==&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;full_name&quot;</span>: <span class=\"string\">&quot;open-android/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;private&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;owner&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">&quot;login&quot;</span>: <span class=\"string\">&quot;open-android&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">23095877</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;node_id&quot;</span>: <span class=\"string\">&quot;MDQ6VXNlcjIzMDk1ODc3&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;avatar_url&quot;</span>: <span class=\"string\">&quot;https://avatars2.githubusercontent.com/u/23095877?v=4&quot;</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">&quot;html_url&quot;</span>: <span class=\"string\">&quot;https://github.com/open-android/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;GitHub上最火的Android开源项目,所有开源项目都有详细资料和配套视频&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;fork&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://api.github.com/repos/open-android/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">12544093</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;node_id&quot;</span>: <span class=\"string\">&quot;MDEwOlJlcG9zaXRvcnkxMjU0NDA5Mw==&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;full_name&quot;</span>: <span class=\"string\">&quot;hmkcode/Android&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;private&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;owner&quot;</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">&quot;login&quot;</span>: <span class=\"string\">&quot;hmkcode&quot;</span>,</span><br><span class=\"line\">                <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">3790597</span>,</span><br><span class=\"line\">                <span class=\"comment\">//……</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"comment\">//……</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"引入Retrofit依赖\"><a href=\"#引入Retrofit依赖\" class=\"headerlink\" title=\"引入Retrofit依赖\"></a>引入Retrofit依赖</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.squareup.retrofit2:retrofit:2.5.0&#x27;</span></span><br><span class=\"line\">implementation <span class=\"string\">&#x27;com.squareup.retrofit2:converter-gson:2.5.0&#x27;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义Repository-Bean类\"><a href=\"#根据返回的请求结果定义Repository-Bean类\" class=\"headerlink\" title=\"根据返回的请求结果定义Repository Bean类\"></a>根据返回的请求结果定义Repository Bean类</h4><p>返回的报文采用google.gson进行处理，金处理必要的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示Repo id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示RepoName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示完整名称</span></span><br><span class=\"line\">    <span class=\"comment\">//Repository中json的返回值为 `full_name`，与定义的变量名不一致，使用注解`@SerializedName`进行标注</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName(&quot;full_name&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String fullName;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"根据返回的请求结果定义一次查询结果\"><a href=\"#根据返回的请求结果定义一次查询结果\" class=\"headerlink\" title=\"根据返回的请求结果定义一次查询结果\"></a>根据返回的请求结果定义一次查询结果</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SearchRepoBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于表示仓库数量</span></span><br><span class=\"line\">    <span class=\"meta\">@SerializedName(&quot;total_count&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalCount;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示是否为完整结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> incompleteResults;</span><br><span class=\"line\">    <span class=\"comment\">//用于表示持有的所有的仓库类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RepoBean&gt;items;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter</span></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"定义网络请求API接口\"><a href=\"#定义网络请求API接口\" class=\"headerlink\" title=\"定义网络请求API接口\"></a>定义网络请求API接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//@Get注解，表示以Get方法发送网络请求</span></span><br><span class=\"line\">    <span class=\"comment\">//返回类型为Call&lt;SearchRepoBean&gt;，SearchRepoBean是接收数据的类，可以自定义</span></span><br><span class=\"line\">    <span class=\"meta\">@GET(&quot;search/repositories&quot;)</span></span><br><span class=\"line\">    <span class=\"function\">Call&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(<span class=\"meta\">@Query(&quot;q&quot;)</span> String query)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化Retrofit实例，生成接口实现类\"><a href=\"#初始化Retrofit实例，生成接口实现类\" class=\"headerlink\" title=\"初始化Retrofit实例，生成接口实现类\"></a>初始化Retrofit实例，生成接口实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">&quot;https://api.github.com/&quot;</span>)                   <span class=\"comment\">//设置网络请求的URL地址           </span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())   <span class=\"comment\">//设置数据解析器 </span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">githubService = retrofit.create(GithubService.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Call&lt;SearchRepoBean&gt; call = githubService.getRepoInfo(<span class=\"string\">&quot;Android&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//同步请求方式</span></span><br><span class=\"line\">    <span class=\"comment\">//call.request();</span></span><br><span class=\"line\">    <span class=\"comment\">//异步请求方式</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Response&lt;SearchRepoBean&gt; response)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//输出请求结果 </span></span><br><span class=\"line\">          <span class=\"comment\">//  LogUtils.printInfo(&quot;搜索到的仓库的数量：&quot; + response.body().getItems().size());</span></span><br><span class=\"line\">           <span class=\"comment\">// List&lt;RepoBean&gt;repoBeans=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"comment\">// repoBeans.addAll(response.body().getItems());</span></span><br><span class=\"line\">           <span class=\"comment\">// for (int i=repoBeans.size()-1;i&gt;=0;i--)&#123;</span></span><br><span class=\"line\">           <span class=\"comment\">//  LogUtils.printInfo(repoBeans.get(i).getFullName());</span></span><br><span class=\"line\">           <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;SearchRepoBean&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将请求值的返回设为LiveData\"><a href=\"#将请求值的返回设为LiveData\" class=\"headerlink\" title=\"将请求值的返回设为LiveData\"></a>将请求值的返回设为LiveData</h4><p>将请求的返回值设为LiveData可以通过为Retrofit添加CallAdapterFactory来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GithubService</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"meta\">@GET(&quot;search/repositories&quot;)</span></span><br><span class=\"line\">     <span class=\"function\">LiveData&lt;SearchRepoBean&gt; <span class=\"title\">getRepoInfo</span><span class=\"params\">(<span class=\"meta\">@Query(&quot;q&quot;)</span> String query)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义LiveDataCallAdapterFactory </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">    Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt; rawObserverType = getRawType(observerType);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(rawObserverType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>自定义 LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">LiveData</span>&lt;<span class=\"title\">SearchRepoBean</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;SearchRepoBean&gt; <span class=\"title\">adapt</span><span class=\"params\">(<span class=\"keyword\">final</span> Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         LiveData&lt;SearchRepoBean&gt;searchRepoBeanLiveData=<span class=\"keyword\">new</span> LiveData&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                    postValue((SearchRepoBean) response.body());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                    LogUtils.printInfo(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//这里的return 即为下文中githubService.getRepoInfo(&quot;Android&quot;)调用的返回值</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> searchRepoBeanLiveData;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>为Retrofit实例添加CallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">          .baseUrl(<span class=\"string\">&quot;https://api.github.com/&quot;</span>)</span><br><span class=\"line\">          .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">          .addCallAdapterFactory(<span class=\"keyword\">new</span> LiveDataCallAdapterFactory())</span><br><span class=\"line\">          .build();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">&quot;Android&quot;</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;SearchRepoBean&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(SearchRepoBean searchRepoBean)</span> </span>&#123;                            </span><br><span class=\"line\">         <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加通用的响应实体\"><a href=\"#添加通用的响应实体\" class=\"headerlink\" title=\"添加通用的响应实体\"></a>添加通用的响应实体</h4><p>通过<code>LiveDataCallAdapter</code> 和<code>LiveDataCallAdapterFactory</code> 可以将返回的数据表示为LiveData数据形式，且只能对返回结果为<code>SearchRepoBean</code>类型的JSON字符串进行处理。如果是返回其他的实体则需要重新构造适配器。</p>\n<p>定义一个通用的响应实体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ApiResponseSuccess&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.isSuccessful()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ApiResponseSuccess&lt;T&gt;(response.body());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//用于表示返回成功的值</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiResponseSuccess</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      /用于表示请求返回成功的内容，在本代码中是SearchRepoBean</span><br><span class=\"line\">      <span class=\"keyword\">private</span> T body;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ApiResponseSuccess</span><span class=\"params\">(T body)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getBody</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> body;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapterFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">CallAdapter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//用于获取泛型的参数</span></span><br><span class=\"line\">        <span class=\"comment\">//return type为LiveData&lt;ApiResponse&lt;SearchRepoBean&gt;&gt; </span></span><br><span class=\"line\">        <span class=\"comment\">//observerType为ApiResponse&lt;SearchRepoBean&gt;</span></span><br><span class=\"line\">        Type observerType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\">        <span class=\"comment\">//bodyType为SearchRepoBean</span></span><br><span class=\"line\">        Type bodyType = getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) observerType);</span><br><span class=\"line\">        LiveDataCallAdapter&lt;Object&gt; liveDataCallAdapter = <span class=\"keyword\">new</span> LiveDataCallAdapter&lt;&gt;(bodyType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> liveDataCallAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>修改LiveDataCallAdapter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveDataCallAdapter</span>&lt;<span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CallAdapter</span>&lt;<span class=\"title\">R</span>,<span class=\"title\">LiveData</span>&lt;<span class=\"title\">ApiResponse</span>&lt;<span class=\"title\">R</span>&gt;&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Type responseType;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveDataCallAdapter</span><span class=\"params\">(Type responseType)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.responseType=responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> LiveData&lt;ApiResponse&lt;R&gt;&gt; adapt(<span class=\"keyword\">final</span> Call&lt;R&gt; call) &#123;</span><br><span class=\"line\">            LiveData&lt;ApiResponse&lt;R&gt;&gt; result=<span class=\"keyword\">new</span> LiveData&lt;ApiResponse&lt;R&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.onActive();</span><br><span class=\"line\">                    call.enqueue(<span class=\"keyword\">new</span> Callback&lt;R&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;R&gt; call, Response&lt;R&gt; response)</span> </span>&#123;</span><br><span class=\"line\">                       postValue(<span class=\"keyword\">new</span> ApiResponse&lt;R&gt;().create(response));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;R&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                          <span class=\"comment\">//  LogUtils.printInfo(&quot;+++++!2312qwqweww31&quot;);</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改调用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repoBeanLiveData = githubService.getRepoInfo(<span class=\"string\">&quot;Android&quot;</span>);</span><br><span class=\"line\">repoBeanLiveData.observe(GithubApiActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;ApiResponse&lt;SearchRepoBean&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(ApiResponse&lt;SearchRepoBean&gt; searchRepoBeanApiResponse)</span> </span>&#123;</span><br><span class=\"line\">        SearchRepoBean searchRepoBean = (SearchRepoBean) ((ApiResponse.ApiResponseSuccess) searchRepoBeanApiResponse).getBody();</span><br><span class=\"line\">       <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"源码详解\"><a href=\"#源码详解\" class=\"headerlink\" title=\"源码详解\"></a>源码详解</h2><h5 id=\"Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\"><a href=\"#Retrofit构建中的-baseUrl-quot-https-api-github-com-quot-介绍\" class=\"headerlink\" title=\"Retrofit构建中的.baseUrl(&quot;https://api.github.com/&quot;)介绍\"></a>Retrofit构建中的<code>.baseUrl(&quot;https://api.github.com/&quot;)</code>介绍</h5><p>Retrofit源碼，Retrofit在源码中使用建造者模式进行实例化，将String类型的地址转换为OKhttp3中的HttpUrl类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(String baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">&quot;baseUrl == null&quot;</span>);</span><br><span class=\"line\">              <span class=\"keyword\">return</span> baseUrl(HttpUrl.get(baseUrl));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">baseUrl</span><span class=\"params\">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class=\"line\">              checkNotNull(baseUrl, <span class=\"string\">&quot;baseUrl == null&quot;</span>);</span><br><span class=\"line\">              List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!<span class=\"string\">&quot;&quot;</span>.equals(pathSegments.get(pathSegments.size() - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;baseUrl must end in /: &quot;</span> + baseUrl);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.baseUrl = baseUrl;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\"><a href=\"#Retrofit构建中的-addConverterFactory-GsonConverterFactory-create\" class=\"headerlink\" title=\"Retrofit构建中的.addConverterFactory(GsonConverterFactory.create())\"></a>Retrofit构建中的<code>.addConverterFactory(GsonConverterFactory.create())</code></h5><p>通过.addConverterFactory()传入我们需要的ConverFactory，目的是将responseBody转换成我们的Bean类，在这里我们使用的是GsonConverterFactory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addConverterFactory</span><span class=\"params\">(Converter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">  converterFactories.add(checkNotNull(factory, <span class=\"string\">&quot;factory == null&quot;</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Converter接口源码，核心是<code>T convert(F value)</code>,将F类型的数据转换为T类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">F</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将F类型的数据转换为T类型</span></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">convert</span><span class=\"params\">(F value)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//根据数据类型创建Converter创建 Converter</span></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将HTTP响应的body体转换成type,type是由CallAdapter 接口里面的responseType()函数返回的。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将API方法的输入参数使用注解@Body, @Part 和 @PartMap标记的类型，从type转换为RequestBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class=\"line\">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将API方法的输入参数使用注解@Header, @HeaderMap, @Path, @Query 和 @QueryMap 标记的类型从type转换为String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Type <span class=\"title\">getParameterUpperBound</span><span class=\"params\">(<span class=\"keyword\">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Utils.getRawType(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\"><a href=\"#Retrofit构建中的-addCallAdapterFactory-new-LiveDataCallAdapterFactory\" class=\"headerlink\" title=\"Retrofit构建中的.addCallAdapterFactory(new LiveDataCallAdapterFactory())\"></a>Retrofit构建中的<code>.addCallAdapterFactory(new LiveDataCallAdapterFactory())</code></h5><p>用于添加数据适配器，在HttpServiceMethod实例生成的时候会调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">addCallAdapterFactory</span><span class=\"params\">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class=\"line\">          callAdapterFactories.add(checkNotNull(factory, <span class=\"string\">&quot;factory == null&quot;</span>));</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//…………</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"最终用来创建Service的代码retrofit-create-GithubService-class\"><a href=\"#最终用来创建Service的代码retrofit-create-GithubService-class\" class=\"headerlink\" title=\"最终用来创建Service的代码retrofit.create(GithubService.class)\"></a>最终用来创建Service的代码<code>retrofit.create(GithubService.class)</code></h5><p>create()采用代理的方式进行创建，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Retrofit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断定义的接口服务是否可用</span></span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, <span class=\"meta\">@Nullable</span> Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是Object本身的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果是platform默认的方法，正常调用后返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//解析我们定义的网络请求的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>loadServiceMethod(Method method)</code>源码解析,其实际上是HttpServiceMethod对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//从解析的缓存中获取</span></span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code> static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//RequestFactory负责解析接口并且生成Request</span></span><br><span class=\"line\">        RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//…………</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将一个接口方法转变为一个Http请求</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServiceMethod</span>&lt;<span class=\"title\">ResponseT</span>, <span class=\"title\">ReturnT</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">ReturnT</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//创建HTTP请求的CallAdapter，在下面有createCallAdapter()源码</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">CallAdapter&lt;ResponseT, ReturnT&gt; <span class=\"title\">createCallAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    Type returnType = method.getGenericReturnType();</span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//retrofit.callAdapter()返回 Retrofit实例化中.addCallAdapterFactory(new LiveDataCallAdapterFactory())添加的CallAdapter</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123; <span class=\"comment\">// Wide exception range because factories are user code.</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> methodError(method, e, <span class=\"string\">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//…………</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RequestFactory requestFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> okhttp3.Call.Factory callFactory;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;ResponseBody, ResponseT&gt; responseConverter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HttpServiceMethod</span><span class=\"params\">(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Converter&lt;ResponseBody, ResponseT&gt; responseConverter)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.requestFactory = requestFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callFactory = callFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callAdapter = callAdapter;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.responseConverter = responseConverter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//代理调用的invoke最终会调用下面invoke方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> callAdapter.adapt(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">`call.enqueue(<span class=\"keyword\">new</span> Callback&lt;SearchRepoBean&gt;() &#123;&#125;)`最终调用的方法是OkhttpCall中的`call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;&#125;)`</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OkHttpCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">    call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">        Response&lt;T&gt; response;</span><br><span class=\"line\">        <span class=\"comment\">//……</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">          t.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">//……</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Hexo博客搭建相关资料","description":"Hexo博客搭建相关资料","type":["函数式编程"],"toc":true,"cover":"/cover/img112.jpg","date":"2021-01-04T16:00:00.000Z","_content":"\n\n## Butterfly主题配置\n\nhttp://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%88%86%E7%B1%BB%E9%A1%B5\n\n\n## 图片下载网站\n\nhttps://burst.shopify.com/\n\nhttps://wallpapersafari.com/","source":"_posts/Other/Blog/相关资料.md","raw":"---\ntitle: \"Hexo博客搭建相关资料\"\ndescription: \"Hexo博客搭建相关资料\"\ntype: [函数式编程]\ntoc: true\ncover:  /cover/img112.jpg\ncategories: Blog\ndate: 2021/1/5\n---\n\n\n## Butterfly主题配置\n\nhttp://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%88%86%E7%B1%BB%E9%A1%B5\n\n\n## 图片下载网站\n\nhttps://burst.shopify.com/\n\nhttps://wallpapersafari.com/","slug":"Other/Blog/相关资料","published":1,"updated":"2021-01-06T01:07:29.002Z","_id":"ckjjypdld00043wua1eqc4yuj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Butterfly主题配置\"><a href=\"#Butterfly主题配置\" class=\"headerlink\" title=\"Butterfly主题配置\"></a>Butterfly主题配置</h2><p><a href=\"http://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%88%86%E7%B1%BB%E9%A1%B5\">http://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%88%86%E7%B1%BB%E9%A1%B5</a></p>\n<h2 id=\"图片下载网站\"><a href=\"#图片下载网站\" class=\"headerlink\" title=\"图片下载网站\"></a>图片下载网站</h2><p><a href=\"https://burst.shopify.com/\">https://burst.shopify.com/</a></p>\n<p><a href=\"https://wallpapersafari.com/\">https://wallpapersafari.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Butterfly主题配置\"><a href=\"#Butterfly主题配置\" class=\"headerlink\" title=\"Butterfly主题配置\"></a>Butterfly主题配置</h2><p><a href=\"http://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%88%86%E7%B1%BB%E9%A1%B5\">http://www.c-hasel.cn/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C/#%E5%88%86%E7%B1%BB%E9%A1%B5</a></p>\n<h2 id=\"图片下载网站\"><a href=\"#图片下载网站\" class=\"headerlink\" title=\"图片下载网站\"></a>图片下载网站</h2><p><a href=\"https://burst.shopify.com/\">https://burst.shopify.com/</a></p>\n<p><a href=\"https://wallpapersafari.com/\">https://wallpapersafari.com/</a></p>\n"},{"title":"RTMP集成","description":"RTMP集成","type":["Android"],"toc":true,"cover":"/cover/img103.jpg","date":"2020-07-05T16:00:00.000Z","_content":"\n","source":"_posts/Android/Rtmp/RTMP集成.md","raw":"---\ntitle: \"RTMP集成\"\ndescription: \"RTMP集成\"\ntype: [Android]\ntoc: true\ncover:  /cover/img103.jpg\ncategories: Android\ndate: 2020/7/6\n---\n\n","slug":"Android/Rtmp/RTMP集成","published":1,"updated":"2021-01-06T00:59:10.513Z","_id":"ckjkpqv54000a3wua5om3899y","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Flutter开发基础","description":"Flutter开发基础","type":["Android"],"toc":true,"cover":"/cover/img114.jpg","date":"2021-01-05T16:00:00.000Z","_content":"\n\n## 图表库\n\nhttps://pub.dev/packages/fl_chart\n\nhttps://github.com/google/charts","source":"_posts/Flutter/Flutter常用的开源库.md","raw":"---\ntitle: \"Flutter开发基础\"\ndescription: \"Flutter开发基础\"\ntype: [Android]\ntoc: true\ncover:  /cover/img114.jpg\ncategories: Android\ndate: 2021/1/06\n---\n\n\n## 图表库\n\nhttps://pub.dev/packages/fl_chart\n\nhttps://github.com/google/charts","slug":"Flutter/Flutter常用的开源库","published":1,"updated":"2021-01-06T01:38:33.505Z","_id":"ckjkr30sl0000a4ua2rqn1v2w","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"图表库\"><a href=\"#图表库\" class=\"headerlink\" title=\"图表库\"></a>图表库</h2><p><a href=\"https://pub.dev/packages/fl_chart\">https://pub.dev/packages/fl_chart</a></p>\n<p><a href=\"https://github.com/google/charts\">https://github.com/google/charts</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"图表库\"><a href=\"#图表库\" class=\"headerlink\" title=\"图表库\"></a>图表库</h2><p><a href=\"https://pub.dev/packages/fl_chart\">https://pub.dev/packages/fl_chart</a></p>\n<p><a href=\"https://github.com/google/charts\">https://github.com/google/charts</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckjju0m08000c20uaccga5zof","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0c000k20ua2suu2guy"},{"post_id":"ckjju0m09000d20ua5vnzdmej","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0e000s20uabk4f01x4"},{"post_id":"ckjju0m0c000j20ua8hdecrje","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0i001120ua7njdedl2"},{"post_id":"ckjju0m0d000o20ua592wcpvf","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0j001420uacl6a9tbj"},{"post_id":"ckjju0m07000b20ua4qitdrmf","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0j001720ua1i3y1c2k"},{"post_id":"ckjju0m0e000r20uaagiv70kh","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0k001a20ua3t9c32ch"},{"post_id":"ckjju0m0f000u20uaahlqdrp5","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0l001d20ua9kwc0g99"},{"post_id":"ckjju0m0h000x20ua7yju8jz1","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0l001g20uafhujbxiv"},{"post_id":"ckjju0m0h001020ua9m8rf5w7","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0m001j20ua9tpi3zzk"},{"post_id":"ckjju0m0i001320ua3xo4cs3t","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0n001m20ua7act5q0v"},{"post_id":"ckjju0m0j001620ua6kn1df6p","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0n001p20ua4jr007hh"},{"post_id":"ckjju0m0k001920uadgwdhj4c","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjju0m0o001u20ua6ctkcxmm"},{"post_id":"ckjju0m0p001v20uaa24wgqtq","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0r002420ua11sf0iqb"},{"post_id":"ckjju0m0m001l20ua2bsb13aq","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0t002920ua4f85e7qm"},{"post_id":"ckjju0m0p001x20ua6vgucrls","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0u002c20uad8ilc34w"},{"post_id":"ckjju0m0q002120ua1tp70jrq","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0u002f20uahhci0bzx"},{"post_id":"ckjju0m0n001o20uag3cy14sw","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0w002k20ua3x5rdbfv"},{"post_id":"ckjju0m0r002320ua6gopb5fa","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0w002n20ua0adh0osi"},{"post_id":"ckjju0m0s002820ua2hmm21t2","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0x002s20ua038f81mn"},{"post_id":"ckjju0m0o001t20uafcxf3yen","category_id":"ckjju0m0n001q20uagcxdaye5","_id":"ckjju0m0y002u20ua7ukz95lz"},{"post_id":"ckjju0m0t002b20ua92532b0o","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m0z002x20uaeahafydu"},{"post_id":"ckjju0m0x002p20ua0ffd009r","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m12003120uaa51jghy1"},{"post_id":"ckjju0m0y002t20ua3wbf3es3","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m12003420uafalxfx2w"},{"post_id":"ckjju0m0u002e20ua0doib7kr","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m13003820ua18lnf48h"},{"post_id":"ckjju0m0y002v20ua1pglgl0t","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m14003b20uahmg518z2"},{"post_id":"ckjju0m0v002j20uah2rodt0k","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m16003i20ua95nphi4x"},{"post_id":"ckjju0m12003320uaehwqdao5","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m18003l20uadvjohzwe"},{"post_id":"ckjju0m14003a20uac1nz7cb7","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m19003r20uadynohxrr"},{"post_id":"ckjju0m15003e20uaddpr356c","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1a003u20ua7iq1cgue"},{"post_id":"ckjju0m15003h20uagush5jwe","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1a003x20uaafrsaj04"},{"post_id":"ckjju0m16003k20uacxpzawrj","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1b004020ua3oluh94g"},{"post_id":"ckjju0m19003q20ua74lg4efo","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1c004320ua6xye8b9a"},{"post_id":"ckjju0m19003t20ua4a044hzb","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1d004620uafppzbl1f"},{"post_id":"ckjju0m1b003z20ua5ati36g6","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1d004920uac74wg6zq"},{"post_id":"ckjju0m1b004220ua7x3ea7r5","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1e004c20uadtvqeku9"},{"post_id":"ckjju0m1d004820uac2n46364","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1f004h20uaev5f9v7g"},{"post_id":"ckjju0m1d004b20uab0dug3c8","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1g004k20uabsm4cm5h"},{"post_id":"ckjju0m1e004e20ua9k4g51ks","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1h004n20uae76wei31"},{"post_id":"ckjju0m1f004g20uafjdf7skb","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1i004q20uafv9af6y1"},{"post_id":"ckjju0m1f004j20uaa3kq05t3","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1i004t20ua3f27193k"},{"post_id":"ckjju0m1h004m20uadaachyyt","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1j004w20uafhpcelh4"},{"post_id":"ckjju0m1h004p20ua26v30fp9","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1l004z20ua44owdh4x"},{"post_id":"ckjju0m1i004s20ua7i7parld","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1l005220ua5sccfi5t"},{"post_id":"ckjju0m1j004v20uagvc3f4yb","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1m005520uaahcy3ow5"},{"post_id":"ckjju0m1j004y20uabf9f7w1g","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1n005820ua90oeea7r"},{"post_id":"ckjju0m1l005120ua29jj0m2p","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1o005d20ua0tfh55ho"},{"post_id":"ckjju0m1m005420uab3yr4j95","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1s005s20ua38609m21"},{"post_id":"ckjju0m1p005g20ua4se242w2","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1s005v20ua0lllebip"},{"post_id":"ckjju0m1q005k20ua680872k5","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1t005y20uag50p89zy"},{"post_id":"ckjju0m1n005720ua05iyg8ui","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1u006120uah0dm04y2"},{"post_id":"ckjju0m1q005m20ua1lkfdyuk","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1u006420ua5fwn80ix"},{"post_id":"ckjju0m1r005r20ua416v024o","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1v006720uahez672fo"},{"post_id":"ckjju0m1n005c20ua28zd0jst","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1v006a20uab8ow38jw"},{"post_id":"ckjju0m1s005u20ua62ye17n3","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1w006d20ua5yzh8p3b"},{"post_id":"ckjju0m1t005x20uaf50bgahi","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1x006g20ua6klbh242"},{"post_id":"ckjju0m1t006020ua0h1mgnqh","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m1x006j20uaeo1t9xh5"},{"post_id":"ckjju0m1u006320uab0pfh9et","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1y006m20ua24pqaqpv"},{"post_id":"ckjju0m1u006620uafbkz2c2p","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1z006r20ua52mhdfu9"},{"post_id":"ckjju0m1v006920ua3doobtbf","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m1z006u20ua4ytv4n6g"},{"post_id":"ckjju0m1w006c20ua9v58e155","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m20006x20ua8t0f05jh"},{"post_id":"ckjju0m1w006f20uabus27d47","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m20007020uacpae6m92"},{"post_id":"ckjju0m1x006l20ua1cbc1tw3","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m21007520uacv8deoen"},{"post_id":"ckjju0m1z006t20ua8was7o89","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjju0m22007820ua7ijda316"},{"post_id":"ckjju0m1x006i20uacu3vcnvs","category_id":"ckjju0m1y006n20ua298i63jo","_id":"ckjju0m23007c20uablkh0r2a"},{"post_id":"ckjju0m21007720uahtw48e4m","category_id":"ckjju0m20007120uaazpf9aoj","_id":"ckjju0m24007h20ua10ht5usx"},{"post_id":"ckjju0m1z006w20ua55cmckue","category_id":"ckjju0m20007120uaazpf9aoj","_id":"ckjju0m25007l20uagfwfa2gc"},{"post_id":"ckjju0m22007920uaajxra2uj","category_id":"ckjju0m20007120uaazpf9aoj","_id":"ckjju0m26007o20ua81x320am"},{"post_id":"ckjju0m23007e20ua279qcb38","category_id":"ckjju0m20007120uaazpf9aoj","_id":"ckjju0m27007s20ua06fz0264"},{"post_id":"ckjju0m21007420uacl8k9rqk","category_id":"ckjju0m20007120uaazpf9aoj","_id":"ckjju0m27007v20ua5y790o3r"},{"post_id":"ckjju0m24007g20uahqwy0vmx","category_id":"ckjju0m20007120uaazpf9aoj","_id":"ckjju0m28007z20uaexs92fy1"},{"post_id":"ckjju0m25007k20uadn9jb2c5","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m29008220uabhzx2r3v"},{"post_id":"ckjju0m26007n20ua1j3r1l1x","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m29008520uagtbg5zcz"},{"post_id":"ckjju0m26007r20ua6x6y9mga","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2a008920ua9h4zhvm3"},{"post_id":"ckjju0m27007u20uadwn4ew6l","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2b008c20ua7y0n64zc"},{"post_id":"ckjju0m27007x20uaaagkalsl","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2b008f20ua7mbr96j0"},{"post_id":"ckjju0m29008420ua1fg0b5oj","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2c008i20uac1hlc5cx"},{"post_id":"ckjju0m2a008720uacr7kfs11","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2c008l20uabnyc7kkg"},{"post_id":"ckjju0m2a008a20uaa0lzd6cf","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2d008o20ua5sy7548h"},{"post_id":"ckjju0m2b008d20ua1nr1da8m","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2d008r20uagushby0j"},{"post_id":"ckjju0m2b008g20ua0rizeeo8","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2f008u20ua2fzdd7kt"},{"post_id":"ckjju0m2d008m20ua3kim9hs8","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2f008x20ua8twugr04"},{"post_id":"ckjju0m2d008p20ua0gs1dk9j","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2g009020uacoqhamt7"},{"post_id":"ckjju0m2e008s20ua08ck693n","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2h009320ua4wky3mnw"},{"post_id":"ckjju0m2f008v20ua8kp79a9s","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2h009620uaeto3hhn1"},{"post_id":"ckjju0m2f008y20uahr7l9qra","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2i009920uaen5laxzu"},{"post_id":"ckjju0m2g009120ua0ix32016","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2i009c20ua2c8p6kzu"},{"post_id":"ckjju0m2h009420uacqhyejcf","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2j009f20uaegwi86oe"},{"post_id":"ckjju0m2h009720uad5g67ysx","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2j009i20uag2zfhs5o"},{"post_id":"ckjju0m2i009a20uahx9o1f4k","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2k009k20uaehmo8nz1"},{"post_id":"ckjju0m2i009d20uady8v3jib","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2k009m20uacjeo8l58"},{"post_id":"ckjju0m2j009g20uah9wu5o71","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2k009o20ua9dibfgdh"},{"post_id":"ckjju0m2m009s20uaakev7n08","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2n009x20uafd75alih"},{"post_id":"ckjju0m2m009t20uabhvxh8sd","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2n009z20ua9s1kebvr"},{"post_id":"ckjju0m2n009v20uafqdk8a70","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjju0m2o00a020uacs86cjv8"},{"post_id":"ckjju0m11003020ua9zzj00wb","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjjyfebz0002tsua6eylc9jg"},{"post_id":"ckjju0m04000820ua0gze8qs3","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjjygkn90003tsua18l66461"},{"post_id":"ckjju0m03000720uacxip4bds","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjjygn980004tsua9va2f6oq"},{"post_id":"ckjju0m0b000h20ua68yh6nxz","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjjygsqd0005tsuadull8nu1"},{"post_id":"ckjju0m0k001c20uags3b7xve","category_id":"ckjju0m05000920uagwnqcjm7","_id":"ckjjyh59b0006tsuaastg8jue"},{"post_id":"ckjju0m13003720ua2mxz58w0","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjjyixox0000roua4hc9121x"},{"post_id":"ckjju0m1o005f20uaa1clbvsn","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjjyixpd0001rouaehyj1m9w"},{"post_id":"ckjju0m28008120ua5xbrav3v","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpl3u200053wua302xht4f"},{"post_id":"ckjju0m2c008j20uafpb5elqa","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpmz2j00063wuafa2418pu"},{"post_id":"ckjju0m18003n20ua7hkmgcwf","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpojbw00073wua43zfg0d2"},{"post_id":"ckjju0m1a003w20uacdl80df8","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpp4sb00083wua06htdm8j"},{"post_id":"ckjju0m1c004520ua6egy1e7s","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpq75v00093wua018v6gh7"},{"post_id":"ckjkpqv54000a3wua5om3899y","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkprczg000b3wua90q046yx"},{"post_id":"ckjju0m2l009q20ua92x5az5b","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpssbd000c3wuabqcq1cbv"},{"post_id":"ckjju0m2l009r20uaael80rd4","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkptd36000d3wua91b4cb5q"},{"post_id":"ckjju0m02000520ua5hie20hf","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpv1oc000e3wuah4en2dwf"},{"post_id":"ckjju0m02000620ua87f22pie","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpvoq9000f3wua2h9p8axj"},{"post_id":"ckjju0m0l001f20ua7xhg7r5j","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpwwaq000g3wua2ppxa85n"},{"post_id":"ckjju0m0m001i20uah48ihmoj","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkpx9yy000h3wuadfvn4l13"},{"post_id":"ckjju0m1y006q20ua8f4p8dye","category_id":"ckjju0m1n005920uabpgq7sot","_id":"ckjkpz4ak000j3wuaft570lml"},{"post_id":"ckjju0m20006z20uacj0k60lo","category_id":"ckjkq16kl000n3wua5n6z1vep","_id":"ckjkq16km000o3wuagbje1peh"},{"post_id":"ckjjypdld00043wua1eqc4yuj","category_id":"ckjkq1lpv000p3wua8e3m0anx","_id":"ckjkq1lpw000q3wua3tszbfjn"},{"post_id":"ckjkr30sl0000a4ua2rqn1v2w","category_id":"ckjju0m0v002g20ua6ka6fhqk","_id":"ckjkr4cck0001a4ua4q0ac4fy"}],"PostTag":[],"Tag":[{"name":"数据结构","_id":"ckjju0m07000a20uaf10phk4n"},{"name":"pat","_id":"ckjju0m0o001r20uabwb77r20"},{"name":"JNI","_id":"ckjju0m0v002h20uadkps7pq8"},{"name":"Android","_id":"ckjju0m0x002r20ua1rcl8h3d"},{"name":"Java","_id":"ckjju0m1n005a20ua5j0l7m8g"},{"name":"Kotlin","_id":"ckjju0m1y006o20uafvfvfeka"},{"name":"Other","_id":"ckjju0m21007220ua24zuhxwn"},{"name":"Git","_id":"ckjju0m23007b20uad7nj44jj"},{"name":"Ubuntu","_id":"ckjju0m26007p20uackmzfc2v"},{"name":"性能优化","_id":"ckjju0m28007y20ua1pcs9sm2"},{"name":"优化","_id":"ckjju0m29008620uafl4eguez"}]}}